{"ast":null,"code":"import _classCallCheck from \"C:\\\\visualizacion_microservicios\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\visualizacion_microservicios\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/*\r\n*  Copyright (C) 1998-2022 by Northwoods Software Corporation. All Rights Reserved.\r\n*/\n\n/*\r\n* This is an extension and not part of the main GoJS library.\r\n* Note that the API for this class may change with any version, even point releases.\r\n* If you intend to use an extension in production, you should copy the code to your own source directory.\r\n* Extensions can be found in the GoJS kit under the extensions or extensionsJSM folders.\r\n* See the Extensions intro page (https://gojs.net/latest/intro/extensions.html) for more information.\r\n*/\nimport * as go from '../release/go-module.js';\n/**\r\n * This class implements an inspector for GoJS model data objects.\r\n * The constructor takes three arguments:\r\n *   - `divid` ***string*** a string referencing the HTML ID of the to-be inspector's div\r\n *   - `diagram` ***Diagram*** a reference to a GoJS Diagram\r\n *   - `options` ***Object*** an optional JS Object describing options for the inspector\r\n *\r\n * Options:\r\n *   - `inspectSelection` ***boolean*** see {@link #inspectSelection}\r\n *   - `includesOwnProperties` ***boolean*** see {@link #includesOwnProperties}\r\n *   - `properties` ***Object*** see {@link #properties}\r\n *   - `propertyModified` ***function(propertyName, newValue, inspector)*** see {@link #propertyModified}\r\n *   - `multipleSelection` ***boolean*** see {@link #multipleSelection}\r\n *   - `showUnionProperties` ***boolean*** see {@link #showUnionProperties}\r\n *   - `showLimit` ***number*** see {@link #showLimit}\r\n *\r\n * Options for properties:\r\n *   - `show` ***boolean | function*** a boolean value to show or hide the property from the inspector, or a predicate function to show conditionally.\r\n *   - `readOnly` ***boolean | function*** whether or not the property is read-only\r\n *   - `type` ***string*** a string describing the data type. Supported values: \"string|number|boolean|color|arrayofnumber|point|rect|size|spot|margin|select|date|datetime-local|time\"\r\n *   - `defaultValue` ***any*** a default value for the property. Defaults to the empty string.\r\n *   - `choices` ***Array | function*** when type === \"select\", the Array of choices to use or a function that returns the Array of choices.\r\n *\r\n * Example usage of Inspector:\r\n * ```js\r\n * var inspector = new Inspector(\"myInspector\", myDiagram,\r\n *   {\r\n *     includesOwnProperties: false,\r\n *     properties: {\r\n *       \"key\": { show: Inspector.showIfPresent, readOnly: true },\r\n *       \"comments\": { show: Inspector.showIfNode  },\r\n *       \"LinkComments\": { show: Inspector.showIfLink },\r\n *       \"chosen\": { show: Inspector.showIfNode, type: \"checkbox\" },\r\n *       \"state\": { show: Inspector.showIfNode, type: \"select\", choices: [\"Stopped\", \"Parked\", \"Moving\"] }\r\n *     }\r\n *   });\r\n * ```\r\n *\r\n * This is the basic HTML Structure that the Inspector creates within the given DIV element:\r\n * ```html\r\n * <div id=\"divid\" class=\"inspector\">\r\n *   <tr>\r\n *     <td>propertyName</td>\r\n *     <td><input value=propertyValue /></td>\r\n *   </tr>\r\n *   ...\r\n * </div>\r\n * ```\r\n *\r\n * If you want to experiment with this extension, try the <a href=\"../../extensionsJSM/DataInspector.html\">Data Inspector</a> sample.\r\n * @category Extension\r\n */\n\nexport var Inspector = /*#__PURE__*/function () {\n  /**\r\n   * Constructs an Inspector and sets up properties based on the options provided.\r\n   * Also sets up change listeners on the Diagram so the Inspector stays up-to-date.\r\n   * @param {string} divid a string referencing the HTML ID of the to-be Inspector's div\r\n   * @param {Diagram} diagram a reference to a GoJS Diagram\r\n   * @param {Object=} options an optional JS Object describing options for the inspector\r\n   */\n  function Inspector(divid, diagram, options) {\n    _classCallCheck(this, Inspector);\n\n    this._inspectedObject = null; // Inspector options defaults:\n\n    this._inspectSelection = true;\n    this._includesOwnProperties = true;\n    this._properties = {};\n    this._propertyModified = null;\n    this._multipleSelection = false;\n    this._showUnionProperties = false;\n    this._showLimit = 0; // Private variables used to keep track of internal state\n\n    this.inspectedProperties = {};\n    this.multipleProperties = {};\n    var mainDiv = document.getElementById(divid);\n    mainDiv.className = 'inspector';\n    mainDiv.innerHTML = '';\n    this._div = mainDiv;\n    this._diagram = diagram;\n    this.tabIndex = 0; // Set properties based on options\n\n    if (options !== undefined) {\n      if (options.inspectSelection !== undefined) this._inspectSelection = options.inspectSelection;\n      if (options.includesOwnProperties !== undefined) this._includesOwnProperties = options.includesOwnProperties;\n      if (options.properties !== undefined) this._properties = options.properties;\n      if (options.propertyModified !== undefined) this._propertyModified = options.propertyModified;\n      if (options.multipleSelection !== undefined) this._multipleSelection = options.multipleSelection;\n      if (options.showUnionProperties !== undefined) this._showUnionProperties = options.showUnionProperties;\n      if (options.showLimit !== undefined) this._showLimit = options.showLimit;\n    } // Prepare change listeners\n\n\n    var self = this;\n\n    this.inspectOnModelChanged = function (e) {\n      if (e.isTransactionFinished) self.inspectObject();\n    };\n\n    this.inspectOnSelectionChanged = function (e) {\n      self.inspectObject();\n    };\n\n    this._diagram.addModelChangedListener(this.inspectOnModelChanged);\n\n    if (this._inspectSelection) {\n      this._diagram.addDiagramListener('ChangedSelection', this.inspectOnSelectionChanged);\n    }\n  }\n  /**\r\n   * This read-only property returns the HTMLElement containing the Inspector.\r\n   */\n\n\n  _createClass(Inspector, [{\n    key: \"inspectObject\",\n\n    /**\r\n     * Update the HTML state of this Inspector with the given object.\r\n     *\r\n     * If passed an object, the Inspector will inspect that object.\r\n     * If passed null, this will do nothing.\r\n     * If no parameter is supplied, the {@link #inspectedObject} will be set based on the value of {@link #inspectSelection}.\r\n     * @param {Object=} object an optional argument, used when {@link #inspectSelection} is false to\r\n     *   set {@link #inspectedObject} and show and edit that object's properties.\r\n     */\n    value: function inspectObject(object) {\n      var inspectedObject = null;\n      var inspectedObjects = null;\n      if (object === null) return;\n\n      if (object === undefined) {\n        if (this._inspectSelection) {\n          if (this._multipleSelection) {\n            // gets the selection if multiple selection is true\n            inspectedObjects = this._diagram.selection;\n            this._inspectedObject = inspectedObjects.first();\n          } else {\n            // otherwise grab the first object\n            inspectedObject = this._diagram.selection.first();\n          }\n        } else {\n          // if there is a single inspected object\n          inspectedObject = this._inspectedObject;\n        }\n      } else {\n        // if object was passed in as a parameter\n        inspectedObject = object;\n      }\n\n      if (!inspectedObjects && inspectedObject) {\n        inspectedObjects = new go.Set();\n        inspectedObjects.add(inspectedObject);\n      }\n\n      if (!inspectedObjects || inspectedObjects.count < 1) {\n        // if nothing is selected\n        this.updateAllHTML();\n        return;\n      }\n\n      if (inspectedObjects) {\n        var mainDiv = this._div;\n        mainDiv.innerHTML = '';\n        var shared = new go.Map(); // for properties that the nodes have in common\n\n        var properties = new go.Map(); // for adding properties\n\n        var all = new go.Map(); // used later to prevent changing properties when unneeded\n\n        var it = inspectedObjects.iterator;\n        var nodecount = 2; // Build table:\n\n        var table = document.createElement('table');\n        var tbody = document.createElement('tbody');\n        this.inspectedProperties = {};\n        this.tabIndex = 0;\n        var declaredProperties = this._properties;\n        it.next();\n        inspectedObject = it.value;\n        this._inspectedObject = inspectedObject;\n        var data = inspectedObject instanceof go.Part ? inspectedObject.data : inspectedObject;\n\n        if (data) {\n          // initial pass to set shared and all\n          // Go through all the properties passed in to the inspector and add them to the map, if appropriate:\n          for (var name in declaredProperties) {\n            var desc = declaredProperties[name];\n            if (!this.canShowProperty(name, desc, inspectedObject)) continue;\n            var val = this.findValue(name, desc, data);\n\n            if (val === '' && this._properties[name] && this._properties[name].type === 'checkbox') {\n              shared.add(name, false);\n              all.add(name, false);\n            } else {\n              shared.add(name, val);\n              all.add(name, val);\n            }\n          } // Go through all the properties on the model data and add them to the map, if appropriate:\n\n\n          if (this._includesOwnProperties) {\n            for (var k in data) {\n              if (k === '__gohashid') continue; // skip internal GoJS hash property\n\n              if (this.inspectedProperties[k]) continue; // already exists\n\n              if (declaredProperties[k] && !this.canShowProperty(k, declaredProperties[k], inspectedObject)) continue;\n              shared.add(k, data[k]);\n              all.add(k, data[k]);\n            }\n          }\n        }\n\n        while (it.next() && (this._showLimit < 1 || nodecount <= this._showLimit)) {\n          // grabs all the properties from the other selected objects\n          properties.clear();\n          inspectedObject = it.value;\n\n          if (inspectedObject) {\n            // use either the Part.data or the object itself (for model.modelData)\n            data = inspectedObject instanceof go.Part ? inspectedObject.data : inspectedObject;\n\n            if (data) {\n              // Go through all the properties passed in to the inspector and add them to properties to add, if appropriate:\n              for (var _name in declaredProperties) {\n                var _desc = declaredProperties[_name];\n                if (!this.canShowProperty(_name, _desc, inspectedObject)) continue;\n\n                var _val = this.findValue(_name, _desc, data);\n\n                if (_val === '' && this._properties[_name] && this._properties[_name].type === 'checkbox') {\n                  properties.add(_name, false);\n                } else {\n                  properties.add(_name, _val);\n                }\n              } // Go through all the properties on the model data and add them to properties to add, if appropriate:\n\n\n              if (this._includesOwnProperties) {\n                for (var _k in data) {\n                  if (_k === '__gohashid') continue; // skip internal GoJS hash property\n\n                  if (this.inspectedProperties[_k]) continue; // already exists\n\n                  if (declaredProperties[_k] && !this.canShowProperty(_k, declaredProperties[_k], inspectedObject)) continue;\n                  properties.add(_k, data[_k]);\n                }\n              }\n            }\n          }\n\n          if (!this._showUnionProperties) {\n            // Cleans up shared map with properties that aren't shared between the selected objects\n            // Also adds properties to the add and shared maps if applicable\n            var addIt = shared.iterator;\n            var toRemove = [];\n\n            while (addIt.next()) {\n              if (properties.has(addIt.key)) {\n                var newVal = all.get(addIt.key) + '|' + properties.get(addIt.key);\n                all.set(addIt.key, newVal);\n\n                if (declaredProperties[addIt.key] && declaredProperties[addIt.key].type !== 'color' && declaredProperties[addIt.key].type !== 'checkbox' && declaredProperties[addIt.key].type !== 'select' || !declaredProperties[addIt.key]) {\n                  // for non-string properties i.e color\n                  newVal = shared.get(addIt.key) + '|' + properties.get(addIt.key);\n                  shared.set(addIt.key, newVal);\n                }\n              } else {\n                // toRemove array since addIt is still iterating\n                toRemove.push(addIt.key);\n              }\n            }\n\n            for (var i = 0; i < toRemove.length; i++) {\n              // removes anything that doesn't showUnionProperties\n              shared.remove(toRemove[i]);\n              all.remove(toRemove[i]);\n            }\n          } else {\n            // Adds missing properties to all with the correct amount of seperators\n            var _addIt = properties.iterator;\n\n            while (_addIt.next()) {\n              if (all.has(_addIt.key)) {\n                if (declaredProperties[_addIt.key] && declaredProperties[_addIt.key].type !== 'color' && declaredProperties[_addIt.key].type !== 'checkbox' && declaredProperties[_addIt.key].type !== 'select' || !declaredProperties[_addIt.key]) {\n                  // for non-string properties i.e color\n                  var _newVal = all.get(_addIt.key) + '|' + properties.get(_addIt.key);\n\n                  all.set(_addIt.key, _newVal);\n                }\n              } else {\n                var _newVal2 = '';\n\n                for (var _i = 0; _i < nodecount - 1; _i++) {\n                  _newVal2 += '|';\n                }\n\n                _newVal2 += properties.get(_addIt.key);\n                all.set(_addIt.key, _newVal2);\n              }\n            } // Adds bars in case properties is not in all\n\n\n            _addIt = all.iterator;\n\n            while (_addIt.next()) {\n              if (!properties.has(_addIt.key)) {\n                if (declaredProperties[_addIt.key] && declaredProperties[_addIt.key].type !== 'color' && declaredProperties[_addIt.key].type !== 'checkbox' && declaredProperties[_addIt.key].type !== 'select' || !declaredProperties[_addIt.key]) {\n                  // for non-string properties i.e color\n                  var _newVal3 = all.get(_addIt.key) + '|';\n\n                  all.set(_addIt.key, _newVal3);\n                }\n              }\n            }\n          }\n\n          nodecount++;\n        } // builds the table property rows and sets multipleProperties to help with updateall\n\n\n        var mapIt;\n        if (!this._showUnionProperties) mapIt = shared.iterator;else mapIt = all.iterator;\n\n        while (mapIt.next()) {\n          tbody.appendChild(this.buildPropertyRow(mapIt.key, mapIt.value)); // shows the properties that are allowed\n        }\n\n        table.appendChild(tbody);\n        mainDiv.appendChild(table);\n        var allIt = all.iterator;\n\n        while (allIt.next()) {\n          this.multipleProperties[allIt.key] = allIt.value; // used for updateall to know which properties to change\n        }\n      }\n    }\n    /**\r\n     * This predicate should be false if the given property should not be shown.\r\n     * Normally it only checks the value of \"show\" on the property descriptor.\r\n     *\r\n     * The default value is true.\r\n     * @param {string} propertyName the property name\r\n     * @param {Object} propertyDesc the property descriptor\r\n     * @param {Object} inspectedObject the data object\r\n     * @return {boolean} whether a particular property should be shown in this Inspector\r\n     */\n\n  }, {\n    key: \"canShowProperty\",\n    value: function canShowProperty(propertyName, propertyDesc, inspectedObject) {\n      var prop = propertyDesc;\n      if (prop.show === false) return false; // if \"show\" is a predicate, make sure it passes or do not show this property\n\n      if (typeof prop.show === 'function') return prop.show(inspectedObject, propertyName);\n      return true;\n    }\n    /**\r\n     * This predicate should be false if the given property should not be editable by the user.\r\n     * Normally it only checks the value of \"readOnly\" on the property descriptor.\r\n     *\r\n     * The default value is true.\r\n     * @param {string} propertyName the property name\r\n     * @param {Object} propertyDesc the property descriptor\r\n     * @param {Object} inspectedObject the data object\r\n     * @return {boolean} whether a particular property should be shown in this Inspector\r\n     */\n\n  }, {\n    key: \"canEditProperty\",\n    value: function canEditProperty(propertyName, propertyDesc, inspectedObject) {\n      if (this._diagram.isReadOnly || this._diagram.isModelReadOnly) return false;\n      if (inspectedObject === null) return false; // assume property values that are functions of Objects cannot be edited\n\n      var data = inspectedObject instanceof go.Part ? inspectedObject.data : inspectedObject;\n      var valtype = typeof data[propertyName];\n      if (valtype === 'function') return false;\n\n      if (propertyDesc) {\n        var prop = propertyDesc;\n        if (prop.readOnly === true) return false; // if \"readOnly\" is a predicate, make sure it passes or do not show this property\n\n        if (typeof prop.readOnly === 'function') return !prop.readOnly(inspectedObject, propertyName);\n      }\n\n      return true;\n    }\n    /**\r\n     * @ignore\r\n     * @param propName\r\n     * @param propDesc\r\n     * @param data\r\n     */\n\n  }, {\n    key: \"findValue\",\n    value: function findValue(propName, propDesc, data) {\n      var val = '';\n      if (propDesc && propDesc.defaultValue !== undefined) val = propDesc.defaultValue;\n      if (data[propName] !== undefined) val = data[propName];\n      if (val === undefined) return '';\n      return val;\n    }\n    /**\r\n     * This sets `inspectedProperties[propertyName]` and creates the HTML table row for a given property:\r\n     * ```html\r\n     * <tr>\r\n     *   <td>propertyName</td>\r\n     *   <td><input value=propertyValue /></td>\r\n     * </tr>\r\n     * ```\r\n     *\r\n     * This method can be customized to change how an Inspector row is rendered.\r\n     * @param {string} propertyName the property name\r\n     * @param {*} propertyValue the property value\r\n     * @return {HTMLTableRowElement} the table row\r\n     */\n\n  }, {\n    key: \"buildPropertyRow\",\n    value: function buildPropertyRow(propertyName, propertyValue) {\n      var tr = document.createElement('tr');\n      var td1 = document.createElement('td');\n      var displayName;\n\n      if (this._properties[propertyName] && this._properties[propertyName].name !== undefined) {\n        // name changes the dispaly name shown on inspector\n        displayName = this._properties[propertyName].name;\n      } else {\n        displayName = propertyName;\n      }\n\n      td1.textContent = displayName;\n      tr.appendChild(td1);\n      var td2 = document.createElement('td');\n      var decProp = this._properties[propertyName];\n      var input = null;\n      var self = this;\n\n      function updateall() {\n        if (self._diagram.selection.count === 1 || !self.multipleSelection) {\n          self.updateAllProperties();\n        } else {\n          self.updateAllObjectsProperties();\n        }\n      }\n\n      if (decProp && decProp.type === 'select') {\n        var inputs = input = document.createElement('select');\n        this.updateSelect(decProp, inputs, propertyName, propertyValue);\n        inputs.addEventListener('change', updateall);\n      } else {\n        var inputi = input = document.createElement('input');\n\n        if (inputi && inputi.setPointerCapture) {\n          inputi.addEventListener(\"pointerdown\", function (e) {\n            return inputi.setPointerCapture(e.pointerId);\n          });\n        }\n\n        inputi.value = this.convertToString(propertyValue);\n\n        if (decProp) {\n          var t = decProp.type;\n\n          if (t !== 'string' && t !== 'number' && t !== 'boolean' && t !== 'arrayofnumber' && t !== 'point' && t !== 'size' && t !== 'rect' && t !== 'spot' && t !== 'margin') {\n            inputi.setAttribute('type', decProp.type);\n          }\n\n          if (decProp.type === 'color') {\n            if (inputi.type === 'color') {\n              inputi.value = this.convertToColor(propertyValue); // input.addEventListener('input', updateall); // removed with multi select\n\n              inputi.addEventListener('change', updateall);\n            }\n          }\n\n          if (decProp.type === 'checkbox') {\n            inputi.checked = !!propertyValue;\n            inputi.addEventListener('change', updateall);\n          }\n        }\n\n        if (inputi.type !== 'color') inputi.addEventListener('blur', updateall);\n      }\n\n      if (input) {\n        input.tabIndex = this.tabIndex++;\n        input.disabled = !this.canEditProperty(propertyName, decProp, this._inspectedObject);\n        td2.appendChild(input);\n      }\n\n      tr.appendChild(td2);\n      this.inspectedProperties[propertyName] = input;\n      return tr;\n    }\n    /**\r\n     * @hidden @ignore\r\n     * HTML5 color input will only take hex,\r\n     * so let HTML5 canvas convert the color into hex format.\r\n     * This converts \"rgb(255, 0, 0)\" into \"#FF0000\", etc.\r\n     */\n\n  }, {\n    key: \"convertToColor\",\n    value: function convertToColor(propertyValue) {\n      var ctx = document.createElement('canvas').getContext('2d');\n      if (ctx === null) return '#000000';\n      ctx.fillStyle = propertyValue;\n      return ctx.fillStyle;\n    }\n    /**\r\n     * @hidden @ignore\r\n     */\n\n  }, {\n    key: \"convertToArrayOfNumber\",\n    value: function convertToArrayOfNumber(propertyValue) {\n      if (propertyValue === 'null') return null;\n      var split = propertyValue.split(' ');\n      var arr = [];\n\n      for (var i = 0; i < split.length; i++) {\n        var str = split[i];\n        if (!str) continue;\n        arr.push(parseFloat(str));\n      }\n\n      return arr;\n    }\n    /**\r\n     * @hidden @ignore\r\n     */\n\n  }, {\n    key: \"convertToString\",\n    value: function convertToString(x) {\n      if (x === undefined) return 'undefined';\n      if (x === null) return 'null';\n      if (x instanceof go.Point) return go.Point.stringify(x);\n      if (x instanceof go.Size) return go.Size.stringify(x);\n      if (x instanceof go.Rect) return go.Rect.stringify(x);\n      if (x instanceof go.Spot) return go.Spot.stringify(x);\n      if (x instanceof go.Margin) return go.Margin.stringify(x);\n      if (x instanceof go.List) return this.convertToString(x.toArray());\n\n      if (Array.isArray(x)) {\n        var str = '';\n\n        for (var i = 0; i < x.length; i++) {\n          if (i > 0) str += ' ';\n          var v = x[i];\n          str += this.convertToString(v);\n        }\n\n        return str;\n      }\n\n      return x.toString();\n    }\n    /**\r\n     * @hidden @ignore\r\n     * Update all of the HTML in this Inspector.\r\n     */\n\n  }, {\n    key: \"updateAllHTML\",\n    value: function updateAllHTML() {\n      var inspectedProps = this.inspectedProperties;\n      var isPart = this._inspectedObject instanceof go.Part;\n      var data = isPart ? this._inspectedObject.data : this._inspectedObject;\n\n      if (!data) {\n        // clear out all of the fields\n        for (var name in inspectedProps) {\n          var input = inspectedProps[name];\n\n          if (input instanceof HTMLSelectElement) {\n            input.innerHTML = '';\n          } else if (input.type === 'color') {\n            input.value = '#000000';\n          } else if (input.type === 'checkbox') {\n            input.checked = false;\n          } else {\n            input.value = '';\n          }\n        }\n      } else {\n        for (var _name2 in inspectedProps) {\n          var _input = inspectedProps[_name2];\n          var propertyValue = data[_name2];\n\n          if (_input instanceof HTMLSelectElement) {\n            var decProp = this._properties[_name2];\n            this.updateSelect(decProp, _input, _name2, propertyValue);\n          } else if (_input.type === 'color') {\n            _input.value = this.convertToColor(propertyValue);\n          } else if (_input.type === 'checkbox') {\n            _input.checked = !!propertyValue;\n          } else {\n            _input.value = this.convertToString(propertyValue);\n          }\n        }\n      }\n    }\n    /**\r\n     * @hidden @ignore\r\n     * Update an HTMLSelectElement with an appropriate list of choices, given the propertyName\r\n     */\n\n  }, {\n    key: \"updateSelect\",\n    value: function updateSelect(decProp, select, propertyName, propertyValue) {\n      select.innerHTML = ''; // clear out anything that was there\n\n      var choices = decProp.choices;\n      if (typeof choices === 'function') choices = choices(this._inspectedObject, propertyName);\n      if (!Array.isArray(choices)) choices = [];\n      decProp.choicesArray = choices; // remember list of actual choice values (not strings)\n\n      for (var i = 0; i < choices.length; i++) {\n        var choice = choices[i];\n        var opt = document.createElement('option');\n        opt.text = this.convertToString(choice);\n        select.add(opt);\n      }\n\n      select.value = this.convertToString(propertyValue);\n    }\n  }, {\n    key: \"parseValue\",\n    value: function parseValue(decProp, value, input, oldval) {\n      // If it's a boolean, or if its previous value was boolean,\n      // parse the value to be a boolean and then update the input.value to match\n      var type = '';\n\n      if (decProp !== undefined && decProp.type !== undefined) {\n        type = decProp.type;\n      }\n\n      if (type === '') {\n        if (typeof oldval === 'boolean') type = 'boolean'; // infer boolean\n        else if (typeof oldval === 'number') type = 'number';else if (oldval instanceof go.Point) type = 'point';else if (oldval instanceof go.Size) type = 'size';else if (oldval instanceof go.Rect) type = 'rect';else if (oldval instanceof go.Spot) type = 'spot';else if (oldval instanceof go.Margin) type = 'margin';\n      } // convert to specific type, if needed\n\n\n      switch (type) {\n        case 'boolean':\n          value = !(value === false || value === 'false' || value === '0');\n          break;\n\n        case 'number':\n          value = parseFloat(value);\n          break;\n\n        case 'arrayofnumber':\n          value = this.convertToArrayOfNumber(value);\n          break;\n\n        case 'point':\n          value = go.Point.parse(value);\n          break;\n\n        case 'size':\n          value = go.Size.parse(value);\n          break;\n\n        case 'rect':\n          value = go.Rect.parse(value);\n          break;\n\n        case 'spot':\n          value = go.Spot.parse(value);\n          break;\n\n        case 'margin':\n          value = go.Margin.parse(value);\n          break;\n\n        case 'checkbox':\n          value = input.checked;\n          break;\n\n        case 'select':\n          value = decProp.choicesArray[input.selectedIndex];\n          break;\n      }\n\n      return value;\n    }\n    /**\r\n     * @hidden @ignore\r\n     * Update all of the data properties of all the objects in {@link #inspectedObjects} according to the\r\n     * current values held in the HTML input elements.\r\n     */\n\n  }, {\n    key: \"updateAllObjectsProperties\",\n    value: function updateAllObjectsProperties() {\n      var inspectedProps = this.inspectedProperties;\n      var diagram = this._diagram;\n      diagram.startTransaction('set all properties');\n\n      for (var name in inspectedProps) {\n        var input = inspectedProps[name];\n        var value = input.value;\n        var arr1 = value.split('|');\n        var arr2 = [];\n\n        if (this.multipleProperties[name]) {\n          // don't split if it is union and its checkbox type\n          if (this._properties[name] && this._properties[name].type === 'checkbox' && this._showUnionProperties) {\n            arr2.push(this.multipleProperties[name]);\n          } else if (this._properties[name]) {\n            arr2 = this.multipleProperties[name].toString().split('|');\n          }\n        }\n\n        var it = diagram.selection.iterator;\n        var change = false;\n        if (this._properties[name] && this._properties[name].type === 'checkbox') change = true; // always change checkbox\n\n        if (arr1.length < arr2.length // i.e Alpha|Beta -> Alpha procs the change\n        && (!this._properties[name] // from and to links\n        || !(this._properties[name] // do not change color checkbox and choices due to them always having less\n        && (this._properties[name].type === 'color' || this._properties[name].type === 'checkbox' || this._properties[name].type === 'choices')))) {\n          change = true;\n        } else {\n          // standard detection in change in properties\n          for (var j = 0; j < arr1.length && j < arr2.length; j++) {\n            if (!(arr1[j] === arr2[j]) && !(this._properties[name] && this._properties[name].type === 'color' && arr1[j].toLowerCase() === arr2[j].toLowerCase())) {\n              change = true;\n            }\n          }\n        }\n\n        if (change) {\n          // only change properties it needs to change instead all of them\n          for (var i = 0; i < diagram.selection.count; i++) {\n            it.next();\n            var isPart = it.value instanceof go.Part;\n            var data = isPart ? it.value.data : it.value;\n\n            if (data) {\n              // ignores the selected node if there is no data\n              if (i < arr1.length) value = arr1[i];else value = arr1[0]; // don't update \"readOnly\" data properties\n\n              var decProp = this._properties[name];\n              if (!this.canEditProperty(name, decProp, it.value)) continue;\n              var oldval = data[name];\n              value = this.parseValue(decProp, value, input, oldval); // in case parsed to be different, such as in the case of boolean values,\n              // the value shown should match the actual value\n\n              input.value = value; // modify the data object in an undo-able fashion\n\n              diagram.model.setDataProperty(data, name, value); // notify any listener\n\n              if (this.propertyModified !== null) this.propertyModified(name, value, this);\n            }\n          }\n        }\n      }\n\n      diagram.commitTransaction('set all properties');\n    }\n    /**\r\n     * @hidden @ignore\r\n     * Update all of the data properties of {@link #inspectedObject} according to the\r\n     * current values held in the HTML input elements.\r\n     */\n\n  }, {\n    key: \"updateAllProperties\",\n    value: function updateAllProperties() {\n      var inspectedProps = this.inspectedProperties;\n      var diagram = this._diagram;\n      var isPart = this.inspectedObject instanceof go.Part;\n      var data = isPart ? this.inspectedObject.data : this.inspectedObject;\n      if (!data) return; // must not try to update data when there's no data!\n\n      diagram.startTransaction('set all properties');\n\n      for (var name in inspectedProps) {\n        var input = inspectedProps[name];\n        var value = input.value; // don't update \"readOnly\" data properties\n\n        var decProp = this._properties[name];\n        if (!this.canEditProperty(name, decProp, this.inspectedObject)) continue;\n        var oldval = data[name];\n        value = this.parseValue(decProp, value, input, oldval); // in case parsed to be different, such as in the case of boolean values,\n        // the value shown should match the actual value\n\n        input.value = value; // modify the data object in an undo-able fashion\n\n        diagram.model.setDataProperty(data, name, value); // notify any listener\n\n        if (this.propertyModified !== null) this.propertyModified(name, value, this);\n      }\n\n      diagram.commitTransaction('set all properties');\n    }\n  }, {\n    key: \"div\",\n    get: function get() {\n      return this._div;\n    }\n    /**\r\n     * Gets or sets the {@link Diagram} associated with this Inspector.\r\n     */\n\n  }, {\n    key: \"diagram\",\n    get: function get() {\n      return this._diagram;\n    },\n    set: function set(val) {\n      if (val !== this._diagram) {\n        // First, unassociate change listeners with current inspected diagram\n        this._diagram.removeModelChangedListener(this.inspectOnModelChanged);\n\n        this._diagram.removeDiagramListener('ChangedSelection', this.inspectOnSelectionChanged); // Now set the diagram and add the necessary change listeners\n\n\n        this._diagram = val;\n\n        this._diagram.addModelChangedListener(this.inspectOnModelChanged);\n\n        if (this._inspectSelection) {\n          this._diagram.addDiagramListener('ChangedSelection', this.inspectOnSelectionChanged);\n\n          this.inspectObject();\n        } else {\n          this.inspectObject(null);\n        }\n      }\n    }\n    /**\r\n     * This read-only property returns the object currently being inspected.\r\n     *\r\n     * To set the inspected object, call {@link #inspectObject}.\r\n     */\n\n  }, {\n    key: \"inspectedObject\",\n    get: function get() {\n      return this._inspectedObject;\n    }\n    /**\r\n     * Gets or sets whether the Inspector automatically inspects the associated Diagram's selection.\r\n     * When set to false, the Inspector won't show anything until {@link #inspectObject} is called.\r\n     *\r\n     * The default value is true.\r\n     */\n\n  }, {\n    key: \"inspectSelection\",\n    get: function get() {\n      return this._inspectSelection;\n    },\n    set: function set(val) {\n      if (val !== this._inspectSelection) {\n        this._inspectSelection = val;\n\n        if (this._inspectSelection) {\n          this._diagram.addDiagramListener('ChangedSelection', this.inspectOnSelectionChanged);\n\n          this.inspectObject();\n        } else {\n          this._diagram.removeDiagramListener('ChangedSelection', this.inspectOnSelectionChanged);\n\n          this.inspectObject(null);\n        }\n      }\n    }\n    /**\r\n     * Gets or sets whether the Inspector includes all properties currently on the inspected object.\r\n     *\r\n     * The default value is true.\r\n     */\n\n  }, {\n    key: \"includesOwnProperties\",\n    get: function get() {\n      return this._includesOwnProperties;\n    },\n    set: function set(val) {\n      if (val !== this._includesOwnProperties) {\n        this._includesOwnProperties = val;\n        this.inspectObject();\n      }\n    }\n    /**\r\n     * Gets or sets the properties that the Inspector will inspect, maybe setting options for those properties.\r\n     * The object should contain string: Object pairs represnting propertyName: propertyOptions.\r\n     * Can be used to include or exclude additional properties.\r\n     *\r\n     * The default value is an empty object.\r\n     */\n\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return this._properties;\n    },\n    set: function set(val) {\n      if (val !== this._properties) {\n        this._properties = val;\n        this.inspectObject();\n      }\n    }\n    /**\r\n     * Gets or sets the function to be called when a property is modified by the Inspector.\r\n     * The first paremeter will be the property name, the second will be the new value, and the third will be a reference to this Inspector.\r\n     *\r\n     * The default value is null, meaning nothing will be done.\r\n     */\n\n  }, {\n    key: \"propertyModified\",\n    get: function get() {\n      return this._propertyModified;\n    },\n    set: function set(val) {\n      if (val !== this._propertyModified) {\n        this._propertyModified = val;\n      }\n    }\n    /**\r\n     * Gets or sets whether the Inspector displays properties for multiple selected objects or just the first.\r\n     *\r\n     * The default value is false, meaning only the first item in the {@link Diagram#selection} is inspected.\r\n     */\n\n  }, {\n    key: \"multipleSelection\",\n    get: function get() {\n      return this._multipleSelection;\n    },\n    set: function set(val) {\n      if (val !== this._multipleSelection) {\n        this._multipleSelection = val;\n        this.inspectObject();\n      }\n    }\n    /**\r\n     * Gets or sets whether the Inspector displays the union or intersection of properties for multiple selected objects.\r\n     *\r\n     * The default value is false, meaning the intersection of properties is inspected.\r\n     */\n\n  }, {\n    key: \"showUnionProperties\",\n    get: function get() {\n      return this._showUnionProperties;\n    },\n    set: function set(val) {\n      if (val !== this._showUnionProperties) {\n        this._showUnionProperties = val;\n        this.inspectObject();\n      }\n    }\n    /**\r\n     * Gets or sets how many objects will be displayed when {@link #multipleSelection} is true.\r\n     *\r\n     * The default value is 0, meaning all selected objects will be displayed for a given property.\r\n     */\n\n  }, {\n    key: \"showLimit\",\n    get: function get() {\n      return this._showLimit;\n    },\n    set: function set(val) {\n      if (val !== this._showLimit) {\n        this._showLimit = val;\n        this.inspectObject();\n      }\n    }\n    /**\r\n     * This predicate function can be used as a value for the `show` option for properties.\r\n     * When used, the property will only be shown when inspecting a {@link Node}.\r\n     * @param {Part} part the Part being inspected\r\n     * @return {boolean}\r\n     */\n\n  }], [{\n    key: \"showIfNode\",\n    value: function showIfNode(part) {\n      return part instanceof go.Node;\n    }\n    /**\r\n     * This predicate function can be used as a value for the `show` option for properties.\r\n     * When used, the property will only be shown when inspecting a {@link Link}.\r\n     * @param {Part} part the Part being inspected\r\n     * @return {boolean}\r\n     */\n\n  }, {\n    key: \"showIfLink\",\n    value: function showIfLink(part) {\n      return part instanceof go.Link;\n    }\n    /**\r\n     * This predicate function can be used as a value for the `show` option for properties.\r\n     * When used, the property will only be shown when inspecting a {@link Group}.\r\n     * @param {Part} part the Part being inspected\r\n     * @return {boolean}\r\n     */\n\n  }, {\n    key: \"showIfGroup\",\n    value: function showIfGroup(part) {\n      return part instanceof go.Group;\n    }\n    /**\r\n     * This predicate function can be used as a value for the `show` option for properties.\r\n     * When used, the property will only be shown if present.\r\n     * Useful for properties such as `key`, which will be shown on Nodes and Groups, but normally not on Links\r\n     * @param {Part|null} part the Part being inspected\r\n     * @param {string} propname the property to check presence of\r\n     * @return {boolean}\r\n     */\n\n  }, {\n    key: \"showIfPresent\",\n    value: function showIfPresent(data, propname) {\n      if (data instanceof go.Part) data = data.data;\n      return typeof data === 'object' && data[propname] !== undefined;\n    }\n  }]);\n\n  return Inspector;\n}();","map":{"version":3,"names":["go","Inspector","divid","diagram","options","_inspectedObject","_inspectSelection","_includesOwnProperties","_properties","_propertyModified","_multipleSelection","_showUnionProperties","_showLimit","inspectedProperties","multipleProperties","mainDiv","document","getElementById","className","innerHTML","_div","_diagram","tabIndex","undefined","inspectSelection","includesOwnProperties","properties","propertyModified","multipleSelection","showUnionProperties","showLimit","self","inspectOnModelChanged","e","isTransactionFinished","inspectObject","inspectOnSelectionChanged","addModelChangedListener","addDiagramListener","object","inspectedObject","inspectedObjects","selection","first","Set","add","count","updateAllHTML","shared","Map","all","it","iterator","nodecount","table","createElement","tbody","declaredProperties","next","value","data","Part","name","desc","canShowProperty","val","findValue","type","k","clear","addIt","toRemove","has","key","newVal","get","set","push","i","length","remove","mapIt","appendChild","buildPropertyRow","allIt","propertyName","propertyDesc","prop","show","isReadOnly","isModelReadOnly","valtype","readOnly","propName","propDesc","defaultValue","propertyValue","tr","td1","displayName","textContent","td2","decProp","input","updateall","updateAllProperties","updateAllObjectsProperties","inputs","updateSelect","addEventListener","inputi","setPointerCapture","pointerId","convertToString","t","setAttribute","convertToColor","checked","disabled","canEditProperty","ctx","getContext","fillStyle","split","arr","str","parseFloat","x","Point","stringify","Size","Rect","Spot","Margin","List","toArray","Array","isArray","v","toString","inspectedProps","isPart","HTMLSelectElement","select","choices","choicesArray","choice","opt","text","oldval","convertToArrayOfNumber","parse","selectedIndex","startTransaction","arr1","arr2","change","j","toLowerCase","parseValue","model","setDataProperty","commitTransaction","removeModelChangedListener","removeDiagramListener","part","Node","Link","Group","propname"],"sources":["C:/visualizacion_microservicios/src/DataInspector.js"],"sourcesContent":["/*\r\n*  Copyright (C) 1998-2022 by Northwoods Software Corporation. All Rights Reserved.\r\n*/\r\n/*\r\n* This is an extension and not part of the main GoJS library.\r\n* Note that the API for this class may change with any version, even point releases.\r\n* If you intend to use an extension in production, you should copy the code to your own source directory.\r\n* Extensions can be found in the GoJS kit under the extensions or extensionsJSM folders.\r\n* See the Extensions intro page (https://gojs.net/latest/intro/extensions.html) for more information.\r\n*/\r\nimport * as go from '../release/go-module.js';\r\n/**\r\n * This class implements an inspector for GoJS model data objects.\r\n * The constructor takes three arguments:\r\n *   - `divid` ***string*** a string referencing the HTML ID of the to-be inspector's div\r\n *   - `diagram` ***Diagram*** a reference to a GoJS Diagram\r\n *   - `options` ***Object*** an optional JS Object describing options for the inspector\r\n *\r\n * Options:\r\n *   - `inspectSelection` ***boolean*** see {@link #inspectSelection}\r\n *   - `includesOwnProperties` ***boolean*** see {@link #includesOwnProperties}\r\n *   - `properties` ***Object*** see {@link #properties}\r\n *   - `propertyModified` ***function(propertyName, newValue, inspector)*** see {@link #propertyModified}\r\n *   - `multipleSelection` ***boolean*** see {@link #multipleSelection}\r\n *   - `showUnionProperties` ***boolean*** see {@link #showUnionProperties}\r\n *   - `showLimit` ***number*** see {@link #showLimit}\r\n *\r\n * Options for properties:\r\n *   - `show` ***boolean | function*** a boolean value to show or hide the property from the inspector, or a predicate function to show conditionally.\r\n *   - `readOnly` ***boolean | function*** whether or not the property is read-only\r\n *   - `type` ***string*** a string describing the data type. Supported values: \"string|number|boolean|color|arrayofnumber|point|rect|size|spot|margin|select|date|datetime-local|time\"\r\n *   - `defaultValue` ***any*** a default value for the property. Defaults to the empty string.\r\n *   - `choices` ***Array | function*** when type === \"select\", the Array of choices to use or a function that returns the Array of choices.\r\n *\r\n * Example usage of Inspector:\r\n * ```js\r\n * var inspector = new Inspector(\"myInspector\", myDiagram,\r\n *   {\r\n *     includesOwnProperties: false,\r\n *     properties: {\r\n *       \"key\": { show: Inspector.showIfPresent, readOnly: true },\r\n *       \"comments\": { show: Inspector.showIfNode  },\r\n *       \"LinkComments\": { show: Inspector.showIfLink },\r\n *       \"chosen\": { show: Inspector.showIfNode, type: \"checkbox\" },\r\n *       \"state\": { show: Inspector.showIfNode, type: \"select\", choices: [\"Stopped\", \"Parked\", \"Moving\"] }\r\n *     }\r\n *   });\r\n * ```\r\n *\r\n * This is the basic HTML Structure that the Inspector creates within the given DIV element:\r\n * ```html\r\n * <div id=\"divid\" class=\"inspector\">\r\n *   <tr>\r\n *     <td>propertyName</td>\r\n *     <td><input value=propertyValue /></td>\r\n *   </tr>\r\n *   ...\r\n * </div>\r\n * ```\r\n *\r\n * If you want to experiment with this extension, try the <a href=\"../../extensionsJSM/DataInspector.html\">Data Inspector</a> sample.\r\n * @category Extension\r\n */\r\nexport class Inspector {\r\n    /**\r\n     * Constructs an Inspector and sets up properties based on the options provided.\r\n     * Also sets up change listeners on the Diagram so the Inspector stays up-to-date.\r\n     * @param {string} divid a string referencing the HTML ID of the to-be Inspector's div\r\n     * @param {Diagram} diagram a reference to a GoJS Diagram\r\n     * @param {Object=} options an optional JS Object describing options for the inspector\r\n     */\r\n    constructor(divid, diagram, options) {\r\n        this._inspectedObject = null;\r\n        // Inspector options defaults:\r\n        this._inspectSelection = true;\r\n        this._includesOwnProperties = true;\r\n        this._properties = {};\r\n        this._propertyModified = null;\r\n        this._multipleSelection = false;\r\n        this._showUnionProperties = false;\r\n        this._showLimit = 0;\r\n        // Private variables used to keep track of internal state\r\n        this.inspectedProperties = {};\r\n        this.multipleProperties = {};\r\n        const mainDiv = document.getElementById(divid);\r\n        mainDiv.className = 'inspector';\r\n        mainDiv.innerHTML = '';\r\n        this._div = mainDiv;\r\n        this._diagram = diagram;\r\n        this.tabIndex = 0;\r\n        // Set properties based on options\r\n        if (options !== undefined) {\r\n            if (options.inspectSelection !== undefined)\r\n                this._inspectSelection = options.inspectSelection;\r\n            if (options.includesOwnProperties !== undefined)\r\n                this._includesOwnProperties = options.includesOwnProperties;\r\n            if (options.properties !== undefined)\r\n                this._properties = options.properties;\r\n            if (options.propertyModified !== undefined)\r\n                this._propertyModified = options.propertyModified;\r\n            if (options.multipleSelection !== undefined)\r\n                this._multipleSelection = options.multipleSelection;\r\n            if (options.showUnionProperties !== undefined)\r\n                this._showUnionProperties = options.showUnionProperties;\r\n            if (options.showLimit !== undefined)\r\n                this._showLimit = options.showLimit;\r\n        }\r\n        // Prepare change listeners\r\n        const self = this;\r\n        this.inspectOnModelChanged = (e) => {\r\n            if (e.isTransactionFinished)\r\n                self.inspectObject();\r\n        };\r\n        this.inspectOnSelectionChanged = (e) => { self.inspectObject(); };\r\n        this._diagram.addModelChangedListener(this.inspectOnModelChanged);\r\n        if (this._inspectSelection) {\r\n            this._diagram.addDiagramListener('ChangedSelection', this.inspectOnSelectionChanged);\r\n        }\r\n    }\r\n    /**\r\n     * This read-only property returns the HTMLElement containing the Inspector.\r\n     */\r\n    get div() { return this._div; }\r\n    /**\r\n     * Gets or sets the {@link Diagram} associated with this Inspector.\r\n     */\r\n    get diagram() { return this._diagram; }\r\n    set diagram(val) {\r\n        if (val !== this._diagram) {\r\n            // First, unassociate change listeners with current inspected diagram\r\n            this._diagram.removeModelChangedListener(this.inspectOnModelChanged);\r\n            this._diagram.removeDiagramListener('ChangedSelection', this.inspectOnSelectionChanged);\r\n            // Now set the diagram and add the necessary change listeners\r\n            this._diagram = val;\r\n            this._diagram.addModelChangedListener(this.inspectOnModelChanged);\r\n            if (this._inspectSelection) {\r\n                this._diagram.addDiagramListener('ChangedSelection', this.inspectOnSelectionChanged);\r\n                this.inspectObject();\r\n            }\r\n            else {\r\n                this.inspectObject(null);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * This read-only property returns the object currently being inspected.\r\n     *\r\n     * To set the inspected object, call {@link #inspectObject}.\r\n     */\r\n    get inspectedObject() { return this._inspectedObject; }\r\n    /**\r\n     * Gets or sets whether the Inspector automatically inspects the associated Diagram's selection.\r\n     * When set to false, the Inspector won't show anything until {@link #inspectObject} is called.\r\n     *\r\n     * The default value is true.\r\n     */\r\n    get inspectSelection() { return this._inspectSelection; }\r\n    set inspectSelection(val) {\r\n        if (val !== this._inspectSelection) {\r\n            this._inspectSelection = val;\r\n            if (this._inspectSelection) {\r\n                this._diagram.addDiagramListener('ChangedSelection', this.inspectOnSelectionChanged);\r\n                this.inspectObject();\r\n            }\r\n            else {\r\n                this._diagram.removeDiagramListener('ChangedSelection', this.inspectOnSelectionChanged);\r\n                this.inspectObject(null);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Gets or sets whether the Inspector includes all properties currently on the inspected object.\r\n     *\r\n     * The default value is true.\r\n     */\r\n    get includesOwnProperties() { return this._includesOwnProperties; }\r\n    set includesOwnProperties(val) {\r\n        if (val !== this._includesOwnProperties) {\r\n            this._includesOwnProperties = val;\r\n            this.inspectObject();\r\n        }\r\n    }\r\n    /**\r\n     * Gets or sets the properties that the Inspector will inspect, maybe setting options for those properties.\r\n     * The object should contain string: Object pairs represnting propertyName: propertyOptions.\r\n     * Can be used to include or exclude additional properties.\r\n     *\r\n     * The default value is an empty object.\r\n     */\r\n    get properties() { return this._properties; }\r\n    set properties(val) {\r\n        if (val !== this._properties) {\r\n            this._properties = val;\r\n            this.inspectObject();\r\n        }\r\n    }\r\n    /**\r\n     * Gets or sets the function to be called when a property is modified by the Inspector.\r\n     * The first paremeter will be the property name, the second will be the new value, and the third will be a reference to this Inspector.\r\n     *\r\n     * The default value is null, meaning nothing will be done.\r\n     */\r\n    get propertyModified() { return this._propertyModified; }\r\n    set propertyModified(val) {\r\n        if (val !== this._propertyModified) {\r\n            this._propertyModified = val;\r\n        }\r\n    }\r\n    /**\r\n     * Gets or sets whether the Inspector displays properties for multiple selected objects or just the first.\r\n     *\r\n     * The default value is false, meaning only the first item in the {@link Diagram#selection} is inspected.\r\n     */\r\n    get multipleSelection() { return this._multipleSelection; }\r\n    set multipleSelection(val) {\r\n        if (val !== this._multipleSelection) {\r\n            this._multipleSelection = val;\r\n            this.inspectObject();\r\n        }\r\n    }\r\n    /**\r\n     * Gets or sets whether the Inspector displays the union or intersection of properties for multiple selected objects.\r\n     *\r\n     * The default value is false, meaning the intersection of properties is inspected.\r\n     */\r\n    get showUnionProperties() { return this._showUnionProperties; }\r\n    set showUnionProperties(val) {\r\n        if (val !== this._showUnionProperties) {\r\n            this._showUnionProperties = val;\r\n            this.inspectObject();\r\n        }\r\n    }\r\n    /**\r\n     * Gets or sets how many objects will be displayed when {@link #multipleSelection} is true.\r\n     *\r\n     * The default value is 0, meaning all selected objects will be displayed for a given property.\r\n     */\r\n    get showLimit() { return this._showLimit; }\r\n    set showLimit(val) {\r\n        if (val !== this._showLimit) {\r\n            this._showLimit = val;\r\n            this.inspectObject();\r\n        }\r\n    }\r\n    /**\r\n     * This predicate function can be used as a value for the `show` option for properties.\r\n     * When used, the property will only be shown when inspecting a {@link Node}.\r\n     * @param {Part} part the Part being inspected\r\n     * @return {boolean}\r\n     */\r\n    static showIfNode(part) { return part instanceof go.Node; }\r\n    /**\r\n     * This predicate function can be used as a value for the `show` option for properties.\r\n     * When used, the property will only be shown when inspecting a {@link Link}.\r\n     * @param {Part} part the Part being inspected\r\n     * @return {boolean}\r\n     */\r\n    static showIfLink(part) { return part instanceof go.Link; }\r\n    /**\r\n     * This predicate function can be used as a value for the `show` option for properties.\r\n     * When used, the property will only be shown when inspecting a {@link Group}.\r\n     * @param {Part} part the Part being inspected\r\n     * @return {boolean}\r\n     */\r\n    static showIfGroup(part) { return part instanceof go.Group; }\r\n    /**\r\n     * This predicate function can be used as a value for the `show` option for properties.\r\n     * When used, the property will only be shown if present.\r\n     * Useful for properties such as `key`, which will be shown on Nodes and Groups, but normally not on Links\r\n     * @param {Part|null} part the Part being inspected\r\n     * @param {string} propname the property to check presence of\r\n     * @return {boolean}\r\n     */\r\n    static showIfPresent(data, propname) {\r\n        if (data instanceof go.Part)\r\n            data = data.data;\r\n        return typeof data === 'object' && data[propname] !== undefined;\r\n    }\r\n    /**\r\n     * Update the HTML state of this Inspector with the given object.\r\n     *\r\n     * If passed an object, the Inspector will inspect that object.\r\n     * If passed null, this will do nothing.\r\n     * If no parameter is supplied, the {@link #inspectedObject} will be set based on the value of {@link #inspectSelection}.\r\n     * @param {Object=} object an optional argument, used when {@link #inspectSelection} is false to\r\n     *   set {@link #inspectedObject} and show and edit that object's properties.\r\n     */\r\n    inspectObject(object) {\r\n        let inspectedObject = null;\r\n        let inspectedObjects = null;\r\n        if (object === null)\r\n            return;\r\n        if (object === undefined) {\r\n            if (this._inspectSelection) {\r\n                if (this._multipleSelection) { // gets the selection if multiple selection is true\r\n                    inspectedObjects = this._diagram.selection;\r\n                    this._inspectedObject = inspectedObjects.first();\r\n                }\r\n                else { // otherwise grab the first object\r\n                    inspectedObject = this._diagram.selection.first();\r\n                }\r\n            }\r\n            else { // if there is a single inspected object\r\n                inspectedObject = this._inspectedObject;\r\n            }\r\n        }\r\n        else { // if object was passed in as a parameter\r\n            inspectedObject = object;\r\n        }\r\n        if (!inspectedObjects && inspectedObject) {\r\n            inspectedObjects = new go.Set();\r\n            inspectedObjects.add(inspectedObject);\r\n        }\r\n        if (!inspectedObjects || inspectedObjects.count < 1) { // if nothing is selected\r\n            this.updateAllHTML();\r\n            return;\r\n        }\r\n        if (inspectedObjects) {\r\n            const mainDiv = this._div;\r\n            mainDiv.innerHTML = '';\r\n            const shared = new go.Map(); // for properties that the nodes have in common\r\n            const properties = new go.Map(); // for adding properties\r\n            const all = new go.Map(); // used later to prevent changing properties when unneeded\r\n            const it = inspectedObjects.iterator;\r\n            let nodecount = 2;\r\n            // Build table:\r\n            const table = document.createElement('table');\r\n            const tbody = document.createElement('tbody');\r\n            this.inspectedProperties = {};\r\n            this.tabIndex = 0;\r\n            const declaredProperties = this._properties;\r\n            it.next();\r\n            inspectedObject = it.value;\r\n            this._inspectedObject = inspectedObject;\r\n            let data = (inspectedObject instanceof go.Part) ? inspectedObject.data : inspectedObject;\r\n            if (data) { // initial pass to set shared and all\r\n                // Go through all the properties passed in to the inspector and add them to the map, if appropriate:\r\n                for (const name in declaredProperties) {\r\n                    const desc = declaredProperties[name];\r\n                    if (!this.canShowProperty(name, desc, inspectedObject))\r\n                        continue;\r\n                    const val = this.findValue(name, desc, data);\r\n                    if (val === '' && this._properties[name] && this._properties[name].type === 'checkbox') {\r\n                        shared.add(name, false);\r\n                        all.add(name, false);\r\n                    }\r\n                    else {\r\n                        shared.add(name, val);\r\n                        all.add(name, val);\r\n                    }\r\n                }\r\n                // Go through all the properties on the model data and add them to the map, if appropriate:\r\n                if (this._includesOwnProperties) {\r\n                    for (const k in data) {\r\n                        if (k === '__gohashid')\r\n                            continue; // skip internal GoJS hash property\r\n                        if (this.inspectedProperties[k])\r\n                            continue; // already exists\r\n                        if (declaredProperties[k] && !this.canShowProperty(k, declaredProperties[k], inspectedObject))\r\n                            continue;\r\n                        shared.add(k, data[k]);\r\n                        all.add(k, data[k]);\r\n                    }\r\n                }\r\n            }\r\n            while (it.next() && (this._showLimit < 1 || nodecount <= this._showLimit)) { // grabs all the properties from the other selected objects\r\n                properties.clear();\r\n                inspectedObject = it.value;\r\n                if (inspectedObject) {\r\n                    // use either the Part.data or the object itself (for model.modelData)\r\n                    data = (inspectedObject instanceof go.Part) ? inspectedObject.data : inspectedObject;\r\n                    if (data) {\r\n                        // Go through all the properties passed in to the inspector and add them to properties to add, if appropriate:\r\n                        for (const name in declaredProperties) {\r\n                            const desc = declaredProperties[name];\r\n                            if (!this.canShowProperty(name, desc, inspectedObject))\r\n                                continue;\r\n                            const val = this.findValue(name, desc, data);\r\n                            if (val === '' && this._properties[name] && this._properties[name].type === 'checkbox') {\r\n                                properties.add(name, false);\r\n                            }\r\n                            else {\r\n                                properties.add(name, val);\r\n                            }\r\n                        }\r\n                        // Go through all the properties on the model data and add them to properties to add, if appropriate:\r\n                        if (this._includesOwnProperties) {\r\n                            for (const k in data) {\r\n                                if (k === '__gohashid')\r\n                                    continue; // skip internal GoJS hash property\r\n                                if (this.inspectedProperties[k])\r\n                                    continue; // already exists\r\n                                if (declaredProperties[k] && !this.canShowProperty(k, declaredProperties[k], inspectedObject))\r\n                                    continue;\r\n                                properties.add(k, data[k]);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (!this._showUnionProperties) {\r\n                    // Cleans up shared map with properties that aren't shared between the selected objects\r\n                    // Also adds properties to the add and shared maps if applicable\r\n                    const addIt = shared.iterator;\r\n                    const toRemove = [];\r\n                    while (addIt.next()) {\r\n                        if (properties.has(addIt.key)) {\r\n                            let newVal = all.get(addIt.key) + '|' + properties.get(addIt.key);\r\n                            all.set(addIt.key, newVal);\r\n                            if ((declaredProperties[addIt.key] && declaredProperties[addIt.key].type !== 'color'\r\n                                && declaredProperties[addIt.key].type !== 'checkbox' && declaredProperties[addIt.key].type !== 'select')\r\n                                || !declaredProperties[addIt.key]) { // for non-string properties i.e color\r\n                                newVal = shared.get(addIt.key) + '|' + properties.get(addIt.key);\r\n                                shared.set(addIt.key, newVal);\r\n                            }\r\n                        }\r\n                        else { // toRemove array since addIt is still iterating\r\n                            toRemove.push(addIt.key);\r\n                        }\r\n                    }\r\n                    for (let i = 0; i < toRemove.length; i++) { // removes anything that doesn't showUnionProperties\r\n                        shared.remove(toRemove[i]);\r\n                        all.remove(toRemove[i]);\r\n                    }\r\n                }\r\n                else {\r\n                    // Adds missing properties to all with the correct amount of seperators\r\n                    let addIt = properties.iterator;\r\n                    while (addIt.next()) {\r\n                        if (all.has(addIt.key)) {\r\n                            if ((declaredProperties[addIt.key] && declaredProperties[addIt.key].type !== 'color'\r\n                                && declaredProperties[addIt.key].type !== 'checkbox' && declaredProperties[addIt.key].type !== 'select')\r\n                                || !declaredProperties[addIt.key]) { // for non-string properties i.e color\r\n                                const newVal = all.get(addIt.key) + '|' + properties.get(addIt.key);\r\n                                all.set(addIt.key, newVal);\r\n                            }\r\n                        }\r\n                        else {\r\n                            let newVal = '';\r\n                            for (let i = 0; i < nodecount - 1; i++)\r\n                                newVal += '|';\r\n                            newVal += properties.get(addIt.key);\r\n                            all.set(addIt.key, newVal);\r\n                        }\r\n                    }\r\n                    // Adds bars in case properties is not in all\r\n                    addIt = all.iterator;\r\n                    while (addIt.next()) {\r\n                        if (!properties.has(addIt.key)) {\r\n                            if ((declaredProperties[addIt.key] && declaredProperties[addIt.key].type !== 'color'\r\n                                && declaredProperties[addIt.key].type !== 'checkbox' && declaredProperties[addIt.key].type !== 'select')\r\n                                || !declaredProperties[addIt.key]) { // for non-string properties i.e color\r\n                                const newVal = all.get(addIt.key) + '|';\r\n                                all.set(addIt.key, newVal);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                nodecount++;\r\n            }\r\n            // builds the table property rows and sets multipleProperties to help with updateall\r\n            let mapIt;\r\n            if (!this._showUnionProperties)\r\n                mapIt = shared.iterator;\r\n            else\r\n                mapIt = all.iterator;\r\n            while (mapIt.next()) {\r\n                tbody.appendChild(this.buildPropertyRow(mapIt.key, mapIt.value)); // shows the properties that are allowed\r\n            }\r\n            table.appendChild(tbody);\r\n            mainDiv.appendChild(table);\r\n            const allIt = all.iterator;\r\n            while (allIt.next()) {\r\n                this.multipleProperties[allIt.key] = allIt.value; // used for updateall to know which properties to change\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * This predicate should be false if the given property should not be shown.\r\n     * Normally it only checks the value of \"show\" on the property descriptor.\r\n     *\r\n     * The default value is true.\r\n     * @param {string} propertyName the property name\r\n     * @param {Object} propertyDesc the property descriptor\r\n     * @param {Object} inspectedObject the data object\r\n     * @return {boolean} whether a particular property should be shown in this Inspector\r\n     */\r\n    canShowProperty(propertyName, propertyDesc, inspectedObject) {\r\n        const prop = propertyDesc;\r\n        if (prop.show === false)\r\n            return false;\r\n        // if \"show\" is a predicate, make sure it passes or do not show this property\r\n        if (typeof prop.show === 'function')\r\n            return prop.show(inspectedObject, propertyName);\r\n        return true;\r\n    }\r\n    /**\r\n     * This predicate should be false if the given property should not be editable by the user.\r\n     * Normally it only checks the value of \"readOnly\" on the property descriptor.\r\n     *\r\n     * The default value is true.\r\n     * @param {string} propertyName the property name\r\n     * @param {Object} propertyDesc the property descriptor\r\n     * @param {Object} inspectedObject the data object\r\n     * @return {boolean} whether a particular property should be shown in this Inspector\r\n     */\r\n    canEditProperty(propertyName, propertyDesc, inspectedObject) {\r\n        if (this._diagram.isReadOnly || this._diagram.isModelReadOnly)\r\n            return false;\r\n        if (inspectedObject === null)\r\n            return false;\r\n        // assume property values that are functions of Objects cannot be edited\r\n        const data = (inspectedObject instanceof go.Part) ? inspectedObject.data : inspectedObject;\r\n        const valtype = typeof data[propertyName];\r\n        if (valtype === 'function')\r\n            return false;\r\n        if (propertyDesc) {\r\n            const prop = propertyDesc;\r\n            if (prop.readOnly === true)\r\n                return false;\r\n            // if \"readOnly\" is a predicate, make sure it passes or do not show this property\r\n            if (typeof prop.readOnly === 'function')\r\n                return !prop.readOnly(inspectedObject, propertyName);\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * @ignore\r\n     * @param propName\r\n     * @param propDesc\r\n     * @param data\r\n     */\r\n    findValue(propName, propDesc, data) {\r\n        let val = '';\r\n        if (propDesc && propDesc.defaultValue !== undefined)\r\n            val = propDesc.defaultValue;\r\n        if (data[propName] !== undefined)\r\n            val = data[propName];\r\n        if (val === undefined)\r\n            return '';\r\n        return val;\r\n    }\r\n    /**\r\n     * This sets `inspectedProperties[propertyName]` and creates the HTML table row for a given property:\r\n     * ```html\r\n     * <tr>\r\n     *   <td>propertyName</td>\r\n     *   <td><input value=propertyValue /></td>\r\n     * </tr>\r\n     * ```\r\n     *\r\n     * This method can be customized to change how an Inspector row is rendered.\r\n     * @param {string} propertyName the property name\r\n     * @param {*} propertyValue the property value\r\n     * @return {HTMLTableRowElement} the table row\r\n     */\r\n    buildPropertyRow(propertyName, propertyValue) {\r\n        const tr = document.createElement('tr');\r\n        const td1 = document.createElement('td');\r\n        let displayName;\r\n        if (this._properties[propertyName] && this._properties[propertyName].name !== undefined) { // name changes the dispaly name shown on inspector\r\n            displayName = this._properties[propertyName].name;\r\n        }\r\n        else {\r\n            displayName = propertyName;\r\n        }\r\n        td1.textContent = displayName;\r\n        tr.appendChild(td1);\r\n        const td2 = document.createElement('td');\r\n        const decProp = this._properties[propertyName];\r\n        let input = null;\r\n        const self = this;\r\n        function updateall() {\r\n            if (self._diagram.selection.count === 1 || !self.multipleSelection) {\r\n                self.updateAllProperties();\r\n            }\r\n            else {\r\n                self.updateAllObjectsProperties();\r\n            }\r\n        }\r\n        if (decProp && decProp.type === 'select') {\r\n            const inputs = input = document.createElement('select');\r\n            this.updateSelect(decProp, inputs, propertyName, propertyValue);\r\n            inputs.addEventListener('change', updateall);\r\n        }\r\n        else {\r\n            const inputi = input = document.createElement('input');\r\n            if (inputi && inputi.setPointerCapture) {\r\n                inputi.addEventListener(\"pointerdown\", e => inputi.setPointerCapture(e.pointerId));\r\n            }\r\n            inputi.value = this.convertToString(propertyValue);\r\n            if (decProp) {\r\n                const t = decProp.type;\r\n                if (t !== 'string' && t !== 'number' && t !== 'boolean' &&\r\n                    t !== 'arrayofnumber' && t !== 'point' && t !== 'size' &&\r\n                    t !== 'rect' && t !== 'spot' && t !== 'margin') {\r\n                    inputi.setAttribute('type', decProp.type);\r\n                }\r\n                if (decProp.type === 'color') {\r\n                    if (inputi.type === 'color') {\r\n                        inputi.value = this.convertToColor(propertyValue);\r\n                        // input.addEventListener('input', updateall); // removed with multi select\r\n                        inputi.addEventListener('change', updateall);\r\n                    }\r\n                }\r\n                if (decProp.type === 'checkbox') {\r\n                    inputi.checked = !!propertyValue;\r\n                    inputi.addEventListener('change', updateall);\r\n                }\r\n            }\r\n            if (inputi.type !== 'color')\r\n                inputi.addEventListener('blur', updateall);\r\n        }\r\n        if (input) {\r\n            input.tabIndex = this.tabIndex++;\r\n            input.disabled = !this.canEditProperty(propertyName, decProp, this._inspectedObject);\r\n            td2.appendChild(input);\r\n        }\r\n        tr.appendChild(td2);\r\n        this.inspectedProperties[propertyName] = input;\r\n        return tr;\r\n    }\r\n    /**\r\n     * @hidden @ignore\r\n     * HTML5 color input will only take hex,\r\n     * so let HTML5 canvas convert the color into hex format.\r\n     * This converts \"rgb(255, 0, 0)\" into \"#FF0000\", etc.\r\n     */\r\n    convertToColor(propertyValue) {\r\n        const ctx = document.createElement('canvas').getContext('2d');\r\n        if (ctx === null)\r\n            return '#000000';\r\n        ctx.fillStyle = propertyValue;\r\n        return ctx.fillStyle;\r\n    }\r\n    /**\r\n     * @hidden @ignore\r\n     */\r\n    convertToArrayOfNumber(propertyValue) {\r\n        if (propertyValue === 'null')\r\n            return null;\r\n        const split = propertyValue.split(' ');\r\n        const arr = [];\r\n        for (let i = 0; i < split.length; i++) {\r\n            const str = split[i];\r\n            if (!str)\r\n                continue;\r\n            arr.push(parseFloat(str));\r\n        }\r\n        return arr;\r\n    }\r\n    /**\r\n     * @hidden @ignore\r\n     */\r\n    convertToString(x) {\r\n        if (x === undefined)\r\n            return 'undefined';\r\n        if (x === null)\r\n            return 'null';\r\n        if (x instanceof go.Point)\r\n            return go.Point.stringify(x);\r\n        if (x instanceof go.Size)\r\n            return go.Size.stringify(x);\r\n        if (x instanceof go.Rect)\r\n            return go.Rect.stringify(x);\r\n        if (x instanceof go.Spot)\r\n            return go.Spot.stringify(x);\r\n        if (x instanceof go.Margin)\r\n            return go.Margin.stringify(x);\r\n        if (x instanceof go.List)\r\n            return this.convertToString(x.toArray());\r\n        if (Array.isArray(x)) {\r\n            let str = '';\r\n            for (let i = 0; i < x.length; i++) {\r\n                if (i > 0)\r\n                    str += ' ';\r\n                const v = x[i];\r\n                str += this.convertToString(v);\r\n            }\r\n            return str;\r\n        }\r\n        return x.toString();\r\n    }\r\n    /**\r\n     * @hidden @ignore\r\n     * Update all of the HTML in this Inspector.\r\n     */\r\n    updateAllHTML() {\r\n        const inspectedProps = this.inspectedProperties;\r\n        const isPart = this._inspectedObject instanceof go.Part;\r\n        const data = isPart ? this._inspectedObject.data : this._inspectedObject;\r\n        if (!data) { // clear out all of the fields\r\n            for (const name in inspectedProps) {\r\n                const input = inspectedProps[name];\r\n                if (input instanceof HTMLSelectElement) {\r\n                    input.innerHTML = '';\r\n                }\r\n                else if (input.type === 'color') {\r\n                    input.value = '#000000';\r\n                }\r\n                else if (input.type === 'checkbox') {\r\n                    input.checked = false;\r\n                }\r\n                else {\r\n                    input.value = '';\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (const name in inspectedProps) {\r\n                const input = inspectedProps[name];\r\n                const propertyValue = data[name];\r\n                if (input instanceof HTMLSelectElement) {\r\n                    const decProp = this._properties[name];\r\n                    this.updateSelect(decProp, input, name, propertyValue);\r\n                }\r\n                else if (input.type === 'color') {\r\n                    input.value = this.convertToColor(propertyValue);\r\n                }\r\n                else if (input.type === 'checkbox') {\r\n                    input.checked = !!propertyValue;\r\n                }\r\n                else {\r\n                    input.value = this.convertToString(propertyValue);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @hidden @ignore\r\n     * Update an HTMLSelectElement with an appropriate list of choices, given the propertyName\r\n     */\r\n    updateSelect(decProp, select, propertyName, propertyValue) {\r\n        select.innerHTML = ''; // clear out anything that was there\r\n        let choices = decProp.choices;\r\n        if (typeof choices === 'function')\r\n            choices = choices(this._inspectedObject, propertyName);\r\n        if (!Array.isArray(choices))\r\n            choices = [];\r\n        decProp.choicesArray = choices; // remember list of actual choice values (not strings)\r\n        for (let i = 0; i < choices.length; i++) {\r\n            const choice = choices[i];\r\n            const opt = document.createElement('option');\r\n            opt.text = this.convertToString(choice);\r\n            select.add(opt);\r\n        }\r\n        select.value = this.convertToString(propertyValue);\r\n    }\r\n    parseValue(decProp, value, input, oldval) {\r\n        // If it's a boolean, or if its previous value was boolean,\r\n        // parse the value to be a boolean and then update the input.value to match\r\n        let type = '';\r\n        if (decProp !== undefined && decProp.type !== undefined) {\r\n            type = decProp.type;\r\n        }\r\n        if (type === '') {\r\n            if (typeof oldval === 'boolean')\r\n                type = 'boolean'; // infer boolean\r\n            else if (typeof oldval === 'number')\r\n                type = 'number';\r\n            else if (oldval instanceof go.Point)\r\n                type = 'point';\r\n            else if (oldval instanceof go.Size)\r\n                type = 'size';\r\n            else if (oldval instanceof go.Rect)\r\n                type = 'rect';\r\n            else if (oldval instanceof go.Spot)\r\n                type = 'spot';\r\n            else if (oldval instanceof go.Margin)\r\n                type = 'margin';\r\n        }\r\n        // convert to specific type, if needed\r\n        switch (type) {\r\n            case 'boolean':\r\n                value = !(value === false || value === 'false' || value === '0');\r\n                break;\r\n            case 'number':\r\n                value = parseFloat(value);\r\n                break;\r\n            case 'arrayofnumber':\r\n                value = this.convertToArrayOfNumber(value);\r\n                break;\r\n            case 'point':\r\n                value = go.Point.parse(value);\r\n                break;\r\n            case 'size':\r\n                value = go.Size.parse(value);\r\n                break;\r\n            case 'rect':\r\n                value = go.Rect.parse(value);\r\n                break;\r\n            case 'spot':\r\n                value = go.Spot.parse(value);\r\n                break;\r\n            case 'margin':\r\n                value = go.Margin.parse(value);\r\n                break;\r\n            case 'checkbox':\r\n                value = input.checked;\r\n                break;\r\n            case 'select':\r\n                value = decProp.choicesArray[input.selectedIndex];\r\n                break;\r\n        }\r\n        return value;\r\n    }\r\n    /**\r\n     * @hidden @ignore\r\n     * Update all of the data properties of all the objects in {@link #inspectedObjects} according to the\r\n     * current values held in the HTML input elements.\r\n     */\r\n    updateAllObjectsProperties() {\r\n        const inspectedProps = this.inspectedProperties;\r\n        const diagram = this._diagram;\r\n        diagram.startTransaction('set all properties');\r\n        for (const name in inspectedProps) {\r\n            const input = inspectedProps[name];\r\n            let value = input.value;\r\n            const arr1 = value.split('|');\r\n            let arr2 = [];\r\n            if (this.multipleProperties[name]) {\r\n                // don't split if it is union and its checkbox type\r\n                if (this._properties[name] && this._properties[name].type === 'checkbox' && this._showUnionProperties) {\r\n                    arr2.push(this.multipleProperties[name]);\r\n                }\r\n                else if (this._properties[name]) {\r\n                    arr2 = this.multipleProperties[name].toString().split('|');\r\n                }\r\n            }\r\n            const it = diagram.selection.iterator;\r\n            let change = false;\r\n            if (this._properties[name] && this._properties[name].type === 'checkbox')\r\n                change = true; // always change checkbox\r\n            if (arr1.length < arr2.length // i.e Alpha|Beta -> Alpha procs the change\r\n                && (!this._properties[name] // from and to links\r\n                    || !(this._properties[name] // do not change color checkbox and choices due to them always having less\r\n                        && (this._properties[name].type === 'color' || this._properties[name].type === 'checkbox' || this._properties[name].type === 'choices')))) {\r\n                change = true;\r\n            }\r\n            else { // standard detection in change in properties\r\n                for (let j = 0; j < arr1.length && j < arr2.length; j++) {\r\n                    if (!(arr1[j] === arr2[j])\r\n                        && !(this._properties[name] && this._properties[name].type === 'color' && arr1[j].toLowerCase() === arr2[j].toLowerCase())) {\r\n                        change = true;\r\n                    }\r\n                }\r\n            }\r\n            if (change) { // only change properties it needs to change instead all of them\r\n                for (let i = 0; i < diagram.selection.count; i++) {\r\n                    it.next();\r\n                    const isPart = it.value instanceof go.Part;\r\n                    const data = isPart ? it.value.data : it.value;\r\n                    if (data) { // ignores the selected node if there is no data\r\n                        if (i < arr1.length)\r\n                            value = arr1[i];\r\n                        else\r\n                            value = arr1[0];\r\n                        // don't update \"readOnly\" data properties\r\n                        const decProp = this._properties[name];\r\n                        if (!this.canEditProperty(name, decProp, it.value))\r\n                            continue;\r\n                        const oldval = data[name];\r\n                        value = this.parseValue(decProp, value, input, oldval);\r\n                        // in case parsed to be different, such as in the case of boolean values,\r\n                        // the value shown should match the actual value\r\n                        input.value = value;\r\n                        // modify the data object in an undo-able fashion\r\n                        diagram.model.setDataProperty(data, name, value);\r\n                        // notify any listener\r\n                        if (this.propertyModified !== null)\r\n                            this.propertyModified(name, value, this);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        diagram.commitTransaction('set all properties');\r\n    }\r\n    /**\r\n     * @hidden @ignore\r\n     * Update all of the data properties of {@link #inspectedObject} according to the\r\n     * current values held in the HTML input elements.\r\n     */\r\n    updateAllProperties() {\r\n        const inspectedProps = this.inspectedProperties;\r\n        const diagram = this._diagram;\r\n        const isPart = this.inspectedObject instanceof go.Part;\r\n        const data = isPart ? this.inspectedObject.data : this.inspectedObject;\r\n        if (!data)\r\n            return; // must not try to update data when there's no data!\r\n        diagram.startTransaction('set all properties');\r\n        for (const name in inspectedProps) {\r\n            const input = inspectedProps[name];\r\n            let value = input.value;\r\n            // don't update \"readOnly\" data properties\r\n            const decProp = this._properties[name];\r\n            if (!this.canEditProperty(name, decProp, this.inspectedObject))\r\n                continue;\r\n            const oldval = data[name];\r\n            value = this.parseValue(decProp, value, input, oldval);\r\n            // in case parsed to be different, such as in the case of boolean values,\r\n            // the value shown should match the actual value\r\n            input.value = value;\r\n            // modify the data object in an undo-able fashion\r\n            diagram.model.setDataProperty(data, name, value);\r\n            // notify any listener\r\n            if (this.propertyModified !== null)\r\n                this.propertyModified(name, value, this);\r\n        }\r\n        diagram.commitTransaction('set all properties');\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}