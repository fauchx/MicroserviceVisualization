{"ast":null,"code":"/*\n * GoJS v2.2.16 JavaScript Library for HTML Diagrams, https://gojs.net\n * GoJS and Northwoods Software are registered trademarks of Northwoods Software Corporation, https://www.nwoods.com.\n * Copyright (C) 1998-2022 by Northwoods Software Corporation.  All Rights Reserved.\n * THIS SOFTWARE IS LICENSED.  THE LICENSE AGREEMENT IS AT: https://gojs.net/2.2.16/license.html.\n * DO NOT MODIFY THIS FILE.  DO NOT DISTRIBUTE A MODIFIED COPY OF THE CONTENTS OF THIS FILE.\n */\n(function () {\n  var t;\n\n  function aa(a) {\n    var b = 0;\n    return function () {\n      return b < a.length ? {\n        done: !1,\n        value: a[b++]\n      } : {\n        done: !0\n      };\n    };\n  }\n\n  function ba(a) {\n    var b = \"undefined\" != typeof Symbol && Symbol.iterator && a[Symbol.iterator];\n    return b ? b.call(a) : {\n      next: aa(a)\n    };\n  }\n\n  function ca(a) {\n    for (var b, c = []; !(b = a.next()).done;) {\n      c.push(b.value);\n    }\n\n    return c;\n  }\n\n  var ea = \"function\" == typeof Object.create ? Object.create : function (a) {\n    function b() {}\n\n    b.prototype = a;\n    return new b();\n  },\n      fa;\n  if (\"function\" == typeof Object.setPrototypeOf) fa = Object.setPrototypeOf;else {\n    var ha;\n\n    a: {\n      var ia = {\n        a: !0\n      },\n          ja = {};\n\n      try {\n        ja.__proto__ = ia;\n        ha = ja.a;\n        break a;\n      } catch (a) {}\n\n      ha = !1;\n    }\n\n    fa = ha ? function (a, b) {\n      a.__proto__ = b;\n      if (a.__proto__ !== b) throw new TypeError(a + \" is not extensible\");\n      return a;\n    } : null;\n  }\n  var ka = fa;\n\n  function la(a, b) {\n    a.prototype = ea(b.prototype);\n    a.prototype.constructor = a;\n    if (ka) ka(a, b);else for (var c in b) {\n      if (\"prototype\" != c) if (Object.defineProperties) {\n        var d = Object.getOwnPropertyDescriptor(b, c);\n        d && Object.defineProperty(a, c, d);\n      } else a[c] = b[c];\n    }\n    a.zA = b.prototype;\n  }\n\n  var ma = \"undefined\" != typeof global && null != global ? global : self,\n      na = \"function\" == typeof Object.assign ? Object.assign : function (a, b) {\n    for (var c = 1; c < arguments.length; c++) {\n      var d = arguments[c];\n      if (d) for (var e in d) {\n        Object.prototype.hasOwnProperty.call(d, e) && (a[e] = d[e]);\n      }\n    }\n\n    return a;\n  },\n      pa = \"function\" == typeof Object.defineProperties ? Object.defineProperty : function (a, b, c) {\n    a != Array.prototype && a != Object.prototype && (a[b] = c.value);\n  };\n\n  function qa(a, b) {\n    if (b) {\n      var c = ma;\n      a = a.split(\".\");\n\n      for (var d = 0; d < a.length - 1; d++) {\n        var e = a[d];\n        e in c || (c[e] = {});\n        c = c[e];\n      }\n\n      a = a[a.length - 1];\n      d = c[a];\n      b = b(d);\n      b != d && null != b && pa(c, a, {\n        writable: !0,\n        value: b\n      });\n    }\n  }\n\n  qa(\"Object.assign\", function (a) {\n    return a || na;\n  });\n  qa(\"Array.prototype.fill\", function (a) {\n    return a ? a : function (a, c, d) {\n      var b = this.length || 0;\n      0 > c && (c = Math.max(0, b + c));\n      if (null == d || d > b) d = b;\n      d = Number(d);\n      0 > d && (d = Math.max(0, b + d));\n\n      for (c = Number(c || 0); c < d; c++) {\n        this[c] = a;\n      }\n\n      return this;\n    };\n  });\n  var x = \"object\" === typeof globalThis && globalThis || \"object\" === typeof global && global.global === global && global || \"object\" === typeof self && self.self === self && self || {};\n  void 0 === x.requestAnimationFrame && (void 0 === x.setImmediate ? x.requestAnimationFrame = function (a) {\n    x.setTimeout(a, 0);\n  } : x.requestAnimationFrame = x.setImmediate);\n\n  function ra() {}\n\n  function sa(a, b) {\n    var c = -1;\n    return function () {\n      var d = this,\n          e = arguments;\n      -1 !== c && x.clearTimeout(c);\n      c = ta(function () {\n        c = -1;\n        a.apply(d, e);\n      }, b);\n    };\n  }\n\n  function ta(a, b) {\n    return x.setTimeout(a, b);\n  }\n\n  function ua(a) {\n    return x.document.createElement(a);\n  }\n\n  function C(a) {\n    throw Error(a);\n  }\n\n  function va(a, b) {\n    a = \"The object is frozen, so its properties cannot be set: \" + a.toString();\n    void 0 !== b && (a += \"  to value: \" + b);\n    C(a);\n  }\n\n  function wa(a, b, c, d) {\n    c = null === c ? \"*\" : \"string\" === typeof c ? c : \"function\" === typeof c && \"string\" === typeof c.className ? c.className : \"\";\n    void 0 !== d && (c += \".\" + d);\n    C(c + \" is not in the range \" + b + \": \" + a);\n  }\n\n  function xa(a) {\n    x.console && x.console.log(a);\n  }\n\n  function ya(a) {\n    return \"object\" === typeof a && null !== a;\n  }\n\n  function za(a) {\n    return Array.isArray(a) || x.NodeList && a instanceof x.NodeList || x.HTMLCollection && a instanceof x.HTMLCollection;\n  }\n\n  function Aa(a) {\n    return Array.prototype.slice.call(a);\n  }\n\n  function Ca(a, b, c) {\n    Array.isArray(a) ? b >= a.length ? a.push(c) : a.splice(b, 0, c) : C(\"Cannot insert an object into an HTMLCollection or NodeList: \" + c + \" at \" + b);\n  }\n\n  function Da(a, b) {\n    Array.isArray(a) ? b >= a.length ? a.pop() : a.splice(b, 1) : C(\"Cannot remove an object from an HTMLCollection or NodeList at \" + b);\n  }\n\n  function Ea() {\n    var a = Fa.pop();\n    return void 0 === a ? [] : a;\n  }\n\n  function Ga(a) {\n    a.length = 0;\n    Fa.push(a);\n  }\n\n  function Ha(a) {\n    if (\"function\" === typeof a) {\n      if (a.className) return a.className;\n      if (a.name) return a.name;\n      var b = a.toString();\n      b = b.substring(9, b.indexOf(\"(\")).trim();\n      if (\"\" !== b) return a._className = b;\n    } else if (ya(a) && a.constructor) return Ha(a.constructor);\n\n    return typeof a;\n  }\n\n  function Ia(a) {\n    var b = a;\n    ya(a) && (a.text ? b = a.text : a.name ? b = a.name : void 0 !== a.key ? b = a.key : void 0 !== a.id ? b = a.id : a.constructor === Object && (a.Text ? b = a.Text : a.Name ? b = a.Name : void 0 !== a.Key ? b = a.Key : void 0 !== a.Id ? b = a.Id : void 0 !== a.ID && (b = a.ID)));\n    return void 0 === b ? \"undefined\" : null === b ? \"null\" : b.toString();\n  }\n\n  function Ja(a, b) {\n    if (a.hasOwnProperty(b)) return !0;\n\n    for (a = Object.getPrototypeOf(a); a && a !== Function;) {\n      if (a.hasOwnProperty(b)) return !0;\n      var c = a.lA;\n      if (c && c[b]) return !0;\n      a = Object.getPrototypeOf(a);\n    }\n\n    return !1;\n  }\n\n  function Ka(a, b, c) {\n    Object.defineProperty(La.prototype, a, {\n      get: b,\n      set: c\n    });\n  }\n\n  function Ma(a) {\n    for (var b = [], c = 0; 256 > c; c++) {\n      b[\"0123456789abcdef\".charAt(c >> 4) + \"0123456789abcdef\".charAt(c & 15)] = String.fromCharCode(c);\n    }\n\n    a.length % 2 && (a = \"0\" + a);\n    c = [];\n\n    for (var d = 0, e = 0; e < a.length; e += 2) {\n      c[d++] = b[a.substr(e, 2)];\n    }\n\n    a = c.join(\"\");\n    a = \"\" === a ? \"0\" : a;\n    b = [];\n\n    for (c = 0; 256 > c; c++) {\n      b[c] = c;\n    }\n\n    for (c = d = 0; 256 > c; c++) {\n      d = (d + b[c] + 119) % 256, e = b[c], b[c] = b[d], b[d] = e;\n    }\n\n    d = c = 0;\n\n    for (var f = \"\", g = 0; g < a.length; g++) {\n      c = (c + 1) % 256, d = (d + b[c]) % 256, e = b[c], b[c] = b[d], b[d] = e, f += String.fromCharCode(a.charCodeAt(g) ^ b[(b[c] + b[d]) % 256]);\n    }\n\n    return f;\n  }\n\n  var Na = void 0 !== x.navigator && 0 < x.navigator.userAgent.indexOf(\"Trident/7\"),\n      Pa = void 0 !== x.navigator && 0 < x.navigator.userAgent.indexOf(\"Edge/\"),\n      Qa = void 0 !== x.navigator && void 0 !== x.navigator.platform && null !== x.navigator.platform.match(/(iPhone|iPod|iPad|Mac)/i),\n      Fa = [];\n  Object.freeze([]);\n  ra.className = \"Util\";\n  ra.Dx = \"32ab5ff3b26f42dc0ed90f21462913b5\";\n  ra.adym = \"gojs.net\";\n  ra.vfo = \"28e644fdb260\";\n  ra.className = \"Util\";\n\n  function D(a, b, c) {\n    Ra(this);\n    this.j = a;\n    this.va = b;\n    this.m = c;\n  }\n\n  D.prototype.toString = function () {\n    return \"EnumValue.\" + this.va;\n  };\n\n  function Sa(a, b) {\n    return void 0 === b || null === b || \"\" === b ? null : a[b];\n  }\n\n  ma.Object.defineProperties(D.prototype, {\n    classType: {\n      get: function get() {\n        return this.j;\n      }\n    },\n    name: {\n      get: function get() {\n        return this.va;\n      }\n    },\n    value: {\n      get: function get() {\n        return this.m;\n      }\n    }\n  });\n  D.className = \"EnumValue\";\n\n  function Ta() {\n    this.Jv = [];\n  }\n\n  Ta.prototype.toString = function () {\n    return this.Jv.join(\"\");\n  };\n\n  Ta.prototype.add = function (a) {\n    \"\" !== a && this.Jv.push(a);\n  };\n\n  Ta.className = \"StringBuilder\";\n\n  function Wa() {}\n\n  Wa.className = \"PropertyCollection\";\n  var Xa = {\n    nA: !1,\n    sA: !1,\n    pA: !1,\n    rA: !1,\n    xA: !1,\n    vA: !1,\n    Rw: !1,\n    oA: null,\n    trace: function trace(a) {\n      x.console && x.console.log(a);\n    },\n    qA: function qA(a, b, c, d) {\n      a.strokeStyle = \"red\";\n      a.fillStyle = \"red\";\n      a.font = \"8px sans-serif\";\n      a.beginPath();\n      a.moveTo(-10, 0);\n      a.lineTo(10, 0);\n      a.moveTo(0, -10);\n      a.lineTo(0, 10);\n      a.stroke();\n      a.setTransform(1, 0, 0, 1, 0, 0);\n      a.scale(c, c);\n      a.transform(b.m11, b.m12, b.m21, b.m22, b.dx, b.dy);\n      a.lineWidth = 2;\n      a.beginPath();\n      a.moveTo(d.left, d.top + 20);\n      a.lineTo(d.left, d.top);\n      a.lineTo(d.left + 20, d.top);\n      a.moveTo(d.right, d.bottom - 20);\n      a.lineTo(d.right, d.bottom);\n      a.lineTo(d.right - 20, d.bottom);\n      a.stroke();\n      a.fillText(\"DB: \" + Math.round(d.x) + \", \" + Math.round(d.y) + \", \" + Math.round(d.width) + \", \" + Math.round(d.height), d.left, d.top - 5);\n    },\n    mA: function mA(a) {\n      var b = {},\n          c;\n\n      for (c in a) {\n        b.x = c;\n\n        if (\"licenseKey\" !== b.x) {\n          var d = a[b.x];\n\n          if (void 0 !== d.prototype) {\n            b.Gl = Object.getOwnPropertyNames(d.prototype);\n\n            for (var e = {\n              Lj: 0\n            }; e.Lj < b.Gl.length; e = {\n              Lj: e.Lj\n            }, e.Lj++) {\n              var f = Object.getOwnPropertyDescriptor(d.prototype, b.Gl[e.Lj]);\n              void 0 !== f.get && void 0 === f.set && Object.defineProperty(d.prototype, b.Gl[e.Lj], {\n                set: function (a, b) {\n                  return function () {\n                    throw Error(\"Property \" + a.Gl[b.Lj] + \" of \" + a.x + \" is read-only.\");\n                  };\n                }(b, e)\n              });\n            }\n          }\n        }\n\n        b = {\n          Gl: b.Gl,\n          x: b.x\n        };\n      }\n    }\n  };\n\n  function Ya() {}\n\n  Ya.prototype.reset = function () {};\n\n  Ya.prototype.next = function () {\n    return !1;\n  };\n\n  Ya.prototype.ud = function () {\n    return !1;\n  };\n\n  Ya.prototype.first = function () {\n    return null;\n  };\n\n  Ya.prototype.any = function () {\n    return !1;\n  };\n\n  Ya.prototype.all = function () {\n    return !0;\n  };\n\n  Ya.prototype.each = function () {\n    return this;\n  };\n\n  Ya.prototype.map = function () {\n    return this;\n  };\n\n  Ya.prototype.filter = function () {\n    return this;\n  };\n\n  Ya.prototype.Xd = function () {};\n\n  Ya.prototype.toString = function () {\n    return \"EmptyIterator\";\n  };\n\n  ma.Object.defineProperties(Ya.prototype, {\n    iterator: {\n      get: function get() {\n        return this;\n      }\n    },\n    count: {\n      get: function get() {\n        return 0;\n      }\n    }\n  });\n  Ya.prototype.first = Ya.prototype.first;\n  Ya.prototype.hasNext = Ya.prototype.ud;\n  Ya.prototype.next = Ya.prototype.next;\n  Ya.prototype.reset = Ya.prototype.reset;\n  var Za = null;\n  Ya.className = \"EmptyIterator\";\n  Za = new Ya();\n\n  function $a(a) {\n    this.key = -1;\n    this.value = a;\n  }\n\n  $a.prototype.reset = function () {\n    this.key = -1;\n  };\n\n  $a.prototype.next = function () {\n    return -1 === this.key ? (this.key = 0, !0) : !1;\n  };\n\n  $a.prototype.ud = function () {\n    return this.next();\n  };\n\n  $a.prototype.first = function () {\n    this.key = 0;\n    return this.value;\n  };\n\n  $a.prototype.any = function (a) {\n    this.key = -1;\n    return a(this.value);\n  };\n\n  $a.prototype.all = function (a) {\n    this.key = -1;\n    return a(this.value);\n  };\n\n  $a.prototype.each = function (a) {\n    this.key = -1;\n    a(this.value);\n    return this;\n  };\n\n  $a.prototype.map = function (a) {\n    return new $a(a(this.value));\n  };\n\n  $a.prototype.filter = function (a) {\n    return a(this.value) ? new $a(this.value) : Za;\n  };\n\n  $a.prototype.Xd = function () {\n    this.value = null;\n  };\n\n  $a.prototype.toString = function () {\n    return \"SingletonIterator(\" + this.value + \")\";\n  };\n\n  ma.Object.defineProperties($a.prototype, {\n    iterator: {\n      get: function get() {\n        return this;\n      }\n    },\n    count: {\n      get: function get() {\n        return 1;\n      }\n    }\n  });\n  $a.prototype.first = $a.prototype.first;\n  $a.prototype.hasNext = $a.prototype.ud;\n  $a.prototype.next = $a.prototype.next;\n  $a.prototype.reset = $a.prototype.reset;\n  $a.className = \"SingletonIterator\";\n\n  function ab(a) {\n    this.xb = a;\n    this.cf = null;\n    a.Pa = null;\n    this.na = a.Ia;\n    this.Wa = -1;\n  }\n\n  ab.prototype.reset = function () {\n    var a = this.xb;\n    a.Pa = null;\n    this.na = a.Ia;\n    this.Wa = -1;\n  };\n\n  ab.prototype.next = function () {\n    var a = this.xb;\n    if (a.Ia !== this.na && 0 > this.key) return !1;\n    a = a.s;\n    var b = a.length,\n        c = ++this.Wa,\n        d = this.cf;\n    if (null !== d) for (; c < b;) {\n      var e = a[c];\n      if (d(e)) return this.key = this.Wa = c, this.value = e, !0;\n      c++;\n    } else {\n      if (c < b) return this.key = c, this.value = a[c], !0;\n      this.Xd();\n    }\n    return !1;\n  };\n\n  ab.prototype.ud = function () {\n    return this.next();\n  };\n\n  ab.prototype.first = function () {\n    var a = this.xb;\n    this.na = a.Ia;\n    this.Wa = 0;\n    a = a.s;\n    var b = a.length,\n        c = this.cf;\n\n    if (null !== c) {\n      for (var d = 0; d < b;) {\n        var e = a[d];\n        if (c(e)) return this.key = this.Wa = d, this.value = e;\n        d++;\n      }\n\n      return null;\n    }\n\n    return 0 < b ? (a = a[0], this.key = 0, this.value = a) : null;\n  };\n\n  ab.prototype.any = function (a) {\n    var b = this.xb;\n    b.Pa = null;\n    this.Wa = -1;\n    b = b.s;\n\n    for (var c = b.length, d = this.cf, e = 0; e < c; e++) {\n      var f = b[e];\n      if ((null === d || d(f)) && a(f)) return !0;\n    }\n\n    return !1;\n  };\n\n  ab.prototype.all = function (a) {\n    var b = this.xb;\n    b.Pa = null;\n    this.Wa = -1;\n    b = b.s;\n\n    for (var c = b.length, d = this.cf, e = 0; e < c; e++) {\n      var f = b[e];\n      if ((null === d || d(f)) && !a(f)) return !1;\n    }\n\n    return !0;\n  };\n\n  ab.prototype.each = function (a) {\n    var b = this.xb;\n    b.Pa = null;\n    this.Wa = -1;\n    b = b.s;\n\n    for (var c = b.length, d = this.cf, e = 0; e < c; e++) {\n      var f = b[e];\n      (null === d || d(f)) && a(f);\n    }\n\n    return this;\n  };\n\n  ab.prototype.map = function (a) {\n    var b = this.xb;\n    b.Pa = null;\n    this.Wa = -1;\n    var c = [];\n    b = b.s;\n\n    for (var d = b.length, e = this.cf, f = 0; f < d; f++) {\n      var g = b[f];\n      (null === e || e(g)) && c.push(a(g));\n    }\n\n    a = new E();\n    a.s = c;\n    a.sb();\n    return a.iterator;\n  };\n\n  ab.prototype.filter = function (a) {\n    var b = this.xb;\n    b.Pa = null;\n    this.Wa = -1;\n    var c = [];\n    b = b.s;\n\n    for (var d = b.length, e = this.cf, f = 0; f < d; f++) {\n      var g = b[f];\n      (null === e || e(g)) && a(g) && c.push(g);\n    }\n\n    a = new E();\n    a.s = c;\n    a.sb();\n    return a.iterator;\n  };\n\n  ab.prototype.Xd = function () {\n    this.key = -1;\n    this.value = null;\n    this.na = -1;\n    this.cf = null;\n    this.xb.Pa = this;\n  };\n\n  ab.prototype.toString = function () {\n    return \"ListIterator@\" + this.Wa + \"/\" + this.xb.count;\n  };\n\n  ma.Object.defineProperties(ab.prototype, {\n    iterator: {\n      get: function get() {\n        return this;\n      }\n    },\n    predicate: {\n      get: function get() {\n        return this.cf;\n      },\n      set: function set(a) {\n        this.cf = a;\n      }\n    },\n    count: {\n      get: function get() {\n        var a = this.cf;\n\n        if (null !== a) {\n          for (var b = 0, c = this.xb.s, d = c.length, e = 0; e < d; e++) {\n            a(c[e]) && b++;\n          }\n\n          return b;\n        }\n\n        return this.xb.s.length;\n      }\n    }\n  });\n  ab.prototype.first = ab.prototype.first;\n  ab.prototype.hasNext = ab.prototype.ud;\n  ab.prototype.next = ab.prototype.next;\n  ab.prototype.reset = ab.prototype.reset;\n  ab.className = \"ListIterator\";\n\n  function bb(a) {\n    this.xb = a;\n    a.yg = null;\n    this.na = a.Ia;\n    this.Wa = a.s.length;\n  }\n\n  bb.prototype.reset = function () {\n    var a = this.xb;\n    a.yg = null;\n    this.na = a.Ia;\n    this.Wa = a.s.length;\n  };\n\n  bb.prototype.next = function () {\n    var a = this.xb;\n    if (a.Ia !== this.na && 0 > this.key) return !1;\n    var b = --this.Wa;\n    if (0 <= b) return this.key = b, this.value = a.s[b], !0;\n    this.Xd();\n    return !1;\n  };\n\n  bb.prototype.ud = function () {\n    return this.next();\n  };\n\n  bb.prototype.first = function () {\n    var a = this.xb;\n    this.na = a.Ia;\n    var b = a.s;\n    this.Wa = a = b.length - 1;\n    return 0 <= a ? (b = b[a], this.key = a, this.value = b) : null;\n  };\n\n  bb.prototype.any = function (a) {\n    var b = this.xb;\n    b.yg = null;\n    b = b.s;\n    var c = b.length;\n    this.Wa = c;\n\n    for (--c; 0 <= c; c--) {\n      if (a(b[c])) return !0;\n    }\n\n    return !1;\n  };\n\n  bb.prototype.all = function (a) {\n    var b = this.xb;\n    b.yg = null;\n    b = b.s;\n    var c = b.length;\n    this.Wa = c;\n\n    for (--c; 0 <= c; c--) {\n      if (!a(b[c])) return !1;\n    }\n\n    return !0;\n  };\n\n  bb.prototype.each = function (a) {\n    var b = this.xb;\n    b.yg = null;\n    b = b.s;\n    var c = b.length;\n    this.Wa = c;\n\n    for (--c; 0 <= c; c--) {\n      a(b[c]);\n    }\n\n    return this;\n  };\n\n  bb.prototype.map = function (a) {\n    var b = this.xb;\n    b.yg = null;\n    var c = [];\n    b = b.s;\n    var d = b.length;\n    this.Wa = d;\n\n    for (--d; 0 <= d; d--) {\n      c.push(a(b[d]));\n    }\n\n    a = new E();\n    a.s = c;\n    a.sb();\n    return a.iterator;\n  };\n\n  bb.prototype.filter = function (a) {\n    var b = this.xb;\n    b.yg = null;\n    var c = [];\n    b = b.s;\n    var d = b.length;\n    this.Wa = d;\n\n    for (--d; 0 <= d; d--) {\n      var e = b[d];\n      a(e) && c.push(e);\n    }\n\n    a = new E();\n    a.s = c;\n    a.sb();\n    return a.iterator;\n  };\n\n  bb.prototype.Xd = function () {\n    this.key = -1;\n    this.value = null;\n    this.na = -1;\n    this.xb.yg = this;\n  };\n\n  bb.prototype.toString = function () {\n    return \"ListIteratorBackwards(\" + this.Wa + \"/\" + this.xb.count + \")\";\n  };\n\n  ma.Object.defineProperties(bb.prototype, {\n    iterator: {\n      get: function get() {\n        return this;\n      }\n    },\n    count: {\n      get: function get() {\n        return this.xb.s.length;\n      }\n    }\n  });\n  bb.prototype.first = bb.prototype.first;\n  bb.prototype.hasNext = bb.prototype.ud;\n  bb.prototype.next = bb.prototype.next;\n  bb.prototype.reset = bb.prototype.reset;\n  bb.className = \"ListIteratorBackwards\";\n\n  function E(a) {\n    Ra(this);\n    this._isFrozen = !1;\n    this.s = [];\n    this.Ia = 0;\n    this.yg = this.Pa = null;\n    \"string\" === typeof a && C(\"Error: Since 2.0 List/Map/Set constructors no longer take an argument that enforces type.\");\n    void 0 !== a && this.addAll(a);\n  }\n\n  t = E.prototype;\n\n  t.sb = function () {\n    var a = this.Ia;\n    a++;\n    999999999 < a && (a = 0);\n    this.Ia = a;\n  };\n\n  t.freeze = function () {\n    this._isFrozen = !0;\n    return this;\n  };\n\n  t.ja = function () {\n    this._isFrozen = !1;\n    return this;\n  };\n\n  t.toString = function () {\n    return \"List()#\" + cb(this);\n  };\n\n  t.add = function (a) {\n    if (null === a) return this;\n    this._isFrozen && va(this, a);\n    this.s.push(a);\n    this.sb();\n    return this;\n  };\n\n  t.push = function (a) {\n    this.add(a);\n  };\n\n  t.addAll = function (a) {\n    if (null === a) return this;\n    this._isFrozen && va(this);\n    var b = this.s;\n    if (za(a)) for (var c = a.length, d = 0; d < c; d++) {\n      b.push(a[d]);\n    } else for (a = a.iterator; a.next();) {\n      b.push(a.value);\n    }\n    this.sb();\n    return this;\n  };\n\n  t.clear = function () {\n    this._isFrozen && va(this);\n    this.s.length = 0;\n    this.sb();\n  };\n\n  t.contains = function (a) {\n    return null === a ? !1 : -1 !== this.s.indexOf(a);\n  };\n\n  t.has = function (a) {\n    return this.contains(a);\n  };\n\n  t.indexOf = function (a) {\n    return null === a ? -1 : this.s.indexOf(a);\n  };\n\n  t.K = function (a) {\n    var b = this.s;\n    (0 > a || a >= b.length) && wa(a, \"0 <= i < length\", E, \"elt:i\");\n    return b[a];\n  };\n\n  t.get = function (a) {\n    return this.K(a);\n  };\n\n  t.Vc = function (a, b) {\n    var c = this.s;\n    (0 > a || a >= c.length) && wa(a, \"0 <= i < length\", E, \"setElt:i\");\n    this._isFrozen && va(this, a);\n    c[a] = b;\n  };\n\n  t.set = function (a, b) {\n    this.Vc(a, b);\n  };\n\n  t.first = function () {\n    var a = this.s;\n    return 0 === a.length ? null : a[0];\n  };\n\n  t.fc = function () {\n    var a = this.s,\n        b = a.length;\n    return 0 < b ? a[b - 1] : null;\n  };\n\n  t.pop = function () {\n    this._isFrozen && va(this);\n    var a = this.s;\n    return 0 < a.length ? a.pop() : null;\n  };\n\n  E.prototype.any = function (a) {\n    for (var b = this.s, c = b.length, d = 0; d < c; d++) {\n      if (a(b[d])) return !0;\n    }\n\n    return !1;\n  };\n\n  E.prototype.all = function (a) {\n    for (var b = this.s, c = b.length, d = 0; d < c; d++) {\n      if (!a(b[d])) return !1;\n    }\n\n    return !0;\n  };\n\n  E.prototype.each = function (a) {\n    for (var b = this.s, c = b.length, d = 0; d < c; d++) {\n      a(b[d]);\n    }\n\n    return this;\n  };\n\n  E.prototype.map = function (a) {\n    for (var b = new E(), c = [], d = this.s, e = d.length, f = 0; f < e; f++) {\n      c.push(a(d[f]));\n    }\n\n    b.s = c;\n    b.sb();\n    return b;\n  };\n\n  E.prototype.filter = function (a) {\n    for (var b = new E(), c = [], d = this.s, e = d.length, f = 0; f < e; f++) {\n      var g = d[f];\n      a(g) && c.push(g);\n    }\n\n    b.s = c;\n    b.sb();\n    return b;\n  };\n\n  t = E.prototype;\n\n  t.Cb = function (a, b) {\n    0 > a && wa(a, \">= 0\", E, \"insertAt:i\");\n    this._isFrozen && va(this, a);\n    var c = this.s;\n    a >= c.length ? c.push(b) : c.splice(a, 0, b);\n    this.sb();\n  };\n\n  t.remove = function (a) {\n    if (null === a) return !1;\n    this._isFrozen && va(this, a);\n    var b = this.s;\n    a = b.indexOf(a);\n    if (-1 === a) return !1;\n    a === b.length - 1 ? b.pop() : b.splice(a, 1);\n    this.sb();\n    return !0;\n  };\n\n  t.delete = function (a) {\n    return this.remove(a);\n  };\n\n  t.mb = function (a) {\n    var b = this.s;\n    (0 > a || a >= b.length) && wa(a, \"0 <= i < length\", E, \"removeAt:i\");\n    this._isFrozen && va(this, a);\n    a === b.length - 1 ? b.pop() : b.splice(a, 1);\n    this.sb();\n  };\n\n  t.removeRange = function (a, b) {\n    var c = this.s,\n        d = c.length;\n    if (0 > a) a = 0;else if (a >= d) return this;\n    if (0 > b) return this;\n    b >= d && (b = d - 1);\n    if (a > b) return this;\n    this._isFrozen && va(this);\n\n    for (var e = a, f = b + 1; f < d;) {\n      c[e++] = c[f++];\n    }\n\n    c.length = d - (b - a + 1);\n    this.sb();\n    return this;\n  };\n\n  E.prototype.copy = function () {\n    var a = new E(),\n        b = this.s;\n    0 < b.length && (a.s = Array.prototype.slice.call(b));\n    return a;\n  };\n\n  t = E.prototype;\n\n  t.Ea = function () {\n    for (var a = this.s, b = this.count, c = Array(b), d = 0; d < b; d++) {\n      c[d] = a[d];\n    }\n\n    return c;\n  };\n\n  t.lv = function () {\n    for (var a = new G(), b = this.s, c = this.count, d = 0; d < c; d++) {\n      a.add(b[d]);\n    }\n\n    return a;\n  };\n\n  t.sort = function (a) {\n    this._isFrozen && va(this);\n    this.s.sort(a);\n    this.sb();\n    return this;\n  };\n\n  t.ri = function (a, b, c) {\n    var d = this.s,\n        e = d.length;\n    void 0 === b && (b = 0);\n    void 0 === c && (c = e);\n    this._isFrozen && va(this);\n    var f = c - b;\n    if (1 >= f) return this;\n    (0 > b || b >= e - 1) && wa(b, \"0 <= from < length\", E, \"sortRange:from\");\n    if (2 === f) return c = d[b], e = d[b + 1], 0 < a(c, e) && (d[b] = e, d[b + 1] = c, this.sb()), this;\n    if (0 === b) {\n      if (c >= e) d.sort(a);else for (b = d.slice(0, c), b.sort(a), a = 0; a < c; a++) {\n        d[a] = b[a];\n      }\n    } else if (c >= e) for (c = d.slice(b), c.sort(a), a = b; a < e; a++) {\n      d[a] = c[a - b];\n    } else for (e = d.slice(b, c), e.sort(a), a = b; a < c; a++) {\n      d[a] = e[a - b];\n    }\n    this.sb();\n    return this;\n  };\n\n  t.reverse = function () {\n    this._isFrozen && va(this);\n    this.s.reverse();\n    this.sb();\n    return this;\n  };\n\n  ma.Object.defineProperties(E.prototype, {\n    _dataArray: {\n      get: function get() {\n        return this.s;\n      }\n    },\n    count: {\n      get: function get() {\n        return this.s.length;\n      }\n    },\n    size: {\n      get: function get() {\n        return this.s.length;\n      }\n    },\n    length: {\n      get: function get() {\n        return this.s.length;\n      }\n    },\n    iterator: {\n      get: function get() {\n        if (0 >= this.s.length) return Za;\n        var a = this.Pa;\n        return null !== a ? (a.reset(), a) : new ab(this);\n      }\n    },\n    iteratorBackwards: {\n      get: function get() {\n        if (0 >= this.s.length) return Za;\n        var a = this.yg;\n        return null !== a ? (a.reset(), a) : new bb(this);\n      }\n    }\n  });\n  E.prototype.reverse = E.prototype.reverse;\n  E.prototype.sortRange = E.prototype.ri;\n  E.prototype.sort = E.prototype.sort;\n  E.prototype.toSet = E.prototype.lv;\n  E.prototype.toArray = E.prototype.Ea;\n  E.prototype.removeRange = E.prototype.removeRange;\n  E.prototype.removeAt = E.prototype.mb;\n  E.prototype[\"delete\"] = E.prototype.delete;\n  E.prototype.remove = E.prototype.remove;\n  E.prototype.insertAt = E.prototype.Cb;\n  E.prototype.pop = E.prototype.pop;\n  E.prototype.last = E.prototype.fc;\n  E.prototype.first = E.prototype.first;\n  E.prototype.set = E.prototype.set;\n  E.prototype.setElt = E.prototype.Vc;\n  E.prototype.get = E.prototype.get;\n  E.prototype.elt = E.prototype.K;\n  E.prototype.indexOf = E.prototype.indexOf;\n  E.prototype.has = E.prototype.has;\n  E.prototype.contains = E.prototype.contains;\n  E.prototype.clear = E.prototype.clear;\n  E.prototype.addAll = E.prototype.addAll;\n  E.prototype.push = E.prototype.push;\n  E.prototype.add = E.prototype.add;\n  E.prototype.thaw = E.prototype.ja;\n  E.prototype.freeze = E.prototype.freeze;\n  E.className = \"List\";\n\n  function fb(a) {\n    this.Xf = a;\n    a.Pa = null;\n    this.na = a.Ia;\n    this.ra = null;\n  }\n\n  fb.prototype.reset = function () {\n    var a = this.Xf;\n    a.Pa = null;\n    this.na = a.Ia;\n    this.ra = null;\n  };\n\n  fb.prototype.next = function () {\n    var a = this.Xf;\n    if (a.Ia !== this.na && null === this.key) return !1;\n    var b = this.ra;\n    b = null === b ? a.ea : b.ta;\n    if (null !== b) return this.ra = b, this.value = b.value, this.key = b.key, !0;\n    this.Xd();\n    return !1;\n  };\n\n  fb.prototype.ud = function () {\n    return this.next();\n  };\n\n  fb.prototype.first = function () {\n    var a = this.Xf;\n    this.na = a.Ia;\n    a = a.ea;\n\n    if (null !== a) {\n      this.ra = a;\n      var b = a.value;\n      this.key = a.key;\n      return this.value = b;\n    }\n\n    return null;\n  };\n\n  fb.prototype.any = function (a) {\n    var b = this.Xf;\n    this.ra = b.Pa = null;\n\n    for (b = b.ea; null !== b;) {\n      if (a(b.value)) return !0;\n      b = b.ta;\n    }\n\n    return !1;\n  };\n\n  fb.prototype.all = function (a) {\n    var b = this.Xf;\n    this.ra = b.Pa = null;\n\n    for (b = b.ea; null !== b;) {\n      if (!a(b.value)) return !1;\n      b = b.ta;\n    }\n\n    return !0;\n  };\n\n  fb.prototype.each = function (a) {\n    var b = this.Xf;\n    this.ra = b.Pa = null;\n\n    for (b = b.ea; null !== b;) {\n      a(b.value), b = b.ta;\n    }\n\n    return this;\n  };\n\n  fb.prototype.map = function (a) {\n    var b = this.Xf;\n    b.Pa = null;\n    var c = new E();\n\n    for (b = b.ea; null !== b;) {\n      c.add(a(b.value)), b = b.ta;\n    }\n\n    return c.iterator;\n  };\n\n  fb.prototype.filter = function (a) {\n    var b = this.Xf;\n    b.Pa = null;\n    var c = new E();\n\n    for (b = b.ea; null !== b;) {\n      var d = b.value;\n      a(d) && c.add(d);\n      b = b.ta;\n    }\n\n    return c.iterator;\n  };\n\n  fb.prototype.Xd = function () {\n    this.value = this.key = null;\n    this.na = -1;\n    this.Xf.Pa = this;\n  };\n\n  fb.prototype.toString = function () {\n    return null !== this.ra ? \"SetIterator@\" + this.ra.value : \"SetIterator\";\n  };\n\n  ma.Object.defineProperties(fb.prototype, {\n    iterator: {\n      get: function get() {\n        return this;\n      }\n    },\n    count: {\n      get: function get() {\n        return this.Xf.Ob;\n      }\n    }\n  });\n  fb.prototype.first = fb.prototype.first;\n  fb.prototype.hasNext = fb.prototype.ud;\n  fb.prototype.next = fb.prototype.next;\n  fb.prototype.reset = fb.prototype.reset;\n  fb.className = \"SetIterator\";\n\n  function G(a) {\n    Ra(this);\n    this._isFrozen = !1;\n    this.Pb = {};\n    this.Ob = 0;\n    this.Pa = null;\n    this.Ia = 0;\n    this.Ye = this.ea = null;\n    \"string\" === typeof a && C(\"Error: Since 2.0 List/Map/Set constructors no longer take an argument that enforces type.\");\n    void 0 !== a && this.addAll(a);\n  }\n\n  t = G.prototype;\n\n  t.sb = function () {\n    var a = this.Ia;\n    a++;\n    999999999 < a && (a = 0);\n    this.Ia = a;\n  };\n\n  t.freeze = function () {\n    this._isFrozen = !0;\n    return this;\n  };\n\n  t.ja = function () {\n    this._isFrozen = !1;\n    return this;\n  };\n\n  t.toString = function () {\n    return \"Set()#\" + cb(this);\n  };\n\n  t.add = function (a) {\n    if (null === a) return this;\n    this._isFrozen && va(this, a);\n    var b = a;\n    ya(a) && (b = gb(a));\n    void 0 === this.Pb[b] && (this.Ob++, a = new jb(a, a), this.Pb[b] = a, b = this.Ye, null === b ? this.ea = a : (a.al = b, b.ta = a), this.Ye = a, this.sb());\n    return this;\n  };\n\n  t.addAll = function (a) {\n    if (null === a) return this;\n    this._isFrozen && va(this);\n    if (za(a)) for (var b = a.length, c = 0; c < b; c++) {\n      this.add(a[c]);\n    } else for (a = a.iterator; a.next();) {\n      this.add(a.value);\n    }\n    return this;\n  };\n\n  t.contains = function (a) {\n    if (null === a) return !1;\n    var b = a;\n    return ya(a) && (b = cb(a), void 0 === b) ? !1 : void 0 !== this.Pb[b];\n  };\n\n  t.has = function (a) {\n    return this.contains(a);\n  };\n\n  t.zy = function (a) {\n    if (null === a) return !0;\n\n    for (a = a.iterator; a.next();) {\n      if (!this.contains(a.value)) return !1;\n    }\n\n    return !0;\n  };\n\n  t.Ay = function (a) {\n    if (null === a) return !0;\n\n    for (a = a.iterator; a.next();) {\n      if (this.contains(a.value)) return !0;\n    }\n\n    return !1;\n  };\n\n  t.first = function () {\n    var a = this.ea;\n    return null === a ? null : a.value;\n  };\n\n  G.prototype.any = function (a) {\n    for (var b = this.ea; null !== b;) {\n      if (a(b.value)) return !0;\n      b = b.ta;\n    }\n\n    return !1;\n  };\n\n  G.prototype.all = function (a) {\n    for (var b = this.ea; null !== b;) {\n      if (!a(b.value)) return !1;\n      b = b.ta;\n    }\n\n    return !0;\n  };\n\n  G.prototype.each = function (a) {\n    for (var b = this.ea; null !== b;) {\n      a(b.value), b = b.ta;\n    }\n\n    return this;\n  };\n\n  G.prototype.map = function (a) {\n    for (var b = new G(), c = this.ea; null !== c;) {\n      b.add(a(c.value)), c = c.ta;\n    }\n\n    return b;\n  };\n\n  G.prototype.filter = function (a) {\n    for (var b = new G(), c = this.ea; null !== c;) {\n      var d = c.value;\n      a(d) && b.add(d);\n      c = c.ta;\n    }\n\n    return b;\n  };\n\n  t = G.prototype;\n\n  t.remove = function (a) {\n    if (null === a) return !1;\n    this._isFrozen && va(this, a);\n    var b = a;\n    if (ya(a) && (b = cb(a), void 0 === b)) return !1;\n    a = this.Pb[b];\n    if (void 0 === a) return !1;\n    var c = a.ta,\n        d = a.al;\n    null !== c && (c.al = d);\n    null !== d && (d.ta = c);\n    this.ea === a && (this.ea = c);\n    this.Ye === a && (this.Ye = d);\n    delete this.Pb[b];\n    this.Ob--;\n    this.sb();\n    return !0;\n  };\n\n  t.delete = function (a) {\n    return this.remove(a);\n  };\n\n  t.Ko = function (a) {\n    if (null === a) return this;\n    this._isFrozen && va(this);\n    if (za(a)) for (var b = a.length, c = 0; c < b; c++) {\n      this.remove(a[c]);\n    } else for (a = a.iterator; a.next();) {\n      this.remove(a.value);\n    }\n    return this;\n  };\n\n  t.Wz = function (a) {\n    if (null === a || 0 === this.count) return this;\n    this._isFrozen && va(this);\n    var b = new G();\n    b.addAll(a);\n    a = [];\n\n    for (var c = this.iterator; c.next();) {\n      var d = c.value;\n      b.contains(d) || a.push(d);\n    }\n\n    this.Ko(a);\n    return this;\n  };\n\n  t.clear = function () {\n    this._isFrozen && va(this);\n    this.Pb = {};\n    this.Ob = 0;\n    null !== this.Pa && this.Pa.reset();\n    this.Ye = this.ea = null;\n    this.sb();\n  };\n\n  G.prototype.copy = function () {\n    var a = new G(),\n        b = this.Pb,\n        c;\n\n    for (c in b) {\n      a.add(b[c].value);\n    }\n\n    return a;\n  };\n\n  G.prototype.Ea = function () {\n    var a = Array(this.Ob),\n        b = this.Pb,\n        c = 0,\n        d;\n\n    for (d in b) {\n      a[c] = b[d].value, c++;\n    }\n\n    return a;\n  };\n\n  G.prototype.kv = function () {\n    var a = new E(),\n        b = this.Pb,\n        c;\n\n    for (c in b) {\n      a.add(b[c].value);\n    }\n\n    return a;\n  };\n\n  function Ra(a) {\n    a.__gohashid = kb++;\n  }\n\n  function gb(a) {\n    var b = a.__gohashid;\n    void 0 === b && (b = kb++, a.__gohashid = b);\n    return b;\n  }\n\n  function cb(a) {\n    return a.__gohashid;\n  }\n\n  ma.Object.defineProperties(G.prototype, {\n    count: {\n      get: function get() {\n        return this.Ob;\n      }\n    },\n    size: {\n      get: function get() {\n        return this.Ob;\n      }\n    },\n    iterator: {\n      get: function get() {\n        if (0 >= this.Ob) return Za;\n        var a = this.Pa;\n        return null !== a ? (a.reset(), a) : new fb(this);\n      }\n    }\n  });\n  G.prototype.toList = G.prototype.kv;\n  G.prototype.toArray = G.prototype.Ea;\n  G.prototype.clear = G.prototype.clear;\n  G.prototype.retainAll = G.prototype.Wz;\n  G.prototype.removeAll = G.prototype.Ko;\n  G.prototype[\"delete\"] = G.prototype.delete;\n  G.prototype.remove = G.prototype.remove;\n  G.prototype.first = G.prototype.first;\n  G.prototype.containsAny = G.prototype.Ay;\n  G.prototype.containsAll = G.prototype.zy;\n  G.prototype.has = G.prototype.has;\n  G.prototype.contains = G.prototype.contains;\n  G.prototype.addAll = G.prototype.addAll;\n  G.prototype.add = G.prototype.add;\n  G.prototype.thaw = G.prototype.ja;\n  G.prototype.freeze = G.prototype.freeze;\n  var kb = 1;\n  G.className = \"Set\";\n  G.uniqueHash = Ra;\n  G.hashIdUnique = gb;\n  G.hashId = cb;\n\n  function lb(a) {\n    this.la = a;\n    this.na = a.Ia;\n    this.ra = null;\n  }\n\n  lb.prototype.reset = function () {\n    this.na = this.la.Ia;\n    this.ra = null;\n  };\n\n  lb.prototype.next = function () {\n    var a = this.la;\n    if (a.Ia !== this.na && null === this.key) return !1;\n    var b = this.ra;\n    b = null === b ? a.ea : b.ta;\n    if (null !== b) return this.ra = b, this.value = this.key = a = b.key, !0;\n    this.Xd();\n    return !1;\n  };\n\n  lb.prototype.ud = function () {\n    return this.next();\n  };\n\n  lb.prototype.first = function () {\n    var a = this.la;\n    this.na = a.Ia;\n    a = a.ea;\n    return null !== a ? (this.ra = a, this.value = this.key = a = a.key) : null;\n  };\n\n  lb.prototype.any = function (a) {\n    var b = this.la;\n    this.ra = null;\n\n    for (b = b.ea; null !== b;) {\n      if (a(b.key)) return !0;\n      b = b.ta;\n    }\n\n    return !1;\n  };\n\n  lb.prototype.all = function (a) {\n    var b = this.la;\n    this.ra = null;\n\n    for (b = b.ea; null !== b;) {\n      if (!a(b.key)) return !1;\n      b = b.ta;\n    }\n\n    return !0;\n  };\n\n  lb.prototype.each = function (a) {\n    var b = this.la;\n    this.ra = null;\n\n    for (b = b.ea; null !== b;) {\n      a(b.key), b = b.ta;\n    }\n\n    return this;\n  };\n\n  lb.prototype.map = function (a) {\n    var b = this.la;\n    this.ra = null;\n    var c = new E();\n\n    for (b = b.ea; null !== b;) {\n      c.add(a(b.key)), b = b.ta;\n    }\n\n    return c.iterator;\n  };\n\n  lb.prototype.filter = function (a) {\n    var b = this.la;\n    this.ra = null;\n    var c = new E();\n\n    for (b = b.ea; null !== b;) {\n      var d = b.key;\n      a(d) && c.add(d);\n      b = b.ta;\n    }\n\n    return c.iterator;\n  };\n\n  lb.prototype.Xd = function () {\n    this.value = this.key = null;\n    this.na = -1;\n  };\n\n  lb.prototype.toString = function () {\n    return null !== this.ra ? \"MapKeySetIterator@\" + this.ra.value : \"MapKeySetIterator\";\n  };\n\n  ma.Object.defineProperties(lb.prototype, {\n    iterator: {\n      get: function get() {\n        return this;\n      }\n    },\n    count: {\n      get: function get() {\n        return this.la.Ob;\n      }\n    }\n  });\n  lb.prototype.first = lb.prototype.first;\n  lb.prototype.hasNext = lb.prototype.ud;\n  lb.prototype.next = lb.prototype.next;\n  lb.prototype.reset = lb.prototype.reset;\n  lb.className = \"MapKeySetIterator\";\n\n  function mb(a) {\n    G.call(this);\n    Ra(this);\n    this._isFrozen = !0;\n    this.la = a;\n  }\n\n  la(mb, G);\n  t = mb.prototype;\n\n  t.freeze = function () {\n    return this;\n  };\n\n  t.ja = function () {\n    return this;\n  };\n\n  t.toString = function () {\n    return \"MapKeySet(\" + this.la.toString() + \")\";\n  };\n\n  t.add = function () {\n    C(\"This Set is read-only: \" + this.toString());\n  };\n\n  t.contains = function (a) {\n    return this.la.contains(a);\n  };\n\n  t.has = function (a) {\n    return this.contains(a);\n  };\n\n  t.remove = function () {\n    C(\"This Set is read-only: \" + this.toString());\n  };\n\n  t.delete = function (a) {\n    return this.remove(a);\n  };\n\n  t.clear = function () {\n    C(\"This Set is read-only: \" + this.toString());\n  };\n\n  t.first = function () {\n    var a = this.la.ea;\n    return null !== a ? a.key : null;\n  };\n\n  mb.prototype.any = function (a) {\n    for (var b = this.la.ea; null !== b;) {\n      if (a(b.key)) return !0;\n      b = b.ta;\n    }\n\n    return !1;\n  };\n\n  mb.prototype.all = function (a) {\n    for (var b = this.la.ea; null !== b;) {\n      if (!a(b.key)) return !1;\n      b = b.ta;\n    }\n\n    return !0;\n  };\n\n  mb.prototype.each = function (a) {\n    for (var b = this.la.ea; null !== b;) {\n      a(b.key), b = b.ta;\n    }\n\n    return this;\n  };\n\n  mb.prototype.map = function (a) {\n    for (var b = new G(), c = this.la.ea; null !== c;) {\n      b.add(a(c.key)), c = c.ta;\n    }\n\n    return b;\n  };\n\n  mb.prototype.filter = function (a) {\n    for (var b = new G(), c = this.la.ea; null !== c;) {\n      var d = c.key;\n      a(d) && b.add(d);\n      c = c.ta;\n    }\n\n    return b;\n  };\n\n  mb.prototype.copy = function () {\n    return new mb(this.la);\n  };\n\n  mb.prototype.lv = function () {\n    var a = new G(),\n        b = this.la.Pb,\n        c;\n\n    for (c in b) {\n      a.add(b[c].key);\n    }\n\n    return a;\n  };\n\n  mb.prototype.Ea = function () {\n    var a = this.la.Pb,\n        b = Array(this.la.Ob),\n        c = 0,\n        d;\n\n    for (d in a) {\n      b[c] = a[d].key, c++;\n    }\n\n    return b;\n  };\n\n  mb.prototype.kv = function () {\n    var a = new E(),\n        b = this.la.Pb,\n        c;\n\n    for (c in b) {\n      a.add(b[c].key);\n    }\n\n    return a;\n  };\n\n  ma.Object.defineProperties(mb.prototype, {\n    count: {\n      get: function get() {\n        return this.la.Ob;\n      }\n    },\n    size: {\n      get: function get() {\n        return this.la.Ob;\n      }\n    },\n    iterator: {\n      get: function get() {\n        return 0 >= this.la.Ob ? Za : new lb(this.la);\n      }\n    }\n  });\n  mb.prototype.toList = mb.prototype.kv;\n  mb.prototype.toArray = mb.prototype.Ea;\n  mb.prototype.toSet = mb.prototype.lv;\n  mb.prototype.first = mb.prototype.first;\n  mb.prototype.clear = mb.prototype.clear;\n  mb.prototype[\"delete\"] = mb.prototype.delete;\n  mb.prototype.remove = mb.prototype.remove;\n  mb.prototype.has = mb.prototype.has;\n  mb.prototype.contains = mb.prototype.contains;\n  mb.prototype.add = mb.prototype.add;\n  mb.prototype.thaw = mb.prototype.ja;\n  mb.prototype.freeze = mb.prototype.freeze;\n  mb.className = \"MapKeySet\";\n\n  function nb(a) {\n    this.la = a;\n    a.Xe = null;\n    this.na = a.Ia;\n    this.ra = null;\n  }\n\n  nb.prototype.reset = function () {\n    var a = this.la;\n    a.Xe = null;\n    this.na = a.Ia;\n    this.ra = null;\n  };\n\n  nb.prototype.next = function () {\n    var a = this.la;\n    if (a.Ia !== this.na && null === this.key) return !1;\n    var b = this.ra;\n    b = null === b ? a.ea : b.ta;\n    if (null !== b) return this.ra = b, this.value = b.value, this.key = b.key, !0;\n    this.Xd();\n    return !1;\n  };\n\n  nb.prototype.ud = function () {\n    return this.next();\n  };\n\n  nb.prototype.first = function () {\n    var a = this.la;\n    this.na = a.Ia;\n    a = a.ea;\n\n    if (null !== a) {\n      this.ra = a;\n      var b = a.value;\n      this.key = a.key;\n      return this.value = b;\n    }\n\n    return null;\n  };\n\n  nb.prototype.any = function (a) {\n    var b = this.la;\n    this.ra = b.Xe = null;\n\n    for (b = b.ea; null !== b;) {\n      if (a(b.value)) return !0;\n      b = b.ta;\n    }\n\n    return !1;\n  };\n\n  nb.prototype.all = function (a) {\n    var b = this.la;\n    this.ra = b.Xe = null;\n\n    for (b = b.ea; null !== b;) {\n      if (!a(b.value)) return !1;\n      b = b.ta;\n    }\n\n    return !0;\n  };\n\n  nb.prototype.each = function (a) {\n    var b = this.la;\n    this.ra = b.Xe = null;\n\n    for (b = b.ea; null !== b;) {\n      a(b.value), b = b.ta;\n    }\n\n    return this;\n  };\n\n  nb.prototype.map = function (a) {\n    var b = this.la;\n    this.ra = b.Xe = null;\n    var c = new E();\n\n    for (b = b.ea; null !== b;) {\n      c.add(a(b.value)), b = b.ta;\n    }\n\n    return c.iterator;\n  };\n\n  nb.prototype.filter = function (a) {\n    var b = this.la;\n    this.ra = b.Xe = null;\n    var c = new E();\n\n    for (b = b.ea; null !== b;) {\n      var d = b.value;\n      a(d) && c.add(d);\n      b = b.ta;\n    }\n\n    return c.iterator;\n  };\n\n  nb.prototype.Xd = function () {\n    this.value = this.key = null;\n    this.na = -1;\n    this.la.Xe = this;\n  };\n\n  nb.prototype.toString = function () {\n    return null !== this.ra ? \"MapValueSetIterator@\" + this.ra.value : \"MapValueSetIterator\";\n  };\n\n  ma.Object.defineProperties(nb.prototype, {\n    iterator: {\n      get: function get() {\n        return this;\n      }\n    },\n    count: {\n      get: function get() {\n        return this.la.Ob;\n      }\n    }\n  });\n  nb.prototype.first = nb.prototype.first;\n  nb.prototype.hasNext = nb.prototype.ud;\n  nb.prototype.next = nb.prototype.next;\n  nb.prototype.reset = nb.prototype.reset;\n  nb.className = \"MapValueSetIterator\";\n\n  function jb(a, b) {\n    this.key = a;\n    this.value = b;\n    this.al = this.ta = null;\n  }\n\n  jb.prototype.toString = function () {\n    return \"{\" + this.key + \":\" + this.value + \"}\";\n  };\n\n  jb.className = \"KeyValuePair\";\n\n  function ob(a) {\n    this.la = a;\n    a.Pa = null;\n    this.na = a.Ia;\n    this.ra = null;\n  }\n\n  ob.prototype.reset = function () {\n    var a = this.la;\n    a.Pa = null;\n    this.na = a.Ia;\n    this.ra = null;\n  };\n\n  ob.prototype.next = function () {\n    var a = this.la;\n    if (a.Ia !== this.na && null === this.key) return !1;\n    var b = this.ra;\n    b = null === b ? a.ea : b.ta;\n    if (null !== b) return this.ra = b, this.key = b.key, this.value = b.value, !0;\n    this.Xd();\n    return !1;\n  };\n\n  ob.prototype.ud = function () {\n    return this.next();\n  };\n\n  ob.prototype.first = function () {\n    var a = this.la;\n    this.na = a.Ia;\n    a = a.ea;\n    return null !== a ? (this.ra = a, this.key = a.key, this.value = a.value, a) : null;\n  };\n\n  ob.prototype.any = function (a) {\n    var b = this.la;\n    this.ra = b.Pa = null;\n\n    for (b = b.ea; null !== b;) {\n      if (a(b)) return !0;\n      b = b.ta;\n    }\n\n    return !1;\n  };\n\n  ob.prototype.all = function (a) {\n    var b = this.la;\n    this.ra = b.Pa = null;\n\n    for (b = b.ea; null !== b;) {\n      if (!a(b)) return !1;\n      b = b.ta;\n    }\n\n    return !0;\n  };\n\n  ob.prototype.each = function (a) {\n    var b = this.la;\n    this.ra = b.Pa = null;\n\n    for (b = b.ea; null !== b;) {\n      a(b), b = b.ta;\n    }\n\n    return this;\n  };\n\n  ob.prototype.map = function (a) {\n    var b = this.la;\n    this.ra = b.Pa = null;\n    var c = new E();\n\n    for (b = b.ea; null !== b;) {\n      c.add(a(b)), b = b.ta;\n    }\n\n    return c.iterator;\n  };\n\n  ob.prototype.filter = function (a) {\n    var b = this.la;\n    this.ra = b.Pa = null;\n    var c = new E();\n\n    for (b = b.ea; null !== b;) {\n      a(b) && c.add(b), b = b.ta;\n    }\n\n    return c.iterator;\n  };\n\n  ob.prototype.Xd = function () {\n    this.value = this.key = null;\n    this.na = -1;\n    this.la.Pa = this;\n  };\n\n  ob.prototype.toString = function () {\n    return null !== this.ra ? \"MapIterator@\" + this.ra : \"MapIterator\";\n  };\n\n  ma.Object.defineProperties(ob.prototype, {\n    iterator: {\n      get: function get() {\n        return this;\n      }\n    },\n    count: {\n      get: function get() {\n        return this.la.Ob;\n      }\n    }\n  });\n  ob.prototype.first = ob.prototype.first;\n  ob.prototype.hasNext = ob.prototype.ud;\n  ob.prototype.next = ob.prototype.next;\n  ob.prototype.reset = ob.prototype.reset;\n  ob.className = \"MapIterator\";\n\n  function pb(a) {\n    Ra(this);\n    this._isFrozen = !1;\n    this.Pb = {};\n    this.Ob = 0;\n    this.Xe = this.Pa = null;\n    this.Ia = 0;\n    this.Ye = this.ea = null;\n    \"string\" === typeof a && C(\"Error: Since 2.0 List/Map/Set constructors no longer take an argument that enforces type.\");\n    void 0 !== a && this.addAll(a);\n  }\n\n  t = pb.prototype;\n\n  t.sb = function () {\n    var a = this.Ia;\n    a++;\n    999999999 < a && (a = 0);\n    this.Ia = a;\n  };\n\n  t.freeze = function () {\n    this._isFrozen = !0;\n    return this;\n  };\n\n  t.ja = function () {\n    this._isFrozen = !1;\n    return this;\n  };\n\n  t.toString = function () {\n    return \"Map()#\" + cb(this);\n  };\n\n  t.add = function (a, b) {\n    this._isFrozen && va(this, a);\n    var c = a;\n    ya(a) && (c = gb(a));\n    var d = this.Pb[c];\n    void 0 === d ? (this.Ob++, a = new jb(a, b), this.Pb[c] = a, c = this.Ye, null === c ? this.ea = a : (a.al = c, c.ta = a), this.Ye = a, this.sb()) : d.value = b;\n    return this;\n  };\n\n  t.set = function (a, b) {\n    return this.add(a, b);\n  };\n\n  t.addAll = function (a) {\n    if (null === a) return this;\n    if (za(a)) for (var b = a.length, c = 0; c < b; c++) {\n      var d = a[c];\n      this.add(d.key, d.value);\n    } else if (a instanceof pb) for (a = a.iterator; a.next();) {\n      this.add(a.key, a.value);\n    } else for (a = a.iterator; a.next();) {\n      b = a.value, this.add(b.key, b.value);\n    }\n    return this;\n  };\n\n  t.first = function () {\n    return this.ea;\n  };\n\n  pb.prototype.any = function (a) {\n    for (var b = this.ea; null !== b;) {\n      if (a(b)) return !0;\n      b = b.ta;\n    }\n\n    return !1;\n  };\n\n  pb.prototype.all = function (a) {\n    for (var b = this.ea; null !== b;) {\n      if (!a(b)) return !1;\n      b = b.ta;\n    }\n\n    return !0;\n  };\n\n  pb.prototype.each = function (a) {\n    for (var b = this.ea; null !== b;) {\n      a(b), b = b.ta;\n    }\n\n    return this;\n  };\n\n  pb.prototype.map = function (a) {\n    for (var b = new pb(), c = this.ea; null !== c;) {\n      b.add(c.key, a(c)), c = c.ta;\n    }\n\n    return b;\n  };\n\n  pb.prototype.filter = function (a) {\n    for (var b = new pb(), c = this.ea; null !== c;) {\n      a(c) && b.add(c.key, c.value), c = c.ta;\n    }\n\n    return b;\n  };\n\n  t = pb.prototype;\n\n  t.contains = function (a) {\n    var b = a;\n    return ya(a) && (b = cb(a), void 0 === b) ? !1 : void 0 !== this.Pb[b];\n  };\n\n  t.has = function (a) {\n    return this.contains(a);\n  };\n\n  t.I = function (a) {\n    var b = a;\n    if (ya(a) && (b = cb(a), void 0 === b)) return null;\n    a = this.Pb[b];\n    return void 0 === a ? null : a.value;\n  };\n\n  t.get = function (a) {\n    return this.I(a);\n  };\n\n  t.remove = function (a) {\n    if (null === a) return !1;\n    this._isFrozen && va(this, a);\n    var b = a;\n    if (ya(a) && (b = cb(a), void 0 === b)) return !1;\n    a = this.Pb[b];\n    if (void 0 === a) return !1;\n    var c = a.ta,\n        d = a.al;\n    null !== c && (c.al = d);\n    null !== d && (d.ta = c);\n    this.ea === a && (this.ea = c);\n    this.Ye === a && (this.Ye = d);\n    delete this.Pb[b];\n    this.Ob--;\n    this.sb();\n    return !0;\n  };\n\n  t.delete = function (a) {\n    return this.remove(a);\n  };\n\n  t.clear = function () {\n    this._isFrozen && va(this);\n    this.Pb = {};\n    this.Ob = 0;\n    null !== this.Pa && this.Pa.reset();\n    null !== this.Xe && this.Xe.reset();\n    this.Ye = this.ea = null;\n    this.sb();\n  };\n\n  pb.prototype.copy = function () {\n    var a = new pb(),\n        b = this.Pb,\n        c;\n\n    for (c in b) {\n      var d = b[c];\n      a.add(d.key, d.value);\n    }\n\n    return a;\n  };\n\n  pb.prototype.Ea = function () {\n    var a = this.Pb,\n        b = Array(this.Ob),\n        c = 0,\n        d;\n\n    for (d in a) {\n      var e = a[d];\n      b[c] = new jb(e.key, e.value);\n      c++;\n    }\n\n    return b;\n  };\n\n  pb.prototype.Cf = function () {\n    return new mb(this);\n  };\n\n  ma.Object.defineProperties(pb.prototype, {\n    count: {\n      get: function get() {\n        return this.Ob;\n      }\n    },\n    size: {\n      get: function get() {\n        return this.Ob;\n      }\n    },\n    iterator: {\n      get: function get() {\n        if (0 >= this.count) return Za;\n        var a = this.Pa;\n        return null !== a ? (a.reset(), a) : new ob(this);\n      }\n    },\n    iteratorKeys: {\n      get: function get() {\n        return 0 >= this.count ? Za : new lb(this);\n      }\n    },\n    iteratorValues: {\n      get: function get() {\n        if (0 >= this.count) return Za;\n        var a = this.Xe;\n        return null !== a ? (a.reset(), a) : new nb(this);\n      }\n    }\n  });\n  pb.prototype.toKeySet = pb.prototype.Cf;\n  pb.prototype.toArray = pb.prototype.Ea;\n  pb.prototype.clear = pb.prototype.clear;\n  pb.prototype[\"delete\"] = pb.prototype.delete;\n  pb.prototype.remove = pb.prototype.remove;\n  pb.prototype.get = pb.prototype.get;\n  pb.prototype.getValue = pb.prototype.I;\n  pb.prototype.has = pb.prototype.has;\n  pb.prototype.contains = pb.prototype.contains;\n  pb.prototype.first = pb.prototype.first;\n  pb.prototype.addAll = pb.prototype.addAll;\n  pb.prototype.set = pb.prototype.set;\n  pb.prototype.add = pb.prototype.add;\n  pb.prototype.thaw = pb.prototype.ja;\n  pb.prototype.freeze = pb.prototype.freeze;\n  pb.className = \"Map\";\n\n  function I(a, b) {\n    void 0 === a ? this.y = this.x = 0 : \"number\" === typeof a && \"number\" === typeof b ? (this.x = a, this.y = b) : C(\"Invalid arguments to Point constructor: \" + a + \", \" + b);\n    this._isFrozen = !1;\n  }\n\n  var qb, rb, sb, tb, ub;\n\n  I.prototype.assign = function (a) {\n    this.x = a.x;\n    this.y = a.y;\n    return this;\n  };\n\n  I.prototype.h = function (a, b) {\n    this.x = a;\n    this.y = b;\n    return this;\n  };\n\n  I.prototype.kg = function (a, b) {\n    this.x = a;\n    this.y = b;\n    return this;\n  };\n\n  I.prototype.set = function (a) {\n    this.x = a.x;\n    this.y = a.y;\n    return this;\n  };\n\n  I.prototype.copy = function () {\n    var a = new I();\n    a.x = this.x;\n    a.y = this.y;\n    return a;\n  };\n\n  t = I.prototype;\n\n  t.ha = function () {\n    this._isFrozen = !0;\n    Object.freeze(this);\n    return this;\n  };\n\n  t.J = function () {\n    return this._isFrozen || Object.isFrozen(this) ? this : this.copy().freeze();\n  };\n\n  t.freeze = function () {\n    this._isFrozen = !0;\n    return this;\n  };\n\n  t.ja = function () {\n    Object.isFrozen(this) && C(\"cannot thaw constant: \" + this);\n    this._isFrozen = !1;\n    return this;\n  };\n\n  function vb(a) {\n    if (\"string\" === typeof a) {\n      a = a.split(\" \");\n\n      for (var b = 0, c = 0; \"\" === a[b];) {\n        b++;\n      }\n\n      var d = a[b++];\n      d && (c = parseFloat(d));\n\n      for (var e = 0; \"\" === a[b];) {\n        b++;\n      }\n\n      (d = a[b++]) && (e = parseFloat(d));\n      return new I(c, e);\n    }\n\n    return new I();\n  }\n\n  function wb(a) {\n    return a.x.toString() + \" \" + a.y.toString();\n  }\n\n  t.toString = function () {\n    return \"Point(\" + this.x + \",\" + this.y + \")\";\n  };\n\n  t.C = function (a) {\n    return a instanceof I ? this.x === a.x && this.y === a.y : !1;\n  };\n\n  t.bi = function (a, b) {\n    return this.x === a && this.y === b;\n  };\n\n  t.$a = function (a) {\n    return J.B(this.x, a.x) && J.B(this.y, a.y);\n  };\n\n  t.add = function (a) {\n    this.x += a.x;\n    this.y += a.y;\n    return this;\n  };\n\n  t.je = function (a) {\n    this.x -= a.x;\n    this.y -= a.y;\n    return this;\n  };\n\n  t.offset = function (a, b) {\n    this.x += a;\n    this.y += b;\n    return this;\n  };\n\n  I.prototype.rotate = function (a) {\n    if (0 === a) return this;\n    var b = this.x,\n        c = this.y;\n    if (0 === b && 0 === c) return this;\n    360 <= a ? a -= 360 : 0 > a && (a += 360);\n\n    if (90 === a) {\n      a = 0;\n      var d = 1;\n    } else 180 === a ? (a = -1, d = 0) : 270 === a ? (a = 0, d = -1) : (d = a * Math.PI / 180, a = Math.cos(d), d = Math.sin(d));\n\n    this.x = a * b - d * c;\n    this.y = d * b + a * c;\n    return this;\n  };\n\n  t = I.prototype;\n\n  t.scale = function (a, b) {\n    this.x *= a;\n    this.y *= b;\n    return this;\n  };\n\n  t.rf = function (a) {\n    var b = a.x - this.x;\n    a = a.y - this.y;\n    return b * b + a * a;\n  };\n\n  t.td = function (a, b) {\n    a -= this.x;\n    b -= this.y;\n    return a * a + b * b;\n  };\n\n  t.normalize = function () {\n    var a = this.x,\n        b = this.y,\n        c = Math.sqrt(a * a + b * b);\n    0 < c && (this.x = a / c, this.y = b / c);\n    return this;\n  };\n\n  t.Ya = function (a) {\n    return xb(a.x - this.x, a.y - this.y);\n  };\n\n  t.direction = function (a, b) {\n    return xb(a - this.x, b - this.y);\n  };\n\n  function xb(a, b) {\n    if (0 === a) return 0 < b ? 90 : 0 > b ? 270 : 0;\n    if (0 === b) return 0 < a ? 0 : 180;\n    if (isNaN(a) || isNaN(b)) return 0;\n    var c = 180 * Math.atan(Math.abs(b / a)) / Math.PI;\n    0 > a ? c = 0 > b ? c + 180 : 180 - c : 0 > b && (c = 360 - c);\n    return c;\n  }\n\n  t.yy = function (a, b) {\n    return J.sl(a.x, a.y, b.x, b.y, this.x, this.y);\n  };\n\n  t.Mz = function (a, b, c, d) {\n    J.fh(a, b, c, d, this.x, this.y, this);\n    return this;\n  };\n\n  t.Nz = function (a, b) {\n    J.fh(a.x, a.y, b.x, b.y, this.x, this.y, this);\n    return this;\n  };\n\n  t.aA = function (a, b, c, d) {\n    J.so(this.x, this.y, a, b, c, d, this);\n    return this;\n  };\n\n  t.bA = function (a, b) {\n    J.so(this.x, this.y, a.x, a.y, b.width, b.height, this);\n    return this;\n  };\n\n  t.oi = function (a, b) {\n    this.x = a.x + b.x * a.width + b.offsetX;\n    this.y = a.y + b.y * a.height + b.offsetY;\n    return this;\n  };\n\n  t.pi = function (a, b, c, d, e) {\n    this.x = a + e.x * c + e.offsetX;\n    this.y = b + e.y * d + e.offsetY;\n    return this;\n  };\n\n  t.transform = function (a) {\n    a.Fa(this);\n    return this;\n  };\n\n  function yb(a, b) {\n    b.Ld(a);\n    return a;\n  }\n\n  function zb(a, b, c, d, e, f) {\n    var g = e - c,\n        h = f - d,\n        k = g * g + h * h;\n    c -= a;\n    d -= b;\n    var l = -c * g - d * h;\n    if (0 >= l || l >= k) return g = e - a, h = f - b, Math.min(c * c + d * d, g * g + h * h);\n    a = g * d - h * c;\n    return a * a / k;\n  }\n\n  function Ab(a, b, c, d) {\n    a = c - a;\n    b = d - b;\n    return a * a + b * b;\n  }\n\n  function Bb(a, b, c, d) {\n    a = c - a;\n    b = d - b;\n    if (0 === a) return 0 < b ? 90 : 0 > b ? 270 : 0;\n    if (0 === b) return 0 < a ? 0 : 180;\n    if (isNaN(a) || isNaN(b)) return 0;\n    d = 180 * Math.atan(Math.abs(b / a)) / Math.PI;\n    0 > a ? d = 0 > b ? d + 180 : 180 - d : 0 > b && (d = 360 - d);\n    return d;\n  }\n\n  t.v = function () {\n    return isFinite(this.x) && isFinite(this.y);\n  };\n\n  I.alloc = function () {\n    var a = Cb.pop();\n    return void 0 === a ? new I() : a;\n  };\n\n  I.allocAt = function (a, b) {\n    var c = Cb.pop();\n    if (void 0 === c) return new I(a, b);\n    c.x = a;\n    c.y = b;\n    return c;\n  };\n\n  I.free = function (a) {\n    Cb.push(a);\n  };\n\n  I.prototype.isReal = I.prototype.v;\n  I.prototype.setSpot = I.prototype.pi;\n  I.prototype.setRectSpot = I.prototype.oi;\n  I.prototype.snapToGridPoint = I.prototype.bA;\n  I.prototype.snapToGrid = I.prototype.aA;\n  I.prototype.projectOntoLineSegmentPoint = I.prototype.Nz;\n  I.prototype.projectOntoLineSegment = I.prototype.Mz;\n\n  I.intersectingLineSegments = function (a, b, c, d, e, f, g, h) {\n    return J.zl(a, b, c, d, e, f, g, h);\n  };\n\n  I.prototype.compareWithLineSegmentPoint = I.prototype.yy;\n\n  I.compareWithLineSegment = function (a, b, c, d, e, f) {\n    return J.sl(a, b, c, d, e, f);\n  };\n\n  I.prototype.direction = I.prototype.direction;\n  I.prototype.directionPoint = I.prototype.Ya;\n  I.prototype.normalize = I.prototype.normalize;\n  I.prototype.distanceSquared = I.prototype.td;\n  I.prototype.distanceSquaredPoint = I.prototype.rf;\n  I.prototype.scale = I.prototype.scale;\n  I.prototype.rotate = I.prototype.rotate;\n  I.prototype.offset = I.prototype.offset;\n  I.prototype.subtract = I.prototype.je;\n  I.prototype.add = I.prototype.add;\n  I.prototype.equalsApprox = I.prototype.$a;\n  I.prototype.equalTo = I.prototype.bi;\n  I.prototype.equals = I.prototype.C;\n  I.prototype.set = I.prototype.set;\n  I.prototype.setTo = I.prototype.kg;\n  var Cb = [];\n  I.className = \"Point\";\n  I.parse = vb;\n  I.stringify = wb;\n  I.distanceLineSegmentSquared = zb;\n  I.distanceSquared = Ab;\n  I.direction = Bb;\n  I.Origin = qb = new I(0, 0).ha();\n  I.InfiniteTopLeft = rb = new I(-Infinity, -Infinity).ha();\n  I.InfiniteBottomRight = sb = new I(Infinity, Infinity).ha();\n  I.SixPoint = tb = new I(6, 6).ha();\n  I.NoPoint = ub = new I(NaN, NaN).ha();\n  I.parse = vb;\n  I.stringify = wb;\n  I.distanceLineSegmentSquared = zb;\n  I.distanceSquared = Ab;\n  I.direction = Bb;\n\n  function K(a, b) {\n    void 0 === a ? this.height = this.width = 0 : \"number\" === typeof a && (0 <= a || isNaN(a)) && \"number\" === typeof b && (0 <= b || isNaN(b)) ? (this.width = a, this.height = b) : C(\"Invalid arguments to Size constructor: \" + a + \", \" + b);\n    this._isFrozen = !1;\n  }\n\n  var Db, Eb, Ib, Jb, Kb, Lb, Mb;\n\n  K.prototype.assign = function (a) {\n    this.width = a.width;\n    this.height = a.height;\n    return this;\n  };\n\n  K.prototype.h = function (a, b) {\n    this.width = a;\n    this.height = b;\n    return this;\n  };\n\n  K.prototype.kg = function (a, b) {\n    this.width = a;\n    this.height = b;\n    return this;\n  };\n\n  K.prototype.set = function (a) {\n    this.width = a.width;\n    this.height = a.height;\n    return this;\n  };\n\n  K.prototype.copy = function () {\n    var a = new K();\n    a.width = this.width;\n    a.height = this.height;\n    return a;\n  };\n\n  t = K.prototype;\n\n  t.ha = function () {\n    this._isFrozen = !0;\n    Object.freeze(this);\n    return this;\n  };\n\n  t.J = function () {\n    return this._isFrozen || Object.isFrozen(this) ? this : this.copy().freeze();\n  };\n\n  t.freeze = function () {\n    this._isFrozen = !0;\n    return this;\n  };\n\n  t.ja = function () {\n    Object.isFrozen(this) && C(\"cannot thaw constant: \" + this);\n    this._isFrozen = !1;\n    return this;\n  };\n\n  function Nb(a) {\n    if (\"string\" === typeof a) {\n      a = a.split(\" \");\n\n      for (var b = 0, c = 0; \"\" === a[b];) {\n        b++;\n      }\n\n      var d = a[b++];\n      d && (c = parseFloat(d));\n\n      for (var e = 0; \"\" === a[b];) {\n        b++;\n      }\n\n      (d = a[b++]) && (e = parseFloat(d));\n      return new K(c, e);\n    }\n\n    return new K();\n  }\n\n  function Ob(a) {\n    return a.width.toString() + \" \" + a.height.toString();\n  }\n\n  t.toString = function () {\n    return \"Size(\" + this.width + \",\" + this.height + \")\";\n  };\n\n  t.C = function (a) {\n    return a instanceof K ? this.width === a.width && this.height === a.height : !1;\n  };\n\n  t.bi = function (a, b) {\n    return this.width === a && this.height === b;\n  };\n\n  t.$a = function (a) {\n    return J.B(this.width, a.width) && J.B(this.height, a.height);\n  };\n\n  t.vc = function (a, b) {\n    a = this.width + a;\n    this.width = 0 <= a ? a : 0;\n    b = this.height + b;\n    this.height = 0 <= b ? b : 0;\n    return this;\n  };\n\n  t.v = function () {\n    return isFinite(this.width) && isFinite(this.height);\n  };\n\n  K.alloc = function () {\n    var a = Pb.pop();\n    return void 0 === a ? new K() : a;\n  };\n\n  K.free = function (a) {\n    Pb.push(a);\n  };\n\n  K.prototype.isReal = K.prototype.v;\n  K.prototype.inflate = K.prototype.vc;\n  K.prototype.equalsApprox = K.prototype.$a;\n  K.prototype.equalTo = K.prototype.bi;\n  K.prototype.equals = K.prototype.C;\n  K.prototype.set = K.prototype.set;\n  K.prototype.setTo = K.prototype.kg;\n  var Pb = [];\n  K.className = \"Size\";\n  K.parse = Nb;\n  K.stringify = Ob;\n  K.ZeroSize = Db = new K(0, 0).ha();\n  K.OneSize = Eb = new K(1, 1).ha();\n  K.SixSize = Ib = new K(6, 6).ha();\n  K.EightSize = Jb = new K(8, 8).ha();\n  K.TenSize = Kb = new K(10, 10).ha();\n  K.InfiniteSize = Lb = new K(Infinity, Infinity).ha();\n  K.NoSize = Mb = new K(NaN, NaN).ha();\n  K.parse = Nb;\n  K.stringify = Ob;\n\n  function M(a, b, c, d) {\n    void 0 === a ? this.height = this.width = this.y = this.x = 0 : \"number\" === typeof a && \"number\" === typeof b && \"number\" === typeof c && (0 <= c || isNaN(c)) && \"number\" === typeof d && (0 <= d || isNaN(d)) ? (this.x = a, this.y = b, this.width = c, this.height = d) : a instanceof I ? (c = a.x, a = a.y, b instanceof I ? (d = b.x, b = b.y, this.x = Math.min(c, d), this.y = Math.min(a, b), this.width = Math.abs(c - d), this.height = Math.abs(a - b)) : b instanceof K ? (this.x = c, this.y = a, this.width = b.width, this.height = b.height) : C(\"Incorrect second argument supplied to Rect constructor \" + b)) : C(\"Invalid arguments to Rect constructor: \" + a + \", \" + b + \", \" + c + \", \" + d);\n    this._isFrozen = !1;\n  }\n\n  t = M.prototype;\n\n  t.assign = function (a) {\n    this.x = a.x;\n    this.y = a.y;\n    this.width = a.width;\n    this.height = a.height;\n    return this;\n  };\n\n  t.h = function (a, b, c, d) {\n    this.x = a;\n    this.y = b;\n    this.width = c;\n    this.height = d;\n    return this;\n  };\n\n  function Qb(a, b, c) {\n    a.width = b;\n    a.height = c;\n  }\n\n  t.kg = function (a, b, c, d) {\n    this.x = a;\n    this.y = b;\n    this.width = c;\n    this.height = d;\n    return this;\n  };\n\n  t.set = function (a) {\n    this.x = a.x;\n    this.y = a.y;\n    this.width = a.width;\n    this.height = a.height;\n    return this;\n  };\n\n  t.Wc = function (a) {\n    this.x = a.x;\n    this.y = a.y;\n    return this;\n  };\n\n  t.$z = function (a) {\n    this.width = a.width;\n    this.height = a.height;\n    return this;\n  };\n\n  M.prototype.copy = function () {\n    var a = new M();\n    a.x = this.x;\n    a.y = this.y;\n    a.width = this.width;\n    a.height = this.height;\n    return a;\n  };\n\n  t = M.prototype;\n\n  t.ha = function () {\n    this._isFrozen = !0;\n    Object.freeze(this);\n    return this;\n  };\n\n  t.J = function () {\n    return this._isFrozen || Object.isFrozen(this) ? this : this.copy().freeze();\n  };\n\n  t.freeze = function () {\n    this._isFrozen = !0;\n    return this;\n  };\n\n  t.ja = function () {\n    Object.isFrozen(this) && C(\"cannot thaw constant: \" + this);\n    this._isFrozen = !1;\n    return this;\n  };\n\n  function Rb(a) {\n    if (\"string\" === typeof a) {\n      a = a.split(\" \");\n\n      for (var b = 0, c = 0; \"\" === a[b];) {\n        b++;\n      }\n\n      var d = a[b++];\n      d && (c = parseFloat(d));\n\n      for (var e = 0; \"\" === a[b];) {\n        b++;\n      }\n\n      (d = a[b++]) && (e = parseFloat(d));\n\n      for (var f = 0; \"\" === a[b];) {\n        b++;\n      }\n\n      (d = a[b++]) && (f = parseFloat(d));\n\n      for (var g = 0; \"\" === a[b];) {\n        b++;\n      }\n\n      (d = a[b++]) && (g = parseFloat(d));\n      return new M(c, e, f, g);\n    }\n\n    return new M();\n  }\n\n  function Sb(a) {\n    return a.x.toString() + \" \" + a.y.toString() + \" \" + a.width.toString() + \" \" + a.height.toString();\n  }\n\n  t.toString = function () {\n    return \"Rect(\" + this.x + \",\" + this.y + \",\" + this.width + \",\" + this.height + \")\";\n  };\n\n  t.C = function (a) {\n    return a instanceof M ? this.x === a.x && this.y === a.y && this.width === a.width && this.height === a.height : !1;\n  };\n\n  t.bi = function (a, b, c, d) {\n    return this.x === a && this.y === b && this.width === c && this.height === d;\n  };\n\n  t.$a = function (a) {\n    return J.B(this.x, a.x) && J.B(this.y, a.y) && J.B(this.width, a.width) && J.B(this.height, a.height);\n  };\n\n  function Tb(a, b) {\n    return J.ca(a.x, b.x) && J.ca(a.y, b.y) && J.ca(a.width, b.width) && J.ca(a.height, b.height);\n  }\n\n  t.ba = function (a) {\n    return this.x <= a.x && this.x + this.width >= a.x && this.y <= a.y && this.y + this.height >= a.y;\n  };\n\n  t.Ee = function (a) {\n    return this.x <= a.x && a.x + a.width <= this.x + this.width && this.y <= a.y && a.y + a.height <= this.y + this.height;\n  };\n\n  t.contains = function (a, b, c, d) {\n    void 0 === c && (c = 0);\n    void 0 === d && (d = 0);\n    return this.x <= a && a + c <= this.x + this.width && this.y <= b && b + d <= this.y + this.height;\n  };\n\n  t.offset = function (a, b) {\n    this.x += a;\n    this.y += b;\n    return this;\n  };\n\n  t.vc = function (a, b) {\n    return Ub(this, b, a, b, a);\n  };\n\n  t.fo = function (a) {\n    return Ub(this, a.top, a.right, a.bottom, a.left);\n  };\n\n  t.jv = function (a) {\n    return Ub(this, -a.top, -a.right, -a.bottom, -a.left);\n  };\n\n  t.oz = function (a, b, c, d) {\n    return Ub(this, a, b, c, d);\n  };\n\n  function Ub(a, b, c, d, e) {\n    var f = a.width;\n    c + e <= -f ? (a.x += f / 2, a.width = 0) : (a.x -= e, a.width += c + e);\n    c = a.height;\n    b + d <= -c ? (a.y += c / 2, a.height = 0) : (a.y -= b, a.height += b + d);\n    return a;\n  }\n\n  t.ix = function (a) {\n    return Xb(this, a.x, a.y, a.width, a.height);\n  };\n\n  t.Gu = function (a, b, c, d) {\n    return Xb(this, a, b, c, d);\n  };\n\n  function Xb(a, b, c, d, e) {\n    var f = Math.max(a.x, b),\n        g = Math.max(a.y, c);\n    b = Math.min(a.x + a.width, b + d);\n    c = Math.min(a.y + a.height, c + e);\n    a.x = f;\n    a.y = g;\n    a.width = Math.max(0, b - f);\n    a.height = Math.max(0, c - g);\n    return a;\n  }\n\n  t.Sc = function (a) {\n    return this.Hu(a.x, a.y, a.width, a.height);\n  };\n\n  t.Hu = function (a, b, c, d) {\n    var e = this.width,\n        f = this.x;\n    if (Infinity !== e && Infinity !== c && (e += f, c += a, isNaN(c) || isNaN(e) || f > c || a > e)) return !1;\n    a = this.height;\n    c = this.y;\n    return Infinity !== a && Infinity !== d && (a += c, d += b, isNaN(d) || isNaN(a) || c > d || b > a) ? !1 : !0;\n  };\n\n  function Yb(a, b) {\n    var c = a.width,\n        d = a.x,\n        e = b.x - 10;\n    if (d > b.width + 10 + 10 + e || e > c + d) return !1;\n    c = a.height;\n    a = a.y;\n    d = b.y - 10;\n    return a > b.height + 10 + 10 + d || d > c + a ? !1 : !0;\n  }\n\n  t.Me = function (a) {\n    return Zb(this, a.x, a.y, 0, 0);\n  };\n\n  t.Xc = function (a) {\n    return Zb(this, a.x, a.y, a.width, a.height);\n  };\n\n  t.nv = function (a, b, c, d) {\n    void 0 === c && (c = 0);\n    void 0 === d && (d = 0);\n    return Zb(this, a, b, c, d);\n  };\n\n  function Zb(a, b, c, d, e) {\n    var f = Math.min(a.x, b),\n        g = Math.min(a.y, c);\n    b = Math.max(a.x + a.width, b + d);\n    c = Math.max(a.y + a.height, c + e);\n    a.x = f;\n    a.y = g;\n    a.width = b - f;\n    a.height = c - g;\n    return a;\n  }\n\n  t.pi = function (a, b, c) {\n    this.x = a - c.offsetX - c.x * this.width;\n    this.y = b - c.offsetY - c.y * this.height;\n    return this;\n  };\n\n  function $b(a, b, c, d, e, f, g, h) {\n    void 0 === g && (g = 0);\n    void 0 === h && (h = 0);\n    return a <= e && e + g <= a + c && b <= f && f + h <= b + d;\n  }\n\n  function ac(a, b, c, d, e, f, g, h) {\n    return a > g + e || e > c + a ? !1 : b > h + f || f > d + b ? !1 : !0;\n  }\n\n  t.v = function () {\n    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);\n  };\n\n  t.vz = function () {\n    return 0 === this.width && 0 === this.height;\n  };\n\n  M.alloc = function () {\n    var a = bc.pop();\n    return void 0 === a ? new M() : a;\n  };\n\n  M.allocAt = function (a, b, c, d) {\n    var e = bc.pop();\n    return void 0 === e ? new M(a, b, c, d) : e.h(a, b, c, d);\n  };\n\n  M.free = function (a) {\n    bc.push(a);\n  };\n\n  ma.Object.defineProperties(M.prototype, {\n    left: {\n      get: function get() {\n        return this.x;\n      },\n      set: function set(a) {\n        this.x = a;\n      }\n    },\n    top: {\n      get: function get() {\n        return this.y;\n      },\n      set: function set(a) {\n        this.y = a;\n      }\n    },\n    right: {\n      get: function get() {\n        return this.x + this.width;\n      },\n      set: function set(a) {\n        this.x += a - (this.x + this.width);\n      }\n    },\n    bottom: {\n      get: function get() {\n        return this.y + this.height;\n      },\n      set: function set(a) {\n        this.y += a - (this.y + this.height);\n      }\n    },\n    position: {\n      get: function get() {\n        return new I(this.x, this.y);\n      },\n      set: function set(a) {\n        this.x = a.x;\n        this.y = a.y;\n      }\n    },\n    size: {\n      get: function get() {\n        return new K(this.width, this.height);\n      },\n      set: function set(a) {\n        this.width = a.width;\n        this.height = a.height;\n      }\n    },\n    center: {\n      get: function get() {\n        return new I(this.x + this.width / 2, this.y + this.height / 2);\n      },\n      set: function set(a) {\n        this.x = a.x - this.width / 2;\n        this.y = a.y - this.height / 2;\n      }\n    },\n    centerX: {\n      get: function get() {\n        return this.x + this.width / 2;\n      },\n      set: function set(a) {\n        this.x = a - this.width / 2;\n      }\n    },\n    centerY: {\n      get: function get() {\n        return this.y + this.height / 2;\n      },\n      set: function set(a) {\n        this.y = a - this.height / 2;\n      }\n    }\n  });\n  M.prototype.isEmpty = M.prototype.vz;\n  M.prototype.isReal = M.prototype.v;\n\n  M.intersectsLineSegment = function (a, b, c, d, e, f, g, h) {\n    return J.jx(a, b, c, d, e, f, g, h);\n  };\n\n  M.prototype.setSpot = M.prototype.pi;\n  M.prototype.union = M.prototype.nv;\n  M.prototype.unionRect = M.prototype.Xc;\n  M.prototype.unionPoint = M.prototype.Me;\n  M.prototype.intersects = M.prototype.Hu;\n  M.prototype.intersectsRect = M.prototype.Sc;\n  M.prototype.intersect = M.prototype.Gu;\n  M.prototype.intersectRect = M.prototype.ix;\n  M.prototype.grow = M.prototype.oz;\n  M.prototype.subtractMargin = M.prototype.jv;\n  M.prototype.addMargin = M.prototype.fo;\n  M.prototype.inflate = M.prototype.vc;\n  M.prototype.offset = M.prototype.offset;\n  M.prototype.contains = M.prototype.contains;\n  M.prototype.containsRect = M.prototype.Ee;\n  M.prototype.containsPoint = M.prototype.ba;\n  M.prototype.equalsApprox = M.prototype.$a;\n  M.prototype.equalTo = M.prototype.bi;\n  M.prototype.equals = M.prototype.C;\n  M.prototype.setSize = M.prototype.$z;\n  M.prototype.setPoint = M.prototype.Wc;\n  M.prototype.set = M.prototype.set;\n  M.prototype.setTo = M.prototype.kg;\n  var cc = null,\n      dc = null,\n      bc = [];\n  M.className = \"Rect\";\n  M.parse = Rb;\n  M.stringify = Sb;\n  M.contains = $b;\n  M.intersects = ac;\n  M.ZeroRect = cc = new M(0, 0, 0, 0).ha();\n  M.NoRect = dc = new M(NaN, NaN, NaN, NaN).ha();\n  M.parse = Rb;\n  M.stringify = Sb;\n  M.contains = $b;\n  M.intersects = ac;\n\n  function ec(a, b, c, d) {\n    void 0 === a ? this.left = this.bottom = this.right = this.top = 0 : void 0 === b ? this.left = this.bottom = this.right = this.top = a : void 0 === c ? (this.top = a, this.right = b, this.bottom = a, this.left = b) : void 0 !== d ? (this.top = a, this.right = b, this.bottom = c, this.left = d) : C(\"Invalid arguments to Margin constructor: \" + a + \", \" + b + \", \" + c + \", \" + d);\n    this._isFrozen = !1;\n  }\n\n  ec.prototype.assign = function (a) {\n    this.top = a.top;\n    this.right = a.right;\n    this.bottom = a.bottom;\n    this.left = a.left;\n    return this;\n  };\n\n  ec.prototype.kg = function (a, b, c, d) {\n    this.top = a;\n    this.right = b;\n    this.bottom = c;\n    this.left = d;\n    return this;\n  };\n\n  ec.prototype.set = function (a) {\n    this.top = a.top;\n    this.right = a.right;\n    this.bottom = a.bottom;\n    this.left = a.left;\n    return this;\n  };\n\n  ec.prototype.copy = function () {\n    var a = new ec();\n    a.top = this.top;\n    a.right = this.right;\n    a.bottom = this.bottom;\n    a.left = this.left;\n    return a;\n  };\n\n  t = ec.prototype;\n\n  t.ha = function () {\n    this._isFrozen = !0;\n    Object.freeze(this);\n    return this;\n  };\n\n  t.J = function () {\n    return this._isFrozen || Object.isFrozen(this) ? this : this.copy().freeze();\n  };\n\n  t.freeze = function () {\n    this._isFrozen = !0;\n    return this;\n  };\n\n  t.ja = function () {\n    Object.isFrozen(this) && C(\"cannot thaw constant: \" + this);\n    this._isFrozen = !1;\n    return this;\n  };\n\n  function jc(a) {\n    if (\"string\" === typeof a) {\n      a = a.split(\" \");\n\n      for (var b = 0, c = NaN; \"\" === a[b];) {\n        b++;\n      }\n\n      var d = a[b++];\n      d && (c = parseFloat(d));\n      if (isNaN(c)) return new ec();\n\n      for (var e = NaN; \"\" === a[b];) {\n        b++;\n      }\n\n      (d = a[b++]) && (e = parseFloat(d));\n      if (isNaN(e)) return new ec(c);\n\n      for (var f = NaN; \"\" === a[b];) {\n        b++;\n      }\n\n      (d = a[b++]) && (f = parseFloat(d));\n      if (isNaN(f)) return new ec(c, e);\n\n      for (var g = NaN; \"\" === a[b];) {\n        b++;\n      }\n\n      (d = a[b++]) && (g = parseFloat(d));\n      return isNaN(g) ? new ec(c, e) : new ec(c, e, f, g);\n    }\n\n    return new ec();\n  }\n\n  function kc(a) {\n    return a.top.toString() + \" \" + a.right.toString() + \" \" + a.bottom.toString() + \" \" + a.left.toString();\n  }\n\n  t.toString = function () {\n    return \"Margin(\" + this.top + \",\" + this.right + \",\" + this.bottom + \",\" + this.left + \")\";\n  };\n\n  t.C = function (a) {\n    return a instanceof ec ? this.top === a.top && this.right === a.right && this.bottom === a.bottom && this.left === a.left : !1;\n  };\n\n  t.bi = function (a, b, c, d) {\n    return this.top === a && this.right === b && this.bottom === c && this.left === d;\n  };\n\n  t.$a = function (a) {\n    return J.B(this.top, a.top) && J.B(this.right, a.right) && J.B(this.bottom, a.bottom) && J.B(this.left, a.left);\n  };\n\n  t.v = function () {\n    return isFinite(this.top) && isFinite(this.right) && isFinite(this.bottom) && isFinite(this.left);\n  };\n\n  ec.alloc = function () {\n    var a = pc.pop();\n    return void 0 === a ? new ec() : a;\n  };\n\n  ec.free = function (a) {\n    pc.push(a);\n  };\n\n  ec.prototype.isReal = ec.prototype.v;\n  ec.prototype.equalsApprox = ec.prototype.$a;\n  ec.prototype.equalTo = ec.prototype.bi;\n  ec.prototype.equals = ec.prototype.C;\n  ec.prototype.set = ec.prototype.set;\n  ec.prototype.setTo = ec.prototype.kg;\n  var qc = null,\n      rc = null,\n      pc = [];\n  ec.className = \"Margin\";\n  ec.parse = jc;\n  ec.stringify = kc;\n  ec.ZeroMargin = qc = new ec(0, 0, 0, 0).ha();\n  ec.TwoMargin = rc = new ec(2, 2, 2, 2).ha();\n  ec.parse = jc;\n  ec.stringify = kc;\n\n  function N(a, b, c, d) {\n    void 0 === a ? this.offsetY = this.offsetX = this.y = this.x = 0 : (void 0 === b && (b = 0), void 0 === c && (c = 0), void 0 === d && (d = 0), this.x = a, this.y = b, this.offsetX = c, this.offsetY = d);\n    this._isFrozen = !1;\n  }\n\n  var sc, tc, uc, vc, xc, yc, zc, Ac, Bc, Cc, Dc, Ec, Gc, Hc, Ic, Jc, Kc, Lc, Mc, Nc, Oc, Pc, Qc, Uc, Vc, Wc, Xc, Yc, Zc, $c, ad, dd, ed, fd, gd, hd;\n\n  N.prototype.assign = function (a) {\n    this.x = a.x;\n    this.y = a.y;\n    this.offsetX = a.offsetX;\n    this.offsetY = a.offsetY;\n    return this;\n  };\n\n  N.prototype.kg = function (a, b, c, d) {\n    this.x = a;\n    this.y = b;\n    this.offsetX = c;\n    this.offsetY = d;\n    return this;\n  };\n\n  N.prototype.set = function (a) {\n    this.x = a.x;\n    this.y = a.y;\n    this.offsetX = a.offsetX;\n    this.offsetY = a.offsetY;\n    return this;\n  };\n\n  N.prototype.copy = function () {\n    var a = new N();\n    a.x = this.x;\n    a.y = this.y;\n    a.offsetX = this.offsetX;\n    a.offsetY = this.offsetY;\n    return a;\n  };\n\n  t = N.prototype;\n\n  t.ha = function () {\n    this._isFrozen = !0;\n    Object.freeze(this);\n    return this;\n  };\n\n  t.J = function () {\n    return this._isFrozen || Object.isFrozen(this) ? this : this.copy().freeze();\n  };\n\n  t.freeze = function () {\n    this._isFrozen = !0;\n    return this;\n  };\n\n  t.ja = function () {\n    Object.isFrozen(this) && C(\"cannot thaw constant: \" + this);\n    this._isFrozen = !1;\n    return this;\n  };\n\n  function id(a, b) {\n    a.x = NaN;\n    a.y = NaN;\n    a.offsetX = b;\n    return a;\n  }\n\n  function jd(a) {\n    if (\"string\" === typeof a) {\n      a = a.trim();\n      if (\"None\" === a) return sc;\n      if (\"TopLeft\" === a) return tc;\n      if (\"Top\" === a || \"TopCenter\" === a || \"MiddleTop\" === a) return uc;\n      if (\"TopRight\" === a) return vc;\n      if (\"Left\" === a || \"LeftCenter\" === a || \"MiddleLeft\" === a) return xc;\n      if (\"Center\" === a) return yc;\n      if (\"Right\" === a || \"RightCenter\" === a || \"MiddleRight\" === a) return zc;\n      if (\"BottomLeft\" === a) return Ac;\n      if (\"Bottom\" === a || \"BottomCenter\" === a || \"MiddleBottom\" === a) return Bc;\n      if (\"BottomRight\" === a) return Cc;\n      if (\"TopSide\" === a) return Dc;\n      if (\"LeftSide\" === a) return Ec;\n      if (\"RightSide\" === a) return Gc;\n      if (\"BottomSide\" === a) return Hc;\n      if (\"TopBottomSides\" === a) return Ic;\n      if (\"LeftRightSides\" === a) return Jc;\n      if (\"TopLeftSides\" === a) return Kc;\n      if (\"TopRightSides\" === a) return Lc;\n      if (\"BottomLeftSides\" === a) return Mc;\n      if (\"BottomRightSides\" === a) return Nc;\n      if (\"NotTopSide\" === a) return Oc;\n      if (\"NotLeftSide\" === a) return Pc;\n      if (\"NotRightSide\" === a) return Qc;\n      if (\"NotBottomSide\" === a) return Uc;\n      if (\"AllSides\" === a) return Vc;\n      if (\"Default\" === a) return Wc;\n      a = a.split(\" \");\n\n      for (var b = 0, c = 0; \"\" === a[b];) {\n        b++;\n      }\n\n      var d = a[b++];\n      void 0 !== d && 0 < d.length && (c = parseFloat(d));\n\n      for (var e = 0; \"\" === a[b];) {\n        b++;\n      }\n\n      d = a[b++];\n      void 0 !== d && 0 < d.length && (e = parseFloat(d));\n\n      for (var f = 0; \"\" === a[b];) {\n        b++;\n      }\n\n      d = a[b++];\n      void 0 !== d && 0 < d.length && (f = parseFloat(d));\n\n      for (var g = 0; \"\" === a[b];) {\n        b++;\n      }\n\n      d = a[b++];\n      void 0 !== d && 0 < d.length && (g = parseFloat(d));\n      return new N(c, e, f, g);\n    }\n\n    return new N();\n  }\n\n  function kd(a) {\n    return a.pb() ? a.x.toString() + \" \" + a.y.toString() + \" \" + a.offsetX.toString() + \" \" + a.offsetY.toString() : a.toString();\n  }\n\n  t.toString = function () {\n    return this.pb() ? 0 === this.offsetX && 0 === this.offsetY ? \"Spot(\" + this.x + \",\" + this.y + \")\" : \"Spot(\" + this.x + \",\" + this.y + \",\" + this.offsetX + \",\" + this.offsetY + \")\" : this.C(sc) ? \"None\" : this.C(tc) ? \"TopLeft\" : this.C(uc) ? \"Top\" : this.C(vc) ? \"TopRight\" : this.C(xc) ? \"Left\" : this.C(yc) ? \"Center\" : this.C(zc) ? \"Right\" : this.C(Ac) ? \"BottomLeft\" : this.C(Bc) ? \"Bottom\" : this.C(Cc) ? \"BottomRight\" : this.C(Dc) ? \"TopSide\" : this.C(Ec) ? \"LeftSide\" : this.C(Gc) ? \"RightSide\" : this.C(Hc) ? \"BottomSide\" : this.C(Ic) ? \"TopBottomSides\" : this.C(Jc) ? \"LeftRightSides\" : this.C(Kc) ? \"TopLeftSides\" : this.C(Lc) ? \"TopRightSides\" : this.C(Mc) ? \"BottomLeftSides\" : this.C(Nc) ? \"BottomRightSides\" : this.C(Oc) ? \"NotTopSide\" : this.C(Pc) ? \"NotLeftSide\" : this.C(Qc) ? \"NotRightSide\" : this.C(Uc) ? \"NotBottomSide\" : this.C(Vc) ? \"AllSides\" : this.C(Wc) ? \"Default\" : \"None\";\n  };\n\n  t.C = function (a) {\n    return a instanceof N ? (this.x === a.x || isNaN(this.x) && isNaN(a.x)) && (this.y === a.y || isNaN(this.y) && isNaN(a.y)) && this.offsetX === a.offsetX && this.offsetY === a.offsetY : !1;\n  };\n\n  t.Qu = function () {\n    return new N(.5 - (this.x - .5), .5 - (this.y - .5), -this.offsetX, -this.offsetY);\n  };\n\n  t.xf = function (a) {\n    if (!this.Uc()) return !1;\n    if (!a.Uc()) if (a.C(Xc)) a = Ec;else if (a.C(Yc)) a = Gc;else if (a.C(Zc)) a = Dc;else if (a.C($c)) a = Hc;else return !1;\n    a = a.offsetY;\n    return (this.offsetY & a) === a;\n  };\n\n  t.pb = function () {\n    return !isNaN(this.x) && !isNaN(this.y);\n  };\n\n  t.Fc = function () {\n    return isNaN(this.x) || isNaN(this.y);\n  };\n\n  t.Uc = function () {\n    return isNaN(this.x) && isNaN(this.y) && 1 === this.offsetX && 0 !== this.offsetY;\n  };\n\n  t.Wr = function () {\n    return isNaN(this.x) && isNaN(this.y) && 0 === this.offsetX && 0 === this.offsetY;\n  };\n\n  t.Sb = function () {\n    return isNaN(this.x) && isNaN(this.y) && -1 === this.offsetX && 0 === this.offsetY;\n  };\n\n  N.alloc = function () {\n    var a = ld.pop();\n    return void 0 === a ? new N() : a;\n  };\n\n  N.free = function (a) {\n    ld.push(a);\n  };\n\n  N.prototype.isDefault = N.prototype.Sb;\n  N.prototype.isNone = N.prototype.Wr;\n  N.prototype.isSide = N.prototype.Uc;\n  N.prototype.isNoSpot = N.prototype.Fc;\n  N.prototype.isSpot = N.prototype.pb;\n  N.prototype.includesSide = N.prototype.xf;\n  N.prototype.opposite = N.prototype.Qu;\n  N.prototype.equals = N.prototype.C;\n  N.prototype.set = N.prototype.set;\n  N.prototype.setTo = N.prototype.kg;\n  var ld = [];\n  N.className = \"Spot\";\n  N.parse = jd;\n  N.stringify = kd;\n  N.None = sc = id(new N(0, 0, 0, 0), 0).ha();\n  N.Default = Wc = id(new N(0, 0, -1, 0), -1).ha();\n  N.TopLeft = tc = new N(0, 0, 0, 0).ha();\n  N.TopCenter = uc = new N(.5, 0, 0, 0).ha();\n  N.TopRight = vc = new N(1, 0, 0, 0).ha();\n  N.LeftCenter = xc = new N(0, .5, 0, 0).ha();\n  N.Center = yc = new N(.5, .5, 0, 0).ha();\n  N.RightCenter = zc = new N(1, .5, 0, 0).ha();\n  N.BottomLeft = Ac = new N(0, 1, 0, 0).ha();\n  N.BottomCenter = Bc = new N(.5, 1, 0, 0).ha();\n  N.BottomRight = Cc = new N(1, 1, 0, 0).ha();\n  N.MiddleTop = ad = uc;\n  N.MiddleLeft = dd = xc;\n  N.MiddleRight = ed = zc;\n  N.MiddleBottom = fd = Bc;\n  N.Top = Zc = uc;\n  N.Left = Xc = xc;\n  N.Right = Yc = zc;\n  N.Bottom = $c = Bc;\n  N.TopSide = Dc = id(new N(0, 0, 1, 1), 1).ha();\n  N.LeftSide = Ec = id(new N(0, 0, 1, 2), 1).ha();\n  N.RightSide = Gc = id(new N(0, 0, 1, 4), 1).ha();\n  N.BottomSide = Hc = id(new N(0, 0, 1, 8), 1).ha();\n  N.TopBottomSides = Ic = id(new N(0, 0, 1, 9), 1).ha();\n  N.LeftRightSides = Jc = id(new N(0, 0, 1, 6), 1).ha();\n  N.TopLeftSides = Kc = id(new N(0, 0, 1, 3), 1).ha();\n  N.TopRightSides = Lc = id(new N(0, 0, 1, 5), 1).ha();\n  N.BottomLeftSides = Mc = id(new N(0, 0, 1, 10), 1).ha();\n  N.BottomRightSides = Nc = id(new N(0, 0, 1, 12), 1).ha();\n  N.NotTopSide = Oc = id(new N(0, 0, 1, 14), 1).ha();\n  N.NotLeftSide = Pc = id(new N(0, 0, 1, 13), 1).ha();\n  N.NotRightSide = Qc = id(new N(0, 0, 1, 11), 1).ha();\n  N.NotBottomSide = Uc = id(new N(0, 0, 1, 7), 1).ha();\n  N.AllSides = Vc = id(new N(0, 0, 1, 15), 1).ha();\n  gd = new N(.156, .156).ha();\n  hd = new N(.844, .844).ha();\n  N.parse = jd;\n  N.stringify = kd;\n\n  function md() {\n    this.m11 = 1;\n    this.m21 = this.m12 = 0;\n    this.m22 = 1;\n    this.dy = this.dx = 0;\n  }\n\n  md.prototype.set = function (a) {\n    this.m11 = a.m11;\n    this.m12 = a.m12;\n    this.m21 = a.m21;\n    this.m22 = a.m22;\n    this.dx = a.dx;\n    this.dy = a.dy;\n    return this;\n  };\n\n  md.prototype.setTransform = function (a, b, c, d, e, f) {\n    this.m11 = a;\n    this.m12 = b;\n    this.m21 = c;\n    this.m22 = d;\n    this.dx = e;\n    this.dy = f;\n    return this;\n  };\n\n  md.prototype.copy = function () {\n    var a = new md();\n    a.m11 = this.m11;\n    a.m12 = this.m12;\n    a.m21 = this.m21;\n    a.m22 = this.m22;\n    a.dx = this.dx;\n    a.dy = this.dy;\n    return a;\n  };\n\n  md.prototype.toString = function () {\n    return \"Transform(\" + this.m11 + \",\" + this.m12 + \",\" + this.m21 + \",\" + this.m22 + \",\" + this.dx + \",\" + this.dy + \")\";\n  };\n\n  md.prototype.C = function (a) {\n    return this.m11 === a.m11 && this.m12 === a.m12 && this.m21 === a.m21 && this.m22 === a.m22 && this.dx === a.dx && this.dy === a.dy;\n  };\n\n  md.prototype.Ur = function () {\n    return 0 === this.dx && 0 === this.dy && 1 === this.m11 && 0 === this.m12 && 0 === this.m21 && 1 === this.m22;\n  };\n\n  md.prototype.reset = function () {\n    this.m11 = 1;\n    this.m21 = this.m12 = 0;\n    this.m22 = 1;\n    this.dy = this.dx = 0;\n    return this;\n  };\n\n  md.prototype.multiply = function (a) {\n    var b = this.m11 * a.m11 + this.m21 * a.m12,\n        c = this.m12 * a.m11 + this.m22 * a.m12,\n        d = this.m11 * a.m21 + this.m21 * a.m22,\n        e = this.m12 * a.m21 + this.m22 * a.m22;\n    this.dx = this.m11 * a.dx + this.m21 * a.dy + this.dx;\n    this.dy = this.m12 * a.dx + this.m22 * a.dy + this.dy;\n    this.m11 = b;\n    this.m12 = c;\n    this.m21 = d;\n    this.m22 = e;\n    return this;\n  };\n\n  md.prototype.Ou = function (a) {\n    var b = 1 / (a.m11 * a.m22 - a.m12 * a.m21),\n        c = a.m22 * b,\n        d = -a.m12 * b,\n        e = -a.m21 * b,\n        f = a.m11 * b,\n        g = b * (a.m21 * a.dy - a.m22 * a.dx);\n    a = b * (a.m12 * a.dx - a.m11 * a.dy);\n    b = this.m11 * c + this.m21 * d;\n    c = this.m12 * c + this.m22 * d;\n    d = this.m11 * e + this.m21 * f;\n    e = this.m12 * e + this.m22 * f;\n    this.dx = this.m11 * g + this.m21 * a + this.dx;\n    this.dy = this.m12 * g + this.m22 * a + this.dy;\n    this.m11 = b;\n    this.m12 = c;\n    this.m21 = d;\n    this.m22 = e;\n    return this;\n  };\n\n  md.prototype.Tr = function () {\n    var a = 1 / (this.m11 * this.m22 - this.m12 * this.m21),\n        b = -this.m12 * a,\n        c = -this.m21 * a,\n        d = this.m11 * a,\n        e = a * (this.m21 * this.dy - this.m22 * this.dx),\n        f = a * (this.m12 * this.dx - this.m11 * this.dy);\n    this.m11 = this.m22 * a;\n    this.m12 = b;\n    this.m21 = c;\n    this.m22 = d;\n    this.dx = e;\n    this.dy = f;\n    return this;\n  };\n\n  md.prototype.rotate = function (a, b, c) {\n    360 <= a ? a -= 360 : 0 > a && (a += 360);\n    if (0 === a) return this;\n    this.translate(b, c);\n\n    if (90 === a) {\n      a = 0;\n      var d = 1;\n    } else 180 === a ? (a = -1, d = 0) : 270 === a ? (a = 0, d = -1) : (d = a * Math.PI / 180, a = Math.cos(d), d = Math.sin(d));\n\n    var e = this.m12 * a + this.m22 * d,\n        f = this.m11 * -d + this.m21 * a,\n        g = this.m12 * -d + this.m22 * a;\n    this.m11 = this.m11 * a + this.m21 * d;\n    this.m12 = e;\n    this.m21 = f;\n    this.m22 = g;\n    this.translate(-b, -c);\n    return this;\n  };\n\n  t = md.prototype;\n\n  t.translate = function (a, b) {\n    this.dx += this.m11 * a + this.m21 * b;\n    this.dy += this.m12 * a + this.m22 * b;\n    return this;\n  };\n\n  t.scale = function (a, b) {\n    void 0 === b && (b = a);\n    this.m11 *= a;\n    this.m12 *= a;\n    this.m21 *= b;\n    this.m22 *= b;\n    return this;\n  };\n\n  t.Fa = function (a) {\n    var b = a.x,\n        c = a.y;\n    return a.h(b * this.m11 + c * this.m21 + this.dx, b * this.m12 + c * this.m22 + this.dy);\n  };\n\n  t.Ld = function (a) {\n    var b = 1 / (this.m11 * this.m22 - this.m12 * this.m21),\n        c = a.x,\n        d = a.y;\n    return a.h(c * this.m22 * b + d * -this.m21 * b + b * (this.m21 * this.dy - this.m22 * this.dx), c * -this.m12 * b + d * this.m11 * b + b * (this.m12 * this.dx - this.m11 * this.dy));\n  };\n\n  t.Fw = function (a) {\n    var b = 1 / (this.m11 * this.m22 - this.m12 * this.m21),\n        c = 1.25 * a.x,\n        d = 1.2 * a.y;\n    return a.h(c * this.m22 * b + d * -this.m21 * b + b * (this.m21 * this.dy - this.m22 * this.dx), c * -this.m12 * b + d * this.m11 * b + b * (this.m12 * this.dx - this.m11 * this.dy));\n  };\n\n  t.So = function (a) {\n    var b = a.x,\n        c = a.y,\n        d = b + a.width,\n        e = c + a.height,\n        f = this.m11,\n        g = this.m12,\n        h = this.m21,\n        k = this.m22,\n        l = this.dx,\n        m = this.dy,\n        n = b * f + c * h + l,\n        p = b * g + c * k + m,\n        r = d * f + c * h + l,\n        q = d * g + c * k + m;\n    c = b * f + e * h + l;\n    b = b * g + e * k + m;\n    f = d * f + e * h + l;\n    d = d * g + e * k + m;\n    e = Math.min(n, r);\n    n = Math.max(n, r);\n    r = Math.min(p, q);\n    p = Math.max(p, q);\n    e = Math.min(e, c);\n    n = Math.max(n, c);\n    r = Math.min(r, b);\n    p = Math.max(p, b);\n    e = Math.min(e, f);\n    n = Math.max(n, f);\n    r = Math.min(r, d);\n    p = Math.max(p, d);\n    a.h(e, r, n - e, p - r);\n    return a;\n  };\n\n  md.alloc = function () {\n    var a = nd.pop();\n    return void 0 === a ? new md() : a;\n  };\n\n  md.free = function (a) {\n    nd.push(a);\n  };\n\n  md.prototype.transformRect = md.prototype.So;\n  md.prototype.transformPoint = md.prototype.Fa;\n  md.prototype.scale = md.prototype.scale;\n  md.prototype.translate = md.prototype.translate;\n  md.prototype.rotate = md.prototype.rotate;\n  md.prototype.invert = md.prototype.Tr;\n  md.prototype.multiplyInverted = md.prototype.Ou;\n  md.prototype.multiply = md.prototype.multiply;\n  md.prototype.reset = md.prototype.reset;\n  md.prototype.isIdentity = md.prototype.Ur;\n  md.prototype.equals = md.prototype.C;\n  md.prototype.setTransform = md.prototype.setTransform;\n  md.prototype.set = md.prototype.set;\n  var nd = [];\n  md.className = \"Transform\";\n  md.xF = \"54a702f3e53909c447824c6706603faf4c\";\n  var J = {\n    jA: \"7da71ca0ad381e90\",\n    ng: (Math.sqrt(2) - 1) / 3 * 4,\n    yv: null,\n    sqrt: function sqrt(a) {\n      if (0 >= a) return 0;\n      var b = J.yv;\n\n      if (null === b) {\n        b = [];\n\n        for (var c = 0; 2E3 >= c; c++) {\n          b[c] = Math.sqrt(c);\n        }\n\n        J.yv = b;\n      }\n\n      return 1 > a ? (c = 1 / a, 2E3 >= c ? 1 / b[c | 0] : Math.sqrt(a)) : 2E3 >= a ? b[a | 0] : Math.sqrt(a);\n    },\n    B: function B(a, b) {\n      a -= b;\n      return .5 > a && -.5 < a;\n    },\n    ca: function ca(a, b) {\n      a -= b;\n      return 5E-8 > a && -5E-8 < a;\n    },\n    Tb: function Tb(a, b, c, d, e, f, g) {\n      0 >= e && (e = 1E-6);\n\n      if (a < c) {\n        var h = a;\n        var k = c;\n      } else h = c, k = a;\n\n      if (b < d) {\n        var l = b;\n        var m = d;\n      } else l = d, m = b;\n\n      if (a === c) return l <= g && g <= m && a - e <= f && f <= a + e;\n      if (b === d) return h <= f && f <= k && b - e <= g && g <= b + e;\n      k += e;\n      h -= e;\n      if (h <= f && f <= k && (m += e, l -= e, l <= g && g <= m)) if (k - h > m - l) {\n        if (a - c > e || c - a > e) {\n          if (f = (d - b) / (c - a) * (f - a) + b, f - e <= g && g <= f + e) return !0;\n        } else return !0;\n      } else if (b - d > e || d - b > e) {\n        if (g = (c - a) / (d - b) * (g - b) + a, g - e <= f && f <= g + e) return !0;\n      } else return !0;\n      return !1;\n    },\n    Br: function Br(a, b, c, d, e, f, g, h, k, l, m, n) {\n      if (J.Tb(a, b, g, h, n, c, d) && J.Tb(a, b, g, h, n, e, f)) return J.Tb(a, b, g, h, n, l, m);\n      var p = (a + c) / 2,\n          r = (b + d) / 2,\n          q = (c + e) / 2,\n          u = (d + f) / 2;\n      e = (e + g) / 2;\n      f = (f + h) / 2;\n      d = (p + q) / 2;\n      c = (r + u) / 2;\n      q = (q + e) / 2;\n      u = (u + f) / 2;\n      var w = (d + q) / 2,\n          v = (c + u) / 2;\n      return J.Br(a, b, p, r, d, c, w, v, k, l, m, n) || J.Br(w, v, q, u, e, f, g, h, k, l, m, n);\n    },\n    Gw: function Gw(a, b, c, d, e, f, g, h, k) {\n      var l = (c + e) / 2,\n          m = (d + f) / 2;\n      k.h((((a + c) / 2 + l) / 2 + (l + (e + g) / 2) / 2) / 2, (((b + d) / 2 + m) / 2 + (m + (f + h) / 2) / 2) / 2);\n      return k;\n    },\n    ty: function ty(a, b, c, d, e, f, g, h) {\n      var k = (c + e) / 2,\n          l = (d + f) / 2;\n      return Bb(((a + c) / 2 + k) / 2, ((b + d) / 2 + l) / 2, (k + (e + g) / 2) / 2, (l + (f + h) / 2) / 2);\n    },\n    ql: function ql(a, b, c, d, e, f, g, h, k, l) {\n      if (J.Tb(a, b, g, h, k, c, d) && J.Tb(a, b, g, h, k, e, f)) Zb(l, a, b, 0, 0), Zb(l, g, h, 0, 0);else {\n        var m = (a + c) / 2,\n            n = (b + d) / 2,\n            p = (c + e) / 2,\n            r = (d + f) / 2;\n        e = (e + g) / 2;\n        f = (f + h) / 2;\n        d = (m + p) / 2;\n        c = (n + r) / 2;\n        p = (p + e) / 2;\n        r = (r + f) / 2;\n        var q = (d + p) / 2,\n            u = (c + r) / 2;\n        J.ql(a, b, m, n, d, c, q, u, k, l);\n        J.ql(q, u, p, r, e, f, g, h, k, l);\n      }\n      return l;\n    },\n    De: function De(a, b, c, d, e, f, g, h, k, l) {\n      if (J.Tb(a, b, g, h, k, c, d) && J.Tb(a, b, g, h, k, e, f)) 0 === l.length && (l.push(a), l.push(b)), l.push(g), l.push(h);else {\n        var m = (a + c) / 2,\n            n = (b + d) / 2,\n            p = (c + e) / 2,\n            r = (d + f) / 2;\n        e = (e + g) / 2;\n        f = (f + h) / 2;\n        d = (m + p) / 2;\n        c = (n + r) / 2;\n        p = (p + e) / 2;\n        r = (r + f) / 2;\n        var q = (d + p) / 2,\n            u = (c + r) / 2;\n        J.De(a, b, m, n, d, c, q, u, k, l);\n        J.De(q, u, p, r, e, f, g, h, k, l);\n      }\n      return l;\n    },\n    Tu: function Tu(a, b, c, d, e, f, g, h, k, l) {\n      if (J.Tb(a, b, e, f, l, c, d)) return J.Tb(a, b, e, f, l, h, k);\n      var m = (a + c) / 2,\n          n = (b + d) / 2;\n      c = (c + e) / 2;\n      d = (d + f) / 2;\n      var p = (m + c) / 2,\n          r = (n + d) / 2;\n      return J.Tu(a, b, m, n, p, r, g, h, k, l) || J.Tu(p, r, c, d, e, f, g, h, k, l);\n    },\n    yA: function yA(a, b, c, d, e, f, g) {\n      g.h(((a + c) / 2 + (c + e) / 2) / 2, ((b + d) / 2 + (d + f) / 2) / 2);\n      return g;\n    },\n    Su: function Su(a, b, c, d, e, f, g, h) {\n      if (J.Tb(a, b, e, f, g, c, d)) Zb(h, a, b, 0, 0), Zb(h, e, f, 0, 0);else {\n        var k = (a + c) / 2,\n            l = (b + d) / 2;\n        c = (c + e) / 2;\n        d = (d + f) / 2;\n        var m = (k + c) / 2,\n            n = (l + d) / 2;\n        J.Su(a, b, k, l, m, n, g, h);\n        J.Su(m, n, c, d, e, f, g, h);\n      }\n      return h;\n    },\n    Go: function Go(a, b, c, d, e, f, g, h) {\n      if (J.Tb(a, b, e, f, g, c, d)) 0 === h.length && (h.push(a), h.push(b)), h.push(e), h.push(f);else {\n        var k = (a + c) / 2,\n            l = (b + d) / 2;\n        c = (c + e) / 2;\n        d = (d + f) / 2;\n        var m = (k + c) / 2,\n            n = (l + d) / 2;\n        J.Go(a, b, k, l, m, n, g, h);\n        J.Go(m, n, c, d, e, f, g, h);\n      }\n      return h;\n    },\n    io: function io(a, b, c, d, e, f, g, h, k, l, m, n, p, r) {\n      if (J.Tb(a, b, g, h, p, c, d) && J.Tb(a, b, g, h, p, e, f)) {\n        if (!J.zl(a, b, g, h, k, l, m, n)) return !1;\n        p = (a - g) * (l - n) - (b - h) * (k - m);\n        if (0 === p) return !1;\n        r.h(((a * h - b * g) * (k - m) - (a - g) * (k * n - l * m)) / p, ((a * h - b * g) * (l - n) - (b - h) * (k * n - l * m)) / p);\n        return !0;\n      }\n\n      var q = (a + c) / 2,\n          u = (b + d) / 2,\n          w = (c + e) / 2,\n          v = (d + f) / 2;\n      e = (e + g) / 2;\n      f = (f + h) / 2;\n      d = (q + w) / 2;\n      c = (u + v) / 2;\n      w = (w + e) / 2;\n      v = (v + f) / 2;\n      var z = (d + w) / 2,\n          y = (c + v) / 2,\n          A = Infinity,\n          B = !1,\n          F = 0,\n          L = 0;\n      J.io(a, b, q, u, d, c, z, y, k, l, m, n, p, r) && (a = (r.x - k) * (r.x - k) + (r.y - l) * (r.y - l), a < A && (A = a, B = !0, F = r.x, L = r.y));\n      J.io(z, y, w, v, e, f, g, h, k, l, m, n, p, r) && (r.x - k) * (r.x - k) + (r.y - l) * (r.y - l) < A && (B = !0, F = r.x, L = r.y);\n      B && (r.x = F, r.y = L);\n      return B;\n    },\n    jo: function jo(a, b, c, d, e, f, g, h, k, l, m, n, p) {\n      var r = 0;\n\n      if (J.Tb(a, b, g, h, p, c, d) && J.Tb(a, b, g, h, p, e, f)) {\n        p = (a - g) * (l - n) - (b - h) * (k - m);\n        if (0 === p) return r;\n        var q = ((a * h - b * g) * (k - m) - (a - g) * (k * n - l * m)) / p,\n            u = ((a * h - b * g) * (l - n) - (b - h) * (k * n - l * m)) / p;\n        if (q >= m) return r;\n\n        if ((k > m ? k - m : m - k) < (l > n ? l - n : n - l)) {\n          if (b < h ? (k = b, a = h) : (k = h, a = b), u < k || u > a) return r;\n        } else if (a < g ? (k = a, a = g) : k = g, q < k || q > a) return r;\n\n        0 < p ? r++ : 0 > p && r--;\n      } else {\n        q = (a + c) / 2;\n        u = (b + d) / 2;\n        var w = (c + e) / 2,\n            v = (d + f) / 2;\n        e = (e + g) / 2;\n        f = (f + h) / 2;\n        d = (q + w) / 2;\n        c = (u + v) / 2;\n        w = (w + e) / 2;\n        v = (v + f) / 2;\n        var z = (d + w) / 2,\n            y = (c + v) / 2;\n        r += J.jo(a, b, q, u, d, c, z, y, k, l, m, n, p);\n        r += J.jo(z, y, w, v, e, f, g, h, k, l, m, n, p);\n      }\n\n      return r;\n    },\n    fh: function fh(a, b, c, d, e, f, g) {\n      if (J.ca(a, c)) {\n        b < d ? (c = b, b = d) : c = d;\n        if (f < c) return g.h(a, c), !1;\n        if (f > b) return g.h(a, b), !1;\n        g.h(a, f);\n        return !0;\n      }\n\n      if (J.ca(b, d)) {\n        a < c ? (d = a, a = c) : d = c;\n        if (e < d) return g.h(d, b), !1;\n        if (e > a) return g.h(a, b), !1;\n        g.h(e, b);\n        return !0;\n      }\n\n      e = ((a - e) * (a - c) + (b - f) * (b - d)) / ((c - a) * (c - a) + (d - b) * (d - b));\n      if (-5E-6 > e) return g.h(a, b), !1;\n      if (1.000005 < e) return g.h(c, d), !1;\n      g.h(a + e * (c - a), b + e * (d - b));\n      return !0;\n    },\n    Je: function Je(a, b, c, d, e, f, g, h, k) {\n      if (J.B(a, c) && J.B(b, d)) return k.h(a, b), !1;\n      if (J.ca(e, g)) return J.ca(a, c) ? (J.fh(a, b, c, d, e, f, k), !1) : J.fh(a, b, c, d, e, (d - b) / (c - a) * (e - a) + b, k);\n      h = (h - f) / (g - e);\n\n      if (J.ca(a, c)) {\n        c = h * (a - e) + f;\n        b < d ? (e = b, b = d) : e = d;\n        if (c < e) return k.h(a, e), !1;\n        if (c > b) return k.h(a, b), !1;\n        k.h(a, c);\n        return !0;\n      }\n\n      g = (d - b) / (c - a);\n      if (J.ca(h, g)) return J.fh(a, b, c, d, e, f, k), !1;\n      e = (g * a - h * e + f - b) / (g - h);\n\n      if (J.ca(g, 0)) {\n        a < c ? (d = a, a = c) : d = c;\n        if (e < d) return k.h(d, b), !1;\n        if (e > a) return k.h(a, b), !1;\n        k.h(e, b);\n        return !0;\n      }\n\n      return J.fh(a, b, c, d, e, g * (e - a) + b, k);\n    },\n    wA: function wA(a, b, c, d, e) {\n      return J.Je(c.x, c.y, d.x, d.y, a.x, a.y, b.x, b.y, e);\n    },\n    uA: function uA(a, b, c, d, e, f, g, h, k, l) {\n      function m(c, d) {\n        var e = (c - a) * (c - a) + (d - b) * (d - b);\n        e < n && (n = e, k.h(c, d));\n      }\n\n      var n = Infinity;\n      m(k.x, k.y);\n      var p = 0,\n          r = 0,\n          q = 0,\n          u = 0;\n      e < g ? (p = e, r = g) : (p = g, r = e);\n      f < h ? (q = e, u = g) : (q = g, u = e);\n      p = (r - p) / 2 + l;\n      l = (u - q) / 2 + l;\n      e = (e + g) / 2;\n      f = (f + h) / 2;\n      if (0 === p || 0 === l) return k;\n\n      if (.5 > (c > a ? c - a : a - c)) {\n        p = 1 - (c - e) * (c - e) / (p * p);\n        if (0 > p) return k;\n        p = Math.sqrt(p);\n        d = -l * p + f;\n        m(c, l * p + f);\n        m(c, d);\n      } else {\n        c = (d - b) / (c - a);\n        d = 1 / (p * p) + c * c / (l * l);\n        h = 2 * c * (b - c * a) / (l * l) - 2 * c * f / (l * l) - 2 * e / (p * p);\n        p = h * h - 4 * d * (2 * c * a * f / (l * l) - 2 * b * f / (l * l) + f * f / (l * l) + e * e / (p * p) - 1 + (b - c * a) * (b - c * a) / (l * l));\n        if (0 > p) return k;\n        p = Math.sqrt(p);\n        l = (-h + p) / (2 * d);\n        m(l, c * l - c * a + b);\n        p = (-h - p) / (2 * d);\n        m(p, c * p - c * a + b);\n      }\n\n      return k;\n    },\n    wf: function wf(a, b, c, d, e, f, g, h, k) {\n      var l = 1E21,\n          m = a,\n          n = b;\n\n      if (J.Je(a, b, a, d, e, f, g, h, k)) {\n        var p = (k.x - e) * (k.x - e) + (k.y - f) * (k.y - f);\n        p < l && (l = p, m = k.x, n = k.y);\n      }\n\n      J.Je(c, b, c, d, e, f, g, h, k) && (p = (k.x - e) * (k.x - e) + (k.y - f) * (k.y - f), p < l && (l = p, m = k.x, n = k.y));\n      J.Je(a, b, c, b, e, f, g, h, k) && (b = (k.x - e) * (k.x - e) + (k.y - f) * (k.y - f), b < l && (l = b, m = k.x, n = k.y));\n      J.Je(a, d, c, d, e, f, g, h, k) && (a = (k.x - e) * (k.x - e) + (k.y - f) * (k.y - f), a < l && (l = a, m = k.x, n = k.y));\n      k.h(m, n);\n      return 1E21 > l;\n    },\n    tA: function tA(a, b, c, d, e, f, g, h, k) {\n      c = a - c;\n      g = e - g;\n      0 === c || 0 === g ? 0 === c ? (b = (f - h) / g, h = a, e = b * h + (f - b * e)) : (f = (b - d) / c, h = e, e = f * h + (b - f * a)) : (d = (b - d) / c, h = (f - h) / g, a = b - d * a, h = (f - h * e - a) / (d - h), e = d * h + a);\n      k.h(h, e);\n      return k;\n    },\n    Rr: function Rr(a, b, c) {\n      return J.jx(a.x, a.y, a.width, a.height, b.x, b.y, c.x, c.y);\n    },\n    jx: function jx(a, b, c, d, e, f, g, h) {\n      var k = a + c,\n          l = b + d;\n      return e === g ? (f < h ? (g = f, f = h) : g = h, a <= e && e <= k && g <= l && f >= b) : f === h ? (e < g ? (h = e, e = g) : h = g, b <= f && f <= l && h <= k && e >= a) : $b(a, b, c, d, e, f) || $b(a, b, c, d, g, h) || J.zl(a, b, k, b, e, f, g, h) || J.zl(k, b, k, l, e, f, g, h) || J.zl(k, l, a, l, e, f, g, h) || J.zl(a, l, a, b, e, f, g, h) ? !0 : !1;\n    },\n    zl: function zl(a, b, c, d, e, f, g, h) {\n      return 0 >= J.sl(a, b, c, d, e, f) * J.sl(a, b, c, d, g, h) && 0 >= J.sl(e, f, g, h, a, b) * J.sl(e, f, g, h, c, d);\n    },\n    sl: function sl(a, b, c, d, e, f) {\n      c -= a;\n      d -= b;\n      a = e - a;\n      b = f - b;\n      f = a * d - b * c;\n      0 === f && (f = a * c + b * d, 0 < f && (f = (a - c) * c + (b - d) * d, 0 > f && (f = 0)));\n      return f;\n    },\n    Eo: function Eo(a) {\n      0 > a && (a += 360);\n      360 <= a && (a -= 360);\n      return a;\n    },\n    Mw: function Mw(a, b, c, d, e, f) {\n      var g = Math.PI;\n      f || (d *= g / 180, e *= g / 180);\n      var h = d > e ? -1 : 1;\n      f = [];\n      var k = g / 2,\n          l = d;\n      d = Math.min(2 * g, Math.abs(e - d));\n      if (1E-5 > d) return k = l + h * Math.min(d, k), h = a + c * Math.cos(l), l = b + c * Math.sin(l), a += c * Math.cos(k), b += c * Math.sin(k), c = (h + a) / 2, k = (l + b) / 2, f.push([h, l, c, k, c, k, a, b]), f;\n\n      for (; 1E-5 < d;) {\n        e = l + h * Math.min(d, k), f.push(J.Cy(c, l, e, a, b)), d -= Math.abs(e - l), l = e;\n      }\n\n      return f;\n    },\n    Cy: function Cy(a, b, c, d, e) {\n      var f = (c - b) / 2,\n          g = a * Math.cos(f),\n          h = a * Math.sin(f),\n          k = -h,\n          l = g * g + k * k,\n          m = l + g * g + k * h;\n      l = 4 / 3 * (Math.sqrt(2 * l * m) - m) / (g * h - k * g);\n      h = g - l * k;\n      g = k + l * g;\n      k = -g;\n      l = f + b;\n      f = Math.cos(l);\n      l = Math.sin(l);\n      return [d + a * Math.cos(b), e + a * Math.sin(b), d + h * f - g * l, e + h * l + g * f, d + h * f - k * l, e + h * l + k * f, d + a * Math.cos(c), e + a * Math.sin(c)];\n    },\n    so: function so(a, b, c, d, e, f, g) {\n      c = Math.floor((a - c) / e) * e + c;\n      d = Math.floor((b - d) / f) * f + d;\n      var h = c;\n      c + e - a < e / 2 && (h = c + e);\n      a = d;\n      d + f - b < f / 2 && (a = d + f);\n      g.h(h, a);\n      return g;\n    },\n    Xw: function Xw(a, b) {\n      var c = Math.max(a, b);\n      a = Math.min(a, b);\n      var d;\n\n      do {\n        b = c % a, c = d = a, a = b;\n      } while (0 < b);\n\n      return d;\n    },\n    Hy: function Hy(a, b, c, d) {\n      var e = 0 > c,\n          f = 0 > d;\n\n      if (a < b) {\n        var g = 1;\n        var h = 0;\n      } else g = 0, h = 1;\n\n      var k = 0 === g ? a : b;\n      var l = 0 === g ? c : d;\n      if (0 === g ? e : f) l = -l;\n      g = h;\n      c = 0 === g ? c : d;\n      if (0 === g ? e : f) c = -c;\n      return J.Iy(k, 0 === g ? a : b, l, c, 0, 0);\n    },\n    Iy: function Iy(a, b, c, d, e, f) {\n      if (0 < d) {\n        if (0 < c) {\n          e = a * a;\n          f = b * b;\n          a *= c;\n          var g = b * d,\n              h = -f + g,\n              k = -f + Math.sqrt(a * a + g * g);\n          b = h;\n\n          for (var l = 0; 9999999999 > l; ++l) {\n            b = .5 * (h + k);\n            if (b === h || b === k) break;\n            var m = a / (b + e),\n                n = g / (b + f);\n            m = m * m + n * n - 1;\n            if (0 < m) h = b;else if (0 > m) k = b;else break;\n          }\n\n          c = e * c / (b + e) - c;\n          d = f * d / (b + f) - d;\n          c = Math.sqrt(c * c + d * d);\n        } else c = Math.abs(d - b);\n      } else d = a * a - b * b, f = a * c, f < d ? (d = f / d, f = b * Math.sqrt(Math.abs(1 - d * d)), c = a * d - c, c = Math.sqrt(c * c + f * f)) : c = Math.abs(c - a);\n      return c;\n    },\n    Oe: new Wa(),\n    dm: new Wa(),\n    Df: new Wa(),\n    Ef: 0,\n    em: 100\n  };\n  J.za = J.jA;\n\n  function O(a) {\n    Ra(this);\n    this.o = 2;\n    void 0 === a && (a = O.m);\n    this.qa = a;\n    this.yc = this.xc = this.hd = this.gd = 0;\n    a === O.m ? this.Yd = new E() : (null === O.W && (O.W = new E().freeze()), this.Yd = O.W);\n    this.Ep = this.Yd.Ia;\n    this.lp = new M().freeze();\n    this.gm = this.gk = null;\n    this.hm = NaN;\n    this.Yf = tc;\n    this.Zf = Cc;\n    this.Gk = this.Hk = NaN;\n    this.Kf = td;\n  }\n\n  O.prototype.copy = function () {\n    var a = new O();\n    a.o = this.o & -2;\n    a.qa = this.qa;\n    a.gd = this.gd;\n    a.hd = this.hd;\n    a.xc = this.xc;\n    a.yc = this.yc;\n\n    if (this.qa === O.m) {\n      for (var b = this.Yd.s, c = a.Yd, d = 0; d < b.length; d++) {\n        c.add(b[d].copy());\n      }\n\n      a.Yd = c;\n    } else a.Yd = this.Yd;\n\n    a.Ep = this.Ep;\n    a.lp.assign(this.lp);\n    a.gk = this.gk;\n    a.gm = this.gm;\n    a.hm = this.hm;\n    a.Yf = this.Yf.J();\n    a.Zf = this.Zf.J();\n    a.Hk = this.Hk;\n    a.Gk = this.Gk;\n    a.Kf = this.Kf;\n    return a;\n  };\n\n  O.prototype.ha = function () {\n    this.freeze();\n    Object.freeze(this);\n    return this;\n  };\n\n  O.prototype.freeze = function () {\n    this._isFrozen = !0;\n    if (this.type !== O.m) return this;\n    var a = this.figures;\n    a.freeze();\n    a = a.s;\n\n    for (var b = a.length, c = 0; c < b; c++) {\n      a[c].freeze();\n    }\n\n    return this;\n  };\n\n  O.prototype.ja = function () {\n    Object.isFrozen(this) && C(\"cannot thaw constant: \" + this);\n    this._isFrozen = !1;\n    if (this.type !== O.m) return this;\n    var a = this.figures;\n    a.ja();\n    a = a.s;\n\n    for (var b = a.length, c = 0; c < b; c++) {\n      a[c].ja();\n    }\n\n    return this;\n  };\n\n  O.prototype.$a = function (a) {\n    if (!(a instanceof O)) return !1;\n    if (this.type !== a.type) return this.type === O.j && a.type === O.m ? ud(this, a) : a.type === O.j && this.type === O.m ? ud(a, this) : !1;\n\n    if (this.type === O.m) {\n      var b = this.figures.s;\n      a = a.figures.s;\n      var c = b.length;\n      if (c !== a.length) return !1;\n\n      for (var d = 0; d < c; d++) {\n        if (!b[d].$a(a[d])) return !1;\n      }\n\n      return !0;\n    }\n\n    return J.B(this.startX, a.startX) && J.B(this.startY, a.startY) && J.B(this.endX, a.endX) && J.B(this.endY, a.endY);\n  };\n\n  function ud(a, b) {\n    return a.type !== O.j || b.type !== O.m ? !1 : 1 === b.figures.count && (b = b.figures.K(0), 1 === b.segments.count && J.B(a.startX, b.startX) && J.B(a.startY, b.startY) && (b = b.segments.K(0), b.type === vd && J.B(a.endX, b.endX) && J.B(a.endY, b.endY))) ? !0 : !1;\n  }\n\n  O.ga = function (a) {\n    return a.toString();\n  };\n\n  O.prototype.ob = function (a) {\n    a.classType === O && (this.type = a);\n  };\n\n  O.prototype.toString = function (a) {\n    void 0 === a && (a = -1);\n\n    switch (this.type) {\n      case O.j:\n        return 0 > a ? \"M\" + this.startX.toString() + \" \" + this.startY.toString() + \"L\" + this.endX.toString() + \" \" + this.endY.toString() : \"M\" + this.startX.toFixed(a) + \" \" + this.startY.toFixed(a) + \"L\" + this.endX.toFixed(a) + \" \" + this.endY.toFixed(a);\n\n      case O.u:\n        var b = new M(this.startX, this.startY, 0, 0);\n        b.nv(this.endX, this.endY, 0, 0);\n        return 0 > a ? \"M\" + b.x.toString() + \" \" + b.y.toString() + \"H\" + b.right.toString() + \"V\" + b.bottom.toString() + \"H\" + b.left.toString() + \"z\" : \"M\" + b.x.toFixed(a) + \" \" + b.y.toFixed(a) + \"H\" + b.right.toFixed(a) + \"V\" + b.bottom.toFixed(a) + \"H\" + b.left.toFixed(a) + \"z\";\n\n      case O.F:\n        b = new M(this.startX, this.startY, 0, 0);\n        b.nv(this.endX, this.endY, 0, 0);\n        if (0 > a) return a = b.left.toString() + \" \" + (b.y + b.height / 2).toString(), \"M\" + a + \"A\" + (b.width / 2).toString() + \" \" + (b.height / 2).toString() + \" 0 0 1 \" + (b.right.toString() + \" \" + (b.y + b.height / 2).toString()) + \"A\" + (b.width / 2).toString() + \" \" + (b.height / 2).toString() + \" 0 0 1 \" + a;\n        var c = b.left.toFixed(a) + \" \" + (b.y + b.height / 2).toFixed(a);\n        return \"M\" + c + \"A\" + (b.width / 2).toFixed(a) + \" \" + (b.height / 2).toFixed(a) + \" 0 0 1 \" + (b.right.toFixed(a) + \" \" + (b.y + b.height / 2).toFixed(a)) + \"A\" + (b.width / 2).toFixed(a) + \" \" + (b.height / 2).toFixed(a) + \" 0 0 1 \" + c;\n\n      case O.m:\n        b = \"\";\n        c = this.figures.s;\n\n        for (var d = c.length, e = 0; e < d; e++) {\n          var f = c[e];\n          0 < e && (b += \" x \");\n          f.isFilled && (b += \"F \");\n          b += f.toString(a);\n        }\n\n        return b;\n\n      default:\n        return this.type.toString();\n    }\n  };\n\n  O.hb = function (a) {\n    a = a.split(/[Xx]/);\n\n    for (var b = a.length, c = \"\", d = 0; d < b; d++) {\n      var e = a[d];\n      c = null !== e.match(/[Ff]/) ? 0 === d ? c + e : c + (\"X\" + (\" \" === e[0] ? \"\" : \" \") + e) : c + ((0 === d ? \"\" : \"X \") + \"F\" + (\" \" === e[0] ? \"\" : \" \") + e);\n    }\n\n    return c;\n  };\n\n  O.parse = function (a, b) {\n    function c() {\n      return u >= A - 1 ? !0 : null !== l[u + 1].match(B);\n    }\n\n    function d() {\n      u++;\n      return l[u];\n    }\n\n    function e(a) {\n      var b = parseFloat(d()),\n          c = parseFloat(d());\n      w === w.toLowerCase() && (b = y.x + b, c = y.y + c);\n      a.h(b, c);\n    }\n\n    function f() {\n      e(y);\n      return y;\n    }\n\n    function g() {\n      e(z);\n      return z;\n    }\n\n    function h() {\n      var a = v.toLowerCase();\n      return \"c\" !== a && \"s\" !== a && \"q\" !== a && \"t\" !== a ? y : new I(2 * y.x - z.x, 2 * y.y - z.y);\n    }\n\n    void 0 === b && (b = !1);\n    var k = /([UuBbMmZzLlHhVvCcSsQqTtAaFfXx])([UuBbMmZzLlHhVvCcSsQqTtAaFfXx])/gm;\n    a = a.replace(/,/gm, \" \");\n    a = a.replace(k, \"$1 $2\");\n    a = a.replace(k, \"$1 $2\");\n    a = a.replace(/([UuBbMmZzLlHhVvCcSsQqTtAaFfXx])([^s])/gm, \"$1 $2\");\n    a = a.replace(/([^s])([UuBbMmZzLlHhVvCcSsQqTtAaFfXx])/gm, \"$1 $2\");\n    a = a.replace(/([0-9])([+\\-])/gm, \"$1 $2\");\n    a = a.replace(/[\\s\\r\\t\\n]+/gm, \" \");\n    a = a.replace(/^\\s+|\\s+$/g, \"\");\n    var l = a.split(\" \");\n\n    for (a = 0; a < l.length; a++) {\n      var m = l[a];\n\n      if (null !== m.match(/(\\.[0-9]*)(\\.)/gm)) {\n        k = Ea();\n\n        for (var n = \"\", p = !1, r = 0; r < m.length; r++) {\n          var q = m[r];\n          \".\" !== q || p ? \".\" === q ? (k.push(n), n = \".\") : n += q : (p = !0, n += q);\n        }\n\n        k.push(n);\n        l.splice(a, 1);\n\n        for (m = 0; m < k.length; m++) {\n          l.splice(a + m, 0, k[m]);\n        }\n\n        a += k.length - 1;\n        Ga(k);\n      }\n    }\n\n    var u = -1,\n        w = \"\",\n        v = \"\";\n    k = new I(0, 0);\n    var z = new I(0, 0),\n        y = new I(0, 0),\n        A = l.length;\n    a = wd(null);\n    n = m = !1;\n    p = !0;\n    r = null;\n\n    for (var B = /[UuBbMmZzLlHhVvCcSsQqTtAaFfXx]/; !(u >= A - 1);) {\n      if (v = w, w = d(), \"\" !== w) switch (w.toUpperCase()) {\n        case \"X\":\n          p = !0;\n          n = m = !1;\n          break;\n\n        case \"M\":\n          r = f();\n          null === a.pc || !0 === p ? (xd(a, r.x, r.y, m, !n), p = !1) : a.moveTo(r.x, r.y);\n\n          for (k.assign(y); !c();) {\n            r = f(), a.lineTo(r.x, r.y);\n          }\n\n          break;\n\n        case \"L\":\n          for (; !c();) {\n            r = f(), a.lineTo(r.x, r.y);\n          }\n\n          break;\n\n        case \"H\":\n          for (; !c();) {\n            y = new I((w === w.toLowerCase() ? y.x : 0) + parseFloat(d()), y.y), a.lineTo(y.x, y.y);\n          }\n\n          break;\n\n        case \"V\":\n          for (; !c();) {\n            y = new I(y.x, (w === w.toLowerCase() ? y.y : 0) + parseFloat(d())), a.lineTo(y.x, y.y);\n          }\n\n          break;\n\n        case \"C\":\n          for (; !c();) {\n            r = new I();\n            e(r);\n            q = g();\n            var F = f();\n            yd(a, r.x, r.y, q.x, q.y, F.x, F.y);\n          }\n\n          break;\n\n        case \"S\":\n          for (; !c();) {\n            r = h(), q = g(), F = f(), yd(a, r.x, r.y, q.x, q.y, F.x, F.y);\n          }\n\n          break;\n\n        case \"Q\":\n          for (; !c();) {\n            r = g(), q = f(), zd(a, r.x, r.y, q.x, q.y);\n          }\n\n          break;\n\n        case \"T\":\n          for (; !c();) {\n            z = r = h(), q = f(), zd(a, r.x, r.y, q.x, q.y);\n          }\n\n          break;\n\n        case \"B\":\n          for (; !c();) {\n            r = parseFloat(d());\n            q = parseFloat(d());\n            F = parseFloat(d());\n            var L = parseFloat(d()),\n                S = parseFloat(d()),\n                R = S,\n                P = !1;\n            c() || (R = parseFloat(d()), c() || (P = 0 !== parseFloat(d())));\n            w === w.toLowerCase() && (F += y.x, L += y.y);\n            a.arcTo(r, q, F, L, S, R, P);\n          }\n\n          break;\n\n        case \"A\":\n          for (; !c();) {\n            r = Math.abs(parseFloat(d())), q = Math.abs(parseFloat(d())), F = parseFloat(d()), S = L = !1, P = R = 0, R = d(), 1 === R.length ? (L = !!parseFloat(R), S = !!parseFloat(d()), R = parseFloat(d())) : 2 === R.length ? (L = !!parseFloat(R[0]), S = !!parseFloat(R[1]), R = parseFloat(d())) : (L = !!parseFloat(R[0]), S = !!parseFloat(R[1]), R = parseFloat(R.slice(2))), P = parseFloat(d()), w === w.toLowerCase() && (R = y.x + R, P = y.y + P), y.h(R, P), Ad(a, r, q, F, L, S, R, P);\n          }\n\n          break;\n\n        case \"Z\":\n          Gd(a);\n          y.assign(k);\n          break;\n\n        case \"F\":\n          r = \"\";\n\n          for (q = 1; l[u + q];) {\n            if (null !== l[u + q].match(/[Uu]/)) q++;else if (null === l[u + q].match(B)) q++;else {\n              r = l[u + q];\n              break;\n            }\n          }\n\n          r.match(/[Mm]/) ? m = !0 : 0 < a.pc.segments.length && (a.pc.isFilled = !0);\n          break;\n\n        case \"U\":\n          r = \"\";\n\n          for (q = 1; l[u + q];) {\n            if (null !== l[u + q].match(/[Ff]/)) q++;else if (null === l[u + q].match(B)) q++;else {\n              r = l[u + q];\n              break;\n            }\n          }\n\n          r.match(/[Mm]/) ? n = !0 : a.Xl(!1);\n      }\n    }\n\n    k = a.Lr;\n    Hd = a;\n    if (b) for (b = k.figures.iterator; b.next();) {\n      b.value.isFilled = !0;\n    }\n    return k;\n  };\n\n  O.Ga = function (a, b) {\n    for (var c = a.length, d = I.alloc(), e = 0; e < c; e++) {\n      var f = a[e];\n      d.x = f[0];\n      d.y = f[1];\n      b.Fa(d);\n      f[0] = d.x;\n      f[1] = d.y;\n      d.x = f[2];\n      d.y = f[3];\n      b.Fa(d);\n      f[2] = d.x;\n      f[3] = d.y;\n      d.x = f[4];\n      d.y = f[5];\n      b.Fa(d);\n      f[4] = d.x;\n      f[5] = d.y;\n      d.x = f[6];\n      d.y = f[7];\n      b.Fa(d);\n      f[6] = d.x;\n      f[7] = d.y;\n    }\n\n    I.free(d);\n  };\n\n  O.prototype.Lu = function () {\n    if (this._isInvalidBounds) return !0;\n\n    if (this.type === O.m) {\n      if (this.Ep !== this.figures.Ia) return !0;\n\n      for (var a = this.figures.s, b = a.length, c = 0; c < b; c++) {\n        if (a[c].Lu()) return !0;\n      }\n    }\n\n    return !1;\n  };\n\n  O.prototype.computeBounds = function () {\n    this._isInvalidBounds = !1;\n    this.gm = this.gk = null;\n    this.hm = NaN;\n\n    if (this.type === O.m) {\n      this.Ep = this.figures.Ia;\n\n      for (var a = this.figures.s, b = a.length, c = 0; c < b; c++) {\n        var d = a[c];\n        d._isInvalidBounds = !1;\n        var e = d.segments;\n        d.Pq = e.Ia;\n        d = e.s;\n        e = d.length;\n\n        for (var f = 0; f < e; f++) {\n          var g = d[f];\n          g._isInvalidBounds = !1;\n          g.Ud = null;\n        }\n      }\n    }\n\n    a = this.lp;\n    a.ja();\n    isNaN(this.Hk) || isNaN(this.Gk) ? a.h(0, 0, 0, 0) : a.h(0, 0, this.Hk, this.Gk);\n    Id(this, a, !1);\n    Zb(a, 0, 0, 0, 0);\n    a.freeze();\n  };\n\n  O.prototype.Lw = function () {\n    var a = new M();\n    Id(this, a, !0);\n    return a;\n  };\n\n  function Id(a, b, c) {\n    switch (a.type) {\n      case O.j:\n      case O.u:\n      case O.F:\n        c ? b.h(a.gd, a.hd, 0, 0) : Zb(b, a.gd, a.hd, 0, 0);\n        Zb(b, a.xc, a.yc, 0, 0);\n        break;\n\n      case O.m:\n        var d = a.figures;\n        a = d.s;\n        d = d.length;\n\n        for (var e = 0; e < d; e++) {\n          var f = a[e];\n          c && 0 === e ? b.h(f.startX, f.startY, 0, 0) : Zb(b, f.startX, f.startY, 0, 0);\n\n          for (var g = f.segments.s, h = g.length, k = f.startX, l = f.startY, m = 0; m < h; m++) {\n            var n = g[m];\n\n            switch (n.type) {\n              case vd:\n              case Jd:\n                k = n.endX;\n                l = n.endY;\n                Zb(b, k, l, 0, 0);\n                break;\n\n              case Kd:\n                J.ql(k, l, n.point1X, n.point1Y, n.point2X, n.point2Y, n.endX, n.endY, .5, b);\n                k = n.endX;\n                l = n.endY;\n                break;\n\n              case Ld:\n                J.Su(k, l, n.point1X, n.point1Y, n.endX, n.endY, .5, b);\n                k = n.endX;\n                l = n.endY;\n                break;\n\n              case Md:\n              case Qd:\n                var p = n.type === Md ? Rd(n, f) : Sd(n, f, k, l),\n                    r = p.length;\n\n                if (0 === r) {\n                  k = n.type === Md ? n.centerX : n.endX;\n                  l = n.type === Md ? n.centerY : n.endY;\n                  Zb(b, k, l, 0, 0);\n                  break;\n                }\n\n                n = null;\n\n                for (var q = 0; q < r; q++) {\n                  n = p[q], J.ql(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], .5, b);\n                }\n\n                null !== n && (k = n[6], l = n[7]);\n                break;\n\n              default:\n                C(\"Unknown Segment type: \" + n.type);\n            }\n          }\n        }\n\n        break;\n\n      default:\n        C(\"Unknown Geometry type: \" + a.type);\n    }\n  }\n\n  O.prototype.normalize = function () {\n    this._isFrozen && va(this);\n    var a = this.Lw();\n    this.offset(-a.x, -a.y);\n    return new I(-a.x, -a.y);\n  };\n\n  O.prototype.offset = function (a, b) {\n    this._isFrozen && va(this);\n    this.transform(1, 0, 0, 1, a, b);\n    return this;\n  };\n\n  O.prototype.scale = function (a, b) {\n    this._isFrozen && va(this);\n    this.transform(a, 0, 0, b, 0, 0);\n    return this;\n  };\n\n  O.prototype.rotate = function (a, b, c) {\n    this._isFrozen && va(this);\n    void 0 === b && (b = 0);\n    void 0 === c && (c = 0);\n    var d = md.alloc();\n    d.reset();\n    d.rotate(a, b, c);\n    this.transform(d.m11, d.m12, d.m21, d.m22, d.dx, d.dy);\n    md.free(d);\n    return this;\n  };\n\n  t = O.prototype;\n\n  t.transform = function (a, b, c, d, e, f) {\n    switch (this.type) {\n      case O.j:\n      case O.u:\n      case O.F:\n        var g = this.gd;\n        var h = this.hd;\n        this.gd = g * a + h * c + e;\n        this.hd = g * b + h * d + f;\n        g = this.xc;\n        h = this.yc;\n        this.xc = g * a + h * c + e;\n        this.yc = g * b + h * d + f;\n        break;\n\n      case O.m:\n        for (var k = this.figures.s, l = k.length, m = 0; m < l; m++) {\n          var n = k[m];\n          g = n.startX;\n          h = n.startY;\n          n.startX = g * a + h * c + e;\n          n.startY = g * b + h * d + f;\n          n = n.segments.s;\n\n          for (var p = n.length, r = 0; r < p; r++) {\n            var q = n[r];\n\n            switch (q.type) {\n              case vd:\n              case Jd:\n                g = q.endX;\n                h = q.endY;\n                q.endX = g * a + h * c + e;\n                q.endY = g * b + h * d + f;\n                break;\n\n              case Kd:\n                g = q.point1X;\n                h = q.point1Y;\n                q.point1X = g * a + h * c + e;\n                q.point1Y = g * b + h * d + f;\n                g = q.point2X;\n                h = q.point2Y;\n                q.point2X = g * a + h * c + e;\n                q.point2Y = g * b + h * d + f;\n                g = q.endX;\n                h = q.endY;\n                q.endX = g * a + h * c + e;\n                q.endY = g * b + h * d + f;\n                break;\n\n              case Ld:\n                g = q.point1X;\n                h = q.point1Y;\n                q.point1X = g * a + h * c + e;\n                q.point1Y = g * b + h * d + f;\n                g = q.endX;\n                h = q.endY;\n                q.endX = g * a + h * c + e;\n                q.endY = g * b + h * d + f;\n                break;\n\n              case Md:\n                g = q.centerX;\n                h = q.centerY;\n                q.centerX = g * a + h * c + e;\n                q.centerY = g * b + h * d + f;\n                0 !== b && (g = 180 * Math.atan2(b, a) / Math.PI, 0 > g && (g += 360), q.startAngle += g);\n                0 > a && (q.startAngle = 180 - q.startAngle, q.sweepAngle = -q.sweepAngle);\n                0 > d && (q.startAngle = -q.startAngle, q.sweepAngle = -q.sweepAngle);\n                q.radiusX *= Math.sqrt(a * a + c * c);\n                void 0 !== q.radiusY && (q.radiusY *= Math.sqrt(b * b + d * d));\n                break;\n\n              case Qd:\n                g = q.endX;\n                h = q.endY;\n                q.endX = g * a + h * c + e;\n                q.endY = g * b + h * d + f;\n                if (0 === q.radiusX || 0 === q.radiusY) break;\n                0 !== b && (g = 180 * Math.atan2(b, a) / Math.PI, 0 > g && (g += 360), q.xAxisRotation += g);\n                0 > a && (q.xAxisRotation = 180 - q.xAxisRotation, q.isClockwiseArc = !q.isClockwiseArc);\n                0 > d && (q.xAxisRotation = -q.xAxisRotation, q.isClockwiseArc = !q.isClockwiseArc);\n                q.radiusX *= Math.sqrt(a * a + c * c);\n                q.radiusY *= Math.sqrt(b * b + d * d);\n                break;\n\n              default:\n                C(\"Unknown Segment type: \" + q.type);\n            }\n          }\n        }\n\n    }\n\n    this._isInvalidBounds = !0;\n    return this;\n  };\n\n  t.ba = function (a, b) {\n    void 0 === b && (b = 0);\n    var c = this.gd,\n        d = this.hd,\n        e = this.xc,\n        f = this.yc;\n\n    switch (this.type) {\n      case O.j:\n        return J.Tb(c, d, e, f, b, a.x, a.y);\n\n      case O.u:\n        var g = M.allocAt(Math.min(c, e) - b, Math.min(d, f) - b, Math.abs(e - c) + 2 * b, Math.abs(f - d) + 2 * b);\n        a = g.ba(a);\n        M.free(g);\n        return a;\n\n      case O.F:\n        g = Math.min(c, e) - b;\n        var h = Math.min(d, f) - b;\n        c = (Math.abs(e - c) + 2 * b) / 2;\n        b = (Math.abs(f - d) + 2 * b) / 2;\n        if (0 >= c || 0 >= b) return !1;\n        g = a.x - (g + c);\n        h = a.y - (h + b);\n        return 1 >= g * g / (c * c) + h * h / (b * b);\n\n      case O.m:\n        return Td(this, a, b, !0, !1);\n\n      default:\n        return !1;\n    }\n  };\n\n  function Td(a, b, c, d, e) {\n    var f = b.x;\n    b = b.y;\n\n    for (var g = a.bounds.x - 20, h = 0, k, l, m, n, p = a.figures.s, r = p.length, q = 0; q < r; q++) {\n      var u = p[q];\n\n      if (u.isFilled) {\n        if (d && u.ba(f, b, c)) return !0;\n        var w = u.segments;\n        k = u.startX;\n        l = u.startY;\n\n        for (var v = k, z = l, y = w.s, A = 0; A <= w.length; A++) {\n          var B = void 0;\n\n          if (A !== w.length) {\n            B = y[A];\n            var F = B.type;\n            a = B.endX;\n            n = B.endY;\n          } else F = vd, a = v, n = z;\n\n          switch (F) {\n            case Jd:\n              v = Ud(f, b, g, b, k, l, v, z);\n              if (isNaN(v)) return !0;\n              h += v;\n              v = a;\n              z = n;\n              break;\n\n            case vd:\n              k = Ud(f, b, g, b, k, l, a, n);\n              if (isNaN(k)) return !0;\n              h += k;\n              break;\n\n            case Kd:\n              m = J.jo(k, l, B.point1X, B.point1Y, B.point2X, B.point2Y, a, n, g, b, f, b, .5);\n              h += m;\n              break;\n\n            case Ld:\n              m = J.jo(k, l, (k + 2 * B.point1X) / 3, (l + 2 * B.point1Y) / 3, (2 * B.point1X + a) / 3, (2 * B.point1Y + n) / 3, a, n, g, b, f, b, .5);\n              h += m;\n              break;\n\n            case Md:\n            case Qd:\n              F = B.type === Md ? Rd(B, u) : Sd(B, u, k, l);\n              var L = F.length;\n\n              if (0 === L) {\n                k = Ud(f, b, g, b, k, l, B.type === Md ? B.centerX : B.endX, B.type === Md ? B.centerY : B.endY);\n                if (isNaN(k)) return !0;\n                h += k;\n                break;\n              }\n\n              B = null;\n\n              for (var S = 0; S < L; S++) {\n                B = F[S];\n\n                if (0 === S) {\n                  m = Ud(f, b, g, b, k, l, B[0], B[1]);\n                  if (isNaN(m)) return !0;\n                  h += m;\n                }\n\n                m = J.jo(B[0], B[1], B[2], B[3], B[4], B[5], B[6], B[7], g, b, f, b, .5);\n                h += m;\n              }\n\n              null !== B && (a = B[6], n = B[7]);\n              break;\n\n            default:\n              C(\"Unknown Segment type: \" + B.type);\n          }\n\n          k = a;\n          l = n;\n        }\n\n        if (0 !== h) return !0;\n        h = 0;\n      } else if (u.ba(f, b, e ? c : c + 2)) return !0;\n    }\n\n    return 0 !== h;\n  }\n\n  function Ud(a, b, c, d, e, f, g, h) {\n    if (J.Tb(e, f, g, h, .05, a, b)) return NaN;\n    var k = (a - c) * (f - h);\n    if (0 === k) return 0;\n    var l = ((a * d - b * c) * (e - g) - (a - c) * (e * h - f * g)) / k;\n    b = (a * d - b * c) * (f - h) / k;\n    if (l >= a) return 0;\n    if ((e > g ? e - g : g - e) < (f > h ? f - h : h - f)) {\n      if (f < h) {\n        if (b < f || b > h) return 0;\n      } else {\n        if (b < h || b > f) return 0;\n      }\n    } else if (e < g) {\n      if (l < e || l > g) return 0;\n    } else if (l < g || l > e) return 0;\n    return 0 < k ? 1 : -1;\n  }\n\n  function Vd(a, b, c, d) {\n    a = a.figures.s;\n\n    for (var e = a.length, f = 0; f < e; f++) {\n      if (a[f].ba(b, c, d)) return !0;\n    }\n\n    return !1;\n  }\n\n  t.Bu = function (a, b) {\n    0 > a ? a = 0 : 1 < a && (a = 1);\n    void 0 === b && (b = new I());\n    if (this.type === O.j) return b.h(this.startX + a * (this.endX - this.startX), this.startY + a * (this.endY - this.startY)), b;\n\n    for (var c = this.flattenedSegments, d = this.flattenedLengths, e = c.length, f = this.flattenedTotalLength * a, g = 0, h = 0; h < e; h++) {\n      var k = d[h],\n          l = k.length;\n\n      for (a = 0; a < l; a++) {\n        var m = k[a];\n        if (g + m >= f) return d = f - g, d = 0 === m ? 0 : d / m, c = c[h], h = c[2 * a], e = c[2 * a + 1], b.h(h + (c[2 * a + 2] - h) * d, e + (c[2 * a + 3] - e) * d), b;\n        g += m;\n      }\n    }\n\n    return b;\n  };\n\n  t.Yw = function (a) {\n    0 > a ? a = 0 : 1 < a && (a = 1);\n    if (this.type === O.j) return 180 * Math.atan2(this.endY - this.startY, this.endX - this.startX) / Math.PI;\n\n    for (var b = this.flattenedSegments, c = this.flattenedLengths, d = b.length, e = this.flattenedTotalLength * a, f = 0, g = 0; g < d; g++) {\n      var h = c[g],\n          k = h.length;\n\n      for (a = 0; a < k; a++) {\n        var l = h[a];\n        if (f + l >= e) return e = b[g], b = e[2 * a], c = e[2 * a + 1], d = e[2 * a + 2], a = e[2 * a + 3], 1 > Math.abs(d - b) && 1 > Math.abs(a - c) ? 0 : 1 > Math.abs(d - b) ? 0 <= a - c ? 90 : 270 : 1 > Math.abs(a - c) ? 0 <= d - b ? 0 : 180 : 180 * Math.atan2(a - c, d - b) / Math.PI;\n        f += l;\n      }\n    }\n\n    return NaN;\n  };\n\n  t.Cu = function (a, b) {\n    0 > a ? a = 0 : 1 < a && (a = 1);\n    void 0 === b && (b = []);\n    b.length = 3;\n    if (this.type === O.j) return b[0] = this.startX + a * (this.endX - this.startX), b[1] = this.startY + a * (this.endY - this.startY), b[2] = 180 * Math.atan2(this.endY - this.startY, this.endX - this.startX) / Math.PI, b;\n\n    for (var c = this.flattenedSegments, d = this.flattenedLengths, e = c.length, f = this.flattenedTotalLength * a, g = 0, h = 0; h < e; h++) {\n      var k = d[h],\n          l = k.length;\n\n      for (a = 0; a < l; a++) {\n        var m = k[a];\n        if (g + m >= f) return d = f - g, d = 0 === m ? 0 : d / m, m = c[h], c = m[2 * a], h = m[2 * a + 1], e = m[2 * a + 2], a = m[2 * a + 3], b[0] = c + (e - c) * d, b[1] = h + (a - h) * d, b[2] = 1 > Math.abs(e - c) && 1 > Math.abs(a - h) ? 0 : 1 > Math.abs(e - c) ? 0 <= a - h ? 90 : 270 : 1 > Math.abs(a - h) ? 0 <= e - c ? 0 : 180 : 180 * Math.atan2(a - h, e - c) / Math.PI, b;\n        g += m;\n      }\n    }\n\n    return b;\n  };\n\n  t.Zw = function (a) {\n    if (this.type === O.j) {\n      var b = this.startX,\n          c = this.startY,\n          d = this.endX,\n          e = this.endY;\n\n      if (b !== d || c !== e) {\n        var f = a.x;\n        a = a.y;\n\n        if (b === d) {\n          if (c < e) {\n            var g = c;\n            d = e;\n          } else g = e, d = c;\n\n          return a <= g ? g === c ? 0 : 1 : a >= d ? d === c ? 0 : 1 : Math.abs(a - c) / (d - g);\n        }\n\n        if (c === e) return b < d ? g = b : (g = d, d = b), f <= g ? g === b ? 0 : 1 : f >= d ? d === b ? 0 : 1 : Math.abs(f - b) / (d - g);\n        g = (d - b) * (d - b) + (e - c) * (e - c);\n        var h = I.alloc();\n        J.fh(b, c, d, e, f, a, h);\n        a = h.x;\n        f = h.y;\n        I.free(h);\n        return Math.sqrt(((a - b) * (a - b) + (f - c) * (f - c)) / g);\n      }\n    } else if (this.type === O.u) {\n      g = this.startX;\n      h = this.startY;\n      var k = this.endX;\n      e = this.endY;\n\n      if (g !== k || h !== e) {\n        b = k - g;\n        c = e - h;\n        f = 2 * b + 2 * c;\n        d = a.x;\n        a = a.y;\n        d = Math.min(Math.max(d, g), k);\n        a = Math.min(Math.max(a, h), e);\n        g = Math.abs(d - g);\n        k = Math.abs(d - k);\n        h = Math.abs(a - h);\n        e = Math.abs(a - e);\n        var l = Math.min(g, k, h, e);\n        if (l === h) return d / f;\n        if (l === k) return (b + a) / f;\n        if (l === e) return (2 * b + c - d) / f;\n        if (l === g) return (2 * b + 2 * c - a) / f;\n      }\n    } else {\n      b = this.flattenedSegments;\n      c = this.flattenedLengths;\n      f = this.flattenedTotalLength;\n      d = I.alloc();\n      e = Infinity;\n      h = g = 0;\n      k = b.length;\n\n      for (var m = l = 0, n = 0; n < k; n++) {\n        for (var p = b[n], r = c[n], q = p.length, u = 0; u < q; u += 2) {\n          var w = p[u],\n              v = p[u + 1];\n\n          if (0 !== u) {\n            J.fh(l, m, w, v, a.x, a.y, d);\n            var z = (d.x - a.x) * (d.x - a.x) + (d.y - a.y) * (d.y - a.y);\n            z < e && (e = z, g = h, g += Math.sqrt((d.x - l) * (d.x - l) + (d.y - m) * (d.y - m)));\n            h += r[(u - 2) / 2];\n          }\n\n          l = w;\n          m = v;\n        }\n      }\n\n      I.free(d);\n      a = g / f;\n      return 0 > a ? 0 : 1 < a ? 1 : a;\n    }\n\n    return 0;\n  };\n\n  function Wd(a) {\n    if (null === a.gk) {\n      var b = a.gk = [],\n          c = a.gm = [],\n          d = [],\n          e = [];\n      if (a.type === O.j) d.push(a.startX), d.push(a.startY), d.push(a.endX), d.push(a.endY), b.push(d), e.push(Math.sqrt((a.startX - a.endX) * (a.startX - a.endX) + (a.startY - a.endY) * (a.startY - a.endY))), c.push(e);else if (a.type === O.u) d.push(a.startX), d.push(a.startY), d.push(a.endX), d.push(a.startY), d.push(a.endX), d.push(a.endY), d.push(a.startX), d.push(a.endY), d.push(a.startX), d.push(a.startY), b.push(d), e.push(Math.abs(a.startX - a.endX)), e.push(Math.abs(a.startY - a.endY)), e.push(Math.abs(a.startX - a.endX)), e.push(Math.abs(a.startY - a.endY)), c.push(e);else if (a.type === O.F) {\n        var f = new Xd();\n        f.startX = a.endX;\n        f.startY = (a.startY + a.endY) / 2;\n        var g = new Yd(Md);\n        g.startAngle = 0;\n        g.sweepAngle = 360;\n        g.centerX = (a.startX + a.endX) / 2;\n        g.centerY = (a.startY + a.endY) / 2;\n        g.radiusX = Math.abs(a.startX - a.endX) / 2;\n        g.radiusY = Math.abs(a.startY - a.endY) / 2;\n        f.add(g);\n        a = Rd(g, f);\n        e = a.length;\n        if (0 === e) d.push(g.centerX), d.push(g.centerY);else {\n          g = f.startX;\n          f = f.startY;\n\n          for (var h = 0; h < e; h++) {\n            var k = a[h];\n            J.De(g, f, k[2], k[3], k[4], k[5], k[6], k[7], .5, d);\n            g = k[6];\n            f = k[7];\n          }\n        }\n        b.push(d);\n        c.push(Zd(d));\n      } else for (a = a.figures.iterator; a.next();) {\n        e = a.value;\n        d = [];\n        d.push(e.startX);\n        d.push(e.startY);\n        g = e.startX;\n        f = e.startY;\n        h = g;\n        k = f;\n\n        for (var l = e.segments.s, m = l.length, n = 0; n < m; n++) {\n          var p = l[n];\n\n          switch (p.type) {\n            case Jd:\n              4 <= d.length && (b.push(d), c.push(Zd(d)));\n              d = [];\n              d.push(p.endX);\n              d.push(p.endY);\n              g = p.endX;\n              f = p.endY;\n              h = g;\n              k = f;\n              break;\n\n            case vd:\n              d.push(p.endX);\n              d.push(p.endY);\n              g = p.endX;\n              f = p.endY;\n              break;\n\n            case Kd:\n              J.De(g, f, p.point1X, p.point1Y, p.point2X, p.point2Y, p.endX, p.endY, .5, d);\n              g = p.endX;\n              f = p.endY;\n              break;\n\n            case Ld:\n              J.Go(g, f, p.point1X, p.point1Y, p.endX, p.endY, .5, d);\n              g = p.endX;\n              f = p.endY;\n              break;\n\n            case Md:\n              var r = Rd(p, e),\n                  q = r.length;\n\n              if (0 === q) {\n                d.push(p.centerX);\n                d.push(p.centerY);\n                g = p.centerX;\n                f = p.centerY;\n                break;\n              }\n\n              for (var u = 0; u < q; u++) {\n                var w = r[u];\n                J.De(g, f, w[2], w[3], w[4], w[5], w[6], w[7], .5, d);\n                g = w[6];\n                f = w[7];\n              }\n\n              break;\n\n            case Qd:\n              r = Sd(p, e, g, f);\n              q = r.length;\n              u = p.endX;\n              w = p.endY;\n\n              if (0 === q) {\n                d.push(u);\n                d.push(w);\n                g = u;\n                f = w;\n                break;\n              }\n\n              for (u = 0; u < q; u++) {\n                w = r[u], J.De(g, f, w[2], w[3], w[4], w[5], w[6], w[7], .5, d), g = w[6], f = w[7];\n              }\n\n              break;\n\n            default:\n              C(\"Segment not of valid type: \" + p.type);\n          }\n\n          p.isClosed && (d.push(h), d.push(k));\n        }\n\n        4 <= d.length && (b.push(d), c.push(Zd(d)));\n      }\n    }\n  }\n\n  function Zd(a) {\n    for (var b = [], c = 0, d = 0, e = a.length, f = 0; f < e; f += 2) {\n      var g = a[f],\n          h = a[f + 1];\n      0 !== f && b.push(Math.sqrt(Ab(c, d, g, h)));\n      c = g;\n      d = h;\n    }\n\n    return b;\n  }\n\n  t.add = function (a) {\n    this.Yd.add(a);\n    return this;\n  };\n\n  t.Yl = function (a, b, c, d, e, f, g, h) {\n    this._isFrozen && va(this);\n    this.Yf = new N(a, b, e, f).freeze();\n    this.Zf = new N(c, d, g, h).freeze();\n    return this;\n  };\n\n  ma.Object.defineProperties(O.prototype, {\n    _isFrozen: {\n      get: function get() {\n        return 0 !== (this.o & 1);\n      },\n      set: function set(a) {\n        this.o = a ? this.o | 1 : this.o & -2;\n      }\n    },\n    _isInvalidBounds: {\n      get: function get() {\n        return 0 !== (this.o & 2);\n      },\n      set: function set(a) {\n        this.o = a ? this.o | 2 : this.o & -3;\n      }\n    },\n    flattenedSegments: {\n      get: function get() {\n        Wd(this);\n        return this.gk;\n      }\n    },\n    flattenedLengths: {\n      get: function get() {\n        Wd(this);\n        return this.gm;\n      }\n    },\n    flattenedTotalLength: {\n      get: function get() {\n        var a = this.hm;\n\n        if (isNaN(a)) {\n          if (this.type === O.j) {\n            a = Math.abs(this.endX - this.startX);\n            var b = Math.abs(this.endY - this.startY);\n            a = Math.sqrt(a * a + b * b);\n          } else if (this.type === O.u) a = 2 * Math.abs(this.endX - this.startX) + 2 * Math.abs(this.endY - this.startY);else {\n            b = this.flattenedLengths;\n\n            for (var c = b.length, d = a = 0; d < c; d++) {\n              for (var e = b[d], f = e.length, g = 0; g < f; g++) {\n                a += e[g];\n              }\n            }\n          }\n\n          this.hm = a;\n        }\n\n        return a;\n      }\n    },\n    type: {\n      get: function get() {\n        return this.qa;\n      },\n      set: function set(a) {\n        this.qa !== a && (this._isFrozen && va(this, a), this.qa = a, a === O.m ? this.Yd = new E() : (null === O.W && (O.W = new E().freeze()), this.Yd = O.W), this._isInvalidBounds = !0);\n      }\n    },\n    startX: {\n      get: function get() {\n        return this.gd;\n      },\n      set: function set(a) {\n        this.gd !== a && (this._isFrozen && va(this, a), this.gd = a, this._isInvalidBounds = !0);\n      }\n    },\n    startY: {\n      get: function get() {\n        return this.hd;\n      },\n      set: function set(a) {\n        this.hd !== a && (this._isFrozen && va(this, a), this.hd = a, this._isInvalidBounds = !0);\n      }\n    },\n    endX: {\n      get: function get() {\n        return this.xc;\n      },\n      set: function set(a) {\n        this.xc !== a && (this._isFrozen && va(this, a), this.xc = a, this._isInvalidBounds = !0);\n      }\n    },\n    endY: {\n      get: function get() {\n        return this.yc;\n      },\n      set: function set(a) {\n        this.yc !== a && (this._isFrozen && va(this, a), this.yc = a, this._isInvalidBounds = !0);\n      }\n    },\n    figures: {\n      get: function get() {\n        return this.Yd;\n      },\n      set: function set(a) {\n        this.Yd !== a && (this._isFrozen && va(this, a), this.Yd = a, this._isInvalidBounds = !0);\n      }\n    },\n    spot1: {\n      get: function get() {\n        return this.Yf;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.Yf = a.J();\n      }\n    },\n    spot2: {\n      get: function get() {\n        return this.Zf;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.Zf = a.J();\n      }\n    },\n    defaultStretch: {\n      get: function get() {\n        return this.Kf;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.Kf = a;\n      }\n    },\n    bounds: {\n      get: function get() {\n        this.Lu() && this.computeBounds();\n        return this.lp;\n      }\n    }\n  });\n  O.prototype.setSpots = O.prototype.Yl;\n  O.prototype.add = O.prototype.add;\n  O.prototype.getFractionForPoint = O.prototype.Zw;\n  O.prototype.getPointAndAngleAlongPath = O.prototype.Cu;\n  O.prototype.getAngleAlongPath = O.prototype.Yw;\n  O.prototype.getPointAlongPath = O.prototype.Bu;\n  O.prototype.containsPoint = O.prototype.ba;\n  O.prototype.transform = O.prototype.transform;\n  O.prototype.rotate = O.prototype.rotate;\n  O.prototype.scale = O.prototype.scale;\n  O.prototype.offset = O.prototype.offset;\n  O.prototype.normalize = O.prototype.normalize;\n  O.prototype.computeBoundsWithoutOrigin = O.prototype.Lw;\n  O.prototype.equalsApprox = O.prototype.$a;\n  O.className = \"Geometry\";\n  O.j = new D(O, \"Line\", 0);\n  O.u = new D(O, \"Rectangle\", 1);\n  O.F = new D(O, \"Ellipse\", 2);\n  O.m = new D(O, \"Path\", 3);\n  O.W = null;\n  O.cb = \"UuBbMmZzLlHhVvCcSsQqTtAaFfXx\";\n  O.className = \"Geometry\";\n  O.stringify = O.ga;\n  O.fillPath = O.hb;\n  O.parse = O.parse;\n  O.Line = O.j;\n  O.Rectangle = O.u;\n  O.Ellipse = O.F;\n  O.Path = O.m;\n\n  function Xd(a, b, c, d) {\n    Ra(this);\n    void 0 === c && (c = !0);\n    void 0 === d && (d = !0);\n    this.o = 2 | (c ? 4 : 0) | (d ? 8 : 0);\n    void 0 !== a ? this.gd = a : this.gd = 0;\n    void 0 !== b ? this.hd = b : this.hd = 0;\n    this.el = new E();\n    this.Pq = this.el.Ia;\n    this.Kv = null;\n  }\n\n  Xd.prototype.copy = function () {\n    var a = new Xd();\n    a.o = this.o & -2;\n    a.gd = this.gd;\n    a.hd = this.hd;\n\n    for (var b = this.el.s, c = b.length, d = a.el, e = 0; e < c; e++) {\n      var f = b[e].copy();\n      d.add(f);\n    }\n\n    a.Pq = this.Pq;\n    a.Kv = this.Kv;\n    return a;\n  };\n\n  t = Xd.prototype;\n\n  t.$a = function (a) {\n    if (!(a instanceof Xd && J.B(this.startX, a.startX) && J.B(this.startY, a.startY))) return !1;\n    var b = this.segments.s;\n    a = a.segments.s;\n    var c = b.length;\n    if (c !== a.length) return !1;\n\n    for (var d = 0; d < c; d++) {\n      if (!b[d].$a(a[d])) return !1;\n    }\n\n    return !0;\n  };\n\n  t.toString = function (a) {\n    void 0 === a && (a = -1);\n    var b = 0 > a ? \"M\" + this.startX.toString() + \" \" + this.startY.toString() : \"M\" + this.startX.toFixed(a) + \" \" + this.startY.toFixed(a);\n\n    for (var c = this.segments.s, d = c.length, e = 0; e < d; e++) {\n      b += \" \" + c[e].toString(a);\n    }\n\n    return b;\n  };\n\n  t.freeze = function () {\n    this._isFrozen = !0;\n    var a = this.segments;\n    a.freeze();\n    var b = a.s;\n    a = a.length;\n\n    for (var c = 0; c < a; c++) {\n      b[c].freeze();\n    }\n\n    return this;\n  };\n\n  t.ja = function () {\n    this._isFrozen = !1;\n    var a = this.segments;\n    a.ja();\n    a = a.s;\n\n    for (var b = a.length, c = 0; c < b; c++) {\n      a[c].ja();\n    }\n\n    return this;\n  };\n\n  t.Lu = function () {\n    if (this._isInvalidBounds) return !0;\n    var a = this.segments;\n    if (this.Pq !== a.Ia) return !0;\n    a = a.s;\n\n    for (var b = a.length, c = 0; c < b; c++) {\n      if (a[c]._isInvalidBounds) return !0;\n    }\n\n    return !1;\n  };\n\n  t.add = function (a) {\n    this.el.add(a);\n    return this;\n  };\n\n  t.ba = function (a, b, c) {\n    for (var d = this.startX, e = this.startY, f = d, g = e, h = this.segments.s, k = h.length, l = 0; l < k; l++) {\n      var m = h[l];\n\n      switch (m.type) {\n        case Jd:\n          f = m.endX;\n          g = m.endY;\n          d = m.endX;\n          e = m.endY;\n          break;\n\n        case vd:\n          if (J.Tb(d, e, m.endX, m.endY, c, a, b)) return !0;\n          d = m.endX;\n          e = m.endY;\n          break;\n\n        case Kd:\n          if (J.Br(d, e, m.point1X, m.point1Y, m.point2X, m.point2Y, m.endX, m.endY, .5, a, b, c)) return !0;\n          d = m.endX;\n          e = m.endY;\n          break;\n\n        case Ld:\n          if (J.Tu(d, e, m.point1X, m.point1Y, m.endX, m.endY, .5, a, b, c)) return !0;\n          d = m.endX;\n          e = m.endY;\n          break;\n\n        case Md:\n        case Qd:\n          var n = m.type === Md ? Rd(m, this) : Sd(m, this, d, e),\n              p = n.length,\n              r = m.type === Md ? m.centerX : m.endX,\n              q = m.type === Md ? m.centerY : m.endY;\n\n          if (0 === p) {\n            if (J.Tb(d, e, r, q, c, a, b)) return !0;\n            d = r;\n            e = q;\n            break;\n          }\n\n          r = null;\n\n          for (q = 0; q < p; q++) {\n            if (r = n[q], 0 === q && J.Tb(d, e, r[0], r[1], c, a, b) || J.Br(r[0], r[1], r[2], r[3], r[4], r[5], r[6], r[7], .5, a, b, c)) return !0;\n          }\n\n          null !== r && (d = r[6], e = r[7]);\n          break;\n\n        default:\n          C(\"Unknown Segment type: \" + m.type);\n      }\n\n      if (m.isClosed && (d !== f || e !== g) && J.Tb(d, e, f, g, c, a, b)) return !0;\n    }\n\n    return !1;\n  };\n\n  ma.Object.defineProperties(Xd.prototype, {\n    _isFrozen: {\n      get: function get() {\n        return 0 !== (this.o & 1);\n      },\n      set: function set(a) {\n        this.o = a ? this.o | 1 : this.o & -2;\n      }\n    },\n    _isInvalidBounds: {\n      get: function get() {\n        return 0 !== (this.o & 2);\n      },\n      set: function set(a) {\n        this.o = a ? this.o | 2 : this.o & -3;\n      }\n    },\n    isFilled: {\n      get: function get() {\n        return 0 !== (this.o & 4);\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.o = a ? this.o | 4 : this.o & -5;\n      }\n    },\n    isShadowed: {\n      get: function get() {\n        return 0 !== (this.o & 8);\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.o = a ? this.o | 8 : this.o & -9;\n      }\n    },\n    startX: {\n      get: function get() {\n        return this.gd;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.gd = a;\n        this._isInvalidBounds = !0;\n      }\n    },\n    startY: {\n      get: function get() {\n        return this.hd;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.hd = a;\n        this._isInvalidBounds = !0;\n      }\n    },\n    segments: {\n      get: function get() {\n        return this.el;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.el = a;\n        this._isInvalidBounds = !0;\n      }\n    }\n  });\n  Xd.prototype.add = Xd.prototype.add;\n  Xd.prototype.equalsApprox = Xd.prototype.$a;\n  Xd.className = \"PathFigure\";\n\n  function Yd(a, b, c, d, e, f, g, h) {\n    Ra(this);\n    void 0 === a && (a = vd);\n    this.qa = a;\n    this.o = 2;\n    void 0 !== b ? this.xc = b : this.xc = 0;\n    void 0 !== c ? this.yc = c : this.yc = 0;\n    void 0 === d && (d = 0);\n    void 0 === e && (e = 0);\n    void 0 === f && (f = 0);\n    void 0 === g && (g = 0);\n    a === Qd ? (a = f % 360, 0 > a && (a += 360), this.Be = a, this.Oh = 0, this.Ph = Math.max(d, 0), this.Gg = Math.max(e, 0), \"boolean\" === typeof g ? g && (this.isLargeArc = !0) : \"number\" === typeof g && g && (this.isLargeArc = !0), h && (this.isClockwiseArc = !0)) : (this.Be = d, this.Oh = e, a === Md && (f = Math.max(f, 0)), this.Ph = f, \"number\" === typeof g ? (a === Md && (g = Math.max(g, 0)), this.Gg = g) : this.Gg = 0);\n    this.Ud = null;\n  }\n\n  Yd.prototype.copy = function () {\n    var a = new Yd();\n    a.qa = this.qa;\n    a.o = this.o & -2;\n    a.xc = this.xc;\n    a.yc = this.yc;\n    a.Be = this.Be;\n    a.Oh = this.Oh;\n    a.Ph = this.Ph;\n    a.Gg = this.Gg;\n    return a;\n  };\n\n  t = Yd.prototype;\n\n  t.$a = function (a) {\n    if (!(a instanceof Yd) || this.type !== a.type || this.isClosed !== a.isClosed) return !1;\n\n    switch (this.type) {\n      case Jd:\n      case vd:\n        return J.B(this.endX, a.endX) && J.B(this.endY, a.endY);\n\n      case Kd:\n        return J.B(this.endX, a.endX) && J.B(this.endY, a.endY) && J.B(this.point1X, a.point1X) && J.B(this.point1Y, a.point1Y) && J.B(this.point2X, a.point2X) && J.B(this.point2Y, a.point2Y);\n\n      case Ld:\n        return J.B(this.endX, a.endX) && J.B(this.endY, a.endY) && J.B(this.point1X, a.point1X) && J.B(this.point1Y, a.point1Y);\n\n      case Md:\n        return J.B(this.startAngle, a.startAngle) && J.B(this.sweepAngle, a.sweepAngle) && J.B(this.centerX, a.centerX) && J.B(this.centerY, a.centerY) && J.B(this.radiusX, a.radiusX) && J.B(this.radiusY, a.radiusY);\n\n      case Qd:\n        return this.isClockwiseArc === a.isClockwiseArc && this.isLargeArc === a.isLargeArc && J.B(this.xAxisRotation, a.xAxisRotation) && J.B(this.endX, a.endX) && J.B(this.endY, a.endY) && J.B(this.radiusX, a.radiusX) && J.B(this.radiusY, a.radiusY);\n\n      default:\n        return !1;\n    }\n  };\n\n  t.ob = function (a) {\n    a.classType === Yd && (this.type = a);\n  };\n\n  t.toString = function (a) {\n    void 0 === a && (a = -1);\n\n    switch (this.type) {\n      case Jd:\n        a = 0 > a ? \"M\" + this.endX.toString() + \" \" + this.endY.toString() : \"M\" + this.endX.toFixed(a) + \" \" + this.endY.toFixed(a);\n        break;\n\n      case vd:\n        a = 0 > a ? \"L\" + this.endX.toString() + \" \" + this.endY.toString() : \"L\" + this.endX.toFixed(a) + \" \" + this.endY.toFixed(a);\n        break;\n\n      case Kd:\n        a = 0 > a ? \"C\" + this.point1X.toString() + \" \" + this.point1Y.toString() + \" \" + this.point2X.toString() + \" \" + this.point2Y.toString() + \" \" + this.endX.toString() + \" \" + this.endY.toString() : \"C\" + this.point1X.toFixed(a) + \" \" + this.point1Y.toFixed(a) + \" \" + this.point2X.toFixed(a) + \" \" + this.point2Y.toFixed(a) + \" \" + this.endX.toFixed(a) + \" \" + this.endY.toFixed(a);\n        break;\n\n      case Ld:\n        a = 0 > a ? \"Q\" + this.point1X.toString() + \" \" + this.point1Y.toString() + \" \" + this.endX.toString() + \" \" + this.endY.toString() : \"Q\" + this.point1X.toFixed(a) + \" \" + this.point1Y.toFixed(a) + \" \" + this.endX.toFixed(a) + \" \" + this.endY.toFixed(a);\n        break;\n\n      case Md:\n        a = 0 > a ? \"B\" + this.startAngle.toString() + \" \" + this.sweepAngle.toString() + \" \" + this.centerX.toString() + \" \" + this.centerY.toString() + \" \" + this.radiusX.toString() + \" \" + this.radiusY.toString() : \"B\" + this.startAngle.toFixed(a) + \" \" + this.sweepAngle.toFixed(a) + \" \" + this.centerX.toFixed(a) + \" \" + this.centerY.toFixed(a) + \" \" + this.radiusX.toFixed(a) + \" \" + this.radiusY.toFixed(a);\n        break;\n\n      case Qd:\n        a = 0 > a ? \"A\" + this.radiusX.toString() + \" \" + this.radiusY.toString() + \" \" + this.xAxisRotation.toString() + \" \" + (this.isLargeArc ? 1 : 0) + \" \" + (this.isClockwiseArc ? 1 : 0) + \" \" + this.endX.toString() + \" \" + this.endY.toString() : \"A\" + this.radiusX.toFixed(a) + \" \" + this.radiusY.toFixed(a) + \" \" + this.xAxisRotation.toFixed(a) + \" \" + (this.isLargeArc ? 1 : 0) + \" \" + (this.isClockwiseArc ? 1 : 0) + \" \" + this.endX.toFixed(a) + \" \" + this.endY.toFixed(a);\n        break;\n\n      default:\n        a = this.type.toString();\n    }\n\n    return a + (this.isClosed ? \"z\" : \"\");\n  };\n\n  t.freeze = function () {\n    this._isFrozen = !0;\n    return this;\n  };\n\n  t.ja = function () {\n    this._isFrozen = !1;\n    return this;\n  };\n\n  t.close = function () {\n    this.isClosed = !0;\n    return this;\n  };\n\n  function Rd(a, b) {\n    if (null !== a.Ud && !1 === b._isInvalidBounds) return a.Ud;\n    var c = a.radiusX,\n        d = a.radiusY;\n    void 0 === d && (d = c);\n    if (0 === c || 0 === d) return a.Ud = [], a.Ud;\n    b = a.Be;\n    var e = a.Oh,\n        f = J.Mw(0, 0, c < d ? c : d, a.startAngle, a.startAngle + a.sweepAngle, !1);\n\n    if (c !== d) {\n      var g = md.alloc();\n      g.reset();\n      c < d ? g.scale(1, d / c) : g.scale(c / d, 1);\n      O.Ga(f, g);\n      md.free(g);\n    }\n\n    c = f.length;\n\n    for (d = 0; d < c; d++) {\n      g = f[d], g[0] += b, g[1] += e, g[2] += b, g[3] += e, g[4] += b, g[5] += e, g[6] += b, g[7] += e;\n    }\n\n    a.Ud = f;\n    return a.Ud;\n  }\n\n  function Sd(a, b, c, d) {\n    function e(a, b, c, d) {\n      return (a * d < b * c ? -1 : 1) * Math.acos((a * c + b * d) / (Math.sqrt(a * a + b * b) * Math.sqrt(c * c + d * d)));\n    }\n\n    if (null !== a.Ud && !1 === b._isInvalidBounds) return a.Ud;\n    if (0 === a.radiusX || 0 === a.radiusY) return a.Ud = [], a.Ud;\n    b = a.Ph;\n    var f = a.Gg;\n    0 === b && (b = 1E-4);\n    0 === f && (f = 1E-4);\n    var g = Math.PI / 180 * a.Be,\n        h = a.isLargeArc,\n        k = a.isClockwiseArc,\n        l = a.xc,\n        m = a.yc,\n        n = Math.cos(g),\n        p = Math.sin(g),\n        r = n * (c - l) / 2 + p * (d - m) / 2;\n    g = -p * (c - l) / 2 + n * (d - m) / 2;\n    var q = r * r / (b * b) + g * g / (f * f);\n    1 < q && (b *= Math.sqrt(q), f *= Math.sqrt(q));\n    q = (h === k ? -1 : 1) * Math.sqrt((b * b * f * f - b * b * g * g - f * f * r * r) / (b * b * g * g + f * f * r * r));\n    isNaN(q) && (q = 0);\n    h = q * b * g / f;\n    q = q * -f * r / b;\n    isNaN(h) && (h = 0);\n    isNaN(q) && (q = 0);\n    c = (c + l) / 2 + n * h - p * q;\n    d = (d + m) / 2 + p * h + n * q;\n    m = e(1, 0, (r - h) / b, (g - q) / f);\n    n = (r - h) / b;\n    l = (g - q) / f;\n    r = (-r - h) / b;\n    h = (-g - q) / f;\n    g = e(n, l, r, h);\n    r = (n * r + l * h) / (Math.sqrt(n * n + l * l) * Math.sqrt(r * r + h * h));\n    -1 >= r ? g = Math.PI : 1 <= r && (g = 0);\n    !k && 0 < g && (g -= 2 * Math.PI);\n    k && 0 > g && (g += 2 * Math.PI);\n    k = b > f ? 1 : b / f;\n    r = b > f ? f / b : 1;\n    b = J.Mw(0, 0, b > f ? b : f, m, m + g, !0);\n    f = md.alloc();\n    f.reset();\n    f.translate(c, d);\n    f.rotate(a.Be, 0, 0);\n    f.scale(k, r);\n    O.Ga(b, f);\n    md.free(f);\n    a.Ud = b;\n    return a.Ud;\n  }\n\n  ma.Object.defineProperties(Yd.prototype, {\n    _isFrozen: {\n      get: function get() {\n        return 0 !== (this.o & 1);\n      },\n      set: function set(a) {\n        this.o = a ? this.o | 1 : this.o & -2;\n      }\n    },\n    _isInvalidBounds: {\n      get: function get() {\n        return 0 !== (this.o & 2);\n      },\n      set: function set(a) {\n        this.o = a ? this.o | 2 : this.o & -3;\n      }\n    },\n    isClosed: {\n      get: function get() {\n        return 0 !== (this.o & 8);\n      },\n      set: function set(a) {\n        this.isClosed !== a && (this.o = a ? this.o | 8 : this.o & -9, this._isInvalidBounds = !0);\n      }\n    },\n    type: {\n      get: function get() {\n        return this.qa;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.qa = a;\n        this._isInvalidBounds = !0;\n      }\n    },\n    endX: {\n      get: function get() {\n        return this.xc;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.xc = a;\n        this._isInvalidBounds = !0;\n      }\n    },\n    endY: {\n      get: function get() {\n        return this.yc;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.yc = a;\n        this._isInvalidBounds = !0;\n      }\n    },\n    point1X: {\n      get: function get() {\n        return this.Be;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.Be = a;\n        this._isInvalidBounds = !0;\n      }\n    },\n    point1Y: {\n      get: function get() {\n        return this.Oh;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.Oh = a;\n        this._isInvalidBounds = !0;\n      }\n    },\n    point2X: {\n      get: function get() {\n        return this.Ph;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.Ph = a;\n        this._isInvalidBounds = !0;\n      }\n    },\n    point2Y: {\n      get: function get() {\n        return this.Gg;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.Gg = a;\n        this._isInvalidBounds = !0;\n      }\n    },\n    centerX: {\n      get: function get() {\n        return this.Be;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.Be = a;\n        this._isInvalidBounds = !0;\n      }\n    },\n    centerY: {\n      get: function get() {\n        return this.Oh;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.Oh = a;\n        this._isInvalidBounds = !0;\n      }\n    },\n    radiusX: {\n      get: function get() {\n        return this.Ph;\n      },\n      set: function set(a) {\n        0 > a && wa(a, \">= zero\", Yd, \"radiusX\");\n        this._isFrozen && va(this, a);\n        this.Ph = a;\n        this._isInvalidBounds = !0;\n      }\n    },\n    radiusY: {\n      get: function get() {\n        return this.Gg;\n      },\n      set: function set(a) {\n        0 > a && wa(a, \">= zero\", Yd, \"radiusY\");\n        this._isFrozen && va(this, a);\n        this.Gg = a;\n        this._isInvalidBounds = !0;\n      }\n    },\n    startAngle: {\n      get: function get() {\n        return this.xc;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        a %= 360;\n        0 > a && (a += 360);\n        this.xc = a;\n        this._isInvalidBounds = !0;\n      }\n    },\n    sweepAngle: {\n      get: function get() {\n        return this.yc;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        360 < a && (a = 360);\n        -360 > a && (a = -360);\n        this.yc = a;\n        this._isInvalidBounds = !0;\n      }\n    },\n    isClockwiseArc: {\n      get: function get() {\n        return 0 !== (this.o & 4);\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.o = a ? this.o | 4 : this.o & -5;\n        this._isInvalidBounds = !0;\n      }\n    },\n    isLargeArc: {\n      get: function get() {\n        return 0 !== (this.o & 16);\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.o = a ? this.o | 16 : this.o & -17;\n        this._isInvalidBounds = !0;\n      }\n    },\n    xAxisRotation: {\n      get: function get() {\n        return this.Be;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        a %= 360;\n        0 > a && (a += 360);\n        this.Be = a;\n        this._isInvalidBounds = !0;\n      }\n    }\n  });\n  Yd.prototype.equalsApprox = Yd.prototype.$a;\n  var Jd = new D(Yd, \"Move\", 0),\n      vd = new D(Yd, \"Line\", 1),\n      Kd = new D(Yd, \"Bezier\", 2),\n      Ld = new D(Yd, \"QuadraticBezier\", 3),\n      Md = new D(Yd, \"Arc\", 4),\n      Qd = new D(Yd, \"SvgArc\", 4);\n  Yd.className = \"PathSegment\";\n  Yd.Move = Jd;\n  Yd.Line = vd;\n  Yd.Bezier = Kd;\n  Yd.QuadraticBezier = Ld;\n  Yd.Arc = Md;\n  Yd.SvgArc = Qd;\n\n  function $d() {\n    this.H = null;\n    this.cu = new I(0, 0).freeze();\n    this.Os = new I(0, 0).freeze();\n    this.ep = this.qq = 0;\n    this.fp = 1;\n    this.yh = \"\";\n    this.vr = this.xp = !1;\n    this.vp = this.hp = 0;\n    this.og = this.Pp = this.Vp = !1;\n    this.Cp = null;\n    this.qr = 0;\n    this.sd = this.lr = null;\n  }\n\n  $d.prototype.copy = function () {\n    var a = new $d();\n    return this.clone(a);\n  };\n\n  $d.prototype.clone = function (a) {\n    a.H = this.H;\n    a.cu.assign(this.viewPoint);\n    a.Os.assign(this.documentPoint);\n    a.qq = this.qq;\n    a.ep = this.ep;\n    a.fp = this.fp;\n    a.yh = this.yh;\n    a.xp = this.xp;\n    a.vr = this.vr;\n    a.hp = this.hp;\n    a.vp = this.vp;\n    a.Vp = this.Vp;\n    a.Pp = this.Pp;\n    a.og = this.og;\n    a.Cp = this.Cp;\n    a.qr = this.qr;\n    a.lr = this.lr;\n    a.sd = this.sd;\n    return a;\n  };\n\n  $d.prototype.toString = function () {\n    var a = \"^\";\n    0 !== this.modifiers && (a += \"M:\" + this.modifiers);\n    0 !== this.button && (a += \"B:\" + this.button);\n    \"\" !== this.key && (a += \"K:\" + this.key);\n    0 !== this.clickCount && (a += \"C:\" + this.clickCount);\n    0 !== this.delta && (a += \"D:\" + this.delta);\n    this.handled && (a += \"h\");\n    this.bubbles && (a += \"b\");\n    null !== this.documentPoint && (a += \"@\" + this.documentPoint.toString());\n    return a;\n  };\n\n  $d.prototype.vo = function (a, b) {\n    var c = this.diagram;\n    if (null === c) return b;\n    ae(c, this.event, a, b);\n    return b;\n  };\n\n  $d.prototype.iz = function (a, b) {\n    var c = this.diagram;\n    if (null === c) return b;\n    ae(c, this.event, a, b);\n    b.assign(c.rs(b));\n    return b;\n  };\n\n  ma.Object.defineProperties($d.prototype, {\n    diagram: {\n      get: function get() {\n        return this.H;\n      },\n      set: function set(a) {\n        this.H = a;\n      }\n    },\n    viewPoint: {\n      get: function get() {\n        return this.cu;\n      },\n      set: function set(a) {\n        this.cu.assign(a);\n      }\n    },\n    documentPoint: {\n      get: function get() {\n        return this.Os;\n      },\n      set: function set(a) {\n        this.Os.assign(a);\n      }\n    },\n    modifiers: {\n      get: function get() {\n        return this.qq;\n      },\n      set: function set(a) {\n        this.qq = a;\n      }\n    },\n    button: {\n      get: function get() {\n        return this.ep;\n      },\n      set: function set(a) {\n        this.ep = a;\n        if (null === this.event) switch (a) {\n          case 0:\n            this.buttons = 1;\n            break;\n\n          case 1:\n            this.buttons = 4;\n            break;\n\n          case 2:\n            this.buttons = 2;\n        }\n      }\n    },\n    buttons: {\n      get: function get() {\n        return this.fp;\n      },\n      set: function set(a) {\n        this.fp = a;\n      }\n    },\n    key: {\n      get: function get() {\n        return this.yh;\n      },\n      set: function set(a) {\n        this.yh = a;\n      }\n    },\n    down: {\n      get: function get() {\n        return this.xp;\n      },\n      set: function set(a) {\n        this.xp = a;\n      }\n    },\n    up: {\n      get: function get() {\n        return this.vr;\n      },\n      set: function set(a) {\n        this.vr = a;\n      }\n    },\n    clickCount: {\n      get: function get() {\n        return this.hp;\n      },\n      set: function set(a) {\n        this.hp = a;\n      }\n    },\n    delta: {\n      get: function get() {\n        return this.vp;\n      },\n      set: function set(a) {\n        this.vp = a;\n      }\n    },\n    isMultiTouch: {\n      get: function get() {\n        return this.Vp;\n      },\n      set: function set(a) {\n        this.Vp = a;\n      }\n    },\n    handled: {\n      get: function get() {\n        return this.Pp;\n      },\n      set: function set(a) {\n        this.Pp = a;\n      }\n    },\n    bubbles: {\n      get: function get() {\n        return this.og;\n      },\n      set: function set(a) {\n        this.og = a;\n      }\n    },\n    event: {\n      get: function get() {\n        return this.Cp;\n      },\n      set: function set(a) {\n        this.Cp = a;\n      }\n    },\n    isTouchEvent: {\n      get: function get() {\n        var a = x.TouchEvent,\n            b = this.event;\n        return a && b instanceof a ? !0 : (a = x.PointerEvent) && b instanceof a && (\"touch\" === b.pointerType || \"pen\" === b.pointerType);\n      }\n    },\n    timestamp: {\n      get: function get() {\n        return this.qr;\n      },\n      set: function set(a) {\n        this.qr = a;\n      }\n    },\n    targetDiagram: {\n      get: function get() {\n        return this.lr;\n      },\n      set: function set(a) {\n        this.lr = a;\n      }\n    },\n    targetObject: {\n      get: function get() {\n        return this.sd;\n      },\n      set: function set(a) {\n        this.sd = a;\n      }\n    },\n    control: {\n      get: function get() {\n        return 0 !== (this.modifiers & 1);\n      },\n      set: function set(a) {\n        this.modifiers = a ? this.modifiers | 1 : this.modifiers & -2;\n      }\n    },\n    shift: {\n      get: function get() {\n        return 0 !== (this.modifiers & 4);\n      },\n      set: function set(a) {\n        this.modifiers = a ? this.modifiers | 4 : this.modifiers & -5;\n      }\n    },\n    alt: {\n      get: function get() {\n        return 0 !== (this.modifiers & 2);\n      },\n      set: function set(a) {\n        this.modifiers = a ? this.modifiers | 2 : this.modifiers & -3;\n      }\n    },\n    meta: {\n      get: function get() {\n        return 0 !== (this.modifiers & 8);\n      },\n      set: function set(a) {\n        this.modifiers = a ? this.modifiers | 8 : this.modifiers & -9;\n      }\n    },\n    left: {\n      get: function get() {\n        var a = this.event;\n        return null === a || \"mousedown\" !== a.type && \"mouseup\" !== a.type && \"pointerdown\" !== a.type && \"pointerup\" !== a.type ? 0 !== (this.buttons & 1) : 0 === this.button;\n      },\n      set: function set(a) {\n        this.buttons = a ? this.buttons | 1 : this.buttons & -2;\n      }\n    },\n    right: {\n      get: function get() {\n        var a = this.event;\n        return null === a || \"mousedown\" !== a.type && \"mouseup\" !== a.type && \"pointerdown\" !== a.type && \"pointerup\" !== a.type ? 0 !== (this.buttons & 2) : 2 === this.button;\n      },\n      set: function set(a) {\n        this.buttons = a ? this.buttons | 2 : this.buttons & -3;\n      }\n    },\n    middle: {\n      get: function get() {\n        var a = this.event;\n        return null === a || \"mousedown\" !== a.type && \"mouseup\" !== a.type && \"pointerdown\" !== a.type && \"pointerup\" !== a.type ? 0 !== (this.buttons & 4) : 1 === this.button;\n      },\n      set: function set(a) {\n        this.buttons = a ? this.buttons | 4 : this.buttons & -5;\n      }\n    }\n  });\n  $d.prototype.getMultiTouchDocumentPoint = $d.prototype.iz;\n  $d.prototype.getMultiTouchViewPoint = $d.prototype.vo;\n  $d.className = \"InputEvent\";\n\n  function be() {\n    this.H = null;\n    this.va = \"\";\n    this.zq = this.hr = null;\n  }\n\n  be.prototype.copy = function () {\n    var a = new be();\n    a.H = this.H;\n    a.va = this.va;\n    a.hr = this.hr;\n    a.zq = this.zq;\n    return a;\n  };\n\n  be.prototype.toString = function () {\n    var a = \"*\" + this.name;\n    null !== this.subject && (a += \":\" + this.subject.toString());\n    null !== this.parameter && (a += \"(\" + this.parameter.toString() + \")\");\n    return a;\n  };\n\n  ma.Object.defineProperties(be.prototype, {\n    diagram: {\n      get: function get() {\n        return this.H;\n      },\n      set: function set(a) {\n        this.H = a;\n      }\n    },\n    name: {\n      get: function get() {\n        return this.va;\n      },\n      set: function set(a) {\n        this.va = a;\n      }\n    },\n    subject: {\n      get: function get() {\n        return this.hr;\n      },\n      set: function set(a) {\n        this.hr = a;\n      }\n    },\n    parameter: {\n      get: function get() {\n        return this.zq;\n      },\n      set: function set(a) {\n        this.zq = a;\n      }\n    }\n  });\n  be.className = \"DiagramEvent\";\n\n  function ce() {\n    this.nm = de;\n    this.df = this.pq = \"\";\n    this.sn = this.tn = this.yn = this.zn = this.xn = this.H = this.ac = null;\n  }\n\n  ce.prototype.clear = function () {\n    this.sn = this.tn = this.yn = this.zn = this.xn = this.H = this.ac = null;\n  };\n\n  ce.prototype.copy = function () {\n    var a = new ce();\n    a.nm = this.nm;\n    a.pq = this.pq;\n    a.df = this.df;\n    a.ac = this.ac;\n    a.H = this.H;\n    a.xn = this.xn;\n    var b = this.zn;\n    a.zn = ya(b) && \"function\" === typeof b.J ? b.J() : b;\n    b = this.yn;\n    a.yn = ya(b) && \"function\" === typeof b.J ? b.J() : b;\n    b = this.tn;\n    a.tn = ya(b) && \"function\" === typeof b.J ? b.J() : b;\n    b = this.sn;\n    a.sn = ya(b) && \"function\" === typeof b.J ? b.J() : b;\n    return a;\n  };\n\n  ce.prototype.ob = function (a) {\n    a.classType === ce && (this.change = a);\n  };\n\n  ce.prototype.toString = function () {\n    var a = \"\";\n    a = this.change === ee ? a + \"* \" : this.change === de ? a + (null !== this.model ? \"!m\" : \"!d\") : a + ((null !== this.model ? \"!m\" : \"!d\") + this.change);\n    this.propertyName && \"string\" === typeof this.propertyName && (a += \" \" + this.propertyName);\n    this.modelChange && this.modelChange !== this.propertyName && (a += \" \" + this.modelChange);\n    a += \": \";\n    this.change === ee ? null !== this.oldValue && (a += \" \" + this.oldValue) : (null !== this.object && (a += Ia(this.object)), null !== this.oldValue && (a += \"  old: \" + Ia(this.oldValue)), null !== this.oldParam && (a += \" \" + this.oldParam), null !== this.newValue && (a += \"  new: \" + Ia(this.newValue)), null !== this.newParam && (a += \" \" + this.newParam));\n    return a;\n  };\n\n  ce.prototype.I = function (a) {\n    return a ? this.oldValue : this.newValue;\n  };\n\n  ce.prototype.kz = function (a) {\n    return a ? this.oldParam : this.newParam;\n  };\n\n  ce.prototype.canUndo = function () {\n    return null !== this.model || null !== this.diagram ? !0 : !1;\n  };\n\n  ce.prototype.undo = function () {\n    this.canUndo() && (null !== this.model ? this.model.changeState(this, !0) : null !== this.diagram && this.diagram.changeState(this, !0));\n  };\n\n  ce.prototype.canRedo = function () {\n    return null !== this.model || null !== this.diagram ? !0 : !1;\n  };\n\n  ce.prototype.redo = function () {\n    this.canRedo() && (null !== this.model ? this.model.changeState(this, !1) : null !== this.diagram && this.diagram.changeState(this, !1));\n  };\n\n  ma.Object.defineProperties(ce.prototype, {\n    model: {\n      get: function get() {\n        return this.ac;\n      },\n      set: function set(a) {\n        this.ac = a;\n      }\n    },\n    diagram: {\n      get: function get() {\n        return this.H;\n      },\n      set: function set(a) {\n        this.H = a;\n      }\n    },\n    change: {\n      get: function get() {\n        return this.nm;\n      },\n      set: function set(a) {\n        this.nm = a;\n      }\n    },\n    modelChange: {\n      get: function get() {\n        return this.pq;\n      },\n      set: function set(a) {\n        this.pq = a;\n      }\n    },\n    propertyName: {\n      get: function get() {\n        return this.df;\n      },\n      set: function set(a) {\n        this.df = a;\n      }\n    },\n    isTransactionFinished: {\n      get: function get() {\n        return this.nm === ee && (\"CommittedTransaction\" === this.df || \"FinishedUndo\" === this.df || \"FinishedRedo\" === this.df);\n      }\n    },\n    object: {\n      get: function get() {\n        return this.xn;\n      },\n      set: function set(a) {\n        this.xn = a;\n      }\n    },\n    oldValue: {\n      get: function get() {\n        return this.zn;\n      },\n      set: function set(a) {\n        this.zn = a;\n      }\n    },\n    oldParam: {\n      get: function get() {\n        return this.yn;\n      },\n      set: function set(a) {\n        this.yn = a;\n      }\n    },\n    newValue: {\n      get: function get() {\n        return this.tn;\n      },\n      set: function set(a) {\n        this.tn = a;\n      }\n    },\n    newParam: {\n      get: function get() {\n        return this.sn;\n      },\n      set: function set(a) {\n        this.sn = a;\n      }\n    }\n  });\n  ce.prototype.redo = ce.prototype.redo;\n  ce.prototype.canRedo = ce.prototype.canRedo;\n  ce.prototype.undo = ce.prototype.undo;\n  ce.prototype.canUndo = ce.prototype.canUndo;\n  ce.prototype.getParam = ce.prototype.kz;\n  ce.prototype.getValue = ce.prototype.I;\n  ce.prototype.clear = ce.prototype.clear;\n  var ee = new D(ce, \"Transaction\", -1),\n      de = new D(ce, \"Property\", 0),\n      fe = new D(ce, \"Insert\", 1),\n      ge = new D(ce, \"Remove\", 2);\n  ce.className = \"ChangedEvent\";\n  ce.Transaction = ee;\n  ce.Property = de;\n  ce.Insert = fe;\n  ce.Remove = ge;\n\n  function he() {\n    this.m = new E().freeze();\n    this.va = \"\";\n    this.j = !1;\n  }\n\n  he.prototype.toString = function (a) {\n    var b = \"Transaction: \" + this.name + \" \" + this.changes.count.toString() + (this.isComplete ? \"\" : \", incomplete\");\n\n    if (void 0 !== a && 0 < a) {\n      a = this.changes.count;\n\n      for (var c = 0; c < a; c++) {\n        var d = this.changes.K(c);\n        null !== d && (b += \"\\n  \" + d.toString());\n      }\n    }\n\n    return b;\n  };\n\n  he.prototype.clear = function () {\n    var a = this.changes;\n    a.ja();\n\n    for (var b = a.count - 1; 0 <= b; b--) {\n      var c = a.K(b);\n      null !== c && c.clear();\n    }\n\n    a.clear();\n    a.freeze();\n  };\n\n  he.prototype.canUndo = function () {\n    return this.isComplete;\n  };\n\n  he.prototype.undo = function () {\n    if (this.canUndo()) for (var a = this.changes.count - 1; 0 <= a; a--) {\n      var b = this.changes.K(a);\n      null !== b && b.undo();\n    }\n  };\n\n  he.prototype.canRedo = function () {\n    return this.isComplete;\n  };\n\n  he.prototype.redo = function () {\n    if (this.canRedo()) for (var a = this.changes.count, b = 0; b < a; b++) {\n      var c = this.changes.K(b);\n      null !== c && c.redo();\n    }\n  };\n\n  he.prototype.Vj = function () {\n    if (this.isComplete) {\n      var a = this.changes;\n      a.ja();\n\n      for (var b = new pb(), c = 0; c < a.count; c++) {\n        var d = a.K(c);\n\n        if (null !== d && d.change === de && d.object) {\n          var e = b.get(d.object);\n          e || (e = new pb(), b.set(d.object, e));\n          var f = e.get(d.propertyName);\n          null === f ? e.set(d.propertyName, -1) : (0 < f && a.Vc(f, null), e.set(d.propertyName, c));\n        }\n      }\n\n      for (c = b = 0; c < a.count; c++) {\n        d = a.K(c), null !== d && (c > b && a.Vc(b, d), b++);\n      }\n\n      for (; a.length > b;) {\n        a.pop();\n      }\n\n      a.freeze();\n    }\n  };\n\n  ma.Object.defineProperties(he.prototype, {\n    changes: {\n      get: function get() {\n        return this.m;\n      }\n    },\n    name: {\n      get: function get() {\n        return this.va;\n      },\n      set: function set(a) {\n        this.va = a;\n      }\n    },\n    isComplete: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        this.j = a;\n      }\n    }\n  });\n  he.prototype.optimize = he.prototype.Vj;\n  he.prototype.redo = he.prototype.redo;\n  he.prototype.canRedo = he.prototype.canRedo;\n  he.prototype.undo = he.prototype.undo;\n  he.prototype.canUndo = he.prototype.canUndo;\n  he.prototype.clear = he.prototype.clear;\n  he.className = \"Transaction\";\n\n  function ie() {\n    this.ut = new G();\n    this.Ad = !1;\n    this.u = new E().freeze();\n    this.se = -1;\n    this.m = 999;\n    this.ue = !1;\n    this.qp = null;\n    this.Vh = 0;\n    this.j = !1;\n    this.xe = new E().freeze();\n    this.Wk = new E();\n    this.Ws = !0;\n    this.ft = this.Tp = this.it = this.ht = !1;\n  }\n\n  ie.prototype.toString = function (a) {\n    var b = \"UndoManager \" + this.historyIndex + \"<\" + this.history.count + \"<=\" + this.maxHistoryLength;\n    b += \"[\";\n\n    for (var c = this.nestedTransactionNames.count, d = 0; d < c; d++) {\n      0 < d && (b += \" \"), b += this.nestedTransactionNames.K(d);\n    }\n\n    b += \"]\";\n    if (void 0 !== a && 0 < a) for (c = this.history.count, d = 0; d < c; d++) {\n      b += \"\\n \" + this.history.K(d).toString(a - 1);\n    }\n    return b;\n  };\n\n  ie.prototype.clear = function () {\n    var a = this.history;\n    a.ja();\n\n    for (var b = a.count - 1; 0 <= b; b--) {\n      var c = a.K(b);\n      null !== c && c.clear();\n    }\n\n    a.clear();\n    this.se = -1;\n    a.freeze();\n    this.ue = !1;\n    this.qp = null;\n    this.Vh = 0;\n    this.xe.ja();\n    this.xe.clear();\n    this.xe.freeze();\n    this.Wk.clear();\n    this.ft = this.Tp = this.it = this.ht = !1;\n  };\n\n  ie.prototype.copyProperties = function (a) {\n    this.isEnabled = a.isEnabled;\n    this.maxHistoryLength = a.maxHistoryLength;\n    this.checksTransactionLevel = a.checksTransactionLevel;\n  };\n\n  t = ie.prototype;\n\n  t.Bw = function (a) {\n    this.ut.add(a);\n  };\n\n  t.yx = function (a) {\n    this.ut.remove(a);\n  };\n\n  t.Da = function (a) {\n    void 0 === a && (a = \"\");\n    null === a && (a = \"\");\n    if (this.isUndoingRedoing) return !1;\n    !0 === this.Ws && (this.Ws = !1, this.Vh++, this.isInternalTransaction || this.Kb(\"StartingFirstTransaction\", a, this.currentTransaction), 0 < this.Vh && this.Vh--);\n    this.isEnabled && (this.xe.ja(), this.xe.add(a), this.xe.freeze(), null === this.currentTransaction ? this.Wk.add(0) : this.Wk.add(this.currentTransaction.changes.count));\n    this.Vh++;\n    var b = 1 === this.transactionLevel;\n    b && (this.isInternalTransaction || this.Kb(\"StartedTransaction\", a, this.currentTransaction));\n    return b;\n  };\n\n  t.eb = function (a) {\n    void 0 === a && (a = \"\");\n    return je(this, !0, a);\n  };\n\n  t.Bf = function () {\n    return je(this, !1, \"\");\n  };\n\n  function je(a, b, c) {\n    if (a.isUndoingRedoing) return !1;\n    a.checksTransactionLevel && 1 > a.transactionLevel && xa(\"Ending transaction without having started a transaction: \" + c);\n    var d = 1 === a.transactionLevel,\n        e = a.currentTransaction;\n    d && b && (a.isInternalTransaction || a.Kb(\"CommittingTransaction\", c, e));\n    var f = 0;\n\n    if (0 < a.transactionLevel && (a.Vh--, a.isEnabled)) {\n      var g = a.xe.count;\n      0 < g && (\"\" === c && (c = a.xe.K(0)), a.xe.ja(), a.xe.mb(g - 1), a.xe.freeze());\n      g = a.Wk.count;\n      0 < g && (f = a.Wk.K(g - 1), a.Wk.mb(g - 1));\n    }\n\n    if (d) {\n      if (b) {\n        a.Tp = !1;\n        null === e && \"\" !== c && (e = a.currentTransaction);\n\n        if (a.isEnabled && null !== e) {\n          e.isComplete || (e.isComplete = !0, e.name = c);\n          b = a.history;\n          b.ja();\n\n          for (d = b.count - 1; d > a.historyIndex; d--) {\n            f = b.K(d), null !== f && f.clear(), b.mb(d), a.Tp = !0;\n          }\n\n          d = a.maxHistoryLength;\n          0 <= d && (0 === d ? b.clear() : b.count >= d && (f = b.K(0), null !== f && f.clear(), b.mb(0), a.se--));\n          0 === d || 0 !== b.count && b.get(b.count - 1) === e || (b.add(e), a.se++);\n          b.freeze();\n        }\n\n        a.isInternalTransaction || a.Kb(\"CommittedTransaction\", c, e);\n      } else {\n        a.ue = !0;\n\n        try {\n          a.isEnabled && null !== e && (e.isComplete = !0, e.undo());\n        } finally {\n          a.isInternalTransaction || a.Kb(\"RolledBackTransaction\", c, e), a.ue = !1;\n        }\n\n        null !== e && e.clear();\n      }\n\n      a.qp = null;\n      a.isPendingClear && a.clear();\n      a.isPendingClear = !1;\n      a.isPendingUnmodified = !1;\n      return !0;\n    }\n\n    if (a.isEnabled && !b && null !== e) {\n      a = f;\n      c = e.changes;\n\n      for (e = c.count - 1; e >= a; e--) {\n        b = c.K(e), null !== b && b.undo(), c.ja(), c.mb(e);\n      }\n\n      c.freeze();\n    }\n\n    return !1;\n  }\n\n  ie.prototype.canUndo = function () {\n    if (!this.isEnabled || 0 < this.transactionLevel) return !1;\n    var a = this.transactionToUndo;\n    return null !== a && a.canUndo() ? !0 : !1;\n  };\n\n  ie.prototype.undo = function () {\n    if (this.canUndo()) {\n      var a = this.transactionToUndo;\n\n      try {\n        this.ue = !0, this.Kb(\"StartingUndo\", \"Undo\", a), this.se--, a.undo();\n      } catch (b) {\n        xa(\"undo error: \" + b.toString());\n      } finally {\n        this.Kb(\"FinishedUndo\", \"Undo\", a), this.ue = !1;\n      }\n    }\n  };\n\n  ie.prototype.canRedo = function () {\n    if (!this.isEnabled || 0 < this.transactionLevel) return !1;\n    var a = this.transactionToRedo;\n    return null !== a && a.canRedo() ? !0 : !1;\n  };\n\n  ie.prototype.redo = function () {\n    if (this.canRedo()) {\n      var a = this.transactionToRedo;\n\n      try {\n        this.ue = !0, this.Kb(\"StartingRedo\", \"Redo\", a), this.se++, a.redo();\n      } catch (b) {\n        xa(\"redo error: \" + b.toString());\n      } finally {\n        this.Kb(\"FinishedRedo\", \"Redo\", a), this.ue = !1;\n      }\n    }\n  };\n\n  ie.prototype.Kb = function (a, b, c) {\n    void 0 === c && (c = null);\n    var d = new ce();\n    d.change = ee;\n    d.propertyName = a;\n    d.object = c;\n    d.oldValue = b;\n\n    for (a = this.models; a.next();) {\n      b = a.value, d.model = b, b.Cr(d);\n    }\n  };\n\n  ie.prototype.Fu = function (a) {\n    if (this.isEnabled && !this.isUndoingRedoing && !this.skipsEvent(a)) {\n      var b = this.currentTransaction;\n      null === b && (this.qp = b = new he());\n      var c = a.copy();\n      b = b.changes;\n      b.ja();\n      b.add(c);\n      b.freeze();\n      this.checksTransactionLevel && 0 >= this.transactionLevel && !this.Ws && (a = a.diagram, null !== a && !1 === a.ji || xa(\"Change not within a transaction: \" + c.toString()));\n    }\n  };\n\n  ie.prototype.skipsEvent = function (a) {\n    if (null === a || 0 > a.change.value) return !0;\n    a = a.object;\n    if (null === a) return !1;\n\n    if (void 0 !== a.layer) {\n      if (a = a.layer, null !== a && a.isTemporary) return !0;\n    } else if (a.isTemporary) return !0;\n\n    return !1;\n  };\n\n  ma.Object.defineProperties(ie.prototype, {\n    models: {\n      get: function get() {\n        return this.ut.iterator;\n      }\n    },\n    isEnabled: {\n      get: function get() {\n        return this.Ad;\n      },\n      set: function set(a) {\n        this.Ad = a;\n      }\n    },\n    transactionToUndo: {\n      get: function get() {\n        return 0 <= this.historyIndex && this.historyIndex <= this.history.count - 1 ? this.history.K(this.historyIndex) : null;\n      }\n    },\n    transactionToRedo: {\n      get: function get() {\n        return this.historyIndex < this.history.count - 1 ? this.history.K(this.historyIndex + 1) : null;\n      }\n    },\n    isUndoingRedoing: {\n      get: function get() {\n        return this.ue;\n      }\n    },\n    history: {\n      get: function get() {\n        return this.u;\n      }\n    },\n    maxHistoryLength: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        this.m = a;\n      }\n    },\n    historyIndex: {\n      get: function get() {\n        return this.se;\n      }\n    },\n    currentTransaction: {\n      get: function get() {\n        return this.qp;\n      }\n    },\n    transactionLevel: {\n      get: function get() {\n        return this.Vh;\n      }\n    },\n    isInTransaction: {\n      get: function get() {\n        return 0 < this.Vh;\n      }\n    },\n    checksTransactionLevel: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        this.j = a;\n      }\n    },\n    nestedTransactionNames: {\n      get: function get() {\n        return this.xe;\n      }\n    },\n    isPendingClear: {\n      get: function get() {\n        return this.ht;\n      },\n      set: function set(a) {\n        this.ht = a;\n      }\n    },\n    isPendingUnmodified: {\n      get: function get() {\n        return this.it;\n      },\n      set: function set(a) {\n        this.it = a;\n      }\n    },\n    isInternalTransaction: {\n      get: function get() {\n        return this.ft;\n      },\n      set: function set(a) {\n        this.ft = a;\n      }\n    },\n    isJustDiscarded: {\n      get: function get() {\n        return this.Tp;\n      }\n    }\n  });\n  ie.prototype.handleChanged = ie.prototype.Fu;\n  ie.prototype.redo = ie.prototype.redo;\n  ie.prototype.undo = ie.prototype.undo;\n  ie.prototype.canUndo = ie.prototype.canUndo;\n  ie.prototype.rollbackTransaction = ie.prototype.Bf;\n  ie.prototype.commitTransaction = ie.prototype.eb;\n  ie.prototype.startTransaction = ie.prototype.Da;\n  ie.prototype.removeModel = ie.prototype.yx;\n  ie.prototype.addModel = ie.prototype.Bw;\n  ie.prototype.clear = ie.prototype.clear;\n  ie.className = \"UndoManager\";\n\n  function ke() {\n    Ra(this);\n    this.H = le;\n    this.va = \"\";\n    this.Ad = !0;\n    this.hb = !1;\n    this.xi = null;\n    this.gy = new $d();\n    this.yr = -1;\n  }\n\n  ke.prototype.toString = function () {\n    return \"\" !== this.name ? this.name + \" Tool\" : Ha(this.constructor);\n  };\n\n  ke.prototype.updateAdornments = function () {};\n\n  ke.prototype.canStart = function () {\n    return this.isEnabled;\n  };\n\n  ke.prototype.doStart = function () {};\n\n  ke.prototype.doActivate = function () {\n    this.isActive = !0;\n  };\n\n  ke.prototype.doDeactivate = function () {\n    this.isActive = !1;\n  };\n\n  ke.prototype.doStop = function () {};\n\n  ke.prototype.doCancel = function () {\n    this.transactionResult = null;\n    this.stopTool();\n  };\n\n  ke.prototype.stopTool = function () {\n    var a = this.diagram;\n    a.currentTool === this && (a.currentTool = null, a.currentCursor = \"\");\n  };\n\n  ke.prototype.doMouseDown = function () {\n    !this.isActive && this.canStart() && this.doActivate();\n  };\n\n  ke.prototype.doMouseMove = function () {};\n\n  ke.prototype.doMouseUp = function () {\n    this.stopTool();\n  };\n\n  ke.prototype.doMouseWheel = function () {};\n\n  ke.prototype.canStartMultiTouch = function () {\n    return !0;\n  };\n\n  ke.prototype.standardPinchZoomStart = function () {\n    var a = this.diagram,\n        b = a.lastInput,\n        c = b.vo(0, I.allocAt(NaN, NaN)),\n        d = b.vo(1, I.allocAt(NaN, NaN));\n\n    if (c.v() && d.v() && (this.doCancel(), a.yl(\"hasGestureZoom\"))) {\n      a.fw = a.scale;\n      var e = d.x - c.x,\n          f = d.y - c.y;\n      a.nw = Math.sqrt(e * e + f * f);\n      b.bubbles = !1;\n    }\n\n    I.free(c);\n    I.free(d);\n  };\n\n  ke.prototype.standardPinchZoomMove = function () {\n    var a = this.diagram,\n        b = a.lastInput,\n        c = b.vo(0, I.allocAt(NaN, NaN)),\n        d = b.vo(1, I.allocAt(NaN, NaN));\n\n    if (c.v() && d.v() && (this.doCancel(), a.yl(\"hasGestureZoom\"))) {\n      var e = d.x - c.x,\n          f = d.y - c.y;\n      f = Math.sqrt(e * e + f * f) / a.nw;\n      e = new I((Math.min(d.x, c.x) + Math.max(d.x, c.x)) / 2, (Math.min(d.y, c.y) + Math.max(d.y, c.y)) / 2);\n      f *= a.fw;\n      var g = a.commandHandler;\n\n      if (f !== a.scale && g.canResetZoom(f)) {\n        var h = a.zoomPoint;\n        a.zoomPoint = e;\n        g.resetZoom(f);\n        a.zoomPoint = h;\n      }\n\n      b.bubbles = !1;\n    }\n\n    I.free(c);\n    I.free(d);\n  };\n\n  ke.prototype.doKeyDown = function () {\n    \"Esc\" === this.diagram.lastInput.key && this.doCancel();\n  };\n\n  ke.prototype.doKeyUp = function () {};\n\n  ke.prototype.Da = function (a) {\n    void 0 === a && (a = this.name);\n    this.transactionResult = null;\n    return this.diagram.Da(a);\n  };\n\n  ke.prototype.stopTransaction = function () {\n    var a = this.diagram;\n    return null === this.transactionResult ? a.Bf() : a.eb(this.transactionResult);\n  };\n\n  ke.prototype.standardMouseSelect = function () {\n    var a = this.diagram;\n\n    if (a.allowSelect) {\n      var b = a.lastInput,\n          c = a.wl(b.documentPoint, !1);\n      if (null !== c) {\n        if (Qa ? b.meta : b.control) {\n          a.P(\"ChangingSelection\", a.selection);\n\n          for (b = c; null !== b && !b.canSelect();) {\n            b = b.containingGroup;\n          }\n\n          null !== b && (b.isSelected = !b.isSelected);\n          a.P(\"ChangedSelection\", a.selection);\n        } else if (b.shift) {\n          if (!c.isSelected) {\n            a.P(\"ChangingSelection\", a.selection);\n\n            for (b = c; null !== b && !b.canSelect();) {\n              b = b.containingGroup;\n            }\n\n            null !== b && (b.isSelected = !0);\n            a.P(\"ChangedSelection\", a.selection);\n          }\n        } else {\n          if (!c.isSelected) {\n            for (b = c; null !== b && !b.canSelect();) {\n              b = b.containingGroup;\n            }\n\n            null !== b && a.select(b);\n          }\n        }\n      } else !b.left || (Qa ? b.meta : b.control) || b.shift || a.clearSelection();\n    }\n  };\n\n  ke.prototype.standardMouseClick = function (a, b) {\n    void 0 === a && (a = null);\n    void 0 === b && (b = function b(a) {\n      return !a.layer.isTemporary;\n    });\n    var c = this.diagram,\n        d = c.lastInput;\n    a = c.ec(d.documentPoint, a, b);\n    d.targetObject = a;\n    re(a, d, c);\n    return d.handled;\n  };\n\n  function re(a, b, c) {\n    b.handled = !1;\n\n    if (null === a || a.yf()) {\n      var d = 0;\n      b.left ? d = 1 === b.clickCount ? 1 : 2 === b.clickCount ? 2 : 1 : b.right && 1 === b.clickCount && (d = 3);\n      var e = \"ObjectSingleClicked\";\n\n      if (null !== a) {\n        switch (d) {\n          case 1:\n            e = \"ObjectSingleClicked\";\n            break;\n\n          case 2:\n            e = \"ObjectDoubleClicked\";\n            break;\n\n          case 3:\n            e = \"ObjectContextClicked\";\n        }\n\n        0 !== d && c.P(e, a);\n      } else {\n        switch (d) {\n          case 1:\n            e = \"BackgroundSingleClicked\";\n            break;\n\n          case 2:\n            e = \"BackgroundDoubleClicked\";\n            break;\n\n          case 3:\n            e = \"BackgroundContextClicked\";\n        }\n\n        0 !== d && c.P(e);\n      }\n\n      if (null !== a) for (; null !== a;) {\n        c = null;\n\n        switch (d) {\n          case 1:\n            c = a.click;\n            break;\n\n          case 2:\n            c = a.doubleClick ? a.doubleClick : a.click;\n            break;\n\n          case 3:\n            c = a.contextClick;\n        }\n\n        if (null !== c && (c(b, a), b.handled)) break;\n        a = a.panel;\n      } else {\n        a = null;\n\n        switch (d) {\n          case 1:\n            a = c.click;\n            break;\n\n          case 2:\n            a = c.doubleClick ? c.doubleClick : c.click;\n            break;\n\n          case 3:\n            a = c.contextClick;\n        }\n\n        null !== a && a(b);\n      }\n    }\n  }\n\n  ke.prototype.standardMouseOver = function () {\n    var a = this.diagram,\n        b = a.lastInput;\n\n    if (!0 !== a.animationManager.zb) {\n      var c = a.skipsUndoManager;\n      a.skipsUndoManager = !0;\n      var d = a.viewportBounds.ba(b.documentPoint) ? a.ec(b.documentPoint, null, null) : null;\n      b.targetObject = d;\n      var e = !1;\n\n      if (d !== a.qk) {\n        var f = a.qk,\n            g = f;\n        a.qk = d;\n        this.doCurrentObjectChanged(f, d);\n\n        for (b.handled = !1; null !== f;) {\n          var h = f.mouseLeave;\n\n          if (null !== h) {\n            if (d === f) break;\n            if (null !== d && d.jg(f)) break;\n            h(b, f, d);\n            e = !0;\n            if (b.handled) break;\n          }\n\n          f = f.panel;\n        }\n\n        f = g;\n\n        for (b.handled = !1; null !== d;) {\n          g = d.mouseEnter;\n\n          if (null !== g) {\n            if (f === d) break;\n            if (null !== f && f.jg(d)) break;\n            g(b, d, f);\n            e = !0;\n            if (b.handled) break;\n          }\n\n          d = d.panel;\n        }\n\n        d = a.qk;\n      }\n\n      if (null !== d) {\n        f = d;\n\n        for (g = \"\"; null !== f;) {\n          g = f.cursor;\n          if (\"\" !== g) break;\n          f = f.panel;\n        }\n\n        a.currentCursor = g;\n        b.handled = !1;\n\n        for (f = d; null !== f;) {\n          d = f.mouseOver;\n          if (null !== d && (d(b, f), e = !0, b.handled)) break;\n          f = f.panel;\n        }\n      } else a.currentCursor = \"\", d = a.mouseOver, null !== d && (d(b), e = !0);\n\n      e && a.Mb();\n      a.skipsUndoManager = c;\n    }\n  };\n\n  ke.prototype.doCurrentObjectChanged = function () {};\n\n  ke.prototype.standardMouseWheel = function () {\n    var a = this.diagram,\n        b = a.lastInput,\n        c = b.delta;\n\n    if (0 !== c && a.documentBounds.v()) {\n      var d = a.commandHandler,\n          e = a.toolManager.mouseWheelBehavior;\n\n      if (null !== d && (e === se && !b.shift || e === te && b.control)) {\n        if (0 < c ? d.canIncreaseZoom() : d.canDecreaseZoom()) e = a.zoomPoint, a.zoomPoint = b.viewPoint, 0 < c ? d.increaseZoom() : d.decreaseZoom(), a.zoomPoint = e;\n        b.bubbles = !1;\n      } else if (e === se && b.shift || e === te && !b.control) {\n        d = a.position.copy();\n        var f = 0 < c ? c : -c,\n            g = b.event,\n            h = g.deltaMode;\n        e = g.deltaX;\n        g = g.deltaY;\n        if (Na || Pa) h = 1, 0 < e && (e = 3), 0 > e && (e = -3), 0 < g && (g = 3), 0 > g && (g = -3);\n        if (void 0 === h || void 0 === e || void 0 === g || 0 === e && 0 === g || b.shift) !b.shift && a.allowVerticalScroll ? (f = 3 * f * a.scrollVerticalLineChange, 0 < c ? a.scroll(\"pixel\", \"up\", f) : a.scroll(\"pixel\", \"down\", f)) : b.shift && a.allowHorizontalScroll && (f = 3 * f * a.scrollHorizontalLineChange, 0 < c ? a.scroll(\"pixel\", \"left\", f) : a.scroll(\"pixel\", \"right\", f));else {\n          switch (h) {\n            case 0:\n              c = \"pixel\";\n              break;\n\n            case 1:\n              c = \"line\";\n              break;\n\n            case 2:\n              c = \"page\";\n              break;\n\n            default:\n              c = \"pixel\";\n          }\n\n          0 !== e && a.allowHorizontalScroll && (e *= a.scrollHorizontalLineChange / 16, 0 < e ? a.scroll(c, \"left\", -e) : a.scroll(c, \"right\", e));\n          0 !== g && a.allowVerticalScroll && (g *= a.scrollVerticalLineChange / 16, 0 < g ? a.scroll(c, \"up\", -g) : a.scroll(c, \"down\", g));\n        }\n        a.position.C(d) || (b.bubbles = !1);\n      }\n    }\n  };\n\n  ke.prototype.standardWaitAfter = function (a, b) {\n    void 0 === b && (b = this.diagram.lastInput);\n    this.cancelWaitAfter();\n    var c = this,\n        d = b.clone(this.gy);\n    this.yr = ta(function () {\n      c.doWaitAfter(d);\n    }, a);\n  };\n\n  ke.prototype.cancelWaitAfter = function () {\n    -1 !== this.yr && x.clearTimeout(this.yr);\n    this.yr = -1;\n  };\n\n  ke.prototype.doWaitAfter = function () {};\n\n  ke.prototype.findToolHandleAt = function (a, b) {\n    a = this.diagram.ec(a, function (a) {\n      for (; null !== a && !(a.panel instanceof ue);) {\n        a = a.panel;\n      }\n\n      return a;\n    });\n    return null === a ? null : a.part.category === b ? a : null;\n  };\n\n  ke.prototype.isBeyondDragSize = function (a, b) {\n    var c = this.diagram;\n    void 0 === a && (a = c.firstInput.viewPoint);\n    void 0 === b && (b = c.lastInput.viewPoint);\n    var d = c.toolManager.dragSize,\n        e = d.width;\n    d = d.height;\n    c.firstInput.isTouchEvent && (e += 6, d += 6);\n    return Math.abs(b.x - a.x) > e || Math.abs(b.y - a.y) > d;\n  };\n\n  ma.Object.defineProperties(ke.prototype, {\n    diagram: {\n      get: function get() {\n        return this.H;\n      },\n      set: function set(a) {\n        a instanceof Q && (this.H = a);\n      }\n    },\n    name: {\n      get: function get() {\n        return this.va;\n      },\n      set: function set(a) {\n        this.va = a;\n      }\n    },\n    isEnabled: {\n      get: function get() {\n        return this.Ad;\n      },\n      set: function set(a) {\n        this.Ad = a;\n      }\n    },\n    isActive: {\n      get: function get() {\n        return this.hb;\n      },\n      set: function set(a) {\n        this.hb = a;\n      }\n    },\n    transactionResult: {\n      get: function get() {\n        return this.xi;\n      },\n      set: function set(a) {\n        this.xi = a;\n      }\n    }\n  });\n  ke.prototype.startTransaction = ke.prototype.Da;\n  ke.className = \"Tool\";\n\n  function La() {\n    ke.call(this);\n    this.name = \"ToolManager\";\n    this.cb = new E();\n    this.nb = new E();\n    this.Db = new E();\n    this.F = this.W = 850;\n    this.m = new K(2, 2).ha();\n    this.Ga = 5E3;\n    this.ga = te;\n    this.u = ve;\n    this.pp = this.j = null;\n    this.uj = -1;\n  }\n\n  la(La, ke);\n\n  La.prototype.initializeStandardTools = function () {};\n\n  La.prototype.updateAdornments = function (a) {\n    var b = this.currentToolTip;\n\n    if (b instanceof ue && this.pp === a) {\n      var c = b.adornedObject;\n      (null !== a ? c.part === a : null === c) ? this.showToolTip(b, c) : this.hideToolTip();\n    }\n  };\n\n  La.prototype.doMouseDown = function () {\n    var a = this.diagram,\n        b = a.lastInput;\n    b.isTouchEvent && this.gestureBehavior === we && (b.bubbles = !1);\n\n    if (b.isMultiTouch) {\n      this.cancelWaitAfter();\n\n      if (this.gestureBehavior === xe) {\n        b.bubbles = !0;\n        return;\n      }\n\n      if (this.gestureBehavior === we) return;\n\n      if (a.currentTool.canStartMultiTouch()) {\n        a.currentTool.standardPinchZoomStart();\n        return;\n      }\n    }\n\n    for (var c = this.mouseDownTools.length, d = 0; d < c; d++) {\n      var e = this.mouseDownTools.K(d);\n      e.diagram = this.diagram;\n\n      if (e.canStart()) {\n        a.doFocus();\n        a.currentTool = e;\n        a.currentTool === e && (e.isActive || e.doActivate(), e.doMouseDown());\n        return;\n      }\n    }\n\n    1 === a.lastInput.button && (this.mouseWheelBehavior === te ? this.mouseWheelBehavior = se : this.mouseWheelBehavior === se && (this.mouseWheelBehavior = te));\n    this.doActivate();\n    this.standardWaitAfter(this.holdDelay, b);\n  };\n\n  La.prototype.doMouseMove = function () {\n    var a = this.diagram,\n        b = a.lastInput;\n\n    if (b.isMultiTouch) {\n      if (this.gestureBehavior === xe) {\n        b.bubbles = !0;\n        return;\n      }\n\n      if (this.gestureBehavior === we) return;\n\n      if (a.currentTool.canStartMultiTouch()) {\n        a.currentTool.standardPinchZoomMove();\n        return;\n      }\n    }\n\n    if (this.isActive) for (var c = this.mouseMoveTools.length, d = 0; d < c; d++) {\n      var e = this.mouseMoveTools.K(d);\n      e.diagram = this.diagram;\n\n      if (e.canStart()) {\n        a.doFocus();\n        a.currentTool = e;\n        a.currentTool === e && (e.isActive || e.doActivate(), e.doMouseMove());\n        return;\n      }\n    }\n    ye(this, a);\n    a = b.event;\n    null === a || \"pointermove\" !== a.type && a.cancelable || (b.bubbles = !0);\n  };\n\n  function ye(a, b) {\n    a.standardMouseOver();\n    a.isBeyondDragSize() && a.standardWaitAfter(a.isActive ? a.holdDelay : a.hoverDelay, b.lastInput);\n  }\n\n  La.prototype.doCurrentObjectChanged = function (a, b) {\n    a = this.currentToolTip;\n    null === a || null !== b && a instanceof ue && (b === a || b.jg(a)) || this.hideToolTip();\n  };\n\n  La.prototype.doWaitAfter = function (a) {\n    var b = this.diagram;\n    b.Ha && (this.doMouseHover(), this.isActive || this.doToolTip(), a.isTouchEvent && !b.lastInput.handled && (a = a.copy(), a.button = 2, a.buttons = 2, b.lastInput = a, b.Wt = !0, b.doMouseUp()));\n  };\n\n  La.prototype.doMouseHover = function () {\n    var a = this.diagram,\n        b = a.lastInput;\n    null === b.targetObject && (b.targetObject = a.ec(b.documentPoint, null, null));\n    var c = b.targetObject;\n    if (null !== c) for (b.handled = !1; null !== c;) {\n      a = this.isActive ? c.mouseHold : c.mouseHover;\n      if (null !== a && (a(b, c), b.handled)) break;\n      c = c.panel;\n    } else c = this.isActive ? a.mouseHold : a.mouseHover, null !== c && c(b);\n  };\n\n  La.prototype.doToolTip = function () {\n    var a = this.diagram,\n        b = a.lastInput;\n    null === b.targetObject && (b.targetObject = a.ec(b.documentPoint, null, null));\n    b = b.targetObject;\n\n    if (null !== b) {\n      if (a = this.currentToolTip, !(a instanceof ue) || b !== a && !b.jg(a)) {\n        for (; null !== b;) {\n          a = b.toolTip;\n\n          if (null !== a) {\n            this.showToolTip(a, b);\n            return;\n          }\n\n          b = b.panel;\n        }\n\n        this.hideToolTip();\n      }\n    } else b = a.toolTip, null !== b ? this.showToolTip(b, null) : this.hideToolTip();\n  };\n\n  La.prototype.showToolTip = function (a, b) {\n    var c = this.diagram;\n    a !== this.currentToolTip && this.hideToolTip();\n\n    if (a instanceof ue) {\n      a.layerName = \"Tool\";\n      a.selectable = !1;\n      a.scale = 1 / c.scale;\n      a.category = \"ToolTip\";\n      null !== a.placeholder && (a.placeholder.scale = c.scale);\n      var d = a.diagram;\n      null !== d && d !== c && d.remove(a);\n      c.add(a);\n      null !== b ? a.adornedObject = b : a.data = c.model;\n      a.Za();\n      this.positionToolTip(a, b);\n    } else a instanceof ze && a !== this.currentToolTip && a.show(b, c, this);\n\n    this.currentToolTip = a;\n    -1 !== this.uj && (x.clearTimeout(this.uj), this.uj = -1);\n    a = this.toolTipDuration;\n\n    if (0 < a && Infinity !== a) {\n      var e = this;\n      this.uj = ta(function () {\n        e.hideToolTip();\n      }, a);\n    }\n  };\n\n  La.prototype.positionToolTip = function (a) {\n    if (null === a.placeholder) {\n      var b = this.diagram,\n          c = b.lastInput.documentPoint.copy(),\n          d = a.measuredBounds,\n          e = b.viewportBounds;\n      b.lastInput.isTouchEvent && (c.x -= d.width);\n      c.x + d.width > e.right && (c.x -= d.width + 5 / b.scale);\n      c.x < e.x && (c.x = e.x);\n      c.y = c.y + 20 / b.scale + d.height > e.bottom ? c.y - (d.height + 5 / b.scale) : c.y + 20 / b.scale;\n      c.y < e.y && (c.y = e.y);\n      a.position = c;\n    }\n  };\n\n  La.prototype.hideToolTip = function () {\n    -1 !== this.uj && (x.clearTimeout(this.uj), this.uj = -1);\n    var a = this.diagram,\n        b = this.currentToolTip;\n    null !== b && (b instanceof ue ? (a.remove(b), null !== this.pp && this.pp.Af(b.category), b.data = null, b.adornedObject = null) : b instanceof ze && null !== b.hide && b.hide(a, this), this.currentToolTip = null);\n  };\n\n  La.prototype.doMouseUp = function () {\n    this.cancelWaitAfter();\n    var a = this.diagram;\n    if (this.isActive) for (var b = this.mouseUpTools.length, c = 0; c < b; c++) {\n      var d = this.mouseUpTools.K(c);\n      d.diagram = this.diagram;\n\n      if (d.canStart()) {\n        a.doFocus();\n        a.currentTool = d;\n        a.currentTool === d && (d.isActive || d.doActivate(), d.doMouseUp());\n        return;\n      }\n    }\n    a.doFocus();\n    this.doDeactivate();\n  };\n\n  La.prototype.doMouseWheel = function () {\n    this.standardMouseWheel();\n  };\n\n  La.prototype.doKeyDown = function () {\n    var a = this.diagram;\n    null !== a.commandHandler && a.commandHandler.doKeyDown();\n  };\n\n  La.prototype.doKeyUp = function () {\n    var a = this.diagram;\n    null !== a.commandHandler && a.commandHandler.doKeyUp();\n  };\n\n  La.prototype.findTool = function (a) {\n    for (var b = this.mouseDownTools.length, c = 0; c < b; c++) {\n      var d = this.mouseDownTools.K(c);\n      if (d.name === a) return d;\n    }\n\n    b = this.mouseMoveTools.length;\n\n    for (c = 0; c < b; c++) {\n      if (d = this.mouseMoveTools.K(c), d.name === a) return d;\n    }\n\n    b = this.mouseUpTools.length;\n\n    for (c = 0; c < b; c++) {\n      if (d = this.mouseUpTools.K(c), d.name === a) return d;\n    }\n\n    return null;\n  };\n\n  La.prototype.replaceTool = function (a, b) {\n    null !== b && (b.diagram = this.diagram);\n\n    for (var c = this.mouseDownTools.length, d = 0; d < c; d++) {\n      var e = this.mouseDownTools.K(d);\n      if (e.name === a) return null !== b ? this.mouseDownTools.Vc(d, b) : this.mouseDownTools.mb(d), e;\n    }\n\n    c = this.mouseMoveTools.length;\n\n    for (d = 0; d < c; d++) {\n      if (e = this.mouseMoveTools.K(d), e.name === a) return null !== b ? this.mouseMoveTools.Vc(d, b) : this.mouseMoveTools.mb(d), e;\n    }\n\n    c = this.mouseUpTools.length;\n\n    for (d = 0; d < c; d++) {\n      if (e = this.mouseUpTools.K(d), e.name === a) return null !== b ? this.mouseUpTools.Vc(d, b) : this.mouseUpTools.mb(d), e;\n    }\n\n    return null;\n  };\n\n  La.prototype.gb = function (a, b, c) {\n    null !== b && (b.name = a, b.diagram = this.diagram);\n    this.findTool(a) ? this.replaceTool(a, b) : null !== b && c.add(b);\n  };\n\n  ma.Object.defineProperties(La.prototype, {\n    mouseWheelBehavior: {\n      get: function get() {\n        return this.ga;\n      },\n      set: function set(a) {\n        this.ga = a;\n      }\n    },\n    gestureBehavior: {\n      get: function get() {\n        return this.u;\n      },\n      set: function set(a) {\n        this.u = a;\n      }\n    },\n    currentToolTip: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        this.j = a;\n        this.pp = null !== a && a instanceof ue ? a.adornedPart : null;\n      }\n    },\n    mouseDownTools: {\n      get: function get() {\n        return this.cb;\n      }\n    },\n    mouseMoveTools: {\n      get: function get() {\n        return this.nb;\n      }\n    },\n    mouseUpTools: {\n      get: function get() {\n        return this.Db;\n      }\n    },\n    hoverDelay: {\n      get: function get() {\n        return this.W;\n      },\n      set: function set(a) {\n        this.W = a;\n      }\n    },\n    holdDelay: {\n      get: function get() {\n        return this.F;\n      },\n      set: function set(a) {\n        this.F = a;\n      }\n    },\n    dragSize: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        this.m = a.J();\n      }\n    },\n    toolTipDuration: {\n      get: function get() {\n        return this.Ga;\n      },\n      set: function set(a) {\n        this.Ga = a;\n      }\n    }\n  });\n  La.prototype.replaceStandardTool = La.prototype.gb;\n  var te = new D(La, \"WheelScroll\", 0),\n      se = new D(La, \"WheelZoom\", 1),\n      Ae = new D(La, \"WheelNone\", 2),\n      ve = new D(La, \"GestureZoom\", 3),\n      we = new D(La, \"GestureCancel\", 4),\n      xe = new D(La, \"GestureNone\", 5);\n  La.className = \"ToolManager\";\n  La.WheelScroll = te;\n  La.WheelZoom = se;\n  La.WheelNone = Ae;\n  La.GestureZoom = ve;\n  La.GestureCancel = we;\n  La.GestureNone = xe;\n\n  function Be() {\n    ke.call(this);\n    this.name = \"Dragging\";\n    this.u = this.ww = this.nb = !0;\n    this.m = this.Ga = this.W = this.Ce = null;\n    this.Gm = this.Db = !1;\n    this.il = new I(NaN, NaN);\n    this.br = new I();\n    this.cb = !0;\n    this.wk = 100;\n    this.tg = [];\n    this.le = new G().freeze();\n    this.ga = new Ce();\n    this.hn = null;\n    this.F = \"copy\";\n    this.Hc = \"\";\n    this.Ic = \"no-drop\";\n  }\n\n  var De;\n  la(Be, ke);\n\n  Be.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    if (a.isReadOnly && !a.allowDragOut || !a.allowMove && !a.allowCopy && !a.allowDragOut || !a.allowSelect) return !1;\n    var b = a.lastInput;\n    return !b.left || a.currentTool !== this && (!this.isBeyondDragSize() || b.isTouchEvent && b.timestamp - a.firstInput.timestamp < this.wk) ? !1 : null !== this.findDraggablePart();\n  };\n\n  Be.prototype.findDraggablePart = function () {\n    var a = this.diagram;\n    a = a.wl(a.firstInput.documentPoint, !1);\n    if (null === a) return null;\n\n    for (; null !== a && !a.canSelect();) {\n      a = a.containingGroup;\n    }\n\n    return null !== a && (a.canMove() || a.canCopy()) ? a : null;\n  };\n\n  Be.prototype.standardMouseSelect = function () {\n    var a = this.diagram;\n\n    if (a.allowSelect) {\n      var b = a.wl(a.firstInput.documentPoint, !1);\n\n      if (null !== b) {\n        for (; null !== b && !b.canSelect();) {\n          b = b.containingGroup;\n        }\n\n        this.currentPart = b;\n        null === this.currentPart || this.currentPart.isSelected || (a.P(\"ChangingSelection\", a.selection), b = a.lastInput, (Qa ? b.meta : b.control) || b.shift || a.clearSelection(!0), this.currentPart.isSelected = !0, a.P(\"ChangedSelection\", a.selection));\n      }\n    }\n  };\n\n  Be.prototype.doActivate = function () {\n    var a = this.diagram;\n    this.hn = null;\n    null === this.currentPart && this.standardMouseSelect();\n    var b = this.currentPart;\n    null !== b && (b.canMove() || b.canCopy()) && (a.lu(!0), Ee = null, this.isActive = !0, this.il.set(a.position), Fe(this, a.selection), this.tg.length = 0, a.animationManager.wc(), this.draggedParts = this.computeEffectiveCollection(a.selection, this.dragOptions), this.ww = this.diagram.layout.isRealtime, this.diagram.layout.isRealtime = !1, a.os = !0, !0 === a.Ge(\"temporaryPixelRatio\") && 30 < a.Ew && Ge(a), He(a, this.draggedParts), this.Da(\"Drag\"), this.startPoint = a.firstInput.documentPoint, a.isMouseCaptured = !0, a.allowDragOut && (this.isDragOutStarted = !0, this.Gm = !1, Ee = this, Ie = this.diagram, this.doSimulatedDragOut()));\n  };\n\n  function Fe(a, b) {\n    if (a.dragsLink) {\n      var c = a.diagram;\n      c.allowRelink && (c.model.Nj() && 1 === b.count && b.first() instanceof T ? (a.draggedLink = b.first(), a.draggedLink.canRelinkFrom() && a.draggedLink.canRelinkTo() && a.draggedLink.zj(), a.Ce = c.toolManager.findTool(\"Relinking\"), null === a.Ce && (a.Ce = new Se(), a.Ce.diagram = c), a.Ce.originalLink = a.draggedLink) : (a.draggedLink = null, a.Ce = null));\n    }\n  }\n\n  Be.prototype.computeEffectiveCollection = function (a, b) {\n    return this.diagram.commandHandler.computeEffectiveCollection(a, b);\n  };\n\n  Be.prototype.Fd = function (a) {\n    return void 0 === a ? new Te(qb) : this.isGridSnapEnabled ? new Te(new I(Math.round(1E3 * a.x) / 1E3, Math.round(1E3 * a.y) / 1E3)) : new Te(a.copy());\n  };\n\n  Be.prototype.doDeactivate = function () {\n    this.isActive = !1;\n    var a = this.diagram;\n    this.diagram.layout.isRealtime = this.ww;\n    a.lu(!1);\n    a.lg();\n    Ue(this);\n    Ve(a, this.draggedParts);\n    this.draggedParts = this.currentPart = this.hn = null;\n    this.Gm = this.isDragOutStarted = !1;\n\n    if (0 < De.count) {\n      for (var b = De, c = b.length, d = 0; d < c; d++) {\n        var e = b.K(d);\n        We(e);\n        Xe(e);\n        Ue(e);\n        e.diagram.lg();\n      }\n\n      b.clear();\n    }\n\n    We(this);\n    this.il.h(NaN, NaN);\n    null !== Ie && (Ie.currentCursor = \"\");\n    Ee = Ie = null;\n    Xe(this);\n    a.isMouseCaptured = !1;\n    a.currentCursor = \"\";\n    a.os = !1;\n    this.stopTransaction();\n    Ye(a, !0);\n  };\n\n  Be.prototype.stopTransaction = function () {\n    var a = this.diagram,\n        b = ke.prototype.stopTransaction.call(this);\n    b && null !== a.undoManager.transactionToUndo && a.undoManager.transactionToUndo.Vj();\n    return b;\n  };\n\n  function Ue(a) {\n    var b = a.diagram,\n        c = b.skipsUndoManager;\n    b.skipsUndoManager = !0;\n    Ze(a, b.lastInput, null);\n    b.skipsUndoManager = c;\n    a.tg.length = 0;\n  }\n\n  function $e() {\n    var a = Ee;\n    Xe(a);\n    af(a);\n    var b = a.diagram;\n    a.il.v() && (b.position = a.il);\n    b.lg();\n  }\n\n  Be.prototype.doCancel = function () {\n    Xe(this);\n    af(this);\n    var a = this.diagram;\n    this.il.v() && (a.position = this.il);\n    this.stopTool();\n  };\n\n  Be.prototype.doKeyDown = function () {\n    var a = this.diagram,\n        b = a.lastInput;\n    this.isActive && (\"Esc\" === b.key ? this.doCancel() : b.key !== a.previousInput.key && this.doMouseMove());\n  };\n\n  Be.prototype.doKeyUp = function () {\n    this.isActive && this.doMouseMove();\n  };\n\n  function bf(a, b) {\n    if (null === a.copiedParts) {\n      var c = a.diagram;\n\n      if ((!b || !c.isReadOnly && !c.isModelReadOnly) && null !== a.draggedParts) {\n        var d = c.undoManager;\n        d.isEnabled && d.isInTransaction ? null !== d.currentTransaction && 0 < d.currentTransaction.changes.count && (c.undoManager.Bf(), c.Da(\"Drag\")) : af(a);\n        c.skipsUndoManager = !b;\n        c.partManager.addsToTemporaryLayer = !b;\n        a.startPoint = c.firstInput.documentPoint;\n        b = a.copiesEffectiveCollection ? a.draggedParts.Cf() : c.selection;\n        b = c.Ej(b, c, !0);\n        c = new pb();\n\n        for (d = a.draggedParts.iterator; d.next();) {\n          var e = d.key;\n\n          if (e.Tc() && e.canCopy()) {\n            var f = b.I(e);\n            null !== f && (f.location = e.location, f.Za(), c.add(f, a.Fd(f.location)));\n          }\n        }\n\n        for (b = b.iterator; b.next();) {\n          d = b.value, d instanceof T && d.canCopy() && c.add(d, a.Fd());\n        }\n\n        a.copiedParts = c;\n        Fe(a, c.Cf());\n        null !== a.draggedLink && (c = a.draggedLink, b = c.routeBounds, cf(c, a.startPoint.x - (b.x + b.width / 2), a.startPoint.y - (b.y + b.height / 2)));\n        a.doUpdateCursor(null, !0);\n      }\n    }\n  }\n\n  function Xe(a) {\n    var b = a.diagram;\n\n    if (null !== a.copiedParts) {\n      b.hs(a.copiedParts.Cf(), !1);\n      a.copiedParts = null;\n      if (null !== a.draggedParts) for (var c = a.draggedParts.iterator; c.next();) {\n        c.key instanceof T && (c.value.point = new I(0, 0));\n      }\n      a.doUpdateCursor(null, !0);\n    }\n\n    b.skipsUndoManager = !1;\n    b.partManager.addsToTemporaryLayer = !1;\n    a.startPoint = b.firstInput.documentPoint;\n  }\n\n  function We(a) {\n    if (null !== a.draggedLink) {\n      if (a.dragsLink && null !== a.Ce) {\n        var b = a.Ce;\n        b.diagram.remove(b.temporaryFromNode);\n        b.diagram.remove(b.temporaryToNode);\n        a.Ce.originalLink = null;\n      }\n\n      a.draggedLink = null;\n      a.Ce = null;\n    }\n  }\n\n  function df(a, b, c) {\n    var d = a.diagram,\n        e = a.startPoint,\n        f = I.alloc();\n    f.assign(d.lastInput.documentPoint);\n    a.moveParts(b, f.je(e), c);\n    I.free(f);\n    !0 === d.Ge(\"temporaryPixelRatio\") && null === d.Rh && 30 < d.Ew && (Ge(d), d.Jo());\n  }\n\n  Be.prototype.moveParts = function (a, b, c) {\n    void 0 === c && (c = !1);\n    var d = this.diagram;\n    null !== d && ef(d, a, b, this.dragOptions, c);\n  };\n\n  function af(a) {\n    if (null !== a.draggedParts) {\n      for (var b = a.diagram, c = a.draggedParts.iterator; c.next();) {\n        var d = c.key;\n        d.Tc() && (d.location = c.value.point);\n      }\n\n      for (c = a.draggedParts.iterator; c.next();) {\n        if (d = c.key, d instanceof T && d.suspendsRouting) {\n          var e = c.value.point;\n          a.draggedParts.add(d, a.Fd());\n          cf(d, -e.x, -e.y);\n        }\n      }\n\n      b.nd();\n    }\n  }\n\n  function ff(a, b) {\n    var c = a.diagram;\n    a.dragsLink && (null !== a.draggedLink && (a.draggedLink.fromNode = null, a.draggedLink.toNode = null), pf(a, !1));\n    var d = a.findDragOverObject(b),\n        e = c.lastInput;\n    e.targetObject = d;\n    a.doUpdateCursor(d, !1);\n    var f = c.skipsUndoManager,\n        g = !1;\n\n    try {\n      c.skipsUndoManager = !0;\n      g = Ze(a, e, d);\n      if (!a.isActive && null === Ee) return;\n      var h = null !== d ? d.part : null;\n\n      if (null === h || c.handlesDragDropForTopLevelParts && h.isTopLevel && !(h instanceof qf)) {\n        var k = c.mouseDragOver;\n        null !== k && (k(e), g = !0);\n      }\n\n      if (!a.isActive && null === Ee) return;\n      a.doDragOver(b, d);\n      if (!a.isActive && null === Ee) return;\n    } finally {\n      c.skipsUndoManager = f, g && c.nd();\n    }\n\n    a.hn = d;\n    c.isReadOnly || !c.allowMove && !c.allowCopy || !c.allowHorizontalScroll && !c.allowVerticalScroll || c.Fr(e.viewPoint);\n  }\n\n  Be.prototype.findDragOverObject = function (a) {\n    var b = this;\n    return rf(this.diagram, a, null, function (a) {\n      null === a ? a = !0 : (a = a.part, a = null === a || a instanceof ue || a.layer.isTemporary || b.draggedParts && b.draggedParts.contains(a) || b.copiedParts && b.copiedParts.contains(a) ? !0 : !1);\n      return !a;\n    });\n  };\n\n  Be.prototype.doUpdateCursor = function (a, b) {\n    var c = this.diagram;\n    if (b || this.hn !== a) !this.diagram.currentTool.isActive || this.mayCopy() ? c.currentCursor = this.copyCursor : this.mayMove() ? c.currentCursor = this.moveCursor : this.mayDragOut() && (c.currentCursor = this.nodropCursor);\n  };\n\n  function Ze(a, b, c) {\n    var d = !1,\n        e = a.tg.length,\n        f = 0 < e ? a.tg[0] : null;\n    if (c === f) return !1;\n    b.handled = !1;\n\n    for (var g = 0; g < e; g++) {\n      var h = a.tg[g],\n          k = h.mouseDragLeave;\n      if (null !== k && (k(b, h, c), d = !0, b.handled)) break;\n    }\n\n    a.tg.length = 0;\n    if (!a.isActive && null === Ee || null === c) return d;\n    b.handled = !1;\n\n    for (e = c; null !== e;) {\n      a.tg.push(e), e = sf(e);\n    }\n\n    e = a.tg.length;\n\n    for (c = 0; c < e && (g = a.tg[c], h = g.mouseDragEnter, null === h || (h(b, g, f), d = !0, !b.handled)); c++) {\n      ;\n    }\n\n    return d;\n  }\n\n  function sf(a) {\n    var b = a.panel;\n    return null !== b ? b : a instanceof U && !(a instanceof qf) && (a = a.containingGroup, null !== a && a.handlesDragDropForMembers) ? a : null;\n  }\n\n  function tf(a, b, c) {\n    var d = a.Ce;\n    if (null === d) return null;\n    var e = a.diagram.hg(b, d.portGravity, function (a) {\n      return d.findValidLinkablePort(a, c);\n    });\n    a = I.alloc();\n    var f = Infinity,\n        g = null;\n\n    for (e = e.iterator; e.next();) {\n      var h = e.value;\n\n      if (null !== h.part) {\n        var k = h.ia(yc, a);\n        k = b.rf(k);\n        k < f && (g = h, f = k);\n      }\n    }\n\n    I.free(a);\n    return g;\n  }\n\n  function pf(a, b) {\n    var c = a.draggedLink;\n\n    if (null !== c && !(2 > c.pointsCount)) {\n      var d = a.diagram;\n\n      if (!d.isReadOnly) {\n        var e = a.Ce;\n\n        if (null !== e) {\n          var f = null,\n              g = null;\n          null === c.fromNode && (f = tf(a, c.i(0), !1), null !== f && (g = f.part));\n          var h = null,\n              k = null;\n          null === c.toNode && (h = tf(a, c.i(c.pointsCount - 1), !0), null !== h && (k = h.part));\n          e.isValidLink(g, f, k, h) ? b ? (c.defaultFromPoint = c.i(0), c.defaultToPoint = c.i(c.pointsCount - 1), c.suspendsRouting = !1, c.fromNode = g, null !== f && (c.fromPortId = f.portId), c.toNode = k, null !== h && (c.toPortId = h.portId), c.fromPort !== d.tx && d.P(\"LinkRelinked\", c, d.tx), c.toPort !== d.ux && d.P(\"LinkRelinked\", c, d.ux)) : uf(e, g, f, k, h) : uf(e, null, null, null, null);\n        }\n      }\n    }\n  }\n\n  Be.prototype.doDragOver = function () {};\n\n  function vf(a, b) {\n    var c = a.diagram;\n    a.dragsLink && pf(a, !0);\n    Ue(a);\n    var d = a.findDragOverObject(b),\n        e = c.lastInput;\n    e.targetObject = d;\n\n    if (null !== d) {\n      e.handled = !1;\n\n      for (var f = d; null !== f;) {\n        var g = f.mouseDrop;\n        if (null !== g && (g(e, f), e.handled)) break;\n        wf(a, e, f);\n        f = sf(f);\n      }\n    } else f = c.mouseDrop, null !== f && f(e);\n\n    if (a.isActive || null !== Ee) {\n      for (e = (a.copiedParts || a.draggedParts).iterator; e.next();) {\n        f = e.key, f instanceof V && f.linksConnected.each(function (a) {\n          a.suspendsRouting = !1;\n        });\n      }\n\n      a.doDropOnto(b, d);\n\n      if (a.isActive || null !== Ee) {\n        a = M.alloc();\n\n        for (b = c.selection.iterator; b.next();) {\n          d = b.value, d instanceof V && xf(c, d, a);\n        }\n\n        M.free(a);\n      }\n    }\n  }\n\n  function wf(a, b, c) {\n    a = a.diagram;\n    c = c.part;\n    !a.handlesDragDropForTopLevelParts || !c.isTopLevel || c instanceof qf || (c = a.mouseDrop, null !== c && c(b));\n  }\n\n  function xf(a, b, c) {\n    var d = !1;\n    b.getAvoidableRect(c);\n    a.viewportBounds.Ee(c) && (d = !0);\n    a = a.zu(c, function (a) {\n      return a.part;\n    }, function (a) {\n      return a instanceof T;\n    }, !0, function (a) {\n      return a instanceof T;\n    }, d);\n    if (0 !== a.count) for (a = a.iterator; a.next();) {\n      c = a.value, !c.Md(b) && c.isAvoiding && c.ab();\n    }\n  }\n\n  Be.prototype.doDropOnto = function () {};\n\n  Be.prototype.doMouseMove = function () {\n    if (this.isActive) {\n      var a = this.diagram,\n          b = a.lastInput;\n      this.simulatedMouseMove(b.event, b.documentPoint, b.targetDiagram) || null === this.currentPart || null === this.draggedParts || (this.mayCopy() ? (bf(this, !1), He(a, this.copiedParts), df(this, this.copiedParts, !1), Ve(a, this.copiedParts)) : this.mayMove() ? (Xe(this), df(this, this.draggedParts, !0)) : this.mayDragOut() ? (bf(this, !1), df(this, this.copiedParts, !1)) : Xe(this), ff(this, a.lastInput.documentPoint));\n    }\n  };\n\n  Be.prototype.doMouseUp = function () {\n    if (this.isActive) {\n      var a = this.diagram,\n          b = a.lastInput;\n\n      if (!this.simulatedMouseUp(b.event, b.documentPoint, b.targetDiagram)) {\n        b = !1;\n        var c = this.mayCopy();\n        c && null !== this.copiedParts ? (Xe(this), bf(this, !0), He(a, this.copiedParts), df(this, this.copiedParts, !1), Ve(a, this.copiedParts), null !== this.copiedParts && (a.P(\"ChangingSelection\", a.selection), a.clearSelection(!0), this.copiedParts.iteratorKeys.each(function (a) {\n          a.isSelected = !0;\n        }))) : (b = !0, Xe(this), this.mayMove() && (df(this, this.draggedParts, !0), ff(this, a.lastInput.documentPoint)));\n        this.Gm = !0;\n        vf(this, a.lastInput.documentPoint);\n\n        if (this.isActive) {\n          var d = c ? this.copiedParts.Cf() : this.draggedParts.Cf();\n          this.copiedParts = null;\n          b && yf(this);\n          a.Va();\n          Ve(a, this.draggedParts);\n          this.transactionResult = c ? \"Copy\" : \"Move\";\n          a.P(c ? \"SelectionCopied\" : \"SelectionMoved\", d);\n        }\n\n        this.stopTool();\n        c && a.P(\"ChangedSelection\", a.selection);\n      }\n    }\n  };\n\n  Be.prototype.simulatedMouseMove = function (a, b, c) {\n    if (null === Ee) return !1;\n    var d = Ee.diagram;\n    c instanceof Q || (c = null);\n    var e = Ie;\n    c !== e && (null !== e && e !== d && (e.lg(), Ee.isDragOutStarted = !1, e = e.toolManager.findTool(\"Dragging\"), null !== e && e.doSimulatedDragLeave()), Ie = c, null !== c && c !== d && ($e(), e = c.toolManager.findTool(\"Dragging\"), null !== e && (De.contains(e) || De.add(e), e.doSimulatedDragEnter())), this.doUpdateCursor(null, !0));\n    if (null === c || c === d || !c.allowDrop || c.isReadOnly || !c.allowInsert) return !1;\n    d = c.toolManager.findTool(\"Dragging\");\n    null !== d && (null !== a && (void 0 !== a.targetTouches && (0 < a.targetTouches.length ? a = a.targetTouches[0] : 0 < a.changedTouches.length && (a = a.changedTouches[0])), b = c.getMouse(a)), c.lastInput.documentPoint = b, c.lastInput.viewPoint = c.Ro(b), c.lastInput.down = !1, c.lastInput.up = !1, d.doSimulatedDragOver());\n    return !0;\n  };\n\n  Be.prototype.simulatedMouseUp = function (a, b, c) {\n    if (null === Ee) return !1;\n    var d = Ie,\n        e = Ee.diagram;\n    if (null === c) return Ee.doCancel(), !0;\n\n    if (c !== d) {\n      var f = d.toolManager.findTool(\"Dragging\");\n      if (null !== d && d !== e && null !== f) return d.lg(), Ee.isDragOutStarted = !1, f.doSimulatedDragLeave(), !1;\n      Ie = c;\n      d = c.toolManager.findTool(\"Dragging\");\n      null !== d && ($e(), De.contains(d) || De.add(d), d.doSimulatedDragEnter());\n    }\n\n    return c !== this.diagram ? (null !== a ? (void 0 !== a.targetTouches && (0 < a.targetTouches.length ? a = a.targetTouches[0] : 0 < a.changedTouches.length && (a = a.changedTouches[0])), b = c.getMouse(a)) : null === b && (b = new I()), c.lastInput.documentPoint = b, c.lastInput.viewPoint = c.Ro(b), c.lastInput.down = !1, c.lastInput.up = !0, a = c.toolManager.findTool(\"Dragging\"), null !== a && a.doSimulatedDrop(), a = Ee, null !== a && (c = a.mayCopy(), a.transactionResult = c ? \"Copy\" : \"Move\", a.stopTool()), !0) : !1;\n  };\n\n  function yf(a) {\n    if (null !== a.draggedParts) for (var b = a.draggedParts.iterator; b.next();) {\n      var c = b.key;\n      c instanceof V && (c = c.containingGroup, null === c || null === c.placeholder || a.draggedParts.contains(c) || c.placeholder.w());\n    }\n  }\n\n  Be.prototype.mayCopy = function () {\n    if (!this.isCopyEnabled) return !1;\n    var a = this.diagram;\n    if (a.isReadOnly || a.isModelReadOnly || !a.allowInsert || !a.allowCopy || (Qa ? !a.lastInput.alt : !a.lastInput.control)) return !1;\n\n    for (a = a.selection.iterator; a.next();) {\n      if (a.value.canCopy()) return !0;\n    }\n\n    return null !== this.draggedLink && this.dragsLink && this.draggedLink.canCopy() ? !0 : !1;\n  };\n\n  Be.prototype.mayDragOut = function () {\n    if (!this.isCopyEnabled) return !1;\n    var a = this.diagram;\n    if (!a.allowDragOut || !a.allowCopy || a.allowMove) return !1;\n\n    for (a = a.selection.iterator; a.next();) {\n      if (a.value.canCopy()) return !0;\n    }\n\n    return null !== this.draggedLink && this.dragsLink && this.draggedLink.canCopy() ? !0 : !1;\n  };\n\n  Be.prototype.mayMove = function () {\n    var a = this.diagram;\n    if (a.isReadOnly || !a.allowMove) return !1;\n\n    for (a = a.selection.iterator; a.next();) {\n      if (a.value.canMove()) return !0;\n    }\n\n    return null !== this.draggedLink && this.dragsLink && this.draggedLink.canMove() ? !0 : !1;\n  };\n\n  Be.prototype.computeBorder = function (a, b, c) {\n    return this.Gm || null === this.draggedParts || this.draggedParts.contains(a) ? null : c.assign(b);\n  };\n\n  Be.prototype.hz = function () {\n    return Ee;\n  };\n\n  Be.prototype.mayDragIn = function () {\n    var a = this.diagram;\n    if (!a.allowDrop || a.isReadOnly || a.isModelReadOnly || !a.allowInsert) return !1;\n    var b = Ee;\n    return null === b || b.diagram.model.dataFormat !== a.model.dataFormat ? !1 : !0;\n  };\n\n  Be.prototype.doSimulatedDragEnter = function () {\n    if (this.mayDragIn()) {\n      var a = this.diagram;\n      a.animationManager.wc();\n      zf(a);\n      a.animationManager.wc();\n      a = Ee;\n      null !== a && (a.diagram.os = !1);\n      this.doUpdateCursor(null, !0);\n    }\n  };\n\n  Be.prototype.doSimulatedDragLeave = function () {\n    var a = Ee;\n    null !== a && a.doSimulatedDragOut();\n    this.doCancel();\n  };\n\n  Be.prototype.doSimulatedDragOver = function () {\n    var a = this.diagram;\n    a.animationManager.lm = !0;\n    var b = Ee;\n\n    if (null !== b && null !== b.draggedParts) {\n      if (!this.mayDragIn()) return;\n      Af(this, b.draggedParts.Cf(), !1, a.firstInput);\n      df(this, this.copiedParts, !1);\n      ff(this, a.lastInput.documentPoint);\n    }\n\n    a.animationManager.lm = !1;\n  };\n\n  Be.prototype.doSimulatedDrop = function () {\n    var a = this.diagram,\n        b = Ee;\n\n    if (null !== b) {\n      var c = b.diagram;\n      b.Gm = !0;\n      Xe(this);\n      if (!this.mayDragIn()) return;\n      a.animationManager.lm = !0;\n      a.P(\"ChangingSelection\", a.selection);\n      this.Da(\"Drop\");\n      Af(this, b.draggedParts.Cf(), !0, a.lastInput);\n      df(this, this.copiedParts, !1);\n      null !== this.copiedParts && (a.clearSelection(!0), this.copiedParts.iteratorKeys.each(function (a) {\n        a.isSelected = !0;\n      }));\n      vf(this, a.lastInput.documentPoint);\n      a.Va();\n      b = a.selection;\n      null !== this.copiedParts ? this.transactionResult = \"ExternalCopy\" : b = new G();\n      this.copiedParts = null;\n      a.doFocus();\n      a.P(\"ExternalObjectsDropped\", b, c);\n      this.stopTransaction();\n      a.P(\"ChangedSelection\", a.selection);\n    }\n\n    a.animationManager.lm = !1;\n  };\n\n  function Af(a, b, c, d) {\n    if (null === a.copiedParts) {\n      var e = a.diagram;\n\n      if (!e.isReadOnly && !e.isModelReadOnly) {\n        e.skipsUndoManager = !c;\n        e.partManager.addsToTemporaryLayer = !c;\n        a.startPoint = d.documentPoint;\n        c = e.Ej(b, e, !0);\n        var f = M.alloc();\n        e = d = Infinity;\n\n        for (var g = -Infinity, h = -Infinity, k = b.iterator; k.next();) {\n          var l = k.value;\n\n          if (l.isVisible()) {\n            var m = l.location;\n            l = m.x;\n            m = m.y;\n            isNaN(l) || isNaN(m) || (l < d && (d = l), m < e && (e = m), l > g && (g = l), m > h && (h = m));\n          }\n        }\n\n        Infinity === d ? f.h(0, 0, 0, 0) : f.h(d, e, g - d, h - e);\n        d = f.x + f.width / 2;\n        e = f.y + f.height / 2;\n        M.free(f);\n        f = a.br;\n        g = new pb();\n        h = I.alloc();\n\n        for (k = b.iterator; k.next();) {\n          l = k.value, l instanceof T && l.canCopy() && (m = c.I(l), null !== m && (m.points = l.points, cf(m, f.x - d, f.y - e), m.suspendsRouting = !0, g.add(m, a.Fd())));\n        }\n\n        for (b = b.iterator; b.next();) {\n          l = b.value, l.Tc() && l.canCopy() && (k = c.I(l), null !== k && (l = l.location, h.h(f.x - (d - l.x), f.y - (e - l.y)), k.location = h, k.Za(), g.add(k, a.Fd(h))));\n        }\n\n        I.free(h);\n        a.copiedParts = g;\n        Fe(a, g.Cf());\n        null !== a.draggedLink && (c = a.draggedLink, b = c.routeBounds, cf(c, a.startPoint.x - (b.x + b.width / 2), a.startPoint.y - (b.y + b.height / 2)));\n        a.doUpdateCursor(null, !0);\n      }\n    }\n  }\n\n  Be.prototype.doSimulatedDragOut = function () {\n    var a = this.diagram;\n    a.os = !1;\n    this.mayCopy() || this.mayMove() ? a.currentCursor = \"\" : a.currentCursor = this.nodropCursor;\n    this.hn = null;\n  };\n\n  Be.prototype.computeMove = function (a, b, c, d) {\n    c = this.diagram;\n    return null !== c ? c.computeMove(a, b, this.dragOptions, d) : new I();\n  };\n\n  ma.Object.defineProperties(Be.prototype, {\n    isCopyEnabled: {\n      get: function get() {\n        return this.nb;\n      },\n      set: function set(a) {\n        this.nb = a;\n      }\n    },\n    copiesEffectiveCollection: {\n      get: function get() {\n        return this.u;\n      },\n      set: function set(a) {\n        this.u = a;\n      }\n    },\n    dragOptions: {\n      get: function get() {\n        return this.ga;\n      },\n      set: function set(a) {\n        this.ga = a;\n      }\n    },\n    isGridSnapEnabled: {\n      get: function get() {\n        return this.dragOptions.isGridSnapEnabled;\n      },\n      set: function set(a) {\n        this.dragOptions.isGridSnapEnabled = a;\n      }\n    },\n    isComplexRoutingRealtime: {\n      get: function get() {\n        return this.cb;\n      },\n      set: function set(a) {\n        this.cb = a;\n      }\n    },\n    isGridSnapRealtime: {\n      get: function get() {\n        return this.dragOptions.isGridSnapRealtime;\n      },\n      set: function set(a) {\n        this.dragOptions.isGridSnapRealtime = a;\n      }\n    },\n    gridSnapCellSize: {\n      get: function get() {\n        return this.dragOptions.gridSnapCellSize;\n      },\n      set: function set(a) {\n        this.dragOptions.gridSnapCellSize.C(a) || (a = a.J(), this.dragOptions.gridSnapCellSize = a);\n      }\n    },\n    gridSnapCellSpot: {\n      get: function get() {\n        return this.dragOptions.gridSnapCellSpot;\n      },\n      set: function set(a) {\n        this.dragOptions.gridSnapCellSpot.C(a) || (a = a.J(), this.dragOptions.gridSnapCellSpot = a);\n      }\n    },\n    gridSnapOrigin: {\n      get: function get() {\n        return this.dragOptions.gridSnapOrigin;\n      },\n      set: function set(a) {\n        this.dragOptions.gridSnapOrigin.C(a) || (a = a.J(), this.dragOptions.gridSnapOrigin = a);\n      }\n    },\n    dragsLink: {\n      get: function get() {\n        return this.dragOptions.dragsLink;\n      },\n      set: function set(a) {\n        this.dragOptions.dragsLink = a;\n      }\n    },\n    dragsTree: {\n      get: function get() {\n        return this.dragOptions.dragsTree;\n      },\n      set: function set(a) {\n        this.dragOptions.dragsTree = a;\n      }\n    },\n    copyCursor: {\n      get: function get() {\n        return this.F;\n      },\n      set: function set(a) {\n        this.F = a;\n      }\n    },\n    moveCursor: {\n      get: function get() {\n        return this.Hc;\n      },\n      set: function set(a) {\n        this.Hc = a;\n      }\n    },\n    nodropCursor: {\n      get: function get() {\n        return this.Ic;\n      },\n      set: function set(a) {\n        this.Ic = a;\n      }\n    },\n    currentPart: {\n      get: function get() {\n        return this.W;\n      },\n      set: function set(a) {\n        this.W = a;\n      }\n    },\n    copiedParts: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        this.m = a;\n      }\n    },\n    draggedParts: {\n      get: function get() {\n        return this.Ga;\n      },\n      set: function set(a) {\n        this.Ga = a;\n      }\n    },\n    draggingParts: {\n      get: function get() {\n        return null !== this.copiedParts ? this.copiedParts.Cf() : null !== this.draggedParts ? this.draggedParts.Cf() : this.le;\n      }\n    },\n    draggedLink: {\n      get: function get() {\n        return this.diagram.draggedLink;\n      },\n      set: function set(a) {\n        this.diagram.draggedLink = a;\n      }\n    },\n    isDragOutStarted: {\n      get: function get() {\n        return this.Db;\n      },\n      set: function set(a) {\n        this.Db = a;\n      }\n    },\n    startPoint: {\n      get: function get() {\n        return this.br;\n      },\n      set: function set(a) {\n        this.br.C(a) || this.br.assign(a);\n      }\n    },\n    delay: {\n      get: function get() {\n        return this.wk;\n      },\n      set: function set(a) {\n        this.wk = a;\n      }\n    }\n  });\n  Be.prototype.getDraggingSource = Be.prototype.hz;\n  var Ee = null,\n      Ie = null;\n  Be.className = \"DraggingTool\";\n  De = new E();\n  Ka(\"draggingTool\", function () {\n    return this.findTool(\"Dragging\");\n  }, function (a) {\n    this.gb(\"Dragging\", a, this.mouseMoveTools);\n  });\n\n  La.prototype.doCancel = function () {\n    null !== Ee && Ee.doCancel();\n    ke.prototype.doCancel.call(this);\n  };\n\n  function Bf() {\n    ke.call(this);\n    this.le = 100;\n    this.Ga = !1;\n    this.u = \"pointer\";\n    var a = new T(),\n        b = new Cf();\n    b.isPanelMain = !0;\n    b.stroke = \"blue\";\n    a.add(b);\n    b = new Cf();\n    b.toArrow = \"Standard\";\n    b.fill = \"blue\";\n    b.stroke = \"blue\";\n    a.add(b);\n    a.layerName = \"Tool\";\n    this.vi = a;\n    a = new V();\n    b = new Cf();\n    b.portId = \"\";\n    b.figure = \"Rectangle\";\n    b.fill = null;\n    b.stroke = \"magenta\";\n    b.strokeWidth = 2;\n    b.desiredSize = Eb;\n    a.add(b);\n    a.selectable = !1;\n    a.layerName = \"Tool\";\n    this.ui = a;\n    this.j = b;\n    a = new V();\n    b = new Cf();\n    b.portId = \"\";\n    b.figure = \"Rectangle\";\n    b.fill = null;\n    b.stroke = \"magenta\";\n    b.strokeWidth = 2;\n    b.desiredSize = Eb;\n    a.add(b);\n    a.selectable = !1;\n    a.layerName = \"Tool\";\n    this.wi = a;\n    this.m = b;\n    this.Ic = this.Hc = this.nb = this.cb = this.Db = null;\n    this.ga = !0;\n    this.Wo = new pb();\n    this.Ff = this.bj = this.Gf = null;\n  }\n\n  la(Bf, ke);\n\n  Bf.prototype.doStop = function () {\n    this.diagram.lg();\n    this.originalToPort = this.originalToNode = this.originalFromPort = this.originalFromNode = this.originalLink = null;\n    this.validPortsCache.clear();\n    this.targetPort = null;\n  };\n\n  Bf.prototype.copyPortProperties = function (a, b, c, d, e) {\n    if (null !== a && null !== b && null !== c && null !== d) {\n      var f = b.uf(),\n          g = K.alloc();\n      g.width = b.naturalBounds.width * f;\n      g.height = b.naturalBounds.height * f;\n      d.desiredSize = g;\n      K.free(g);\n      e ? (d.toSpot = b.toSpot, d.toEndSegmentLength = b.toEndSegmentLength) : (d.fromSpot = b.fromSpot, d.fromEndSegmentLength = b.fromEndSegmentLength);\n      c.locationSpot = yc;\n      f = I.alloc();\n      c.location = b.ia(yc, f);\n      I.free(f);\n      d.angle = b.fi();\n      null !== this.portTargeted && this.portTargeted(a, b, c, d, e);\n    }\n  };\n\n  Bf.prototype.setNoTargetPortProperties = function (a, b, c) {\n    null !== b && (b.desiredSize = Eb, b.fromSpot = sc, b.toSpot = sc);\n    null !== a && (a.location = this.diagram.lastInput.documentPoint);\n    null !== this.portTargeted && this.portTargeted(null, null, a, b, c);\n  };\n\n  Bf.prototype.doMouseDown = function () {\n    this.isActive && this.doMouseMove();\n  };\n\n  Bf.prototype.doMouseMove = function () {\n    if (this.isActive) {\n      var a = this.diagram;\n      this.targetPort = this.findTargetPort(this.isForwards);\n\n      if (null !== this.targetPort && this.targetPort.part instanceof V) {\n        var b = this.targetPort.part;\n        this.isForwards ? this.copyPortProperties(b, this.targetPort, this.temporaryToNode, this.temporaryToPort, !0) : this.copyPortProperties(b, this.targetPort, this.temporaryFromNode, this.temporaryFromPort, !1);\n      } else this.isForwards ? this.setNoTargetPortProperties(this.temporaryToNode, this.temporaryToPort, !0) : this.setNoTargetPortProperties(this.temporaryFromNode, this.temporaryFromPort, !1);\n\n      (a.allowHorizontalScroll || a.allowVerticalScroll) && a.Fr(a.lastInput.viewPoint);\n    }\n  };\n\n  Bf.prototype.findValidLinkablePort = function (a, b) {\n    if (null === a) return null;\n    var c = a.part;\n    if (!(c instanceof V)) return null;\n\n    for (; null !== a;) {\n      var d = b ? a.toLinkable : a.fromLinkable;\n      if (!0 === d && (null !== a.portId || a instanceof V) && (b ? this.isValidTo(c, a) : this.isValidFrom(c, a))) return a;\n      if (!1 === d) break;\n      a = a.panel;\n    }\n\n    return null;\n  };\n\n  Bf.prototype.findTargetPort = function (a) {\n    var b = this.diagram,\n        c = b.lastInput.documentPoint,\n        d = this.portGravity;\n    0 >= d && (d = .1);\n    var e = this,\n        f = b.hg(c, d, function (b) {\n      return e.findValidLinkablePort(b, a);\n    }, null, !0);\n    d = Infinity;\n    b = null;\n\n    for (f = f.iterator; f.next();) {\n      var g = f.value,\n          h = g.part;\n\n      if (h instanceof V) {\n        var k = g.ia(yc, I.alloc()),\n            l = c.x - k.x,\n            m = c.y - k.y;\n        I.free(k);\n        k = l * l + m * m;\n        k < d && (l = this.validPortsCache.I(g), null !== l ? l && (b = g, d = k) : a && this.isValidLink(this.originalFromNode, this.originalFromPort, h, g) || !a && this.isValidLink(h, g, this.originalToNode, this.originalToPort) ? (this.validPortsCache.add(g, !0), b = g, d = k) : this.validPortsCache.add(g, !1));\n      }\n    }\n\n    return null !== b && (c = b.part, c instanceof V && (null === c.layer || c.layer.allowLink)) ? b : null;\n  };\n\n  Bf.prototype.isValidFrom = function (a, b) {\n    if (null === a || null === b) return this.isUnconnectedLinkValid;\n    if (this.diagram.currentTool === this && (null !== a.layer && !a.layer.allowLink || !0 !== b.fromLinkable)) return !1;\n    var c = b.fromMaxLinks;\n\n    if (Infinity > c) {\n      if (null !== this.originalLink && a === this.originalFromNode && b === this.originalFromPort) return !0;\n      b = b.portId;\n      null === b && (b = \"\");\n      if (a.ro(b).count >= c) return !1;\n    }\n\n    return !0;\n  };\n\n  Bf.prototype.isValidTo = function (a, b) {\n    if (null === a || null === b) return this.isUnconnectedLinkValid;\n    if (this.diagram.currentTool === this && (null !== a.layer && !a.layer.allowLink || !0 !== b.toLinkable)) return !1;\n    var c = b.toMaxLinks;\n\n    if (Infinity > c) {\n      if (null !== this.originalLink && a === this.originalToNode && b === this.originalToPort) return !0;\n      b = b.portId;\n      null === b && (b = \"\");\n      if (a.Kd(b).count >= c) return !1;\n    }\n\n    return !0;\n  };\n\n  Bf.prototype.isInSameNode = function (a, b) {\n    if (null === a || null === b) return !1;\n    if (a === b) return !0;\n    a = a.part;\n    b = b.part;\n    return null !== a && a === b;\n  };\n\n  Bf.prototype.isLinked = function (a, b) {\n    if (null === a || null === b) return !1;\n    var c = a.part;\n    if (!(c instanceof V)) return !1;\n    a = a.portId;\n    null === a && (a = \"\");\n    var d = b.part;\n    if (!(d instanceof V)) return !1;\n    b = b.portId;\n    null === b && (b = \"\");\n\n    for (b = d.Kd(b); b.next();) {\n      if (d = b.value, d.fromNode === c && d.fromPortId === a) return !0;\n    }\n\n    return !1;\n  };\n\n  Bf.prototype.isValidLink = function (a, b, c, d) {\n    if (!this.isValidFrom(a, b) || !this.isValidTo(c, d) || !(null === b || null === d || (b.fromLinkableSelfNode && d.toLinkableSelfNode || !this.isInSameNode(b, d)) && (b.fromLinkableDuplicates && d.toLinkableDuplicates || !this.isLinked(b, d))) || null !== this.originalLink && (null !== a && this.isLabelDependentOnLink(a, this.originalLink) || null !== c && this.isLabelDependentOnLink(c, this.originalLink)) || null !== a && null !== c && (null === a.data && null !== c.data || null !== a.data && null === c.data) || !this.isValidCycle(a, c, this.originalLink)) return !1;\n\n    if (null !== a) {\n      var e = a.linkValidation;\n      if (null !== e && !e(a, b, c, d, this.originalLink)) return !1;\n    }\n\n    if (null !== c && (e = c.linkValidation, null !== e && !e(a, b, c, d, this.originalLink))) return !1;\n    e = this.linkValidation;\n    return null !== e ? e(a, b, c, d, this.originalLink) : !0;\n  };\n\n  Bf.prototype.isLabelDependentOnLink = function (a, b) {\n    if (null === a) return !1;\n    var c = a.labeledLink;\n    if (null === c) return !1;\n    if (c === b) return !0;\n    var d = new G();\n    d.add(a);\n    return Df(this, c, b, d);\n  };\n\n  function Df(a, b, c, d) {\n    if (b === c) return !0;\n    var e = b.fromNode;\n    if (null !== e && e.isLinkLabel && (d.add(e), Df(a, e.labeledLink, c, d))) return !0;\n    b = b.toNode;\n    return null !== b && b.isLinkLabel && (d.add(b), Df(a, b.labeledLink, c, d)) ? !0 : !1;\n  }\n\n  Bf.prototype.isValidCycle = function (a, b, c) {\n    void 0 === c && (c = null);\n    if (null === a || null === b) return this.isUnconnectedLinkValid;\n    var d = this.diagram.validCycle;\n\n    if (d !== Ef) {\n      if (d === Ff) {\n        d = c || this.temporaryLink;\n        if (null !== d && !d.isTreeLink) return !0;\n\n        for (d = b.linksConnected; d.next();) {\n          var e = d.value;\n          if (e !== c && e.isTreeLink && e.toNode === b) return !1;\n        }\n\n        return !Gf(this, a, b, c, !0);\n      }\n\n      if (d === Hf) {\n        d = c || this.temporaryLink;\n        if (null !== d && !d.isTreeLink) return !0;\n\n        for (d = a.linksConnected; d.next();) {\n          if (e = d.value, e !== c && e.isTreeLink && e.fromNode === a) return !1;\n        }\n\n        return !Gf(this, a, b, c, !0);\n      }\n\n      if (d === If) return a === b ? a = !0 : (d = new G(), d.add(b), a = Jf(this, d, a, b, c)), !a;\n      if (d === Kf) return !Gf(this, a, b, c, !1);\n      if (d === Lf) return a === b ? a = !0 : (d = new G(), d.add(b), a = Tf(this, d, a, b, c)), !a;\n    }\n\n    return !0;\n  };\n\n  function Gf(a, b, c, d, e) {\n    if (b === c) return !0;\n    if (null === b || null === c) return !1;\n\n    for (var f = b.linksConnected; f.next();) {\n      var g = f.value;\n      if (g !== d && (!e || g.isTreeLink) && g.toNode === b && (g = g.fromNode, g !== b && Gf(a, g, c, d, e))) return !0;\n    }\n\n    return !1;\n  }\n\n  function Jf(a, b, c, d, e) {\n    if (c === d) return !0;\n    if (null === c || null === d || b.contains(c)) return !1;\n    b.add(c);\n\n    for (var f = c.linksConnected; f.next();) {\n      var g = f.value;\n      if (g !== e && g.toNode === c && (g = g.fromNode, g !== c && Jf(a, b, g, d, e))) return !0;\n    }\n\n    return !1;\n  }\n\n  function Tf(a, b, c, d, e) {\n    if (c === d) return !0;\n    if (null === c || null === d || b.contains(c)) return !1;\n    b.add(c);\n\n    for (var f = c.linksConnected; f.next();) {\n      var g = f.value;\n\n      if (g !== e) {\n        var h = g.fromNode;\n        g = g.toNode;\n        h = h === c ? g : h;\n        if (h !== c && Tf(a, b, h, d, e)) return !0;\n      }\n    }\n\n    return !1;\n  }\n\n  ma.Object.defineProperties(Bf.prototype, {\n    portGravity: {\n      get: function get() {\n        return this.le;\n      },\n      set: function set(a) {\n        0 <= a && (this.le = a);\n      }\n    },\n    isUnconnectedLinkValid: {\n      get: function get() {\n        return this.Ga;\n      },\n      set: function set(a) {\n        this.Ga = a;\n      }\n    },\n    linkingCursor: {\n      get: function get() {\n        return this.u;\n      },\n      set: function set(a) {\n        this.u = a;\n      }\n    },\n    temporaryLink: {\n      get: function get() {\n        return this.vi;\n      },\n      set: function set(a) {\n        this.vi = a;\n      }\n    },\n    temporaryFromNode: {\n      get: function get() {\n        return this.ui;\n      },\n      set: function set(a) {\n        if (this.ui = a) this.j = a.port;\n      }\n    },\n    temporaryFromPort: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        if (null !== this.j) {\n          var b = this.j.panel;\n\n          if (null !== b) {\n            var c = b.R.indexOf(this.j);\n            b.mb(c);\n            b.Cb(c, a);\n          }\n        }\n\n        this.j = a;\n      }\n    },\n    temporaryToNode: {\n      get: function get() {\n        return this.wi;\n      },\n      set: function set(a) {\n        if (this.wi = a) this.m = a.port;\n      }\n    },\n    temporaryToPort: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        if (null !== this.m) {\n          var b = this.m.panel;\n\n          if (null !== b) {\n            var c = b.R.indexOf(this.m);\n            b.mb(c);\n            b.Cb(c, a);\n          }\n        }\n\n        this.m = a;\n      }\n    },\n    originalLink: {\n      get: function get() {\n        return this.Db;\n      },\n      set: function set(a) {\n        this.Db = a;\n      }\n    },\n    originalFromNode: {\n      get: function get() {\n        return this.cb;\n      },\n      set: function set(a) {\n        this.cb = a;\n      }\n    },\n    originalFromPort: {\n      get: function get() {\n        return this.nb;\n      },\n      set: function set(a) {\n        this.nb = a;\n      }\n    },\n    originalToNode: {\n      get: function get() {\n        return this.Hc;\n      },\n      set: function set(a) {\n        this.Hc = a;\n      }\n    },\n    originalToPort: {\n      get: function get() {\n        return this.Ic;\n      },\n      set: function set(a) {\n        this.Ic = a;\n      }\n    },\n    isForwards: {\n      get: function get() {\n        return this.ga;\n      },\n      set: function set(a) {\n        this.ga = a;\n      }\n    },\n    validPortsCache: {\n      get: function get() {\n        return this.Wo;\n      }\n    },\n    targetPort: {\n      get: function get() {\n        return this.Gf;\n      },\n      set: function set(a) {\n        this.Gf = a;\n      }\n    },\n    linkValidation: {\n      get: function get() {\n        return this.bj;\n      },\n      set: function set(a) {\n        this.bj = a;\n      }\n    },\n    portTargeted: {\n      get: function get() {\n        return this.Ff;\n      },\n      set: function set(a) {\n        this.Ff = a;\n      }\n    }\n  });\n  Bf.className = \"LinkingBaseTool\";\n\n  function Uf() {\n    Bf.call(this);\n    this.name = \"Linking\";\n    this.W = {};\n    this.F = null;\n    this.L = Vf;\n    this.Qd = null;\n  }\n\n  la(Uf, Bf);\n\n  Uf.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    return a.isReadOnly || a.isModelReadOnly || !a.allowLink || !a.model.Vr() || !a.lastInput.left || a.currentTool !== this && !this.isBeyondDragSize() ? !1 : null !== this.findLinkablePort();\n  };\n\n  Uf.prototype.findLinkablePort = function () {\n    var a = this.diagram,\n        b = this.startObject;\n    null === b && (b = a.ec(a.firstInput.documentPoint, null, null));\n    if (null === b) return null;\n    a = b.part;\n    if (!(a instanceof V)) return null;\n    var c = this.direction;\n\n    if (c === Vf || c === Wf) {\n      var d = this.findValidLinkablePort(b, !1);\n      if (null !== d || this.startObject === a && (d = a.port, this.findValidLinkablePort(d, !1))) return this.isForwards = !0, d;\n    }\n\n    if (c === Vf || c === Xf) if (b = this.findValidLinkablePort(b, !0), null !== b || this.startObject === a && (b = a.port, this.findValidLinkablePort(b, !0))) return this.isForwards = !1, b;\n    return null;\n  };\n\n  Uf.prototype.doActivate = function () {\n    var a = this.diagram,\n        b = this.findLinkablePort();\n    null === b ? this.stopTool() : (this.Da(this.name), a.isMouseCaptured = !0, a.currentCursor = this.linkingCursor, this.isForwards ? (null === this.temporaryToNode || this.temporaryToNode.location.v() || (this.temporaryToNode.location = a.lastInput.documentPoint), this.originalFromPort = b, b = this.originalFromPort.part, b instanceof V && (this.originalFromNode = b), this.copyPortProperties(this.originalFromNode, this.originalFromPort, this.temporaryFromNode, this.temporaryFromPort, !1)) : (null === this.temporaryFromNode || this.temporaryFromNode.location.v() || (this.temporaryFromNode.location = a.lastInput.documentPoint), this.originalToPort = b, b = this.originalToPort.part, b instanceof V && (this.originalToNode = b), this.copyPortProperties(this.originalToNode, this.originalToPort, this.temporaryToNode, this.temporaryToPort, !0)), a.add(this.temporaryFromNode), a.add(this.temporaryToNode), null !== this.temporaryLink && (null !== this.temporaryFromNode && (this.temporaryLink.fromNode = this.temporaryFromNode), null !== this.temporaryToNode && (this.temporaryLink.toNode = this.temporaryToNode), this.temporaryLink.isTreeLink = this.isNewTreeLink(), this.temporaryLink.ab(), a.add(this.temporaryLink)), this.isActive = !0);\n  };\n\n  Uf.prototype.doDeactivate = function () {\n    this.isActive = !1;\n    var a = this.diagram;\n    a.remove(this.temporaryLink);\n    a.remove(this.temporaryFromNode);\n    a.remove(this.temporaryToNode);\n    a.isMouseCaptured = !1;\n    a.currentCursor = \"\";\n    this.stopTransaction();\n  };\n\n  Uf.prototype.doStop = function () {\n    Bf.prototype.doStop.call(this);\n    this.startObject = null;\n  };\n\n  Uf.prototype.doMouseUp = function () {\n    if (this.isActive) {\n      var a = this.diagram,\n          b = this.transactionResult = null,\n          c = null,\n          d = null,\n          e = null,\n          f = null;\n\n      try {\n        var g = this.targetPort = this.findTargetPort(this.isForwards);\n\n        if (null !== g) {\n          var h = g.part;\n          h instanceof V && (this.isForwards ? (null !== this.originalFromNode && (b = this.originalFromNode, c = this.originalFromPort), d = h, e = g) : (b = h, c = g, null !== this.originalToNode && (d = this.originalToNode, e = this.originalToPort)));\n        } else this.isForwards ? null !== this.originalFromNode && this.isUnconnectedLinkValid && (b = this.originalFromNode, c = this.originalFromPort) : null !== this.originalToNode && this.isUnconnectedLinkValid && (d = this.originalToNode, e = this.originalToPort);\n\n        null !== b || null !== d ? (f = this.insertLink(b, c, d, e), null !== f ? (null === g && (this.isForwards ? f.defaultToPoint = a.lastInput.documentPoint : f.defaultFromPoint = a.lastInput.documentPoint), a.allowSelect && (a.P(\"ChangingSelection\", a.selection), a.clearSelection(!0), f.isSelected = !0), this.transactionResult = this.name, a.P(\"LinkDrawn\", f)) : this.doNoLink(b, c, d, e)) : this.isForwards ? this.doNoLink(this.originalFromNode, this.originalFromPort, null, null) : this.doNoLink(null, null, this.originalToNode, this.originalToPort);\n      } finally {\n        this.stopTool(), f && a.allowSelect && a.P(\"ChangedSelection\", a.selection);\n      }\n    }\n  };\n\n  Uf.prototype.isNewTreeLink = function () {\n    var a = this.archetypeLinkData;\n    if (null === a) return !0;\n    if (a instanceof T) return a.isTreeLink;\n    var b = this.diagram;\n    if (null === b) return !0;\n    a = b.partManager.getLinkCategoryForData(a);\n    b = b.partManager.findLinkTemplateForCategory(a);\n    return null !== b ? b.isTreeLink : !0;\n  };\n\n  Uf.prototype.insertLink = function (a, b, c, d) {\n    return this.diagram.partManager.insertLink(a, b, c, d);\n  };\n\n  Uf.prototype.doNoLink = function () {};\n\n  ma.Object.defineProperties(Uf.prototype, {\n    archetypeLinkData: {\n      get: function get() {\n        return this.W;\n      },\n      set: function set(a) {\n        this.W = a;\n      }\n    },\n    archetypeLabelNodeData: {\n      get: function get() {\n        return this.F;\n      },\n      set: function set(a) {\n        this.F = a;\n      }\n    },\n    direction: {\n      get: function get() {\n        return this.L;\n      },\n      set: function set(a) {\n        this.L = a;\n      }\n    },\n    startObject: {\n      get: function get() {\n        return this.Qd;\n      },\n      set: function set(a) {\n        this.Qd = a;\n      }\n    }\n  });\n  var Vf = new D(Uf, \"Either\", 0),\n      Wf = new D(Uf, \"ForwardsOnly\", 0),\n      Xf = new D(Uf, \"BackwardsOnly\", 0);\n  Uf.className = \"LinkingTool\";\n  Uf.Either = Vf;\n  Uf.ForwardsOnly = Wf;\n  Uf.BackwardsOnly = Xf;\n\n  function Se() {\n    Bf.call(this);\n    this.name = \"Relinking\";\n    var a = new Cf();\n    a.figure = \"Diamond\";\n    a.desiredSize = Jb;\n    a.fill = \"lightblue\";\n    a.stroke = \"dodgerblue\";\n    a.cursor = this.linkingCursor;\n    a.segmentIndex = 0;\n    this.W = a;\n    a = new Cf();\n    a.figure = \"Diamond\";\n    a.desiredSize = Jb;\n    a.fill = \"lightblue\";\n    a.stroke = \"dodgerblue\";\n    a.cursor = this.linkingCursor;\n    a.segmentIndex = -1;\n    this.Qd = a;\n    this.F = null;\n    this.iw = new M();\n  }\n\n  la(Se, Bf);\n\n  Se.prototype.updateAdornments = function (a) {\n    if (null !== a && a instanceof T) {\n      var b = \"RelinkFrom\",\n          c = null;\n\n      if (a.isSelected && !this.diagram.isReadOnly) {\n        var d = a.selectionObject;\n        null !== d && a.canRelinkFrom() && a.actualBounds.v() && a.isVisible() && d.actualBounds.v() && d.zf() && (c = a.Hj(b), null === c && (c = this.makeAdornment(d, !1), a.Tg(b, c)));\n      }\n\n      null === c && a.Af(b);\n      b = \"RelinkTo\";\n      c = null;\n      a.isSelected && !this.diagram.isReadOnly && (d = a.selectionObject, null !== d && a.canRelinkTo() && a.actualBounds.v() && a.isVisible() && d.actualBounds.v() && d.zf() && (c = a.Hj(b), null === c ? (c = this.makeAdornment(d, !0), a.Tg(b, c)) : c.w()));\n      null === c && a.Af(b);\n    }\n  };\n\n  Se.prototype.makeAdornment = function (a, b) {\n    var c = new ue();\n    c.type = W.Link;\n    b = b ? this.toHandleArchetype : this.fromHandleArchetype;\n    null !== b && c.add(b.copy());\n    c.adornedObject = a;\n    return c;\n  };\n\n  Se.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    if (a.isReadOnly || a.isModelReadOnly || !a.allowRelink || !a.model.Vr() || !a.lastInput.left) return !1;\n    var b = this.findToolHandleAt(a.firstInput.documentPoint, \"RelinkFrom\");\n    null === b && (b = this.findToolHandleAt(a.firstInput.documentPoint, \"RelinkTo\"));\n    return null !== b;\n  };\n\n  Se.prototype.doActivate = function () {\n    var a = this.diagram;\n\n    if (null === this.originalLink) {\n      var b = this.handle;\n      null === b && (b = this.findToolHandleAt(a.firstInput.documentPoint, \"RelinkFrom\"), null === b && (b = this.findToolHandleAt(a.firstInput.documentPoint, \"RelinkTo\")));\n      if (null === b) return;\n      var c = b.part;\n      if (!(c instanceof ue && c.adornedPart instanceof T)) return;\n      this.handle = b;\n      this.isForwards = null === c || \"RelinkTo\" === c.category;\n      this.originalLink = c.adornedPart;\n    }\n\n    this.Da(this.name);\n    a.isMouseCaptured = !0;\n    a.currentCursor = this.linkingCursor;\n    this.originalFromPort = this.originalLink.fromPort;\n    this.originalFromNode = this.originalLink.fromNode;\n    this.originalToPort = this.originalLink.toPort;\n    this.originalToNode = this.originalLink.toNode;\n    this.iw.set(this.originalLink.actualBounds);\n    null !== this.originalLink && 0 < this.originalLink.pointsCount && (null === this.originalLink.fromNode && (null !== this.temporaryFromPort && (this.temporaryFromPort.desiredSize = Db), null !== this.temporaryFromNode && (this.temporaryFromNode.location = this.originalLink.i(0))), null === this.originalLink.toNode && (null !== this.temporaryToPort && (this.temporaryToPort.desiredSize = Db), null !== this.temporaryToNode && (this.temporaryToNode.location = this.originalLink.i(this.originalLink.pointsCount - 1))));\n    this.copyPortProperties(this.originalFromNode, this.originalFromPort, this.temporaryFromNode, this.temporaryFromPort, !1);\n    this.copyPortProperties(this.originalToNode, this.originalToPort, this.temporaryToNode, this.temporaryToPort, !0);\n    a.add(this.temporaryFromNode);\n    a.add(this.temporaryToNode);\n    null !== this.temporaryLink && (null !== this.temporaryFromNode && (this.temporaryLink.fromNode = this.temporaryFromNode), null !== this.temporaryToNode && (this.temporaryLink.toNode = this.temporaryToNode), this.copyLinkProperties(this.originalLink, this.temporaryLink), this.temporaryLink.ab(), a.add(this.temporaryLink));\n    this.isActive = !0;\n  };\n\n  Se.prototype.copyLinkProperties = function (a, b) {\n    if (null !== a && null !== b) {\n      b.adjusting = a.adjusting;\n      b.corner = a.corner;\n      var c = a.curve;\n      if (c === Yf || c === Zf) c = $f;\n      b.curve = c;\n      b.curviness = a.curviness;\n      b.isTreeLink = a.isTreeLink;\n      b.points = a.points;\n      b.routing = a.routing;\n      b.smoothness = a.smoothness;\n      b.fromSpot = a.fromSpot;\n      b.fromEndSegmentLength = a.fromEndSegmentLength;\n      b.fromShortLength = a.fromShortLength;\n      b.toSpot = a.toSpot;\n      b.toEndSegmentLength = a.toEndSegmentLength;\n      b.toShortLength = a.toShortLength;\n    }\n  };\n\n  Se.prototype.doDeactivate = function () {\n    this.isActive = !1;\n    var a = this.diagram;\n    a.remove(this.temporaryLink);\n    a.remove(this.temporaryFromNode);\n    a.remove(this.temporaryToNode);\n    a.isMouseCaptured = !1;\n    a.currentCursor = \"\";\n    this.stopTransaction();\n  };\n\n  Se.prototype.doStop = function () {\n    Bf.prototype.doStop.call(this);\n    this.handle = null;\n  };\n\n  Se.prototype.doMouseUp = function () {\n    if (this.isActive) {\n      var a = this.diagram;\n      this.transactionResult = null;\n      var b = this.originalFromNode,\n          c = this.originalFromPort,\n          d = this.originalToNode,\n          e = this.originalToPort,\n          f = this.originalLink;\n\n      try {\n        this.targetPort = this.findTargetPort(this.isForwards);\n\n        if (null !== this.targetPort) {\n          var g = this.targetPort.part;\n          g instanceof V && (this.isForwards ? (d = g, e = this.targetPort) : (b = g, c = this.targetPort));\n        } else this.isUnconnectedLinkValid ? this.isForwards ? e = d = null : c = b = null : f = null;\n\n        null !== f ? (this.reconnectLink(f, this.isForwards ? d : b, this.isForwards ? e : c, this.isForwards), null === this.targetPort && (this.isForwards ? f.defaultToPoint = a.lastInput.documentPoint : f.defaultFromPoint = a.lastInput.documentPoint, f.ab()), this.transactionResult = this.name, a.P(\"LinkRelinked\", f, this.isForwards ? this.originalToPort : this.originalFromPort)) : this.doNoRelink(this.originalLink, this.isForwards);\n        this.originalLink.Ao(this.iw);\n      } finally {\n        this.stopTool();\n      }\n    }\n  };\n\n  Se.prototype.reconnectLink = function (a, b, c, d) {\n    c = null !== c && null !== c.portId ? c.portId : \"\";\n    d ? (a.toNode = b, a.toPortId = c) : (a.fromNode = b, a.fromPortId = c);\n    return !0;\n  };\n\n  Se.prototype.doNoRelink = function () {};\n\n  function uf(a, b, c, d, e) {\n    null !== b ? (a.copyPortProperties(b, c, a.temporaryFromNode, a.temporaryFromPort, !1), a.diagram.add(a.temporaryFromNode)) : a.diagram.remove(a.temporaryFromNode);\n    null !== d ? (a.copyPortProperties(d, e, a.temporaryToNode, a.temporaryToPort, !0), a.diagram.add(a.temporaryToNode)) : a.diagram.remove(a.temporaryToNode);\n  }\n\n  ma.Object.defineProperties(Se.prototype, {\n    fromHandleArchetype: {\n      get: function get() {\n        return this.W;\n      },\n      set: function set(a) {\n        this.W = a;\n      }\n    },\n    toHandleArchetype: {\n      get: function get() {\n        return this.Qd;\n      },\n      set: function set(a) {\n        this.Qd = a;\n      }\n    },\n    handle: {\n      get: function get() {\n        return this.F;\n      },\n      set: function set(a) {\n        if (null !== a && !(a.part instanceof ue)) throw Error(\"new handle is not in an Adornment: \" + a);\n        this.F = a;\n      }\n    }\n  });\n  Se.className = \"RelinkingTool\";\n  Ka(\"linkingTool\", function () {\n    return this.findTool(\"Linking\");\n  }, function (a) {\n    this.gb(\"Linking\", a, this.mouseMoveTools);\n  });\n  Ka(\"relinkingTool\", function () {\n    return this.findTool(\"Relinking\");\n  }, function (a) {\n    this.gb(\"Relinking\", a, this.mouseDownTools);\n  });\n\n  function ag() {\n    ke.call(this);\n    this.name = \"LinkReshaping\";\n    var a = new Cf();\n    a.figure = \"Rectangle\";\n    a.desiredSize = Ib;\n    a.fill = \"lightblue\";\n    a.stroke = \"dodgerblue\";\n    this.m = a;\n    a = new Cf();\n    a.figure = \"Diamond\";\n    a.desiredSize = Jb;\n    a.fill = \"lightblue\";\n    a.stroke = \"dodgerblue\";\n    a.cursor = \"move\";\n    this.u = a;\n    this.F = 3;\n    this.vs = this.j = null;\n    this.jw = new I();\n    this.xq = new E();\n  }\n\n  la(ag, ke);\n\n  ag.prototype.Du = function (a) {\n    return a && 0 !== a.reshapingBehavior.value ? a.reshapingBehavior : bg;\n  };\n\n  ag.prototype.Wl = function (a, b) {\n    a.reshapingBehavior = b;\n  };\n\n  ag.prototype.updateAdornments = function (a) {\n    if (null !== a && a instanceof T) {\n      var b = null;\n\n      if (a.isSelected && !this.diagram.isReadOnly) {\n        var c = a.path;\n        null !== c && a.canReshape() && a.actualBounds.v() && a.isVisible() && c.actualBounds.v() && c.zf() && (b = a.Hj(this.name), null === b || b.ew !== a.pointsCount || b.yw !== a.resegmentable) && (b = this.makeAdornment(c), null !== b && (b.ew = a.pointsCount, b.yw = a.resegmentable, a.Tg(this.name, b)));\n      }\n\n      null === b && a.Af(this.name);\n    }\n  };\n\n  ag.prototype.makeAdornment = function (a) {\n    var b = a.part,\n        c = b.pointsCount,\n        d = b.isOrthogonal,\n        e = null;\n\n    if (null !== b.points && 1 < c) {\n      e = new ue();\n      e.type = W.Link;\n      c = b.firstPickIndex;\n      var f = b.lastPickIndex,\n          g = d ? 1 : 0;\n      if (b.resegmentable && b.computeCurve() !== cg) for (var h = c + g; h < f - g; h++) {\n        var k = this.makeResegmentHandle(a, h);\n        null !== k && (k.segmentIndex = h, k.segmentFraction = .5, k.fromMaxLinks = 999, e.add(k));\n      }\n\n      for (g = c + 1; g < f; g++) {\n        if (h = this.makeHandle(a, g), null !== h) {\n          h.segmentIndex = g;\n          if (g !== c) if (g === c + 1 && d) {\n            k = b.i(c);\n            var l = b.i(c + 1);\n            J.B(k.x, l.x) && J.B(k.y, l.y) && (l = b.i(c - 1));\n            J.B(k.x, l.x) ? (this.Wl(h, dg), h.cursor = \"n-resize\") : J.B(k.y, l.y) && (this.Wl(h, eg), h.cursor = \"w-resize\");\n          } else g === f - 1 && d ? (k = b.i(f - 1), l = b.i(f), J.B(k.x, l.x) && J.B(k.y, l.y) && (k = b.i(f + 1)), J.B(k.x, l.x) ? (this.Wl(h, dg), h.cursor = \"n-resize\") : J.B(k.y, l.y) && (this.Wl(h, eg), h.cursor = \"w-resize\")) : g !== f && (this.Wl(h, fg), h.cursor = \"move\");\n          e.add(h);\n        }\n      }\n\n      e.adornedObject = a;\n    }\n\n    return e;\n  };\n\n  ag.prototype.makeHandle = function () {\n    var a = this.handleArchetype;\n    return null === a ? null : a.copy();\n  };\n\n  ag.prototype.makeResegmentHandle = function () {\n    var a = this.midHandleArchetype;\n    return null === a ? null : a.copy();\n  };\n\n  ag.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    return !a.isReadOnly && a.allowReshape && a.lastInput.left ? null !== this.findToolHandleAt(a.firstInput.documentPoint, this.name) : !1;\n  };\n\n  ag.prototype.doActivate = function () {\n    var a = this.diagram;\n    null === this.handle && (this.handle = this.findToolHandleAt(a.firstInput.documentPoint, this.name));\n\n    if (null !== this.handle) {\n      var b = this.handle.part.adornedPart;\n\n      if (b instanceof T) {\n        this.vs = b;\n        a.isMouseCaptured = !0;\n        this.Da(this.name);\n\n        if (b.resegmentable && 999 === this.handle.fromMaxLinks) {\n          var c = b.points.copy(),\n              d = this.getResegmentingPoint();\n          c.Cb(this.handle.segmentIndex + 1, d);\n          b.isOrthogonal && c.Cb(this.handle.segmentIndex + 1, d);\n          b.points = c;\n          b.Rb();\n          b.updateAdornments();\n          this.handle = this.findToolHandleAt(a.firstInput.documentPoint, this.name);\n\n          if (null === this.handle) {\n            this.doDeactivate();\n            return;\n          }\n        }\n\n        this.jw = b.i(this.handle.segmentIndex);\n        this.xq = b.points.copy();\n        this.isActive = !0;\n      }\n    }\n  };\n\n  ag.prototype.doDeactivate = function () {\n    this.stopTransaction();\n    this.vs = this.handle = null;\n    this.isActive = this.diagram.isMouseCaptured = !1;\n  };\n\n  ag.prototype.stopTransaction = function () {\n    var a = this.diagram,\n        b = ke.prototype.stopTransaction.call(this);\n    b && null !== a.undoManager.transactionToUndo && a.undoManager.transactionToUndo.Vj();\n    return b;\n  };\n\n  ag.prototype.doCancel = function () {\n    var a = this.adornedLink;\n    null !== a && (a.points = this.xq);\n    this.stopTool();\n  };\n\n  ag.prototype.getResegmentingPoint = function () {\n    return this.handle.ia(yc);\n  };\n\n  ag.prototype.doMouseMove = function () {\n    var a = this.diagram;\n    this.isActive && (a = this.computeReshape(a.lastInput.documentPoint), this.reshape(a));\n  };\n\n  ag.prototype.doMouseUp = function () {\n    var a = this.diagram;\n\n    if (this.isActive) {\n      var b = this.computeReshape(a.lastInput.documentPoint);\n      this.reshape(b);\n      b = this.adornedLink;\n\n      if (null !== b && b.resegmentable) {\n        var c = this.handle.segmentIndex,\n            d = b.i(c - 1),\n            e = b.i(c),\n            f = b.i(c + 1);\n\n        if (b.isOrthogonal) {\n          if (c > b.firstPickIndex + 1 && c < b.lastPickIndex - 1) {\n            var g = b.i(c - 2);\n\n            if (Math.abs(d.x - e.x) < this.resegmentingDistance && Math.abs(d.y - e.y) < this.resegmentingDistance && (gg(this, g, d, e, f, !0) || gg(this, g, d, e, f, !1))) {\n              var h = b.points.copy();\n              gg(this, g, d, e, f, !0) ? (h.Vc(c - 2, new I(g.x, (f.y + g.y) / 2)), h.Vc(c + 1, new I(f.x, (f.y + g.y) / 2))) : (h.Vc(c - 2, new I((f.x + g.x) / 2, g.y)), h.Vc(c + 1, new I((f.x + g.x) / 2, f.y)));\n              h.mb(c);\n              h.mb(c - 1);\n              b.points = h;\n              b.Rb();\n            } else g = b.i(c + 2), Math.abs(e.x - f.x) < this.resegmentingDistance && Math.abs(e.y - f.y) < this.resegmentingDistance && (gg(this, d, e, f, g, !0) || gg(this, d, e, f, g, !1)) && (h = b.points.copy(), gg(this, d, e, f, g, !0) ? (h.Vc(c - 1, new I(d.x, (d.y + g.y) / 2)), h.Vc(c + 2, new I(g.x, (d.y + g.y) / 2))) : (h.Vc(c - 1, new I((d.x + g.x) / 2, d.y)), h.Vc(c + 2, new I((d.x + g.x) / 2, g.y))), h.mb(c + 1), h.mb(c), b.points = h, b.Rb());\n          }\n        } else g = I.alloc(), J.fh(d.x, d.y, f.x, f.y, e.x, e.y, g) && g.rf(e) < this.resegmentingDistance * this.resegmentingDistance && (d = b.points.copy(), d.mb(c), b.points = d, b.Rb()), I.free(g);\n      }\n\n      a.Va();\n      this.transactionResult = this.name;\n      a.P(\"LinkReshaped\", this.adornedLink, this.xq);\n    }\n\n    this.stopTool();\n  };\n\n  function gg(a, b, c, d, e, f) {\n    return f ? Math.abs(b.y - c.y) < a.resegmentingDistance && Math.abs(c.y - d.y) < a.resegmentingDistance && Math.abs(d.y - e.y) < a.resegmentingDistance : Math.abs(b.x - c.x) < a.resegmentingDistance && Math.abs(c.x - d.x) < a.resegmentingDistance && Math.abs(d.x - e.x) < a.resegmentingDistance;\n  }\n\n  ag.prototype.reshape = function (a) {\n    var b = this.adornedLink;\n    b.jh();\n    var c = this.handle.segmentIndex,\n        d = this.Du(this.handle);\n    if (b.isOrthogonal) {\n      if (c === b.firstPickIndex + 1) c = b.firstPickIndex + 1, d === dg ? (b.M(c, b.i(c - 1).x, a.y), b.M(c + 1, b.i(c + 2).x, a.y)) : d === eg && (b.M(c, a.x, b.i(c - 1).y), b.M(c + 1, a.x, b.i(c + 2).y));else if (c === b.lastPickIndex - 1) c = b.lastPickIndex - 1, d === dg ? (b.M(c - 1, b.i(c - 2).x, a.y), b.M(c, b.i(c + 1).x, a.y)) : d === eg && (b.M(c - 1, a.x, b.i(c - 2).y), b.M(c, a.x, b.i(c + 1).y));else {\n        d = c;\n        var e = b.i(d),\n            f = b.i(d - 1),\n            g = b.i(d + 1);\n        J.B(f.x, e.x) && J.B(e.y, g.y) ? (J.B(f.x, b.i(d - 2).x) && !J.B(f.y, b.i(d - 2).y) ? (b.l(d, a.x, f.y), c++, d++) : b.M(d - 1, a.x, f.y), J.B(g.y, b.i(d + 2).y) && !J.B(g.x, b.i(d + 2).x) ? b.l(d + 1, g.x, a.y) : b.M(d + 1, g.x, a.y)) : J.B(f.y, e.y) && J.B(e.x, g.x) ? (J.B(f.y, b.i(d - 2).y) && !J.B(f.x, b.i(d - 2).x) ? (b.l(d, f.x, a.y), c++, d++) : b.M(d - 1, f.x, a.y), J.B(g.x, b.i(d + 2).x) && !J.B(g.y, b.i(d + 2).y) ? b.l(d + 1, a.x, g.y) : b.M(d + 1, a.x, g.y)) : J.B(f.x, e.x) && J.B(e.x, g.x) ? (J.B(f.x, b.i(d - 2).x) && !J.B(f.y, b.i(d - 2).y) ? (b.l(d, a.x, f.y), c++, d++) : b.M(d - 1, a.x, f.y), J.B(g.x, b.i(d + 2).x) && !J.B(g.y, b.i(d + 2).y) ? b.l(d + 1, a.x, g.y) : b.M(d + 1, a.x, g.y)) : J.B(f.y, e.y) && J.B(e.y, g.y) && (J.B(f.y, b.i(d - 2).y) && !J.B(f.x, b.i(d - 2).x) ? (b.l(d, f.x, a.y), c++, d++) : b.M(d - 1, f.x, a.y), J.B(g.y, b.i(d + 2).y) && !J.B(g.x, b.i(d + 2).x) ? b.l(d + 1, g.x, a.y) : b.M(d + 1, g.x, a.y));\n        b.M(c, a.x, a.y);\n      }\n    } else b.M(c, a.x, a.y), d = b.fromNode, e = b.fromPort, null !== d && (f = d.findVisibleNode(), null !== f && f !== d && (d = f, e = d.port)), 1 === c && b.computeSpot(!0, e).Fc() && (f = e.ia(yc, I.alloc()), d = b.getLinkPointFromPoint(d, e, f, a, !0, I.alloc()), b.M(0, d.x, d.y), I.free(f), I.free(d)), d = b.toNode, e = b.toPort, null !== d && (f = d.findVisibleNode(), null !== f && f !== d && (d = f, e = d.port)), c === b.pointsCount - 2 && b.computeSpot(!1, e).Fc() && (c = e.ia(yc, I.alloc()), a = b.getLinkPointFromPoint(d, e, c, a, !1, I.alloc()), b.M(b.pointsCount - 1, a.x, a.y), I.free(c), I.free(a));\n    b.pf();\n  };\n\n  ag.prototype.computeReshape = function (a) {\n    var b = this.adornedLink,\n        c = this.handle.segmentIndex;\n\n    switch (this.Du(this.handle)) {\n      case fg:\n        return a;\n\n      case dg:\n        return new I(b.i(c).x, a.y);\n\n      case eg:\n        return new I(a.x, b.i(c).y);\n\n      default:\n      case bg:\n        return b.i(c);\n    }\n  };\n\n  ma.Object.defineProperties(ag.prototype, {\n    handleArchetype: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        this.m = a;\n      }\n    },\n    midHandleArchetype: {\n      get: function get() {\n        return this.u;\n      },\n      set: function set(a) {\n        this.u = a;\n      }\n    },\n    handle: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        if (null !== a && !(a.part instanceof ue)) throw Error(\"new handle is not in an Adornment: \" + a);\n        this.j = a;\n      }\n    },\n    adornedLink: {\n      get: function get() {\n        return this.vs;\n      }\n    },\n    resegmentingDistance: {\n      get: function get() {\n        return this.F;\n      },\n      set: function set(a) {\n        this.F = a;\n      }\n    },\n    originalPoint: {\n      get: function get() {\n        return this.jw;\n      }\n    },\n    originalPoints: {\n      get: function get() {\n        return this.xq;\n      }\n    }\n  });\n  ag.prototype.setReshapingBehavior = ag.prototype.Wl;\n  ag.prototype.getReshapingBehavior = ag.prototype.Du;\n  var bg = new D(ag, \"None\", 0),\n      eg = new D(ag, \"Horizontal\", 1),\n      dg = new D(ag, \"Vertical\", 2),\n      fg = new D(ag, \"All\", 3);\n  ag.className = \"LinkReshapingTool\";\n  ag.None = bg;\n  ag.Horizontal = eg;\n  ag.Vertical = dg;\n  ag.All = fg;\n  Ka(\"linkReshapingTool\", function () {\n    return this.findTool(\"LinkReshaping\");\n  }, function (a) {\n    this.gb(\"LinkReshaping\", a, this.mouseDownTools);\n  });\n\n  function hg() {\n    ke.call(this);\n    this.name = \"Resizing\";\n    this.m = new K(1, 1).freeze();\n    this.j = new K(9999, 9999).freeze();\n    this.pg = new K(NaN, NaN).freeze();\n    this.W = !1;\n    this.ga = !0;\n    this.me = null;\n    var a = new Cf();\n    a.alignmentFocus = yc;\n    a.figure = \"Rectangle\";\n    a.desiredSize = Ib;\n    a.fill = \"lightblue\";\n    a.stroke = \"dodgerblue\";\n    a.strokeWidth = 1;\n    a.cursor = \"pointer\";\n    this.F = a;\n    this.u = null;\n    this.wq = new I();\n    this.hw = new K();\n    this.An = new I();\n    this.Us = new K(0, 0);\n    this.Ts = new K(Infinity, Infinity);\n    this.Ss = new K(1, 1);\n  }\n\n  la(hg, ke);\n\n  hg.prototype.updateAdornments = function (a) {\n    if (!(null === a || a instanceof T)) {\n      if (a.isSelected && !this.diagram.isReadOnly) {\n        var b = a.resizeObject,\n            c = a.Hj(this.name);\n\n        if (null !== b && a.canResize() && a.actualBounds.v() && a.isVisible() && b.actualBounds.v() && b.zf()) {\n          if (null === c || c.adornedObject !== b) c = this.makeAdornment(b);\n\n          if (null !== c) {\n            b = b.fi();\n            ig(a) && this.updateResizeHandles(c, b);\n            a.Tg(this.name, c);\n            return;\n          }\n        }\n      }\n\n      a.Af(this.name);\n    }\n  };\n\n  hg.prototype.makeAdornment = function (a) {\n    var b = a.part.resizeAdornmentTemplate;\n\n    if (null === b) {\n      b = new ue();\n      b.type = W.Spot;\n      b.locationSpot = yc;\n      var c = new jg();\n      c.isPanelMain = !0;\n      b.add(c);\n      b.add(this.makeHandle(a, tc));\n      b.add(this.makeHandle(a, vc));\n      b.add(this.makeHandle(a, Cc));\n      b.add(this.makeHandle(a, Ac));\n      b.add(this.makeHandle(a, ad));\n      b.add(this.makeHandle(a, ed));\n      b.add(this.makeHandle(a, fd));\n      b.add(this.makeHandle(a, dd));\n    } else if (kg(b), b = b.copy(), null === b) return null;\n\n    b.adornedObject = a;\n    return b;\n  };\n\n  hg.prototype.makeHandle = function (a, b) {\n    a = this.handleArchetype;\n    if (null === a) return null;\n    a = a.copy();\n    a.alignment = b;\n    return a;\n  };\n\n  hg.prototype.updateResizeHandles = function (a, b) {\n    if (null !== a) if (!a.alignment.Sb() && (\"pointer\" === a.cursor || 0 < a.cursor.indexOf(\"resize\"))) a: {\n      var c = a.alignment;\n      c.Fc() && (c = yc);\n      if (0 >= c.x) b = 0 >= c.y ? b + 225 : 1 <= c.y ? b + 135 : b + 180;else if (1 <= c.x) 0 >= c.y ? b += 315 : 1 <= c.y && (b += 45);else if (0 >= c.y) b += 270;else if (1 <= c.y) b += 90;else break a;\n      0 > b ? b += 360 : 360 <= b && (b -= 360);\n      a.cursor = 22.5 > b ? \"e-resize\" : 67.5 > b ? \"se-resize\" : 112.5 > b ? \"s-resize\" : 157.5 > b ? \"sw-resize\" : 202.5 > b ? \"w-resize\" : 247.5 > b ? \"nw-resize\" : 292.5 > b ? \"n-resize\" : 337.5 > b ? \"ne-resize\" : \"e-resize\";\n    } else if (a instanceof W) for (a = a.elements; a.next();) {\n      this.updateResizeHandles(a.value, b);\n    }\n  };\n\n  hg.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    return !a.isReadOnly && a.allowResize && a.lastInput.left ? null !== this.findToolHandleAt(a.firstInput.documentPoint, this.name) : !1;\n  };\n\n  hg.prototype.doActivate = function () {\n    var a = this.diagram;\n    null === this.handle && (this.handle = this.findToolHandleAt(a.firstInput.documentPoint, this.name));\n    null !== this.handle && (this.adornedObject = this.handle.part.adornedObject, null !== this.adornedObject && (a.isMouseCaptured = !0, a.animationManager.wc(), this.Da(this.name), this.wq.set(this.adornedObject.ia(this.handle.alignment.Qu())), this.An.set(this.adornedObject.part.location), this.hw.set(this.adornedObject.desiredSize), this.Ss = this.computeCellSize(), this.Us = this.computeMinSize(), this.Ts = this.computeMaxSize(), this.isActive = !0));\n  };\n\n  hg.prototype.doDeactivate = function () {\n    var a = this.diagram;\n    this.stopTransaction();\n    this.me = this.handle = null;\n    this.isActive = a.isMouseCaptured = !1;\n  };\n\n  hg.prototype.stopTransaction = function () {\n    var a = this.diagram,\n        b = ke.prototype.stopTransaction.call(this);\n    b && null !== a.undoManager.transactionToUndo && a.undoManager.transactionToUndo.Vj();\n    return b;\n  };\n\n  hg.prototype.doCancel = function () {\n    null !== this.adornedObject && (this.adornedObject.desiredSize = this.originalDesiredSize, this.adornedObject.part.location = this.originalLocation);\n    this.stopTool();\n  };\n\n  hg.prototype.doMouseMove = function () {\n    var a = this.diagram;\n\n    if (this.isActive) {\n      var b = this.Us,\n          c = this.Ts,\n          d = this.Ss,\n          e = this.adornedObject.Nr(a.lastInput.documentPoint, I.alloc()),\n          f = this.computeReshape();\n      b = this.computeResize(e, this.handle.alignment, b, c, d, f);\n      this.resize(b);\n      a.nd();\n      I.free(e);\n    }\n  };\n\n  hg.prototype.doMouseUp = function () {\n    var a = this.diagram;\n\n    if (this.isActive) {\n      var b = this.Us,\n          c = this.Ts,\n          d = this.Ss,\n          e = this.adornedObject.Nr(a.lastInput.documentPoint, I.alloc()),\n          f = this.computeReshape();\n      b = this.computeResize(e, this.handle.alignment, b, c, d, f);\n      this.resize(b);\n      I.free(e);\n      a.Va();\n      this.transactionResult = this.name;\n      a.P(\"PartResized\", this.adornedObject, this.originalDesiredSize);\n    }\n\n    this.stopTool();\n  };\n\n  hg.prototype.resize = function (a) {\n    var b = this.diagram,\n        c = this.adornedObject;\n\n    if (null !== c) {\n      c.desiredSize = a.size;\n      a = c.part;\n      a.Za();\n      c = c.ia(this.handle.alignment.Qu());\n\n      if (a instanceof qf) {\n        var d = new E();\n        d.add(a);\n\n        if (!this.dragsMembers && null === a.placeholder) {\n          var e = new Ce();\n          e.dragsMembers = !1;\n        }\n\n        b.moveParts(d, this.oppositePoint.copy().je(c), !0, e);\n      } else a.location = a.location.copy().je(c).add(this.oppositePoint);\n\n      b.nd();\n    }\n  };\n\n  hg.prototype.computeResize = function (a, b, c, d, e, f) {\n    b.Fc() && (b = yc);\n    var g = this.adornedObject.naturalBounds,\n        h = g.x,\n        k = g.y,\n        l = g.x + g.width,\n        m = g.y + g.height,\n        n = 1;\n\n    if (!f) {\n      n = g.width;\n      var p = g.height;\n      0 >= n && (n = 1);\n      0 >= p && (p = 1);\n      n = p / n;\n    }\n\n    p = I.alloc();\n    J.so(a.x, a.y, h, k, e.width, e.height, p);\n    a = g.copy();\n    0 >= b.x ? 0 >= b.y ? (a.x = Math.max(p.x, l - d.width), a.x = Math.min(a.x, l - c.width), a.width = Math.max(l - a.x, c.width), a.y = Math.max(p.y, m - d.height), a.y = Math.min(a.y, m - c.height), a.height = Math.max(m - a.y, c.height), f || (1 <= a.height / a.width ? (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n) : (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width), a.x = l - a.width, a.y = m - a.height)) : 1 <= b.y ? (a.x = Math.max(p.x, l - d.width), a.x = Math.min(a.x, l - c.width), a.width = Math.max(l - a.x, c.width), a.height = Math.max(Math.min(p.y - k, d.height), c.height), f || (1 <= a.height / a.width ? (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n) : (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width), a.x = l - a.width)) : (a.x = Math.max(p.x, l - d.width), a.x = Math.min(a.x, l - c.width), a.width = l - a.x, f || (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n, a.y = k + .5 * (m - k - a.height))) : 1 <= b.x ? 0 >= b.y ? (a.width = Math.max(Math.min(p.x - h, d.width), c.width), a.y = Math.max(p.y, m - d.height), a.y = Math.min(a.y, m - c.height), a.height = Math.max(m - a.y, c.height), f || (1 <= a.height / a.width ? (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n) : (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width), a.y = m - a.height)) : 1 <= b.y ? (a.width = Math.max(Math.min(p.x - h, d.width), c.width), a.height = Math.max(Math.min(p.y - k, d.height), c.height), f || (1 <= a.height / a.width ? (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n) : (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width))) : (a.width = Math.max(Math.min(p.x - h, d.width), c.width), f || (a.height = Math.max(Math.min(n * a.width, d.height), c.height), a.width = a.height / n, a.y = k + .5 * (m - k - a.height))) : 0 >= b.y ? (a.y = Math.max(p.y, m - d.height), a.y = Math.min(a.y, m - c.height), a.height = m - a.y, f || (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width, a.x = h + .5 * (l - h - a.width))) : 1 <= b.y && (a.height = Math.max(Math.min(p.y - k, d.height), c.height), f || (a.width = Math.max(Math.min(a.height / n, d.width), c.width), a.height = n * a.width, a.x = h + .5 * (l - h - a.width)));\n    I.free(p);\n    return a;\n  };\n\n  hg.prototype.computeReshape = function () {\n    var a = lg;\n    this.adornedObject instanceof Cf && (a = mg(this.adornedObject));\n    return !(a === ng || this.diagram.lastInput.shift);\n  };\n\n  hg.prototype.computeMinSize = function () {\n    var a = this.adornedObject.minSize.copy(),\n        b = this.minSize;\n    !isNaN(b.width) && b.width > a.width && (a.width = b.width);\n    !isNaN(b.height) && b.height > a.height && (a.height = b.height);\n    return a;\n  };\n\n  hg.prototype.computeMaxSize = function () {\n    var a = this.adornedObject.maxSize.copy(),\n        b = this.maxSize;\n    !isNaN(b.width) && b.width < a.width && (a.width = b.width);\n    !isNaN(b.height) && b.height < a.height && (a.height = b.height);\n    return a;\n  };\n\n  hg.prototype.computeCellSize = function () {\n    var a = new K(NaN, NaN),\n        b = this.adornedObject.part;\n    null !== b && (b = b.resizeCellSize, !isNaN(b.width) && 0 < b.width && (a.width = b.width), !isNaN(b.height) && 0 < b.height && (a.height = b.height));\n    b = this.cellSize;\n    isNaN(a.width) && !isNaN(b.width) && 0 < b.width && (a.width = b.width);\n    isNaN(a.height) && !isNaN(b.height) && 0 < b.height && (a.height = b.height);\n    b = this.diagram;\n    (isNaN(a.width) || isNaN(a.height)) && b && (b = b.grid, null !== b && b.visible && this.isGridSnapEnabled && (b = b.gridCellSize, isNaN(a.width) && !isNaN(b.width) && 0 < b.width && (a.width = b.width), isNaN(a.height) && !isNaN(b.height) && 0 < b.height && (a.height = b.height)));\n    if (isNaN(a.width) || 0 === a.width || Infinity === a.width) a.width = 1;\n    if (isNaN(a.height) || 0 === a.height || Infinity === a.height) a.height = 1;\n    return a;\n  };\n\n  ma.Object.defineProperties(hg.prototype, {\n    handleArchetype: {\n      get: function get() {\n        return this.F;\n      },\n      set: function set(a) {\n        this.F = a;\n      }\n    },\n    handle: {\n      get: function get() {\n        return this.u;\n      },\n      set: function set(a) {\n        if (null !== a && !(a.part instanceof ue)) throw Error(\"new handle is not in an Adornment: \" + a);\n        this.u = a;\n      }\n    },\n    adornedObject: {\n      get: function get() {\n        return this.me;\n      },\n      set: function set(a) {\n        if (null !== a && a.part instanceof ue) throw Error(\"new handle must not be in an Adornment: \" + a);\n        this.me = a;\n      }\n    },\n    minSize: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        if (!this.m.C(a)) {\n          var b = a.width;\n          isNaN(b) && (b = 0);\n          a = a.height;\n          isNaN(a) && (a = 0);\n          this.m.h(b, a);\n        }\n      }\n    },\n    maxSize: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        if (!this.j.C(a)) {\n          var b = a.width;\n          isNaN(b) && (b = Infinity);\n          a = a.height;\n          isNaN(a) && (a = Infinity);\n          this.j.h(b, a);\n        }\n      }\n    },\n    cellSize: {\n      get: function get() {\n        return this.pg;\n      },\n      set: function set(a) {\n        this.pg.C(a) || this.pg.assign(a);\n      }\n    },\n    isGridSnapEnabled: {\n      get: function get() {\n        return this.W;\n      },\n      set: function set(a) {\n        this.W = a;\n      }\n    },\n    dragsMembers: {\n      get: function get() {\n        return this.ga;\n      },\n      set: function set(a) {\n        this.ga = a;\n      }\n    },\n    oppositePoint: {\n      get: function get() {\n        return this.wq;\n      },\n      set: function set(a) {\n        this.wq.C(a) || this.wq.assign(a);\n      }\n    },\n    originalDesiredSize: {\n      get: function get() {\n        return this.hw;\n      }\n    },\n    originalLocation: {\n      get: function get() {\n        return this.An;\n      }\n    }\n  });\n  hg.className = \"ResizingTool\";\n  Ka(\"resizingTool\", function () {\n    return this.findTool(\"Resizing\");\n  }, function (a) {\n    this.gb(\"Resizing\", a, this.mouseDownTools);\n  });\n\n  function og() {\n    ke.call(this);\n    this.name = \"Rotating\";\n    this.ga = 45;\n    this.W = 2;\n    this.An = new I();\n    this.me = null;\n    var a = new Cf();\n    a.figure = \"Ellipse\";\n    a.desiredSize = Jb;\n    a.fill = \"lightblue\";\n    a.stroke = \"dodgerblue\";\n    a.strokeWidth = 1;\n    a.cursor = \"pointer\";\n    this.m = a;\n    this.j = null;\n    this.gw = 0;\n    this.Jq = new I(NaN, NaN);\n    this.u = 0;\n    this.F = 50;\n  }\n\n  la(og, ke);\n\n  og.prototype.updateAdornments = function (a) {\n    if (null !== a) {\n      if (a.eh()) {\n        var b = a.rotateObject;\n        if (b === a || b === a.path || b.isPanelMain) return;\n      }\n\n      if (a.isSelected && !this.diagram.isReadOnly && (b = a.rotateObject, null !== b && a.canRotate() && a.actualBounds.v() && a.isVisible() && b.actualBounds.v() && b.zf())) {\n        var c = a.Hj(this.name);\n        if (null === c || c.adornedObject !== b) c = this.makeAdornment(b);\n\n        if (null !== c) {\n          c.angle = b.fi();\n          null === c.placeholder && (c.location = this.computeAdornmentLocation(b));\n          a.Tg(this.name, c);\n          return;\n        }\n      }\n\n      a.Af(this.name);\n    }\n  };\n\n  og.prototype.makeAdornment = function (a) {\n    var b = a.part.rotateAdornmentTemplate;\n\n    if (null === b) {\n      b = new ue();\n      b.type = W.Position;\n      b.locationSpot = yc;\n      var c = this.handleArchetype;\n      null !== c && b.add(c.copy());\n    } else if (kg(b), b = b.copy(), null === b) return null;\n\n    b.adornedObject = a;\n    return b;\n  };\n\n  og.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    return !a.isReadOnly && a.allowRotate && a.lastInput.left ? null !== this.findToolHandleAt(a.firstInput.documentPoint, this.name) : !1;\n  };\n\n  og.prototype.doActivate = function () {\n    var a = this.diagram;\n\n    if (null === this.adornedObject) {\n      null === this.handle && (this.handle = this.findToolHandleAt(a.firstInput.documentPoint, this.name));\n      if (null === this.handle) return;\n      this.adornedObject = this.handle.part.adornedObject;\n    }\n\n    null !== this.adornedObject && (a.isMouseCaptured = !0, a.delaysLayout = !0, this.Da(this.name), this.gw = this.adornedObject.angle, this.Jq = this.computeRotationPoint(this.adornedObject), this.An = this.adornedObject.part.location.copy(), this.isActive = !0);\n  };\n\n  og.prototype.computeRotationPoint = function (a) {\n    var b = a.part,\n        c = b.locationObject;\n    return b.rotationSpot.pb() ? a.ia(b.rotationSpot) : a === b || a === c ? c.ia(b.locationSpot) : a.ia(yc);\n  };\n\n  og.prototype.computeAdornmentLocation = function (a) {\n    var b = this.rotationPoint;\n    b.v() || (b = this.computeRotationPoint(a));\n    b = a.Nr(b);\n    var c = this.handleAngle;\n    0 > c ? c += 360 : 360 <= c && (c -= 360);\n    c = Math.round(45 * Math.round(c / 45));\n    var d = this.handleDistance;\n    0 === c ? b.x = a.naturalBounds.width + d : 45 === c ? (b.x = a.naturalBounds.width + d, b.y = a.naturalBounds.height + d) : 90 === c ? b.y = a.naturalBounds.height + d : 135 === c ? (b.x = -d, b.y = a.naturalBounds.height + d) : 180 === c ? b.x = -d : 225 === c ? (b.x = -d, b.y = -d) : 270 === c ? b.y = -d : 315 === c && (b.x = a.naturalBounds.width + d, b.y = -d);\n    return a.ia(b);\n  };\n\n  og.prototype.doDeactivate = function () {\n    var a = this.diagram;\n    this.stopTransaction();\n    this.me = this.handle = null;\n    this.Jq = new I(NaN, NaN);\n    this.isActive = a.isMouseCaptured = !1;\n  };\n\n  og.prototype.stopTransaction = function () {\n    var a = this.diagram,\n        b = ke.prototype.stopTransaction.call(this);\n    b && null !== a.undoManager.transactionToUndo && a.undoManager.transactionToUndo.Vj();\n    return b;\n  };\n\n  og.prototype.doCancel = function () {\n    this.diagram.delaysLayout = !1;\n    this.rotate(this.originalAngle);\n    this.stopTool();\n  };\n\n  og.prototype.doMouseMove = function () {\n    var a = this.diagram;\n    this.isActive && (a = this.computeRotate(a.lastInput.documentPoint), this.rotate(a));\n  };\n\n  og.prototype.doMouseUp = function () {\n    var a = this.diagram;\n\n    if (this.isActive) {\n      a.delaysLayout = !1;\n      var b = this.computeRotate(a.lastInput.documentPoint);\n      this.rotate(b);\n      a.Va();\n      this.transactionResult = this.name;\n      a.P(\"PartRotated\", this.adornedObject, this.originalAngle);\n    }\n\n    this.stopTool();\n  };\n\n  og.prototype.rotate = function (a) {\n    var b = this.adornedObject;\n\n    if (null !== b) {\n      b.angle = a;\n      b = b.part;\n      b.Za();\n      var c = b.locationObject,\n          d = b.rotateObject;\n      if (c === d || c.jg(d)) c = this.An.copy(), b.location = c.je(this.rotationPoint).rotate(a - this.originalAngle).add(this.rotationPoint);\n      this.diagram.nd();\n    }\n  };\n\n  og.prototype.computeRotate = function (a) {\n    a = this.rotationPoint.Ya(a) - this.handleAngle;\n    var b = this.adornedObject.panel;\n    null !== b && (a -= b.fi());\n    360 <= a ? a -= 360 : 0 > a && (a += 360);\n    b = Math.min(Math.abs(this.snapAngleMultiple), 180);\n    var c = Math.min(Math.abs(this.snapAngleEpsilon), b / 2);\n    !this.diagram.lastInput.shift && 0 < b && 0 < c && (a % b < c ? a = Math.floor(a / b) * b : a % b > b - c && (a = (Math.floor(a / b) + 1) * b));\n    360 <= a ? a -= 360 : 0 > a && (a += 360);\n    return a;\n  };\n\n  ma.Object.defineProperties(og.prototype, {\n    handleArchetype: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        this.m = a;\n      }\n    },\n    handle: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        if (null !== a && !(a.part instanceof ue)) throw Error(\"new handle is not in an Adornment: \" + a);\n        this.j = a;\n      }\n    },\n    adornedObject: {\n      get: function get() {\n        return this.me;\n      },\n      set: function set(a) {\n        if (null !== a && a.part instanceof ue) throw Error(\"new handle must not be in an Adornment: \" + a);\n        this.me = a;\n      }\n    },\n    snapAngleMultiple: {\n      get: function get() {\n        return this.ga;\n      },\n      set: function set(a) {\n        this.ga = a;\n      }\n    },\n    snapAngleEpsilon: {\n      get: function get() {\n        return this.W;\n      },\n      set: function set(a) {\n        this.W = a;\n      }\n    },\n    originalAngle: {\n      get: function get() {\n        return this.gw;\n      }\n    },\n    rotationPoint: {\n      get: function get() {\n        return this.Jq;\n      },\n      set: function set(a) {\n        this.Jq = a.copy();\n      }\n    },\n    handleAngle: {\n      get: function get() {\n        return this.u;\n      },\n      set: function set(a) {\n        this.u = a;\n      }\n    },\n    handleDistance: {\n      get: function get() {\n        return this.F;\n      },\n      set: function set(a) {\n        this.F = a;\n      }\n    }\n  });\n  og.className = \"RotatingTool\";\n  Ka(\"rotatingTool\", function () {\n    return this.findTool(\"Rotating\");\n  }, function (a) {\n    this.gb(\"Rotating\", a, this.mouseDownTools);\n  });\n\n  function pg() {\n    ke.call(this);\n    this.name = \"ClickSelecting\";\n  }\n\n  la(pg, ke);\n\n  pg.prototype.canStart = function () {\n    return !this.isEnabled || this.isBeyondDragSize() ? !1 : !0;\n  };\n\n  pg.prototype.doMouseUp = function () {\n    this.isActive && (this.standardMouseSelect(), !this.standardMouseClick() && this.diagram.lastInput.isTouchEvent && this.diagram.toolManager.doToolTip());\n    this.stopTool();\n  };\n\n  pg.className = \"ClickSelectingTool\";\n\n  function qg() {\n    ke.call(this);\n    this.name = \"Action\";\n    this.ck = null;\n  }\n\n  la(qg, ke);\n\n  qg.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram,\n        b = a.lastInput,\n        c = a.ec(b.documentPoint, function (a) {\n      for (; null !== a.panel && !a.isActionable;) {\n        a = a.panel;\n      }\n\n      return a;\n    });\n\n    if (null !== c) {\n      if (!c.isActionable) return !1;\n      this.ck = c;\n      a.qk = a.ec(b.documentPoint, null, null);\n      return !0;\n    }\n\n    return !1;\n  };\n\n  qg.prototype.doMouseDown = function () {\n    if (this.isActive) {\n      var a = this.diagram.lastInput,\n          b = this.ck;\n      null !== b && (a.targetObject = b, null !== b.actionDown && b.actionDown(a, b));\n    } else this.canStart() && this.doActivate();\n  };\n\n  qg.prototype.doMouseMove = function () {\n    if (this.isActive) {\n      var a = this.diagram.lastInput,\n          b = this.ck;\n      null !== b && (a.targetObject = b, null !== b.actionMove && b.actionMove(a, b));\n    }\n  };\n\n  qg.prototype.doMouseUp = function () {\n    if (this.isActive) {\n      var a = this.diagram.lastInput,\n          b = this.ck;\n      if (null === b) return;\n      a.targetObject = b;\n      null !== b.actionUp && b.actionUp(a, b);\n      this.standardMouseClick(function (a) {\n        for (; null !== a.panel && (!a.isActionable || a !== b);) {\n          a = a.panel;\n        }\n\n        return a;\n      }, function (a) {\n        return a === b;\n      });\n    }\n\n    this.stopTool();\n  };\n\n  qg.prototype.doCancel = function () {\n    var a = this.diagram.lastInput,\n        b = this.ck;\n    null !== b && (a.targetObject = b, null !== b.actionCancel && b.actionCancel(a, b), this.stopTool());\n  };\n\n  qg.prototype.doStop = function () {\n    this.ck = null;\n  };\n\n  qg.className = \"ActionTool\";\n\n  function rg() {\n    ke.call(this);\n    this.name = \"ClickCreating\";\n    this.Li = null;\n    this.m = !0;\n    this.j = !1;\n    this.Rv = new I(0, 0);\n  }\n\n  la(rg, ke);\n\n  rg.prototype.canStart = function () {\n    if (!this.isEnabled || null === this.archetypeNodeData) return !1;\n    var a = this.diagram;\n    if (a.isReadOnly || a.isModelReadOnly || !a.allowInsert || !a.lastInput.left || this.isBeyondDragSize()) return !1;\n\n    if (this.isDoubleClick) {\n      if (1 === a.lastInput.clickCount && (this.Rv = a.lastInput.viewPoint.copy()), 2 !== a.lastInput.clickCount || this.isBeyondDragSize(this.Rv)) return !1;\n    } else if (1 !== a.lastInput.clickCount) return !1;\n\n    return a.currentTool !== this && null !== a.wl(a.lastInput.documentPoint, !0) ? !1 : !0;\n  };\n\n  rg.prototype.doMouseUp = function () {\n    var a = this.diagram;\n    this.isActive && this.insertPart(a.lastInput.documentPoint);\n    this.stopTool();\n  };\n\n  rg.prototype.insertPart = function (a) {\n    var b = this.diagram,\n        c = this.archetypeNodeData;\n    if (null === c) return null;\n    var d = null;\n\n    try {\n      b.P(\"ChangingSelection\", b.selection);\n      this.Da(this.name);\n      if (c instanceof U) c.Tc() && (kg(c), d = c.copy(), null !== d && b.add(d));else if (null !== c) {\n        var e = b.model.copyNodeData(c);\n        ya(e) && (b.model.lf(e), d = b.Ec(e));\n      }\n\n      if (null !== d) {\n        var f = I.allocAt(a.x, a.y);\n        this.isGridSnapEnabled && Ag(this.diagram, d, a, f);\n        d.location = f;\n        b.allowSelect && (b.clearSelection(!0), d.isSelected = !0);\n        I.free(f);\n      }\n\n      b.Va();\n      this.transactionResult = this.name;\n      b.P(\"PartCreated\", d);\n    } finally {\n      this.stopTransaction(), b.P(\"ChangedSelection\", b.selection);\n    }\n\n    return d;\n  };\n\n  ma.Object.defineProperties(rg.prototype, {\n    archetypeNodeData: {\n      get: function get() {\n        return this.Li;\n      },\n      set: function set(a) {\n        this.Li = a;\n      }\n    },\n    isDoubleClick: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        this.m = a;\n      }\n    },\n    isGridSnapEnabled: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        this.j = a;\n      }\n    }\n  });\n  rg.className = \"ClickCreatingTool\";\n\n  function Bg() {\n    ke.call(this);\n    this.name = \"DragSelecting\";\n    this.wk = 175;\n    this.m = !1;\n    var a = new U();\n    a.layerName = \"Tool\";\n    a.selectable = !1;\n    var b = new Cf();\n    b.name = \"SHAPE\";\n    b.figure = \"Rectangle\";\n    b.fill = null;\n    b.stroke = \"magenta\";\n    a.add(b);\n    this.j = a;\n  }\n\n  la(Bg, ke);\n\n  Bg.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    if (!a.allowSelect) return !1;\n    var b = a.lastInput;\n    return !b.left || a.currentTool !== this && (!this.isBeyondDragSize() || b.timestamp - a.firstInput.timestamp < this.delay || null !== a.wl(b.documentPoint, !0)) ? !1 : !0;\n  };\n\n  Bg.prototype.doActivate = function () {\n    var a = this.diagram;\n    this.isActive = !0;\n    a.isMouseCaptured = !0;\n    a.skipsUndoManager = !0;\n    a.add(this.box);\n    this.doMouseMove();\n  };\n\n  Bg.prototype.doDeactivate = function () {\n    var a = this.diagram;\n    a.lg();\n    a.remove(this.box);\n    a.skipsUndoManager = !1;\n    this.isActive = a.isMouseCaptured = !1;\n  };\n\n  Bg.prototype.doMouseMove = function () {\n    var a = this.diagram;\n\n    if (this.isActive && null !== this.box) {\n      var b = this.computeBoxBounds(),\n          c = this.box.fb(\"SHAPE\");\n      null === c && (c = this.box.vb());\n      var d = K.alloc().h(b.width, b.height);\n      c.desiredSize = d;\n      this.box.Ul(b.x, b.y, !1);\n      K.free(d);\n      (a.allowHorizontalScroll || a.allowVerticalScroll) && a.Fr(a.lastInput.viewPoint);\n    }\n  };\n\n  Bg.prototype.doMouseUp = function () {\n    if (this.isActive) {\n      var a = this.diagram;\n      a.remove(this.box);\n\n      try {\n        a.currentCursor = \"wait\", a.P(\"ChangingSelection\", a.selection), this.selectInRect(this.computeBoxBounds()), a.P(\"ChangedSelection\", a.selection);\n      } finally {\n        a.currentCursor = \"\";\n      }\n    }\n\n    this.stopTool();\n  };\n\n  Bg.prototype.computeBoxBounds = function () {\n    var a = this.diagram;\n    return new M(a.firstInput.documentPoint, a.lastInput.documentPoint);\n  };\n\n  Bg.prototype.selectInRect = function (a) {\n    var b = this.diagram,\n        c = b.lastInput;\n    a = b.Ww(a, this.isPartialInclusion);\n    if (Qa ? c.meta : c.control) {\n      if (c.shift) for (a = a.iterator; a.next();) {\n        b = a.value, b.isSelected && (b.isSelected = !1);\n      } else for (a = a.iterator; a.next();) {\n        b = a.value, b.isSelected = !b.isSelected;\n      }\n    } else if (c.shift) for (a = a.iterator; a.next();) {\n      b = a.value, b.isSelected || (b.isSelected = !0);\n    } else {\n      c = new E();\n\n      for (b = b.selection.iterator; b.next();) {\n        var d = b.value;\n        a.contains(d) || c.add(d);\n      }\n\n      for (b = c.iterator; b.next();) {\n        b.value.isSelected = !1;\n      }\n\n      for (a = a.iterator; a.next();) {\n        b = a.value, b.isSelected || (b.isSelected = !0);\n      }\n    }\n  };\n\n  ma.Object.defineProperties(Bg.prototype, {\n    delay: {\n      get: function get() {\n        return this.wk;\n      },\n      set: function set(a) {\n        this.wk = a;\n      }\n    },\n    isPartialInclusion: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        this.m = a;\n      }\n    },\n    box: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        this.j = a;\n      }\n    }\n  });\n  Bg.className = \"DragSelectingTool\";\n\n  function Cg() {\n    ke.call(this);\n    this.name = \"Panning\";\n    this.Ct = new I();\n    this.ey = new I();\n    this.og = !1;\n    var a = this;\n\n    this.ow = function () {\n      var b = a.diagram;\n      null !== b && b.removeEventListener(x.document, \"scroll\", a.ow, !1);\n      a.stopTool();\n    };\n  }\n\n  la(Cg, ke);\n\n  Cg.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    return !a.allowHorizontalScroll && !a.allowVerticalScroll || !a.lastInput.left || a.currentTool !== this && !this.isBeyondDragSize() ? !1 : !0;\n  };\n\n  Cg.prototype.doActivate = function () {\n    var a = this.diagram;\n    this.og ? (a.lastInput.bubbles = !0, a.addEventListener(x.document, \"scroll\", this.ow, !1)) : (a.currentCursor = \"move\", a.isMouseCaptured = !0, this.Ct.assign(a.position));\n    this.isActive = !0;\n  };\n\n  Cg.prototype.doDeactivate = function () {\n    var a = this.diagram;\n    a.currentCursor = \"\";\n    this.isActive = a.isMouseCaptured = !1;\n  };\n\n  Cg.prototype.doCancel = function () {\n    var a = this.diagram;\n    a.position = this.Ct;\n    a.isMouseCaptured = !1;\n    this.stopTool();\n  };\n\n  Cg.prototype.doMouseMove = function () {\n    this.move();\n  };\n\n  Cg.prototype.doMouseUp = function () {\n    this.move();\n    this.stopTool();\n  };\n\n  Cg.prototype.move = function () {\n    var a = this.diagram;\n    if (this.isActive && a) if (this.og) a.lastInput.bubbles = !0;else {\n      var b = a.position,\n          c = a.firstInput.documentPoint,\n          d = a.lastInput.documentPoint,\n          e = b.x + c.x - d.x;\n      c = b.y + c.y - d.y;\n      a.allowHorizontalScroll || (e = b.x);\n      a.allowVerticalScroll || (c = b.y);\n      a.position = this.ey.h(e, c);\n    }\n  };\n\n  ma.Object.defineProperties(Cg.prototype, {\n    bubbles: {\n      get: function get() {\n        return this.og;\n      },\n      set: function set(a) {\n        this.og = a;\n      }\n    },\n    originalPosition: {\n      get: function get() {\n        return this.Ct;\n      }\n    }\n  });\n  Cg.className = \"PanningTool\";\n  Ka(\"clickCreatingTool\", function () {\n    return this.findTool(\"ClickCreating\");\n  }, function (a) {\n    this.gb(\"ClickCreating\", a, this.mouseUpTools);\n  });\n  Ka(\"clickSelectingTool\", function () {\n    return this.findTool(\"ClickSelecting\");\n  }, function (a) {\n    this.gb(\"ClickSelecting\", a, this.mouseUpTools);\n  });\n  Ka(\"panningTool\", function () {\n    return this.findTool(\"Panning\");\n  }, function (a) {\n    this.gb(\"Panning\", a, this.mouseMoveTools);\n  });\n  Ka(\"dragSelectingTool\", function () {\n    return this.findTool(\"DragSelecting\");\n  }, function (a) {\n    this.gb(\"DragSelecting\", a, this.mouseMoveTools);\n  });\n  Ka(\"actionTool\", function () {\n    return this.findTool(\"Action\");\n  }, function (a) {\n    this.gb(\"Action\", a, this.mouseDownTools);\n  });\n\n  function ze() {\n    this.F = this.u = this.j = this.m = null;\n  }\n\n  ma.Object.defineProperties(ze.prototype, {\n    mainElement: {\n      get: function get() {\n        return this.u;\n      },\n      set: function set(a) {\n        this.u = a;\n      }\n    },\n    show: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        this.m !== a && (this.m = a);\n      }\n    },\n    hide: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        this.j !== a && (this.j = a);\n      }\n    },\n    valueFunction: {\n      get: function get() {\n        return this.F;\n      },\n      set: function set(a) {\n        this.F = a;\n      }\n    }\n  });\n  ze.className = \"HTMLInfo\";\n\n  function Dg(a, b, c) {\n    this.text = a;\n    this.Kw = b;\n    this.visible = c;\n  }\n\n  Dg.className = \"ContextMenuButtonInfo\";\n\n  function Eg() {\n    ke.call(this);\n    this.name = \"ContextMenu\";\n    this.m = this.Js = this.j = null;\n    this.cw = new I();\n    this.Ls = null;\n    this.gt = !1;\n    var a = this;\n\n    this.Zt = function () {\n      a.stopTool();\n    };\n  }\n\n  la(Eg, ke);\n\n  function Fg(a) {\n    var b = new ze();\n\n    b.show = function (a, b, c) {\n      c.showDefaultContextMenu();\n    };\n\n    b.hide = function (a, b) {\n      b.hideDefaultContextMenu();\n    };\n\n    Gg = b;\n\n    a.Zt = function () {\n      a.stopTool();\n    };\n\n    b = ua(\"div\");\n    var c = ua(\"div\");\n    b.style.cssText = \"top: 0px;z-index:10002;position: fixed;display: none;text-align: center;left: 25%;width: 50%;background-color: #F5F5F5;padding: 16px;border: 16px solid #444;border-radius: 10px;margin-top: 10px\";\n    c.style.cssText = \"z-index:10001;position: fixed;display: none;top: 0;left: 0;width: 100%;height: 100%;background-color: black;opacity: 0.8;\";\n    var d = ua(\"style\");\n    x.document.getElementsByTagName(\"head\")[0].appendChild(d);\n    d.sheet.insertRule(\".goCXul { list-style: none; }\", 0);\n    d.sheet.insertRule(\".goCXli {font:700 1.5em Helvetica, Arial, sans-serif;position: relative;min-width: 60px; }\", 0);\n    d.sheet.insertRule(\".goCXa {color: #444;display: inline-block;padding: 4px;text-decoration: none;margin: 2px;border: 1px solid gray;border-radius: 10px; }\", 0);\n    d = a.diagram;\n    null !== d && (d.addEventListener(b, \"contextmenu\", Hg, !1), d.addEventListener(b, \"selectstart\", Hg, !1), d.addEventListener(c, \"contextmenu\", Hg, !1));\n    b.className = \"goCXforeground\";\n    c.className = \"goCXbackground\";\n    x.document.body && (x.document.body.appendChild(b), x.document.body.appendChild(c));\n    Ig = b;\n    Jg = c;\n    Kg = !0;\n  }\n\n  function Hg(a) {\n    a.preventDefault();\n    return !1;\n  }\n\n  Eg.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    return this.isBeyondDragSize() || !a.lastInput.right || 1 < a.lastInput.clickCount ? !1 : a.lastInput.isTouchEvent && null !== this.defaultTouchContextMenu || null !== this.findObjectWithContextMenu() ? !0 : !1;\n  };\n\n  Eg.prototype.doStart = function () {\n    this.cw.set(this.diagram.firstInput.documentPoint);\n  };\n\n  Eg.prototype.doStop = function () {\n    this.hideContextMenu();\n    this.currentObject = null;\n  };\n\n  Eg.prototype.findObjectWithContextMenu = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram,\n        c = b.lastInput,\n        d = null;\n    a instanceof Q || (a instanceof Y ? d = a : d = b.ec(c.documentPoint, null, function (a) {\n      return !a.layer.isTemporary;\n    }));\n\n    if (null !== d) {\n      for (a = d; null !== a;) {\n        if (null !== a.contextMenu) return a;\n        a = a.panel;\n      }\n\n      if (b.lastInput.isTouchEvent && this.defaultTouchContextMenu) return d.part;\n    } else if (null !== b.contextMenu) return b;\n\n    return null;\n  };\n\n  Eg.prototype.doActivate = function () {};\n\n  Eg.prototype.doMouseDown = function () {\n    ke.prototype.doMouseDown.call(this);\n\n    if (this.isActive && this.currentContextMenu instanceof ue) {\n      var a = this.diagram.toolManager.findTool(\"Action\");\n      null !== a && a.canStart() && (a.doActivate(), a.doMouseDown(), a.doDeactivate());\n    }\n\n    this.diagram.toolManager.mouseDownTools.contains(this) && Lg(this);\n  };\n\n  Eg.prototype.doMouseUp = function () {\n    if (this.isActive && this.currentContextMenu instanceof ue) {\n      var a = this.diagram.toolManager.findTool(\"Action\");\n      null !== a && a.canStart() && (a.doActivate(), a.doCancel(), a.doDeactivate());\n    }\n\n    Lg(this);\n  };\n\n  function Lg(a) {\n    var b = a.diagram;\n\n    if (a.isActive) {\n      var c = a.currentContextMenu;\n\n      if (null !== c) {\n        if (!(c instanceof ze)) {\n          var d = b.ec(b.lastInput.documentPoint, null, null);\n          null !== d && d.jg(c) && a.standardMouseClick(null, null);\n        }\n\n        a.stopTool();\n        a.canStart() && (b.currentTool = a, a.doMouseUp());\n      }\n    } else a.canStart() && (Mg(a, !0), a.isActive || a.stopTool());\n  }\n\n  function Mg(a, b, c) {\n    void 0 === c && (c = null);\n\n    if (!a.gt && (a.gt = !0, b && a.standardMouseSelect(), b = a.standardMouseClick(), a.gt = !1, !b)) {\n      a.isActive = !0;\n      b = Gg;\n      null === c && (c = a.findObjectWithContextMenu());\n\n      if (null !== c) {\n        var d = c.contextMenu;\n        null !== d ? (a.currentObject = c instanceof Y ? c : null, a.showContextMenu(d, a.currentObject)) : null !== b && a.showContextMenu(b, a.currentObject);\n      } else null !== b && a.showContextMenu(b, null);\n\n      a.currentContextMenu instanceof ue && !a.currentContextMenu.visible && a.stopTool();\n    }\n  }\n\n  Eg.prototype.doMouseMove = function () {\n    var a = this.diagram.toolManager.findTool(\"Action\");\n    null !== a && a.doMouseMove();\n    this.isActive && this.diagram.toolManager.doMouseMove();\n  };\n\n  Eg.prototype.showContextMenu = function (a, b) {\n    var c = this.diagram;\n    a !== this.currentContextMenu && this.hideContextMenu();\n\n    if (a instanceof ue) {\n      a.layerName = \"Tool\";\n      a.selectable = !1;\n      a.scale = 1 / c.scale;\n      a.category = this.name;\n      null !== a.placeholder && (a.placeholder.scale = c.scale);\n      var d = a.diagram;\n      null !== d && d !== c && d.remove(a);\n      c.add(a);\n      null !== b ? a.adornedObject = b : a.data = c.model;\n      a.Za();\n      this.positionContextMenu(a, b);\n    } else a instanceof ze && a.show(b, c, this);\n\n    this.currentContextMenu = a;\n  };\n\n  Eg.prototype.positionContextMenu = function (a) {\n    if (null === a.placeholder) {\n      var b = this.diagram,\n          c = b.lastInput.documentPoint.copy(),\n          d = a.measuredBounds,\n          e = b.viewportBounds;\n      b.lastInput.isTouchEvent && (c.x -= d.width);\n      c.x + d.width > e.right && (c.x -= d.width + 5 / b.scale);\n      c.x < e.x && (c.x = e.x);\n      c.y + d.height > e.bottom && (c.y -= d.height + 5 / b.scale);\n      c.y < e.y && (c.y = e.y);\n      a.position = c;\n    }\n  };\n\n  Eg.prototype.hideContextMenu = function () {\n    var a = this.diagram,\n        b = this.currentContextMenu;\n    null !== b && (b instanceof ue ? (a.remove(b), null !== this.Js && this.Js.Af(b.category), b.data = null, b.adornedObject = null) : b instanceof ze && (null !== b.hide ? b.hide(a, this) : null !== b.mainElement && (b.mainElement.style.display = \"none\")), this.currentContextMenu = null, this.standardMouseOver());\n  };\n\n  function Ng(a) {\n    var b = new E();\n    b.add(new Dg(\"Copy\", function (a) {\n      a.commandHandler.copySelection();\n    }, function (a) {\n      return a.commandHandler.canCopySelection();\n    }));\n    b.add(new Dg(\"Cut\", function (a) {\n      a.commandHandler.cutSelection();\n    }, function (a) {\n      return a.commandHandler.canCutSelection();\n    }));\n    b.add(new Dg(\"Delete\", function (a) {\n      a.commandHandler.deleteSelection();\n    }, function (a) {\n      return a.commandHandler.canDeleteSelection();\n    }));\n    b.add(new Dg(\"Paste\", function (b) {\n      b.commandHandler.pasteSelection(a.mouseDownPoint);\n    }, function (b) {\n      return b.commandHandler.canPasteSelection(a.mouseDownPoint);\n    }));\n    b.add(new Dg(\"Select All\", function (a) {\n      a.commandHandler.selectAll();\n    }, function (a) {\n      return a.commandHandler.canSelectAll();\n    }));\n    b.add(new Dg(\"Undo\", function (a) {\n      a.commandHandler.undo();\n    }, function (a) {\n      return a.commandHandler.canUndo();\n    }));\n    b.add(new Dg(\"Redo\", function (a) {\n      a.commandHandler.redo();\n    }, function (a) {\n      return a.commandHandler.canRedo();\n    }));\n    b.add(new Dg(\"Scroll To Part\", function (a) {\n      a.commandHandler.scrollToPart();\n    }, function (a) {\n      return a.commandHandler.canScrollToPart();\n    }));\n    b.add(new Dg(\"Zoom To Fit\", function (a) {\n      a.commandHandler.zoomToFit();\n    }, function (a) {\n      return a.commandHandler.canZoomToFit();\n    }));\n    b.add(new Dg(\"Reset Zoom\", function (a) {\n      a.commandHandler.resetZoom();\n    }, function (a) {\n      return a.commandHandler.canResetZoom();\n    }));\n    b.add(new Dg(\"Group Selection\", function (a) {\n      a.commandHandler.groupSelection();\n    }, function (a) {\n      return a.commandHandler.canGroupSelection();\n    }));\n    b.add(new Dg(\"Ungroup Selection\", function (a) {\n      a.commandHandler.ungroupSelection();\n    }, function (a) {\n      return a.commandHandler.canUngroupSelection();\n    }));\n    b.add(new Dg(\"Edit Text\", function (a) {\n      a.commandHandler.editTextBlock();\n    }, function (a) {\n      return a.commandHandler.canEditTextBlock();\n    }));\n    return b;\n  }\n\n  Eg.prototype.showDefaultContextMenu = function () {\n    var a = this.diagram;\n    null === this.Ls && (this.Ls = Ng(this));\n    Ig.innerHTML = \"\";\n    Jg.addEventListener(\"pointerdown\", this.Zt, !1);\n    var b = this,\n        c = ua(\"ul\");\n    c.className = \"goCXul\";\n    Ig.appendChild(c);\n    c.innerHTML = \"\";\n\n    for (var d = this.Ls.iterator; d.next();) {\n      var e = d.value,\n          f = e.visible;\n\n      if (\"function\" === typeof e.Kw && (\"function\" !== typeof f || f(a))) {\n        f = ua(\"li\");\n        f.className = \"goCXli\";\n        var g = ua(\"a\");\n        g.className = \"goCXa\";\n        g.href = \"#\";\n        g.Qx = e.Kw;\n        g.addEventListener(\"pointerdown\", function (c) {\n          this.Qx(a);\n          b.stopTool();\n          c.preventDefault();\n          return !1;\n        }, !1);\n        g.textContent = e.text;\n        f.appendChild(g);\n        c.appendChild(f);\n      }\n    }\n\n    Ig.style.display = \"block\";\n    Jg.style.display = \"block\";\n  };\n\n  Eg.prototype.hideDefaultContextMenu = function () {\n    if (null !== this.currentContextMenu && this.currentContextMenu === Gg) {\n      Ig.style.display = \"none\";\n      Jg.style.display = \"none\";\n      var a = this.diagram;\n      null !== a && a.removeEventListener(Jg, \"pointerdown\", this.Zt, !1);\n      this.currentContextMenu = null;\n    }\n  };\n\n  ma.Object.defineProperties(Eg.prototype, {\n    currentContextMenu: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        this.j = a;\n        this.Js = a instanceof ue ? a.adornedPart : null;\n      }\n    },\n    defaultTouchContextMenu: {\n      get: function get() {\n        !1 === Kg && null === Gg && Og && Fg(this);\n        return Gg;\n      },\n      set: function set(a) {\n        null === a && (Kg = !0);\n        Gg = a;\n      }\n    },\n    currentObject: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        this.m = a;\n      }\n    },\n    mouseDownPoint: {\n      get: function get() {\n        return this.cw;\n      }\n    }\n  });\n  var Gg = null,\n      Kg = !1,\n      Jg = null,\n      Ig = null;\n  Eg.className = \"ContextMenuTool\";\n  Ka(\"contextMenuTool\", function () {\n    return this.findTool(\"ContextMenu\");\n  }, function (a) {\n    this.gb(\"ContextMenu\", a, this.mouseUpTools);\n  });\n\n  function Pg() {\n    ke.call(this);\n    this.name = \"TextEditing\";\n    this.Sh = new Qg();\n    this.ga = null;\n    this.W = Rg;\n    this.qj = null;\n    this.na = Sg;\n    this.u = 1;\n    this.F = !0;\n    this.m = null;\n    this.j = new ze();\n    this.Ms = null;\n    Tg(this, this.j);\n  }\n\n  la(Pg, ke);\n\n  function Tg(a, b) {\n    if (Og) {\n      var c = ua(\"textarea\");\n      a.Ms = c;\n      c.addEventListener(\"input\", function () {\n        if (null !== a.textBlock) {\n          var b = a.qx(this.value);\n          this.style.width = 20 + b.measuredBounds.width * this.cA + \"px\";\n          this.rows = b.lineCount;\n        }\n      }, !1);\n      c.addEventListener(\"keydown\", function (b) {\n        if (null !== a.textBlock) {\n          var c = b.key;\n          \"Enter\" === c ? (!1 === a.textBlock.isMultiline && b.preventDefault(), a.acceptText(Ug)) : \"Tab\" === c ? (a.acceptText(Vg), b.preventDefault()) : \"Escape\" === c && (a.doCancel(), null !== a.diagram && a.diagram.doFocus());\n        }\n      }, !1);\n      c.addEventListener(\"focus\", function () {\n        if (null !== a.currentTextEditor && a.state !== Sg) {\n          var b = a.Ms;\n          a.na === Wg && (a.na = Xg);\n          \"function\" === typeof b.select && a.selectsTextOnActivate && (b.select(), b.setSelectionRange(0, 9999));\n        }\n      }, !1);\n      c.addEventListener(\"blur\", function () {\n        if (null !== a.currentTextEditor && a.state !== Sg) {\n          var b = a.Ms;\n          \"function\" === typeof b.focus && b.focus();\n          \"function\" === typeof b.select && a.selectsTextOnActivate && (b.select(), b.setSelectionRange(0, 9999));\n        }\n      }, !1);\n\n      b.valueFunction = function () {\n        return c.value;\n      };\n\n      b.mainElement = c;\n\n      b.show = function (a, b, f) {\n        if (a instanceof Qg && f instanceof Pg) if (f.state === Yg) c.style.border = \"3px solid red\", c.focus();else {\n          var d = a.ia(yc),\n              e = b.position,\n              k = b.scale,\n              l = a.uf() * k;\n          l < f.minimumEditorScale && (l = f.minimumEditorScale);\n          var m = a.naturalBounds.width * l + 6,\n              n = a.naturalBounds.height * l + 2,\n              p = (d.x - e.x) * k;\n          d = (d.y - e.y) * k;\n          e = a.verticalAlignment;\n          k = (a.lineHeight + a.spacingAbove + a.spacingBelow) * a.lineCount * l;\n          n = e.y * n - e.y * k + e.offsetY - (.5 * n - .5 * k) - k / 2;\n          c.value = a.text;\n          b.div.style.font = a.font;\n          c.style.position = \"absolute\";\n          c.style.zIndex = \"100\";\n          c.style.font = \"inherit\";\n          c.style.fontSize = 100 * l + \"%\";\n          c.style.lineHeight = \"normal\";\n          c.style.width = m + \"px\";\n          c.style.left = (p - m / 2 | 0) - 1 + \"px\";\n          c.style.top = (d + n | 0) - 1 + \"px\";\n          c.style.textAlign = a.textAlign;\n          c.style.margin = \"0\";\n          c.style.padding = \"1px\";\n          c.style.border = \"0\";\n          c.style.outline = \"none\";\n          c.style.whiteSpace = \"pre-wrap\";\n          c.style.overflow = \"hidden\";\n          c.rows = a.lineCount;\n          c.cA = l;\n          c.className = \"goTXarea\";\n          b.div.appendChild(c);\n          c.focus();\n          f.selectsTextOnActivate && (c.select(), c.setSelectionRange(0, 9999));\n        }\n      };\n\n      b.hide = function (a) {\n        a.div.removeChild(c);\n      };\n    }\n  }\n\n  Pg.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    if (null === a || a.isReadOnly || Zg && Zg !== this && (Zg.acceptText($g), Zg && Zg !== this) || !a.lastInput.left || this.isBeyondDragSize()) return !1;\n    var b = a.ec(a.lastInput.documentPoint);\n    if (!(null !== b && b instanceof Qg && b.editable && b.part.canEdit())) return !1;\n    b = b.part;\n    return null === b || this.starting === Rg && !b.isSelected || this.starting === ah && 2 > a.lastInput.clickCount ? !1 : !0;\n  };\n\n  Pg.prototype.doStart = function () {\n    Zg = this;\n    null !== this.textBlock && this.doActivate();\n  };\n\n  Pg.prototype.doActivate = function () {\n    if (!this.isActive) {\n      var a = this.diagram;\n\n      if (null !== a) {\n        var b = this.textBlock;\n        null === b && (b = a.ec(a.lastInput.documentPoint));\n\n        if (null !== b && b instanceof Qg && (this.textBlock = b, null !== b.part)) {\n          a.animationManager.wc();\n          this.isActive = !0;\n          this.na = Wg;\n          var c = this.defaultTextEditor;\n          null !== b.textEditor && (c = b.textEditor);\n          this.Sh = this.textBlock.copy();\n          var d = new M(this.textBlock.ia(tc), this.textBlock.ia(Cc));\n          a.bv(d);\n          c.show(b, a, this);\n          this.currentTextEditor = c;\n        }\n      }\n    }\n  };\n\n  Pg.prototype.doCancel = function () {\n    this.stopTool();\n  };\n\n  Pg.prototype.doMouseUp = function () {\n    this.canStart() && this.doActivate();\n  };\n\n  Pg.prototype.doMouseDown = function () {\n    this.isActive && this.acceptText($g);\n  };\n\n  Pg.prototype.acceptText = function (a) {\n    switch (a) {\n      case $g:\n        if (this.na === bh) this.currentTextEditor instanceof HTMLElement && this.currentTextEditor.focus();else if (this.na === Wg || this.na === Yg || this.na === Xg) this.na = ch, dh(this);\n        break;\n\n      case eh:\n      case Ug:\n      case Vg:\n        if (Ug !== a || !0 !== this.textBlock.isMultiline) if (this.na === Wg || this.na === Yg || this.na === Xg) this.na = ch, dh(this);\n    }\n  };\n\n  function dh(a) {\n    var b = a.textBlock,\n        c = a.diagram,\n        d = a.currentTextEditor;\n\n    if (null !== b && null !== d) {\n      var e = b.text,\n          f = \"\";\n      null !== d.valueFunction && (f = d.valueFunction());\n      a.isValidText(b, e, f) ? (a.Da(a.name), a.na = bh, a.transactionResult = a.name, b.text = f, a.doSuccess(e, f), null !== c && c.P(\"TextEdited\", b, e), a.stopTransaction(), a.stopTool(), null !== c && c.doFocus()) : (a.na = Yg, a.doError(e, f));\n    }\n  }\n\n  Pg.prototype.doError = function (a, b) {\n    var c = this.textBlock;\n    null !== c.errorFunction && c.errorFunction(this, a, b);\n    (a = this.currentTextEditor) && a.show(c, this.diagram, this);\n  };\n\n  Pg.prototype.doSuccess = function (a, b) {\n    var c = this.textBlock;\n    null !== c.textEdited && c.textEdited(c, a, b);\n  };\n\n  Pg.prototype.doDeactivate = function () {\n    var a = this.diagram;\n    null !== a && (this.na = Sg, null !== this.currentTextEditor && this.currentTextEditor.hide(a, this), this.textBlock = null, this.isActive = !1);\n  };\n\n  Pg.prototype.doStop = function () {\n    Zg = null;\n  };\n\n  Pg.prototype.isValidText = function (a, b, c) {\n    var d = this.textValidation;\n    if (null !== d && !d(a, b, c)) return !1;\n    d = a.textValidation;\n    return null === d || d(a, b, c) ? !0 : !1;\n  };\n\n  Pg.prototype.qx = function (a) {\n    var b = this.Sh;\n    b.text = a;\n    b.measure(this.textBlock.zh, Infinity);\n    return b;\n  };\n\n  ma.Object.defineProperties(Pg.prototype, {\n    textBlock: {\n      get: function get() {\n        return this.ga;\n      },\n      set: function set(a) {\n        this.ga = a;\n      }\n    },\n    currentTextEditor: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        this.m = a;\n      }\n    },\n    defaultTextEditor: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        this.j = a;\n      }\n    },\n    starting: {\n      get: function get() {\n        return this.W;\n      },\n      set: function set(a) {\n        this.W = a;\n      }\n    },\n    textValidation: {\n      get: function get() {\n        return this.qj;\n      },\n      set: function set(a) {\n        this.qj = a;\n      }\n    },\n    minimumEditorScale: {\n      get: function get() {\n        return this.u;\n      },\n      set: function set(a) {\n        this.u = a;\n      }\n    },\n    selectsTextOnActivate: {\n      get: function get() {\n        return this.F;\n      },\n      set: function set(a) {\n        this.F = a;\n      }\n    },\n    state: {\n      get: function get() {\n        return this.na;\n      },\n      set: function set(a) {\n        this.na !== a && (this.na = a);\n      }\n    }\n  });\n  Pg.prototype.measureTemporaryTextBlock = Pg.prototype.qx;\n  var eh = new D(Pg, \"LostFocus\", 0),\n      $g = new D(Pg, \"MouseDown\", 1),\n      Vg = new D(Pg, \"Tab\", 2),\n      Ug = new D(Pg, \"Enter\", 3),\n      fh = new D(Pg, \"SingleClick\", 0),\n      Rg = new D(Pg, \"SingleClickSelected\", 1),\n      ah = new D(Pg, \"DoubleClick\", 2),\n      Sg = new D(Pg, \"StateNone\", 0),\n      Wg = new D(Pg, \"StateActive\", 1),\n      Xg = new D(Pg, \"StateEditing\", 2),\n      ch = new D(Pg, \"StateValidating\", 3),\n      Yg = new D(Pg, \"StateInvalid\", 4),\n      bh = new D(Pg, \"StateValidated\", 5),\n      Zg = null;\n  Pg.className = \"TextEditingTool\";\n  Pg.LostFocus = eh;\n  Pg.MouseDown = $g;\n  Pg.Tab = Vg;\n  Pg.Enter = Ug;\n  Pg.SingleClick = fh;\n  Pg.SingleClickSelected = Rg;\n  Pg.DoubleClick = ah;\n  Pg.StateNone = Sg;\n  Pg.StateActive = Wg;\n  Pg.StateEditing = Xg;\n  Pg.StateValidating = ch;\n  Pg.StateInvalid = Yg;\n  Pg.StateValidated = bh;\n  Ka(\"textEditingTool\", function () {\n    return this.findTool(\"TextEditing\");\n  }, function (a) {\n    this.gb(\"TextEditing\", a, this.mouseUpTools);\n  });\n\n  function gh(a) {\n    hh || (ih(), hh = !0);\n    this.H = le;\n    this.Dk = this.zb = this.Xp = this.$b = !1;\n    this.uw = !0;\n    this.Ek = jh;\n    this.lm = !1;\n    this.wh = this.Ad = !0;\n    this.ug = 600;\n    this.Hv = this.sw = !1;\n    this.Sd = new G();\n    this.Wd = new kh();\n    this.Wd.Rd = this;\n    this.yi = new G();\n    this.Vt = new G();\n    this.rr = new G();\n    this.dl = new G();\n    a && Object.assign(this, a);\n  }\n\n  gh.prototype.Le = function (a) {\n    this.H = a;\n  };\n\n  gh.prototype.canStart = function () {\n    return !0;\n  };\n\n  function lh(a, b) {\n    a.Ad && a.canStart(b) && (a.Sd.add(b), a.defaultAnimation.isAnimating && a.wc(), mh(a.H), a.zb = !0);\n  }\n\n  function nh(a) {\n    if (a.Ad && a.zb) {\n      var b = a.Wd,\n          c = a.H,\n          d = a.Sd.contains(\"Model\");\n      d && (a.Dk = !0, a.Ek === jh ? (b.isViewportUnconstrained = !0, b.rc.clear(), b.add(c, \"position\", c.position.copy().offset(0, -200), c.position), b.add(c, \"opacity\", 0, 1)) : a.Ek === oh && b.rc.clear(), a.uw = a.Ek === ph && c.Jt.C(c.pa) ? !0 : !1, c.P(\"InitialAnimationStarting\", a));\n      d && !a.wh || 0 === b.rc.count ? (a.Sd.clear(), a.zb = !1, b.rc.clear(), qh(b, c), a.Dk = !1, c.N()) : (a.Sd.clear(), c.cg = !1, d = b.rc.get(c), c.autoScale !== rh && null !== d && (delete d.start.scale, delete d.end.scale), x.requestAnimationFrame(function () {\n        !1 === a.zb || b.$b || (c.Ge(\"temporaryPixelRatio\") && Ge(c), sh(c), a.zb = !1, b.start(), b.$b && (th(a), c.Va(), uh(b, 0), zf(c, !0), vh(a), c.P(\"AnimationStarting\", a)));\n      }));\n    }\n  }\n\n  function wh(a) {\n    return a.Sd.contains(\"Trigger\") && 1 === a.Sd.count;\n  }\n\n  function xh(a, b, c, d) {\n    a.isTicking || wh(a) || b instanceof T && (null !== b.fromNode || null !== b.toNode) || a.Wd.add(b, \"position\", c, d, !1);\n  }\n\n  t = gh.prototype;\n\n  t.es = function (a) {\n    return this.Wd.es(a);\n  };\n\n  t.Ju = function (a) {\n    return this.Wd.Ju(a);\n  };\n\n  function yh(a, b) {\n    function c() {\n      0 < e.rr.count && (d.addAll(e.rr), e.rr.clear(), e.$b = !0);\n\n      if (!1 !== e.$b && 0 !== d.count) {\n        e.Vt.addAll(d);\n\n        for (var a = e.Vt.iterator; a.next();) {\n          var b = a.value;\n\n          if (!1 !== b.$b) {\n            a: if (0 < b.nl.count) var h = !0;else {\n              for (h = b.rc.iterator; h.next();) {\n                var k = h.key;\n\n                if (k instanceof Y && null !== k.diagram || k instanceof Q) {\n                  h = !0;\n                  break a;\n                }\n              }\n\n              h = !1;\n            }\n\n            h ? zh(b, !1) : b.Mk = !0;\n          }\n        }\n\n        e.Vt.clear();\n        !1 !== e.$b && (th(e), zf(e.H), vh(e));\n        x.requestAnimationFrame(c);\n      }\n    }\n\n    var d = a.yi,\n        e = a;\n    a.$b ? a.rr.add(b) : (a.$b = !0, d.add(b), x.requestAnimationFrame(function () {\n      c();\n    }));\n  }\n\n  function Ah(a) {\n    for (a = a.yi.iterator; a.next();) {\n      a.value.Mk = !1;\n    }\n  }\n\n  function th(a) {\n    if (!a.Xp) {\n      var b = a.H;\n      a.sw = b.skipsUndoManager;\n      a.Hv = b.skipsModelSourceBindings;\n      b.skipsUndoManager = !0;\n      b.skipsModelSourceBindings = !0;\n      a.Xp = !0;\n    }\n  }\n\n  function vh(a) {\n    var b = a.H;\n    b.skipsUndoManager = a.sw;\n    b.skipsModelSourceBindings = a.Hv;\n    a.Xp = !1;\n  }\n\n  t.wc = function (a) {\n    var b = this.Wd;\n    !0 === this.zb && (this.Dk = this.zb = !1, this.Sd.clear(), 0 < b.rc.count && this.H.Mb());\n\n    if (this.$b) {\n      if (b.ul(!0), b.rc.clear(), qh(b, null), !0 === a) for (a = this.yi.Ea(), b = 0; b < a.length; b++) {\n        a[b].ul(!0);\n      }\n    } else b.rc.clear(), qh(b, this.H);\n  };\n\n  t.ul = function (a) {\n    a === this.defaultAnimation && this.defaultAnimation.rc.clear();\n    this.yi.remove(a);\n    0 === this.yi.count && (this.$b = !1, this.H.Mb());\n    a === this.defaultAnimation && (this.defaultAnimation.rc.clear(), this.H.P(\"AnimationFinished\", this));\n  };\n\n  t.xj = function (a, b) {\n    this.zb && (this.Sd.contains(\"Expand Tree\") || this.Sd.contains(\"Expand SubGraph\")) && (this.Wd.xj(a, b), Bh(this, a));\n  };\n\n  t.vj = function (a, b) {\n    this.zb && (this.Sd.contains(\"Collapse Tree\") || this.Sd.contains(\"Collapse SubGraph\")) && (this.Wd.vj(a, b), Ch(this.Wd, b, \"position\", b.position, b.position), Bh(this, a));\n  };\n\n  function Nh(a, b, c) {\n    !a.zb || b.C(c) || wh(a) || (a.H.ji || (b = c.copy()), Ch(a.Wd, a.H, \"position\", b, c));\n  }\n\n  function Bh(a, b) {\n    for (b = b.findLinksConnected(); b.next();) {\n      var c = b.value;\n      c.ef = c.points.copy();\n      a.dl.add(c);\n    }\n  }\n\n  function Oh(a, b, c, d, e) {\n    null === a && (a = [0, 0, 0, 0]);\n    null === b && (b = [0, 0, 0, 0]);\n    var f = a[0],\n        g = a[1],\n        h = a[2];\n    a = a[3];\n    var k = b[0],\n        l = b[1],\n        m = b[2];\n    b = b[3];\n    if (0 === h || 100 === h) f = k, g = l;else if (0 === m || 100 === m) k = f, l = g;\n    180 < Math.abs(k - f) && (k > f ? f += 360 : k += 360);\n    f = e(c, f, k - f, d) % 360;\n    g = e(c, g, l - g, d);\n    h = e(c, h, m - h, d);\n    c = e(c, a, b - a, d);\n    return \"hsla(\" + f + \", \" + g + \"%, \" + h + \"%, \" + c + \")\";\n  }\n\n  function ih() {\n    function a(a, b, e, f, g, h) {\n      a.position = new I(f(g, b.x, e.x - b.x, h), f(g, b.y, e.y - b.y, h));\n    }\n\n    var b = new pb();\n    b.add(\"position:diagram\", a);\n    b.add(\"position\", a);\n    b.add(\"position:part\", function (a, b, e, f, g, h) {\n      g < h ? a.Ul(f(g, b.x, e.x - b.x, h), f(g, b.y, e.y - b.y, h), !1) : a.position = new I(f(g, b.x, e.x - b.x, h), f(g, b.y, e.y - b.y, h));\n    });\n    b.add(\"location\", function (a, b, e, f, g, h) {\n      g < h ? a.Ul(f(g, b.x, e.x - b.x, h), f(g, b.y, e.y - b.y, h), !0) : a.location = new I(f(g, b.x, e.x - b.x, h), f(g, b.y, e.y - b.y, h));\n    });\n    b.add(\"position:placeholder\", function (a, b, e, f, g, h) {\n      g < h ? a.Ul(f(g, b.x, e.x - b.x, h), f(g, b.y, e.y - b.y, h), !1) : a.position = new I(f(g, b.x, e.x - b.x, h), f(g, b.y, e.y - b.y, h));\n    });\n    b.add(\"position:nodeCollapse\", function (a, b, e, f, g, h) {\n      var c = a.actualBounds,\n          d = e.actualBounds;\n      e = d.x + d.width / 2 - c.width / 2;\n      c = d.y + d.height / 2 - c.height / 2;\n      g < h ? a.Ul(f(g, b.x, e - b.x, h), f(g, b.y, c - b.y, h), !1) : a.position = new I(f(g, b.x, e - b.x, h), f(g, b.y, c - b.y, h));\n    });\n    b.add(\"desiredSize\", function (a, b, e, f, g, h) {\n      a.desiredSize = new M(f(g, b.width, e.width - b.width, h), f(g, b.height, e.height - b.height, h));\n    });\n    b.add(\"width\", function (a, b, e, f, g, h) {\n      a.width = f(g, b, e - b, h);\n    });\n    b.add(\"height\", function (a, b, e, f, g, h) {\n      a.height = f(g, b, e - b, h);\n    });\n    b.add(\"fill\", function (a, b, e, f, g, h) {\n      a.fill = Oh(b, e, g, h, f);\n    });\n    b.add(\"stroke\", function (a, b, e, f, g, h) {\n      a.stroke = Oh(b, e, g, h, f);\n    });\n    b.add(\"strokeWidth\", function (a, b, e, f, g, h) {\n      a.strokeWidth = f(g, b, e - b, h);\n    });\n    b.add(\"strokeDashOffset\", function (a, b, e, f, g, h) {\n      a.strokeDashOffset = f(g, b, e - b, h);\n    });\n    b.add(\"background\", function (a, b, e, f, g, h) {\n      a.background = Oh(b, e, g, h, f);\n    });\n    b.add(\"areaBackground\", function (a, b, e, f, g, h) {\n      a.areaBackground = Oh(b, e, g, h, f);\n    });\n    b.add(\"opacity\", function (a, b, e, f, g, h) {\n      a.opacity = f(g, b, e - b, h);\n    });\n    b.add(\"scale\", function (a, b, e, f, g, h) {\n      a.scale = f(g, b, e - b, h);\n    });\n    b.add(\"angle\", function (a, b, e, f, g, h) {\n      a.angle = f(g, b, e - b, h);\n    });\n    Ph = b;\n  }\n\n  ma.Object.defineProperties(gh.prototype, {\n    animationReasons: {\n      get: function get() {\n        return this.Sd;\n      }\n    },\n    isEnabled: {\n      get: function get() {\n        return this.Ad;\n      },\n      set: function set(a) {\n        (this.Ad = a) && this.yi.each(function (a) {\n          a.isAnimating || Infinity !== a.runCount || a.start();\n        });\n      }\n    },\n    duration: {\n      get: function get() {\n        return this.ug;\n      },\n      set: function set(a) {\n        1 > a && wa(a, \">= 1\", gh, \"duration\");\n        this.ug = a;\n      }\n    },\n    isAnimating: {\n      get: function get() {\n        return this.$b;\n      }\n    },\n    isTicking: {\n      get: function get() {\n        return this.Xp;\n      }\n    },\n    isInitial: {\n      get: function get() {\n        return this.wh;\n      },\n      set: function set(a) {\n        this.wh = a;\n      }\n    },\n    defaultAnimation: {\n      get: function get() {\n        return this.Wd;\n      }\n    },\n    activeAnimations: {\n      get: function get() {\n        return this.yi;\n      }\n    },\n    initialAnimationStyle: {\n      get: function get() {\n        return this.Ek;\n      },\n      set: function set(a) {\n        this.Ek = a;\n      }\n    }\n  });\n  gh.prototype.stopAnimation = gh.prototype.wc;\n  var Ph = null,\n      hh = !1,\n      jh = new D(gh, \"Default\", 1),\n      ph = new D(gh, \"AnimateLocations\", 2),\n      oh = new D(gh, \"None\", 3);\n  gh.className = \"AnimationManager\";\n\n  gh.defineAnimationEffect = function (a, b) {\n    hh || (ih(), hh = !0);\n    Ph.add(a, b);\n  };\n\n  gh.Default = jh;\n  gh.AnimateLocations = ph;\n  gh.None = oh;\n\n  function kh(a) {\n    this.au = this.rw = this.Rd = this.H = null;\n    this.Mk = this.$b = this.j = !1;\n    this.Km = this.Gd = 0;\n    this.op = this.Rs = Qh;\n    this.Lk = this.Kn = !1;\n    this.It = 1;\n    this.Gt = 0;\n    this.yd = this.ug = NaN;\n    this.Lv = 0;\n    this.Lm = null;\n    this.m = qb;\n    this.rc = new pb();\n    this.yt = new pb();\n    this.nl = new G();\n    this.zt = new G();\n    this.Iv = Rh;\n    a && Object.assign(this, a);\n  }\n\n  kh.prototype.suspend = function () {\n    this.Mk = !0;\n  };\n\n  kh.prototype.advanceTo = function (a, b) {\n    b && (this.Mk = !1);\n    this.Kn && a >= this.yd && (this.Lk = !0, a -= this.yd);\n    this.Lv = a;\n    zh(this, !0);\n    th(this.Rd);\n    zf(this.H);\n    vh(this.Rd);\n    this.H.redraw();\n  };\n\n  function qh(a, b) {\n    a.yt.clear();\n    a.Lk = !1;\n    a.Gt = 0;\n    a.yd = NaN;\n    0 < a.nl.count && a.nl.clear();\n    0 < a.zt.count && a.zt.clear();\n    if (null !== b) for (a = b.links; a.next();) {\n      a.value.ef = null;\n    }\n  }\n\n  t = kh.prototype;\n\n  t.start = function () {\n    if (0 === this.rc.count || this.$b) return this;\n\n    for (var a = this.H, b = this.rc.iterator; b.next();) {\n      var c = b.value.end,\n          d = b.key;\n\n      if (c[\"position:placeholder\"]) {\n        var e = d.findVisibleNode();\n\n        if (e instanceof qf && null !== e.placeholder) {\n          var f = e.placeholder;\n          e = f.ia(tc);\n          f = f.padding;\n          e.x += f.left;\n          e.y += f.top;\n          c[\"position:placeholder\"] = e;\n        }\n      }\n\n      null === a && (d instanceof Q ? a = d : d instanceof Y && (a = d.diagram));\n    }\n\n    if (null !== a) this.H = a, this.Rd = a.animationManager;else return this;\n    b = this.Rd;\n    if (!1 === b.isEnabled) return this;\n    this.yd = isNaN(this.ug) ? b.duration : this.ug;\n    this.op = this.Rs;\n    b.Dk && b.Ek === jh && this === b.defaultAnimation && (this.op = Sh, this.yd = isNaN(this.ug) ? 600 === b.duration ? 900 : b.duration : this.ug);\n    this.Iv = a.scrollMode;\n    this.isViewportUnconstrained && (a.nj = Th);\n    th(b);\n    this.nl.each(function (b) {\n      b.data = null;\n      a.add(b);\n    });\n    vh(b);\n    this.$b = !0;\n    this.Gd = +new Date();\n    this.Km = this.Gd + this.yd;\n    yh(b, this);\n    return this;\n  };\n\n  t.oy = function (a, b) {\n    if (!a.Tc()) return this;\n    this.nl.add(a);\n    this.H = b;\n    return this;\n  };\n\n  t.add = function (a, b, c, d, e) {\n    if (\"position\" === b && c.C(d)) return this;\n    null === this.H && (a instanceof Q ? this.H = a : a instanceof Y && null !== a.diagram && (this.H = a.diagram));\n\n    if (a instanceof U) {\n      if (!a.isAnimated) return this;\n      \"position\" === b && (b = \"position:part\");\n    }\n\n    Ch(this, a, b, c, d, e);\n    return this;\n  };\n\n  function Ch(a, b, c, d, e, f) {\n    var g = a.rc;\n    b instanceof Q && \"position\" === c && (c = \"position:diagram\");\n    if (\"fill\" === c || \"stroke\" === c || \"background\" === c || \"areaBackground\" === c) Uh(d), Vh(), d = [Wh.j, Wh.u, Wh.m, Wh.F], Uh(e), Vh(), e = [Wh.j, Wh.u, Wh.m, Wh.F];\n\n    if (g.contains(b)) {\n      var h = g.I(b);\n      var k = h.start;\n      var l = h.end;\n      void 0 === k[c] && (k[c] = Xh(d));\n      l[c] = Xh(e);\n    } else k = {}, l = {}, k[c] = Xh(d), l[c] = Xh(e), h = k.position, b instanceof Y && h instanceof I && !h.v() && b.diagram.animationManager.Sd.contains(\"Expand SubGraph\") && h.assign(l.position), h = new Yh(k, l, f), g.add(b, h);\n\n    g = k[c];\n    g instanceof I && !g.v() && g.assign(a.m);\n    f && 0 === c.indexOf(\"position:\") && b instanceof U ? h.uu.location = Xh(b.location) : f && (h.uu[c] = Xh(d));\n  }\n\n  function Xh(a) {\n    return a instanceof I ? a.copy() : a instanceof K ? a.copy() : a;\n  }\n\n  t.es = function (a) {\n    if (!this.$b) return !1;\n    a = this.rc.I(a);\n    return null !== a && a.Wu;\n  };\n\n  t.Ju = function (a) {\n    if (!this.$b) return !1;\n    a = this.rc.I(a);\n    return null !== a && (a.start.position || a.start.location);\n  };\n\n  function zh(a, b) {\n    if (!a.Mk || b) {\n      var c = a.Rd;\n\n      if (!1 !== a.$b) {\n        var d = +new Date(),\n            e = d > a.Km ? a.yd : d - a.Gd;\n        b && (e = a.Lv, e < a.yd ? (a.Gd = +new Date() - e, a.Km = a.Gd + a.yd) : e = a.yd);\n        th(c);\n        uh(a, e);\n        zf(a.H, !0);\n        vh(c);\n        d > a.Km && (a.Kn && !a.Lk ? (a.Gd = +new Date(), a.Km = a.Gd + a.yd, a.Lk = !0) : a.ul(!1));\n      }\n    }\n  }\n\n  function uh(a, b) {\n    for (var c = a.yd, d = a.rc.iterator, e = a.Lk; d.next();) {\n      var f = d.key;\n\n      if (!(f instanceof Y && null === f.diagram)) {\n        var g = d.value,\n            h = e ? g.end : g.start;\n        g = e ? g.start : g.end;\n        var k = Ph,\n            l;\n\n        for (l in g) {\n          \"position\" === l && (g[\"position:placeholder\"] || g[\"position:nodeCollapse\"]) || null === k.get(l) || k.get(l)(f, h[l], g[l], a.op, b, c, a);\n        }\n      }\n    }\n  }\n\n  t.stop = function () {\n    if (!this.$b) return this;\n    this.ul(!0);\n    return this;\n  };\n\n  t.ul = function (a) {\n    null !== this.au && this.au.Mn.remove(this.rw);\n\n    if (this.$b) {\n      var b = this.H,\n          c = this.Rd;\n      this.Mk = this.$b = c.Dk = !1;\n      th(c);\n\n      for (var d = this.rc, e = this.nl.iterator; e.next();) {\n        b.remove(e.value);\n      }\n\n      for (e = this.zt.iterator; e.next();) {\n        e.value.w();\n      }\n\n      e = this.Kn;\n      d = d.iterator;\n\n      for (var f = Ph; d.next();) {\n        var g = d.key,\n            h = d.value,\n            k = e ? h.end : h.start,\n            l = e ? h.start : h.end,\n            m = h.uu,\n            n;\n\n        for (n in l) {\n          if (null !== f.get(n)) {\n            var p = n;\n            !h.ou || \"position:nodeCollapse\" !== p && \"position:placeholder\" !== p || (p = \"position\");\n            f.get(p)(g, k[n], void 0 !== m[n] ? m[n] : h.ou ? k[n] : l[n], this.op, this.yd, this.yd, this);\n          }\n        }\n\n        h.ou && void 0 !== m.location && g instanceof U && (g.location = m.location);\n        h.Wu && g instanceof U && g.Ub(!1);\n      }\n\n      b.Zr.clear();\n      Ye(b, !1);\n      b.Va();\n      b.N();\n      zf(b, !0);\n\n      if (c.defaultAnimation === this) {\n        for (n = c.dl.iterator; n.next();) {\n          e = n.value, null !== e.ef && (e.points = e.ef, e.ef = null);\n        }\n\n        c.dl.clear();\n      }\n\n      zf(b, !0);\n      this.isViewportUnconstrained && (b.scrollMode = this.Iv);\n      vh(c);\n      this.Gt++;\n      !a && this.It > this.Gt ? (this.Lk = !1, this.start()) : (this.Lm && this.Lm(this), qh(this, null), c.ul(this), b.Mb());\n    }\n  };\n\n  t.xj = function (a, b) {\n    var c = b.actualBounds,\n        d = null;\n    b instanceof qf && (d = b.placeholder);\n    null !== d ? (c = d.ia(tc), d = d.padding, c.x += d.left, c.y += d.top, this.add(a, \"position\", c, a.position, !1)) : this.add(a, \"position\", new I(c.x + c.width / 2, c.y + c.height / 2), a.position, !1);\n    this.add(a, \"scale\", .01, a.scale, !1);\n    if (a instanceof qf) for (a = a.memberParts; a.next();) {\n      d = a.value, d instanceof V && this.xj(d, b);\n    }\n  };\n\n  t.vj = function (a, b) {\n    if (a.isVisible()) {\n      var c = null;\n      b instanceof qf && (c = b.placeholder);\n      null !== c ? this.add(a, \"position:placeholder\", a.position, c, !0) : this.add(a, \"position:nodeCollapse\", a.position, b, !0);\n      this.add(a, \"scale\", a.scale, .01, !0);\n      c = this.rc;\n      c.contains(a) && (c.I(a).Wu = !0);\n      if (a instanceof qf) for (a = a.memberParts; a.next();) {\n        c = a.value, c instanceof V && this.vj(c, b);\n      }\n    }\n  };\n\n  t.lz = function (a) {\n    var b = this.yt.get(a);\n    null === b && (b = {}, this.yt.add(a, b));\n    return b;\n  };\n\n  ma.Object.defineProperties(kh.prototype, {\n    duration: {\n      get: function get() {\n        return this.ug;\n      },\n      set: function set(a) {\n        1 > a && wa(a, \">= 1\", kh, \"duration\");\n        this.ug = a;\n      }\n    },\n    reversible: {\n      get: function get() {\n        return this.Kn;\n      },\n      set: function set(a) {\n        this.Kn = a;\n      }\n    },\n    runCount: {\n      get: function get() {\n        return this.It;\n      },\n      set: function set(a) {\n        0 < a ? this.It = a : C(\"Animation.runCount value must be a positive integer.\");\n      }\n    },\n    finished: {\n      get: function get() {\n        return this.Lm;\n      },\n      set: function set(a) {\n        this.Lm !== a && (this.Lm = a);\n      }\n    },\n    easing: {\n      get: function get() {\n        return this.Rs;\n      },\n      set: function set(a) {\n        this.Rs = a;\n      }\n    },\n    isViewportUnconstrained: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        this.j = a;\n      }\n    },\n    isAnimating: {\n      get: function get() {\n        return this.$b;\n      }\n    }\n  });\n  kh.prototype.getTemporaryState = kh.prototype.lz;\n  kh.prototype.stop = kh.prototype.stop;\n  kh.prototype.add = kh.prototype.add;\n  kh.prototype.addTemporaryPart = kh.prototype.oy;\n\n  function Qh(a, b, c, d) {\n    a /= d / 2;\n    return 1 > a ? c / 2 * a * a + b : -c / 2 * (--a * (a - 2) - 1) + b;\n  }\n\n  function Sh(a, b, c, d) {\n    return a === d ? b + c : c * (-Math.pow(2, -10 * a / d) + 1) + b;\n  }\n\n  kh.className = \"Animation\";\n\n  kh.EaseLinear = function (a, b, c, d) {\n    return c * a / d + b;\n  };\n\n  kh.EaseInOutQuad = Qh;\n\n  kh.EaseInQuad = function (a, b, c, d) {\n    return c * (a /= d) * a + b;\n  };\n\n  kh.EaseOutQuad = function (a, b, c, d) {\n    return -c * (a /= d) * (a - 2) + b;\n  };\n\n  kh.EaseInExpo = function (a, b, c, d) {\n    return 0 === a ? b : c * Math.pow(2, 10 * (a / d - 1)) + b;\n  };\n\n  kh.EaseOutExpo = Sh;\n\n  function Yh(a, b, c) {\n    this.start = a;\n    this.end = b;\n    this.uu = {};\n    this.ou = c;\n    this.Wu = !1;\n  }\n\n  Yh.className = \"AnimationState\";\n\n  function Zh(a, b, c) {\n    this.sd = null;\n    this.df = a;\n    this.Vn = c || $h;\n    this.hk = null;\n    void 0 !== b && (this.hk = b, void 0 === c && (this.Vn = ai));\n  }\n\n  Zh.prototype.copy = function () {\n    var a = new Zh(this.df);\n    a.Vn = this.Vn;\n    var b = this.hk;\n\n    if (null !== b) {\n      var c = {};\n      void 0 !== b.duration && (c.duration = b.duration);\n      void 0 !== b.finished && (c.finished = b.finished);\n      void 0 !== b.easing && (c.easing = b.easing);\n      a.hk = c;\n    }\n\n    return a;\n  };\n\n  function bi(a, b) {\n    a = a.hk;\n    null !== a && (a.duration && (b.duration = a.duration), a.finished && (b.finished = a.finished), a.easing && (b.easing = a.easing));\n  }\n\n  ma.Object.defineProperties(Zh.prototype, {\n    propertyName: {\n      get: function get() {\n        return this.df;\n      },\n      set: function set(a) {\n        this.df = a;\n      }\n    },\n    animationSettings: {\n      get: function get() {\n        return this.hk;\n      },\n      set: function set(a) {\n        this.hk = a;\n      }\n    },\n    startCondition: {\n      get: function get() {\n        return this.Vn;\n      },\n      set: function set(a) {\n        this.Vn = a;\n      }\n    }\n  });\n  var $h = new D(Zh, \"Default\", 1),\n      ai = new D(Zh, \"Immediate\", 2),\n      ci = new D(Zh, \"Bundled\", 3);\n  Zh.className = \"AnimationTrigger\";\n  Zh.Default = $h;\n  Zh.Immediate = ai;\n  Zh.Bundled = ci;\n\n  function di(a) {\n    Ra(this);\n    this.H = null;\n    this.Ma = new E();\n    this.va = \"\";\n    this.tb = 1;\n    this.m = !1;\n    this.j = this.Nh = this.u = this.Ii = this.Hi = this.Gi = this.Fi = this.Di = this.Ei = this.Ci = this.Ki = this.Bi = this.Ji = this.Ai = this.zi = !0;\n    this.Bn = [];\n    a && Object.assign(this, a);\n  }\n\n  t = di.prototype;\n\n  t.clear = function () {\n    this.Ma.clear();\n    this.Bn.length = 0;\n  };\n\n  t.Le = function (a) {\n    this.H = a;\n  };\n\n  t.toString = function (a) {\n    void 0 === a && (a = 0);\n    var b = 'Layer \"' + this.name + '\"';\n    if (0 >= a) return b;\n\n    for (var c = 0, d = 0, e = 0, f = 0, g = 0, h = this.Ma.iterator; h.next();) {\n      var k = h.value;\n      k instanceof qf ? e++ : k instanceof V ? d++ : k instanceof T ? f++ : k instanceof ue ? g++ : c++;\n    }\n\n    h = \"\";\n    0 < c && (h += c + \" Parts \");\n    0 < d && (h += d + \" Nodes \");\n    0 < e && (h += e + \" Groups \");\n    0 < f && (h += f + \" Links \");\n    0 < g && (h += g + \" Adornments \");\n    if (1 < a) for (a = this.Ma.iterator; a.next();) {\n      c = a.value, h += \"\\n    \" + c.toString(), d = c.data, null !== d && cb(d) && (h += \" #\" + cb(d)), c instanceof V ? h += \" \" + Ia(d) : c instanceof T && (h += \" \" + Ia(c.fromNode) + \" \" + Ia(c.toNode));\n    }\n    return b + \" \" + this.Ma.count + \": \" + h;\n  };\n\n  t.ec = function (a, b, c) {\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    if (!1 === this.Nh) return null;\n    var d = !1;\n    null !== this.diagram && this.diagram.viewportBounds.ba(a) && (d = !0);\n\n    for (var e = I.alloc(), f = this.Ma.s, g = f.length; g--;) {\n      var h = f[g];\n      if ((!0 !== d || !1 !== ig(h)) && h.isVisible() && (e.assign(a), yb(e, h.ge), h = h.ec(e, b, c), null !== h && (null !== b && (h = b(h)), null !== h && (null === c || c(h))))) return I.free(e), h;\n    }\n\n    I.free(e);\n    return null;\n  };\n\n  t.di = function (a, b, c, d) {\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    d instanceof E || d instanceof G || (d = new G());\n    if (!1 === this.Nh) return d;\n    var e = !1;\n    null !== this.diagram && this.diagram.viewportBounds.ba(a) && (e = !0);\n\n    for (var f = I.alloc(), g = this.Ma.s, h = g.length; h--;) {\n      var k = g[h];\n\n      if ((!0 !== e || !1 !== ig(k)) && k.isVisible()) {\n        f.assign(a);\n        yb(f, k.ge);\n        var l = k;\n        k.di(f, b, c, d) && (null !== b && (l = b(l)), null === l || null !== c && !c(l) || d.add(l));\n      }\n    }\n\n    I.free(f);\n    return d;\n  };\n\n  t.tf = function (a, b, c, d, e) {\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    void 0 === d && (d = !1);\n    e instanceof E || e instanceof G || (e = new G());\n    if (!1 === this.Nh) return e;\n    var f = !1;\n    null !== this.diagram && this.diagram.viewportBounds.Ee(a) && (f = !0);\n\n    for (var g = this.Ma.s, h = g.length; h--;) {\n      var k = g[h];\n\n      if ((!0 !== f || !1 !== ig(k)) && k.isVisible()) {\n        var l = k;\n        k.tf(a, b, c, d, e) && (null !== b && (l = b(l)), null === l || null !== c && !c(l) || e.add(l));\n      }\n    }\n\n    return e;\n  };\n\n  t.zu = function (a, b, c, d, e, f, g) {\n    if (!1 === this.Nh) return e;\n\n    for (var h = this.Ma.s, k = h.length; k--;) {\n      var l = h[k];\n\n      if ((!0 !== g || !1 !== ig(l)) && f(l) && l.isVisible()) {\n        var m = l;\n        l.tf(a, b, c, d, e) && (null !== b && (m = b(m)), null === m || null !== c && !c(m) || e.add(m));\n      }\n    }\n\n    return e;\n  };\n\n  t.hg = function (a, b, c, d, e, f) {\n    void 0 === c && (c = null);\n    void 0 === d && (d = null);\n    void 0 === e && (e = !0);\n\n    if (!1 !== e && !0 !== e) {\n      if (e instanceof E || e instanceof G) f = e;\n      e = !0;\n    }\n\n    f instanceof E || f instanceof G || (f = new G());\n    if (!1 === this.Nh) return f;\n    var g = !1;\n    null !== this.diagram && this.diagram.viewportBounds.ba(a) && (g = !0);\n\n    for (var h = I.alloc(), k = I.alloc(), l = this.Ma.s, m = l.length; m--;) {\n      var n = l[m];\n\n      if ((!0 !== g || !1 !== ig(n)) && n.isVisible()) {\n        h.assign(a);\n        yb(h, n.ge);\n        k.h(a.x + b, a.y);\n        yb(k, n.ge);\n        var p = n;\n        n.hg(h, k, c, d, e, f) && (null !== c && (p = c(p)), null === p || null !== d && !d(p) || f.add(p));\n      }\n    }\n\n    I.free(h);\n    I.free(k);\n    return f;\n  };\n\n  t.Pd = function (a, b) {\n    if (this.visible) {\n      var c = this.Ma.s,\n          d = c.length;\n\n      if (0 !== d) {\n        a = Ea();\n\n        for (var e = Ea(), f = 0; f < d; f++) {\n          var g = c[f];\n          g.aw = f;\n\n          if (g instanceof T) {\n            if (!1 === g.xd) continue;\n          } else if (g instanceof ue && null !== g.adornedPart) continue;\n\n          var h = g.actualBounds;\n          g.isVisible() && Yb(h, b) ? (g.Pd(!0), a.push(g)) : (g.Pd(!1), null !== g.adornments && 0 < g.adornments.count && e.push(g));\n        }\n\n        for (b = 0; b < a.length; b++) {\n          for (c = a[b], ei(c), c = c.adornments; c.next();) {\n            d = c.value, d.measure(Infinity, Infinity), d.arrange(), d.Pd(!0);\n          }\n        }\n\n        for (b = 0; b < e.length; b++) {\n          ei(e[b]);\n        }\n\n        Ga(a);\n        Ga(e);\n      }\n    }\n  };\n\n  function fi(a, b) {\n    var c = 1;\n    1 !== a.tb && (c = b.globalAlpha, b.globalAlpha = c * a.tb);\n    return c;\n  }\n\n  t.tc = function (a, b, c) {\n    if (this.visible && 0 !== this.tb && (void 0 === c && (c = !0), c || !this.isTemporary)) {\n      c = this.Ma.s;\n      var d = c.length;\n\n      if (0 !== d) {\n        var e = fi(this, a),\n            f = this.Bn;\n        f.length = 0;\n\n        for (var g = b.scale, h = M.alloc(), k = 0; k < d; k++) {\n          this.$h(a, c[k], b, f, g, h, !0);\n        }\n\n        M.free(h);\n        a.globalAlpha = e;\n      }\n    }\n  };\n\n  t.$h = function (a, b, c, d, e, f, g) {\n    if (!g || ig(b)) {\n      if (null !== d && b instanceof T && (b.isOrthogonal && d.push(b), !1 === b.xd)) return;\n      g = !1;\n\n      for (d = b.containingGroup; null !== d;) {\n        g ? null !== d.ib && f.ix(d.ib) : null !== d.ib && (g = !0, f.assign(d.ib)), d = d.containingGroup;\n      }\n\n      var h = b.actualBounds;\n      d = !1;\n\n      if (g && b.isVisible()) {\n        if (!f.Sc(h)) return;\n        d = !f.Ee(h);\n      }\n\n      d && (a.save(), a.beginPath(), a.rect(f.x, f.y, f.width, f.height), a.clip());\n      h.width * e > c.nq || h.height * e > c.nq ? b.tc(a, c) : (e = b.actualBounds, f = b.naturalBounds, 0 === e.width || 0 === e.height || isNaN(e.x) || isNaN(e.y) || !b.isVisible() || (c = b.transform, null !== b.areaBackground && (gi(b, a, b.areaBackground, !0, !0, f, e), a.fillRect(e.x, e.y, e.width, e.height)), null === b.areaBackground && null === b.background && (gi(b, a, \"rgba(0,0,0,0.3)\", !0, !1, f, e), a.fillRect(e.x, e.y, e.width, e.height)), null !== b.background && (a.transform(c.m11, c.m12, c.m21, c.m22, c.dx, c.dy), gi(b, a, b.background, !0, !1, f, e), a.fillRect(0, 0, f.width / 2, f.height / 2), c.Ur() || (b = 1 / (c.m11 * c.m22 - c.m12 * c.m21), a.transform(c.m22 * b, -c.m12 * b, -c.m21 * b, c.m11 * b, b * (c.m21 * c.dy - c.m22 * c.dx), b * (c.m12 * c.dx - c.m11 * c.dy))))));\n      d && (a.restore(), a.Oc(!0));\n    }\n  };\n\n  t.g = function (a, b, c, d, e) {\n    var f = this.diagram;\n    null !== f && f.bb(de, a, this, b, c, d, e);\n  };\n\n  t.ii = function (a, b, c) {\n    var d = this.Ma;\n    b.Ah = this;\n    if (a >= d.count) a = d.count;else if (d.K(a) === b) return -1;\n    d.Cb(a, b);\n    b.yo(c);\n    d = this.diagram;\n    null !== d && (c ? d.N() : d.ii(b));\n    hi(this, a, b);\n    return a;\n  };\n\n  t.lc = function (a, b, c) {\n    if (!c && b.layer !== this && null !== b.layer) return b.layer.lc(a, b, c);\n    var d = this.Ma;\n\n    if (0 > a || a >= d.length) {\n      if (a = d.indexOf(b), 0 > a) return -1;\n    } else if (d.K(a) !== b && (a = d.indexOf(b), 0 > a)) return -1;\n\n    b.zo(c);\n    d.mb(a);\n    d = this.diagram;\n    null !== d && (c ? d.N() : d.lc(b));\n    b.Ah = null;\n    return a;\n  };\n\n  function hi(a, b, c) {\n    b = ii(a, b, c);\n\n    if (c instanceof qf && null !== c && isNaN(c.zOrder)) {\n      if (0 !== c.memberParts.count) {\n        for (var d = -1, e = a.Ma.s, f = e.length, g = 0; g < f; g++) {\n          var h = e[g];\n          if (h === c && (b = g, 0 <= d)) break;\n          if (0 > d && h.containingGroup === c && (d = g, 0 <= b)) break;\n        }\n\n        !(0 > d) && d < b && (e = a.Ma, e.mb(b), e.Cb(d, c));\n      }\n\n      c = c.containingGroup;\n      null !== c && hi(a, -1, c);\n    }\n  }\n\n  function ii(a, b, c) {\n    var d = c.zOrder;\n    if (isNaN(d)) return b;\n    a = a.Ma;\n    var e = a.count;\n    if (1 >= e) return b;\n    0 > b && (b = a.indexOf(c));\n    if (0 > b) return -1;\n\n    for (var f = b - 1, g = NaN; 0 <= f;) {\n      g = a.K(f).zOrder;\n      if (!isNaN(g)) break;\n      f--;\n    }\n\n    for (var h = b + 1, k = NaN; h < e;) {\n      k = a.K(h).zOrder;\n      if (!isNaN(k)) break;\n      h++;\n    }\n\n    if (!isNaN(g) && g > d) for (;;) {\n      if (-1 === f || g <= d) {\n        f++;\n        if (f === b) break;\n        a.mb(b);\n        a.Cb(f, c);\n        return f;\n      }\n\n      for (g = NaN; 0 <= --f && (g = a.K(f).zOrder, isNaN(g));) {\n        ;\n      }\n    } else if (!isNaN(k) && k < d) for (;;) {\n      if (h === e || k >= d) {\n        h--;\n        if (h === b) break;\n        a.mb(b);\n        a.Cb(h, c);\n        return h;\n      }\n\n      for (k = NaN; ++h < e && (k = a.K(h).zOrder, isNaN(k));) {\n        ;\n      }\n    }\n    return b;\n  }\n\n  ma.Object.defineProperties(di.prototype, {\n    parts: {\n      get: function get() {\n        return this.Ma.iterator;\n      }\n    },\n    partsBackwards: {\n      get: function get() {\n        return this.Ma.iteratorBackwards;\n      }\n    },\n    diagram: {\n      get: function get() {\n        return this.H;\n      }\n    },\n    name: {\n      get: function get() {\n        return this.va;\n      },\n      set: function set(a) {\n        var b = this.va;\n\n        if (b !== a) {\n          var c = this.diagram;\n          if (null !== c) for (\"\" === b && C(\"Cannot rename default Layer to: \" + a), c = c.layers; c.next();) {\n            c.value.name === a && C(\"Layer.name is already present in this diagram: \" + a);\n          }\n          this.va = a;\n          this.g(\"name\", b, a);\n\n          for (a = this.Ma.iterator; a.next();) {\n            a.value.layerName = this.va;\n          }\n        }\n      }\n    },\n    opacity: {\n      get: function get() {\n        return this.tb;\n      },\n      set: function set(a) {\n        var b = this.tb;\n        b !== a && ((0 > a || 1 < a) && wa(a, \"0 <= value <= 1\", di, \"opacity\"), this.tb = a, this.g(\"opacity\", b, a), a = this.diagram, null !== a && a.N());\n      }\n    },\n    isTemporary: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        var b = this.m;\n\n        if (b !== a) {\n          if (this.m = a) this.isInDocumentBounds = !1;\n          this.g(\"isTemporary\", b, a);\n        }\n      }\n    },\n    visible: {\n      get: function get() {\n        return this.u;\n      },\n      set: function set(a) {\n        var b = this.u;\n\n        if (b !== a) {\n          this.u = a;\n          this.g(\"visible\", b, a);\n\n          for (b = this.Ma.iterator; b.next();) {\n            b.value.Ub(a);\n          }\n\n          a = this.diagram;\n          null !== a && a.N();\n        }\n      }\n    },\n    pickable: {\n      get: function get() {\n        return this.Nh;\n      },\n      set: function set(a) {\n        var b = this.Nh;\n        b !== a && (this.Nh = a, this.g(\"pickable\", b, a));\n      }\n    },\n    isInDocumentBounds: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        this.j !== a && (this.j = a, null !== this.diagram && this.diagram.Va());\n      }\n    },\n    allowCopy: {\n      get: function get() {\n        return this.zi;\n      },\n      set: function set(a) {\n        var b = this.zi;\n        b !== a && (this.zi = a, this.g(\"allowCopy\", b, a));\n      }\n    },\n    allowDelete: {\n      get: function get() {\n        return this.Ai;\n      },\n      set: function set(a) {\n        var b = this.Ai;\n        b !== a && (this.Ai = a, this.g(\"allowDelete\", b, a));\n      }\n    },\n    allowTextEdit: {\n      get: function get() {\n        return this.Ji;\n      },\n      set: function set(a) {\n        var b = this.Ji;\n        b !== a && (this.Ji = a, this.g(\"allowTextEdit\", b, a));\n      }\n    },\n    allowGroup: {\n      get: function get() {\n        return this.Bi;\n      },\n      set: function set(a) {\n        var b = this.Bi;\n        b !== a && (this.Bi = a, this.g(\"allowGroup\", b, a));\n      }\n    },\n    allowUngroup: {\n      get: function get() {\n        return this.Ki;\n      },\n      set: function set(a) {\n        var b = this.Ki;\n        b !== a && (this.Ki = a, this.g(\"allowUngroup\", b, a));\n      }\n    },\n    allowLink: {\n      get: function get() {\n        return this.Ci;\n      },\n      set: function set(a) {\n        var b = this.Ci;\n        b !== a && (this.Ci = a, this.g(\"allowLink\", b, a));\n      }\n    },\n    allowRelink: {\n      get: function get() {\n        return this.Ei;\n      },\n      set: function set(a) {\n        var b = this.Ei;\n        b !== a && (this.Ei = a, this.g(\"allowRelink\", b, a));\n      }\n    },\n    allowMove: {\n      get: function get() {\n        return this.Di;\n      },\n      set: function set(a) {\n        var b = this.Di;\n        b !== a && (this.Di = a, this.g(\"allowMove\", b, a));\n      }\n    },\n    allowReshape: {\n      get: function get() {\n        return this.Fi;\n      },\n      set: function set(a) {\n        var b = this.Fi;\n        b !== a && (this.Fi = a, this.g(\"allowReshape\", b, a));\n      }\n    },\n    allowResize: {\n      get: function get() {\n        return this.Gi;\n      },\n      set: function set(a) {\n        var b = this.Gi;\n        b !== a && (this.Gi = a, this.g(\"allowResize\", b, a));\n      }\n    },\n    allowRotate: {\n      get: function get() {\n        return this.Hi;\n      },\n      set: function set(a) {\n        var b = this.Hi;\n        b !== a && (this.Hi = a, this.g(\"allowRotate\", b, a));\n      }\n    },\n    allowSelect: {\n      get: function get() {\n        return this.Ii;\n      },\n      set: function set(a) {\n        var b = this.Ii;\n        b !== a && (this.Ii = a, this.g(\"allowSelect\", b, a));\n      }\n    }\n  });\n  di.prototype.findObjectsNear = di.prototype.hg;\n  di.prototype.findObjectsIn = di.prototype.tf;\n  di.prototype.findObjectsAt = di.prototype.di;\n  di.prototype.findObjectAt = di.prototype.ec;\n  di.className = \"Layer\";\n\n  function Q(a, b) {\n    ji || (ki(), ji = !0);\n    Ra(this);\n    le = this;\n    this.wb = !0;\n    this.La = null;\n    this.Aa = this.Ba = 0;\n    this.Ha = null;\n\n    if (Og) {\n      var c = this,\n          d = function d() {\n        c.removeEventListener(x.document, \"DOMContentLoaded\", d, !1);\n        c.setRTL();\n      };\n\n      null !== x.document.body ? this.setRTL() : c.addEventListener(x.document, \"DOMContentLoaded\", d, !1);\n    }\n\n    this.cl = null;\n    li.add(\"Model\", mi);\n    var e = this;\n\n    this.Db = function (a) {\n      var b = e.partManager;\n\n      if (a.model === b.diagram.model && b.diagram.$) {\n        b.diagram.$ = !1;\n\n        try {\n          var c = a.change;\n          \"\" === a.modelChange && c === de && b.updateDataBindings(a.object, a.propertyName);\n        } finally {\n          b.diagram.$ = !0;\n        }\n      }\n    };\n\n    this.Hc = function (a) {\n      e.partManager.doModelChanged(a);\n    };\n\n    this.Nt = this.Qt = null;\n    ni(this);\n    this.model = oi();\n    this.Mg = !0;\n    pi(this);\n    this.layout = new qi();\n    this.Mg = !1;\n    this.Yj = this.Zj = this.Xj = this.Wj = this.Iz = this.Sj = this.sv = null;\n\n    this.Jo = function () {};\n\n    this.preventDefault = null;\n    this.Ym = !1;\n    this.vh = new ri();\n    void 0 !== a && (\"string\" === typeof a || x.Element && a instanceof Element ? si(this, a) : b = a);\n    this.wb = !1;\n    b && this.Vl(b);\n    return this;\n  }\n\n  var ti, le;\n\n  function ni(a) {\n    a.Rd = new gh();\n    a.Rd.Le(a);\n    a.Ab = 17;\n    a.kw = !1;\n    a.$m = !1;\n    a.Ht = \"default\";\n    a.Ua = new E();\n    a.Yx = new pb();\n    a.Ax();\n    a.zx();\n    a.tb = 1;\n    a.pa = new I(NaN, NaN).freeze();\n    a.Jt = new I(NaN, NaN);\n    a.xa = 1;\n    a.sp = 1;\n    a.bt = new I(NaN, NaN).freeze();\n    a.ct = NaN;\n    a.tt = 1E-4;\n    a.pt = 100;\n    a.Bb = new md();\n    a.eu = new I(NaN, NaN).freeze();\n    a.Xs = new M(NaN, NaN, NaN, NaN).freeze();\n    a.mj = new ec(0, 0, 0, 0).freeze();\n    a.nj = Rh;\n    a.Tt = !1;\n    a.Et = null;\n    a.Lt = null;\n    a.nh = rh;\n    a.mk = Wc;\n    a.wg = rh;\n    a.Rp = Wc;\n    a.at = tc;\n    a.dt = tc;\n    a.bd = !0;\n    a.Wm = !1;\n    a.te = new G();\n    a.th = new pb();\n    a.Fm = !0;\n    a.Yo = 250;\n    a.ik = -1;\n    a.$o = new ec(16, 16, 16, 16).freeze();\n    a.cg = !1;\n    a.xk = !1;\n    a.Nm = !0;\n    a.Fp = new $d();\n    a.Fp.diagram = a;\n    a.Hg = new $d();\n    a.Hg.diagram = a;\n    a.Yi = new $d();\n    a.Yi.diagram = a;\n    a.qg = null;\n    a.bf = null;\n    a.Wt = !1;\n    ui(a);\n    a.Uh = new G();\n    a.kt = !0;\n    a.$t = vi;\n    a.Vv = !1;\n    a.bu = Ef;\n    a.Ks = \"auto\";\n    a.rp = \"auto\";\n    a.oh = null;\n    a.uh = null;\n    a.qh = null;\n    a.Jh = null;\n    a.Hh = null;\n    a.Gh = null;\n    a.vt = null;\n    a.Eh = null;\n    a.$s = !1;\n    a.Fh = null;\n    a.Ih = null;\n    a.Th = null;\n    a.rh = null;\n    a.wt = !1;\n    a.Dt = {};\n    a.$k = [null, null];\n    a.Mg = !1;\n    a.mw = !1;\n    a.Ut = !1;\n    a.Ns = !1;\n    a.Xv = !0;\n    a.cd = !1;\n    a.Vi = !1;\n    a.xw = !0;\n    a.se = -2;\n    a.Fg = new pb();\n    a.Fn = new E();\n    a.xg = !1;\n    a.Ad = !0;\n    a.ws = !0;\n    a.zi = !0;\n    a.Ai = !0;\n    a.xs = !1;\n    a.ys = !0;\n    a.Ji = !0;\n    a.Bi = !0;\n    a.Ki = !0;\n    a.As = !0;\n    a.Ci = !0;\n    a.Ei = !0;\n    a.Di = !0;\n    a.Fi = !0;\n    a.Gi = !0;\n    a.Hi = !0;\n    a.Ii = !0;\n    a.Bs = !0;\n    a.Ds = !0;\n    a.Wv = !1;\n    a.Kk = !1;\n    a.Tm = !0;\n    a.Um = !0;\n    a.zs = !0;\n    a.Cs = !0;\n    a.Ot = 16;\n    a.St = 16;\n    a.Nq = !1;\n    a.Mt = !1;\n    a.Rt = 0;\n    a.Pt = 0;\n    a.ub = new ec(5).freeze();\n    a.lw = new G().freeze();\n    a.qt = 999999999;\n    a.Tv = new G().freeze();\n    a.Si = !0;\n    a.Ti = !0;\n    a.Ui = !0;\n    a.We = !1;\n    a.Of = !1;\n    a.mh = !0;\n    a.Qf = !1;\n    a.Xx = new G();\n    a.Uv = new G();\n    a.Qh = null;\n    a.Fv = new K(8, 8);\n    a.Gv = 999;\n    a.fw = 1;\n    a.nw = 0;\n    a.kd = {\n      scale: 1,\n      position: new I(),\n      bounds: new M(),\n      Hw: new K(),\n      sx: new K(),\n      lx: !1\n    };\n    a.vw = new M(NaN, NaN, NaN, NaN).freeze();\n    a.Zn = new K(NaN, NaN).freeze();\n    a.wp = new M(NaN, NaN, NaN, NaN).freeze();\n    a.lt = !1;\n    a.Dg = new pb();\n    var b = new V(),\n        c = new Qg();\n    c.bind(new wi(\"text\", \"\", Ia));\n    b.add(c);\n    a.Tx = b;\n    a.Dg.add(\"\", b);\n    b = new V();\n    c = new Qg();\n    c.stroke = \"brown\";\n    c.bind(new wi(\"text\", \"\", Ia));\n    b.add(c);\n    a.Dg.add(\"Comment\", b);\n    b = new V();\n    b.selectable = !1;\n    b.avoidable = !1;\n    c = new Cf();\n    c.figure = \"Ellipse\";\n    c.fill = \"black\";\n    c.stroke = null;\n    c.desiredSize = new K(3, 3).ha();\n    b.add(c);\n    a.Dg.add(\"LinkLabel\", b);\n    a.Ri = new pb();\n    b = new qf();\n    b.selectionObjectName = \"GROUPPANEL\";\n    b.type = W.Vertical;\n    c = new Qg();\n    c.font = \"bold 12pt sans-serif\";\n    c.bind(new wi(\"text\", \"\", Ia));\n    b.add(c);\n    c = new W(W.Auto);\n    c.name = \"GROUPPANEL\";\n    var d = new Cf();\n    d.figure = \"Rectangle\";\n    d.fill = \"rgba(128,128,128,0.2)\";\n    d.stroke = \"black\";\n    c.add(d);\n    d = new jg();\n    d.padding = new ec(5, 5, 5, 5).ha();\n    c.add(d);\n    b.add(c);\n    a.Rx = b;\n    a.Ri.add(\"\", b);\n    a.Ch = new pb();\n    b = new T();\n    c = new Cf();\n    c.isPanelMain = !0;\n    b.add(c);\n    c = new Cf();\n    c.toArrow = \"Standard\";\n    c.fill = \"black\";\n    c.stroke = null;\n    c.strokeWidth = 0;\n    b.add(c);\n    a.Sx = b;\n    a.Ch.add(\"\", b);\n    b = new T();\n    c = new Cf();\n    c.isPanelMain = !0;\n    c.stroke = \"brown\";\n    b.add(c);\n    a.Ch.add(\"Comment\", b);\n    b = new ue();\n    b.type = W.Auto;\n    c = new Cf();\n    c.fill = null;\n    c.stroke = \"dodgerblue\";\n    c.strokeWidth = 3;\n    b.add(c);\n    c = new jg();\n    c.margin = new ec(1.5, 1.5, 1.5, 1.5).ha();\n    b.add(c);\n    a.xt = b;\n    a.Zs = b;\n    b = new ue();\n    b.type = W.Link;\n    c = new Cf();\n    c.isPanelMain = !0;\n    c.fill = null;\n    c.stroke = \"dodgerblue\";\n    c.strokeWidth = 3;\n    b.add(c);\n    a.nt = b;\n    a.Zd = null;\n    a.Op = !1;\n    a.qk = null;\n    a.partManager = new mi();\n    a.toolManager = new La();\n    a.toolManager.initializeStandardTools();\n    a.defaultTool = a.toolManager;\n    a.currentTool = a.defaultTool;\n    a.Ps = null;\n    a.Em = new Ce();\n    a.At = null;\n    a.Bt = null;\n    a.jr = !1;\n    a.commandHandler = xi();\n    a.kr = !1;\n    a.Hp = null;\n    a.Ip = ub;\n    a.tw = !1;\n    a.kc = 1;\n    a.Rh = null;\n    a.nq = 1;\n    a.rq = 0;\n    a.dw = [0, 0, 0, 0, 0];\n    a.sq = 0;\n    a.Yp = 1;\n    a.Zv = 0;\n    a.$v = new I();\n    a.hy = 500;\n    a.Zo = new I();\n    a.jt = !1;\n  }\n\n  Q.prototype.clear = function () {\n    this.animationManager.wc();\n    this.model.clear();\n    yi = null;\n    zi = \"\";\n    Ai(this, !1);\n    this.Fn.clear();\n    Bi();\n    this.Fg.clear();\n    this.Qh = null;\n    this.Va();\n    this.Za();\n    this.N();\n  };\n\n  function Ai(a, b) {\n    a.animationManager.wc(!0);\n    a.lw = new G().freeze();\n    a.Tv = new G().freeze();\n    var c = a.skipsUndoManager,\n        d = null !== a.ac && void 0 !== a.ac;\n    d && (a.skipsUndoManager = !0);\n    var e = null;\n    null !== a.Zd && (e = a.Zd.part, null !== e && a.remove(e));\n    var f = [],\n        g = a.Ua.length;\n\n    if (b) {\n      for (b = 0; b < g; b++) {\n        for (var h = a.Ua.s[b].parts; h.next();) {\n          var k = h.value;\n          k !== e && null === k.data && f.push(k);\n        }\n      }\n\n      for (b = 0; b < f.length; b++) {\n        a.remove(f[b]);\n      }\n    }\n\n    for (b = 0; b < g; b++) {\n      a.Ua.s[b].clear();\n    }\n\n    a.partManager.clear();\n    a.te.clear();\n    a.th.clear();\n    a.Uh.clear();\n    a.qk = null;\n    a.Fn.clear();\n    Bi();\n    a.Fg.clear();\n    Fa = [];\n    null !== e && (a.add(e), a.partManager.parts.remove(e));\n    d && (a.skipsUndoManager = c);\n    return f;\n  }\n\n  function xi() {\n    return null;\n  }\n\n  Q.prototype.reset = function () {\n    this.clear();\n    this.wb = !0;\n    ni(this);\n    Ci(this);\n    this.Mg = !0;\n    pi(this);\n    this.layout = new qi();\n    this.Mg = !1;\n    this.model = oi();\n    this.model.undoManager = new ie();\n    this.wb = this.Ym = !1;\n    this.N();\n  };\n\n  Q.prototype.setRTL = function (a) {\n    a = void 0 === a ? this.div : a;\n    null === a && (a = x.document.body);\n    var b = ua(\"div\");\n    b.dir = \"rtl\";\n    b.style.cssText = \"font-size: 14px; width: 1px; height: 1px; position: absolute; top: -1000px; overflow: scroll;\";\n    b.textContent = \"A\";\n    a.appendChild(b);\n    var c = \"reverse\";\n    0 < b.scrollLeft ? c = \"default\" : (b.scrollLeft = 1, 0 === b.scrollLeft && (c = \"negative\"));\n    a.removeChild(b);\n    this.Ht = c;\n  };\n\n  Q.prototype.setScrollWidth = function (a) {\n    a = void 0 === a ? this.div : a;\n    null === a && (a = x.document.body);\n    var b = 0;\n\n    if (Og) {\n      var c = Di;\n      b = ti;\n      null === c && (c = Di = ua(\"p\"), c.style.width = \"100%\", c.style.height = \"200px\", c.style.boxSizing = \"content-box\", b = ti = ua(\"div\"), b.style.position = \"absolute\", b.style.visibility = \"hidden\", b.style.width = \"200px\", b.style.height = \"150px\", b.style.boxSizing = \"content-box\", b.appendChild(c));\n      b.style.overflow = \"hidden\";\n      a.appendChild(b);\n      var d = c.offsetWidth;\n      b.style.overflow = \"scroll\";\n      c = c.offsetWidth;\n      d === c && (c = b.clientWidth);\n      a.removeChild(b);\n      b = d - c;\n      0 !== b || Qa || (b = 11);\n    }\n\n    this.Ab = b;\n    this.kw = !0;\n  };\n\n  Q.prototype.ob = function (a) {\n    a.classType === Q && (this.autoScale = a);\n  };\n\n  Q.prototype.toString = function (a) {\n    void 0 === a && (a = 0);\n    var b = \"\";\n    this.div && this.div.id && (b = this.div.id);\n    b = 'Diagram \"' + b + '\"';\n    if (0 >= a) return b;\n\n    for (var c = this.Ua.iterator; c.next();) {\n      b += \"\\n  \" + c.value.toString(a - 1);\n    }\n\n    return b;\n  };\n\n  Q.prototype.addEventListener = function (a, b, c, d) {\n    a.addEventListener(b, c, {\n      capture: d,\n      passive: !1\n    });\n  };\n\n  Q.prototype.removeEventListener = function (a, b, c, d) {\n    a.removeEventListener(b, c, {\n      capture: d\n    });\n  };\n\n  function Ei(a) {\n    var b = a.Ha.Sa;\n    b instanceof HTMLCanvasElement && (a.addEventListener(b, \"pointerdown\", a.Wj, !1), a.addEventListener(b, \"pointermove\", a.Xj, !1), a.addEventListener(b, \"pointerup\", a.Zj, !1), a.addEventListener(b, \"pointerout\", a.Yj, !1), a.addEventListener(b, \"pointerenter\", a.Jy, !1), a.addEventListener(b, \"pointerleave\", a.Ky, !1), a.addEventListener(b, \"wheel\", a.Sj, !1), a.addEventListener(b, \"keydown\", a.yz, !1), a.addEventListener(b, \"keyup\", a.zz, !1), a.addEventListener(b, \"blur\", a.vy, !1), a.addEventListener(b, \"focus\", a.wy, !1), a.addEventListener(b, \"selectstart\", function (a) {\n      a.preventDefault();\n      return !1;\n    }, !1), a.addEventListener(b, \"contextmenu\", function (a) {\n      a.preventDefault();\n      return !1;\n    }, !1), a.addEventListener(x, \"resize\", a.sv, !1), Qa && a.addEventListener(b, \"touchstart\", function (a) {\n      a.preventDefault();\n    }, !1));\n  }\n\n  function Ge(a) {\n    30 < a.rq && (a.Rh = 1);\n  }\n\n  function Ye(a, b) {\n    null !== a.Rh && (a.Rh = null, b && a.Jo(), Xa && Xa.Rw || (a.rq = 0, a.dw = [0, 0, 0, 0, 0], a.sq = 0));\n  }\n\n  Q.prototype.computePixelRatio = function () {\n    return null !== this.Rh ? this.Rh : x.devicePixelRatio || 1;\n  };\n\n  Q.prototype.doMouseMove = function () {\n    this.currentTool.doMouseMove();\n  };\n\n  Q.prototype.doMouseDown = function () {\n    this.currentTool.doMouseDown();\n  };\n\n  Q.prototype.doMouseUp = function () {\n    this.currentTool.doMouseUp();\n  };\n\n  Q.prototype.doMouseWheel = function () {\n    this.currentTool.doMouseWheel();\n  };\n\n  Q.prototype.doKeyDown = function () {\n    this.currentTool.doKeyDown();\n  };\n\n  Q.prototype.doKeyUp = function () {\n    this.currentTool.doKeyUp();\n  };\n\n  Q.prototype.doFocus = function () {\n    this.focus();\n  };\n\n  Q.prototype.focus = function () {\n    if (this.Ha) if (this.scrollsPageOnFocus) this.Ha.focus();else {\n      var a = x.scrollX || x.pageXOffset,\n          b = x.scrollY || x.pageYOffset;\n      this.Ha.focus();\n      x.scrollTo(a, b);\n    }\n  };\n\n  Q.prototype.wy = function () {\n    this.H.P(\"GainedFocus\");\n  };\n\n  Q.prototype.vy = function () {\n    this.H.P(\"LostFocus\");\n  };\n\n  function sh(a) {\n    if (null !== a.Ha) {\n      var b = a.La;\n\n      if (null !== b && 0 !== b.clientWidth && 0 !== b.clientHeight) {\n        a.kw || a.setScrollWidth();\n        var c = a.Of ? a.Ab : 0,\n            d = a.We ? a.Ab : 0,\n            e = a.kc;\n        a.kc = a.computePixelRatio();\n        a.kc !== e && (a.Wm = !0, a.Mb());\n        if (b.clientWidth !== a.Ba + c || b.clientHeight !== a.Aa + d) a.Ti = !0, a.bd = !0, b = a.layout, null !== b && b.isViewportSized && a.autoScale === rh && (a.xk = !0, b.D()), a.cd || a.Mb();\n      }\n    }\n  }\n\n  function pi(a) {\n    var b = new di();\n    b.name = \"Background\";\n    a.pl(b);\n    b = new di();\n    b.name = \"\";\n    a.pl(b);\n    b = new di();\n    b.name = \"Foreground\";\n    a.pl(b);\n    b = new di();\n    b.name = \"Adornment\";\n    b.isTemporary = !0;\n    b.isInDocumentBounds = !1;\n    a.pl(b);\n    b = new di();\n    b.name = \"Tool\";\n    b.isTemporary = !0;\n    b.isInDocumentBounds = !0;\n    a.pl(b);\n    b = new di();\n    b.name = \"Grid\";\n    b.allowSelect = !1;\n    b.pickable = !1;\n    b.isTemporary = !0;\n    b.isInDocumentBounds = !1;\n    a.Aw(b, a.Ij(\"Background\"));\n  }\n\n  function Fi(a) {\n    var b = new W(W.Grid);\n    b.name = \"GRID\";\n    var c = new Cf();\n    c.figure = \"LineH\";\n    c.stroke = \"lightgray\";\n    c.strokeWidth = .5;\n    c.interval = 1;\n    b.add(c);\n    c = new Cf();\n    c.figure = \"LineH\";\n    c.stroke = \"gray\";\n    c.strokeWidth = .5;\n    c.interval = 5;\n    b.add(c);\n    c = new Cf();\n    c.figure = \"LineH\";\n    c.stroke = \"gray\";\n    c.strokeWidth = 1;\n    c.interval = 10;\n    b.add(c);\n    c = new Cf();\n    c.figure = \"LineV\";\n    c.stroke = \"lightgray\";\n    c.strokeWidth = .5;\n    c.interval = 1;\n    b.add(c);\n    c = new Cf();\n    c.figure = \"LineV\";\n    c.stroke = \"gray\";\n    c.strokeWidth = .5;\n    c.interval = 5;\n    b.add(c);\n    c = new Cf();\n    c.figure = \"LineV\";\n    c.stroke = \"gray\";\n    c.strokeWidth = 1;\n    c.interval = 10;\n    b.add(c);\n    c = new U();\n    c.add(b);\n    c.layerName = \"Grid\";\n    c.zOrder = 0;\n    c.isInDocumentBounds = !1;\n    c.isAnimated = !1;\n    c.pickable = !1;\n    c.locationObjectName = \"GRID\";\n    a.add(c);\n    a.partManager.parts.remove(c);\n    b.visible = !1;\n    return b;\n  }\n\n  function Gi() {\n    this.H.Mt ? this.H.Mt = !1 : this.H.isEnabled ? this.H.Nw(this) : Oi(this.H);\n  }\n\n  function Qi(a) {\n    this.H.isEnabled ? (this.H.Rt = a.target.scrollTop, this.H.Pt = a.target.scrollLeft) : Oi(this.H);\n  }\n\n  Q.prototype.Nw = function (a) {\n    if (null !== this.Ha) {\n      var b = this.Qt,\n          c = this.Nt;\n      this.Nq = !0;\n      var d = this.documentBounds,\n          e = this.viewportBounds,\n          f = this.mj,\n          g = d.x - f.left,\n          h = d.y - f.top,\n          k = d.width + f.left + f.right,\n          l = d.height + f.top + f.bottom,\n          m = d.right + f.right;\n      f = d.bottom + f.bottom;\n      var n = e.x;\n      d = e.y;\n      var p = e.width,\n          r = e.height,\n          q = e.right,\n          u = e.bottom;\n      e = this.scale;\n      var w = a.scrollLeft;\n      if (this.$m) switch (this.Ht) {\n        case \"negative\":\n          w = w + a.scrollWidth - a.clientWidth;\n          break;\n\n        case \"reverse\":\n          w = a.scrollWidth - w - a.clientWidth;\n      }\n      var v = w;\n      p < k || r < l ? (w = I.allocAt(this.position.x, this.position.y), this.allowHorizontalScroll && this.Pt !== v && (w.x = v / e + g, this.Pt = v), this.allowVerticalScroll && this.Rt !== a.scrollTop && (w.y = a.scrollTop / e + h, this.Rt = a.scrollTop), this.position = w, I.free(w), this.Ti = this.Nq = !1) : (w = I.alloc(), a.$x && this.allowHorizontalScroll && (g < n && (this.position = w.h(v + g, this.position.y)), m > q && (this.position = w.h(-(b.scrollWidth - this.Ba) + v - this.Ba / e + m, this.position.y))), a.ay && this.allowVerticalScroll && (h < d && (this.position = w.h(this.position.x, a.scrollTop + h)), f > u && (this.position = w.h(this.position.x, -(b.scrollHeight - this.Aa) + a.scrollTop - this.Aa / e + f))), I.free(w), Ri(this), this.Ti = this.Nq = !1, d = this.documentBounds, e = this.viewportBounds, m = d.right, q = e.right, f = d.bottom, u = e.bottom, g = d.x, n = e.x, h = d.y, d = e.y, p >= k && g >= n && m <= q && (c.style.width = \"1px\"), r >= l && h >= d && f <= u && (c.style.height = \"1px\"));\n    }\n  };\n\n  Q.prototype.computeBounds = function (a) {\n    void 0 === a && (a = new M());\n    mh(this);\n    return Si(this, a);\n  };\n\n  function Si(a, b) {\n    if (a.fixedBounds.v()) return b.assign(a.fixedBounds), b.fo(a.ub), b;\n\n    for (var c = !0, d = a.Ua.s, e = d.length, f = 0; f < e; f++) {\n      var g = d[f];\n\n      if (g.visible && g.isInDocumentBounds) {\n        g = g.Ma.s;\n\n        for (var h = g.length, k = 0; k < h; k++) {\n          var l = g[k];\n          l.isInDocumentBounds && l.isVisible() && (l = l.actualBounds, l.v() && (c ? (c = !1, b.assign(l)) : b.Xc(l)));\n        }\n      }\n    }\n\n    c && b.h(0, 0, 0, 0);\n    b.fo(a.ub);\n    return b;\n  }\n\n  Q.prototype.computePartsBounds = function (a, b) {\n    void 0 === b && (b = !1);\n    var c = null;\n    if (za(a)) for (var d = 0; d < a.length; d++) {\n      var e = a[d];\n      !b && e instanceof T || (e.Za(), null === c ? c = e.actualBounds.copy() : c.Xc(e.actualBounds));\n    } else for (a = a.iterator; a.next();) {\n      d = a.value, !b && d instanceof T || (d.Za(), null === c ? c = d.actualBounds.copy() : c.Xc(d.actualBounds));\n    }\n    return null === c ? new M(NaN, NaN, 0, 0) : c;\n  };\n\n  function Ti(a, b) {\n    if ((b || a.Qf) && !a.wb && null !== a.Ha && a.documentBounds.v()) {\n      if (b) {\n        var c = a.initialPosition;\n\n        if (c.v()) {\n          a.position = c;\n          return;\n        }\n\n        c = I.alloc();\n        c.oi(a.documentBounds, a.initialDocumentSpot);\n        var d = a.viewportBounds;\n        d = M.allocAt(0, 0, d.width, d.height);\n        var e = I.alloc();\n        e.oi(d, a.initialViewportSpot);\n        e.h(c.x - e.x, c.y - e.y);\n        a.position = e;\n        M.free(d);\n        I.free(e);\n        I.free(c);\n      }\n\n      a.wb = !0;\n      c = a.nh;\n      b && a.wg !== rh && (c = a.wg);\n      var f = c !== rh ? Ui(a, c) : a.scale;\n      c = a.pa.x;\n      d = a.pa.y;\n      e = a.Ba / f;\n      var g = a.Aa / f,\n          h = a.mk,\n          k = a.Rp;\n      b && !h.pb() && (k.pb() || k.Sb()) && (h = k.Sb() ? yc : k);\n      Vi(a, a.documentBounds, e, g, h, b);\n      b = a.scale;\n      a.scale = f;\n      a.wb = !1;\n      Wi(a);\n      Xi(a, !0, !1);\n      f = a.viewportBounds;\n      if (!(J.B(f.x, c) && J.B(f.y, d) && J.B(f.width, e) && J.B(f.height, g))) a.onViewportBoundsChanged(new M(c, d, e, g), f, b, !1);\n    }\n  }\n\n  function Ui(a, b) {\n    var c = a.sp;\n    if (null === a.Ha) return c;\n    a.Za();\n    var d = a.documentBounds;\n    if (!d.v()) return c;\n    var e = d.width;\n    d = d.height;\n    var f = a.Ba + (a.Of ? a.Ab : 0),\n        g = a.Aa + (a.We ? a.Ab : 0),\n        h = f / e,\n        k = g / d;\n    return b === Yi ? (b = Math.min(k, h), b > c && (b = c), b < a.minScale && (b = a.minScale), b > a.maxScale && (b = a.maxScale), b) : b === Zi ? (b = k > h ? (g - a.Ab) / d : (f - a.Ab) / e, b > c && (b = c), b < a.minScale && (b = a.minScale), b > a.maxScale && (b = a.maxScale), b) : a.scale;\n  }\n\n  Q.prototype.zoomToFit = function () {\n    var a = this.nj;\n    this.nj = Rh;\n    this.scale = Ui(this, Yi);\n    a !== Rh && (Ti(this, !1), Vi(this, this.documentBounds, this.Ba / this.xa, this.Aa / this.xa, this.mk, !1));\n    this.nj = a;\n  };\n\n  t = Q.prototype;\n\n  t.kA = function (a, b) {\n    void 0 === b && (b = Yi);\n    var c = a.width,\n        d = a.height;\n\n    if (!(0 === c || 0 === d || isNaN(c) && isNaN(d))) {\n      var e = 1;\n      if (b === Yi || b === Zi) if (isNaN(c)) e = this.viewportBounds.height * this.scale / d;else if (isNaN(d)) e = this.viewportBounds.width * this.scale / c;else {\n        e = this.Ba;\n        var f = this.Aa;\n        e = b === Zi ? f / d > e / c ? (f - (this.We ? this.Ab : 0)) / d : (e - (this.Of ? this.Ab : 0)) / c : Math.min(f / d, e / c);\n      }\n      this.scale = e;\n      this.position = new I(a.x, a.y);\n    }\n  };\n\n  t.py = function (a, b) {\n    this.Za();\n    var c = this.documentBounds,\n        d = this.viewportBounds;\n    this.position = new I(c.x + (a.x * c.width + a.offsetX) - (b.x * d.width - b.offsetX), c.y + (a.y * c.height + a.offsetY) - (b.y * d.height - b.offsetY));\n  };\n\n  t.gz = function (a) {\n    if (a instanceof Y) {\n      this.Hp = a;\n      var b = I.alloc();\n      this.Ip = this.Ro(a.ia(tc, b));\n      I.free(b);\n    } else this.Hp = null, this.Ip = ub;\n  };\n\n  function Vi(a, b, c, d, e, f) {\n    var g = I.allocAt(a.pa.x, a.pa.y),\n        h = g.x,\n        k = g.y;\n\n    if (null !== a.Hp) {\n      var l = I.alloc();\n      l = a.Hp.ia(tc, l);\n      h = l.x - a.Ip.x / a.scale;\n      k = l.y - a.Ip.y / a.scale;\n      e = sc;\n      I.free(l);\n    }\n\n    if (f || a.scrollMode === Rh) e.pb() && (c > b.width && (h = b.x + (e.x * b.width + e.offsetX) - (e.x * c - e.offsetX)), d > b.height && (k = b.y + (e.y * b.height + e.offsetY) - (e.y * d - e.offsetY))), e = a.mj, f = c - b.width, c < b.width + e.left + e.right ? (h = Math.min(h + c / 2, b.right + Math.max(f, e.right) - c / 2), h = Math.max(h, b.left - Math.max(f, e.left) + c / 2), h -= c / 2) : h > b.left ? h = b.left : h < b.right - c && (h = b.right - c), c = d - b.height, d < b.height + e.top + e.bottom ? (k = Math.min(k + d / 2, b.bottom + Math.max(c, e.bottom) - d / 2), k = Math.max(k, b.top - Math.max(c, e.top) + d / 2), k -= d / 2) : k > b.top ? k = b.top : k < b.bottom - d && (k = b.bottom - d);\n    g.x = isFinite(h) ? h : -a.ub.left;\n    g.y = isFinite(k) ? k : -a.ub.top;\n    null !== a.positionComputation && (b = a.positionComputation(a, g), g.x = b.x, g.y = b.y);\n    Nh(a.Rd, a.pa, g);\n    a.pa.h(g.x, g.y);\n    Ci(a);\n    I.free(g);\n  }\n\n  t.wl = function (a, b) {\n    void 0 === b && (b = !0);\n\n    if (b) {\n      if (a = rf(this, a, function (a) {\n        return a.part;\n      }, function (a) {\n        return a.canSelect();\n      }), a instanceof U) return a;\n    } else if (a = rf(this, a, function (a) {\n      return a.part;\n    }), a instanceof U) return a;\n\n    return null;\n  };\n\n  t.ec = function (a, b, c) {\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    mh(this);\n\n    for (var d = this.Ua.iteratorBackwards; d.next();) {\n      var e = d.value;\n      if (e.visible && (e = e.ec(a, b, c), null !== e)) return e;\n    }\n\n    return null;\n  };\n\n  function rf(a, b, c, d) {\n    void 0 === c && (c = null);\n    void 0 === d && (d = null);\n    mh(a);\n\n    for (a = a.Ua.iteratorBackwards; a.next();) {\n      var e = a.value;\n      if (e.visible && !e.isTemporary && (e = e.ec(b, c, d), null !== e)) return e;\n    }\n\n    return null;\n  }\n\n  t.Uy = function (a, b, c) {\n    void 0 === b && (b = !0);\n    return $i(this, a, function (a) {\n      return a.part;\n    }, b ? function (a) {\n      return a instanceof U && a.canSelect();\n    } : null, c);\n  };\n\n  function $i(a, b, c, d, e) {\n    void 0 === c && (c = null);\n    void 0 === d && (d = null);\n    e instanceof E || e instanceof G || (e = new G());\n    mh(a);\n\n    for (a = a.Ua.iteratorBackwards; a.next();) {\n      var f = a.value;\n      f.visible && !f.isTemporary && f.di(b, c, d, e);\n    }\n\n    return e;\n  }\n\n  t.di = function (a, b, c, d) {\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    d instanceof E || d instanceof G || (d = new G());\n    mh(this);\n\n    for (var e = this.Ua.iteratorBackwards; e.next();) {\n      var f = e.value;\n      f.visible && f.di(a, b, c, d);\n    }\n\n    return d;\n  };\n\n  t.Ww = function (a, b, c, d) {\n    void 0 === b && (b = !1);\n    void 0 === c && (c = !0);\n    return aj(this, a, function (a) {\n      return a instanceof U && (!c || a.canSelect());\n    }, b, d);\n  };\n\n  t.tf = function (a, b, c, d, e) {\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    void 0 === d && (d = !1);\n    e instanceof E || e instanceof G || (e = new G());\n    mh(this);\n\n    for (var f = this.Ua.iteratorBackwards; f.next();) {\n      var g = f.value;\n      g.visible && g.tf(a, b, c, d, e);\n    }\n\n    return e;\n  };\n\n  t.zu = function (a, b, c, d, e, f) {\n    var g = new G();\n    mh(this);\n\n    for (var h = this.Ua.iteratorBackwards; h.next();) {\n      var k = h.value;\n      k.visible && k.zu(a, b, c, d, g, e, f);\n    }\n\n    return g;\n  };\n\n  function aj(a, b, c, d, e) {\n    var f = null;\n    void 0 === f && (f = null);\n    void 0 === c && (c = null);\n    void 0 === d && (d = !1);\n    e instanceof E || e instanceof G || (e = new G());\n    mh(a);\n\n    for (a = a.Ua.iteratorBackwards; a.next();) {\n      var g = a.value;\n      g.visible && !g.isTemporary && g.tf(b, f, c, d, e);\n    }\n\n    return e;\n  }\n\n  t.Vy = function (a, b, c, d, e) {\n    void 0 === c && (c = !0);\n    void 0 === d && (d = !0);\n    return bj(this, a, b, function (a) {\n      return a instanceof U && (!d || a.canSelect());\n    }, c, e);\n  };\n\n  t.hg = function (a, b, c, d, e, f) {\n    void 0 === c && (c = null);\n    void 0 === d && (d = null);\n    void 0 === e && (e = !0);\n\n    if (!1 !== e && !0 !== e) {\n      if (e instanceof E || e instanceof G) f = e;\n      e = !0;\n    }\n\n    f instanceof E || f instanceof G || (f = new G());\n    mh(this);\n\n    for (var g = this.Ua.iteratorBackwards; g.next();) {\n      var h = g.value;\n      h.visible && h.hg(a, b, c, d, e, f);\n    }\n\n    return f;\n  };\n\n  function bj(a, b, c, d, e, f) {\n    var g = null;\n    void 0 === g && (g = null);\n    void 0 === d && (d = null);\n    void 0 === e && (e = !0);\n\n    if (!1 !== e && !0 !== e) {\n      if (e instanceof E || e instanceof G) f = e;\n      e = !0;\n    }\n\n    f instanceof E || f instanceof G || (f = new G());\n    mh(a);\n\n    for (a = a.Ua.iteratorBackwards; a.next();) {\n      var h = a.value;\n      h.visible && !h.isTemporary && h.hg(b, c, g, d, e, f);\n    }\n\n    return f;\n  }\n\n  Q.prototype.acceptEvent = function (a) {\n    return cj(this, a, a instanceof MouseEvent);\n  };\n\n  function cj(a, b, c) {\n    var d = a.Hg;\n    a.Hg = a.Yi;\n    a.Yi = d;\n    d.diagram = a;\n    d.event = b;\n    c ? dj(a, b, d) : (d.viewPoint = a.Hg.viewPoint, d.documentPoint = a.Hg.documentPoint);\n    a = 0;\n    b.ctrlKey && (a += 1);\n    b.altKey && (a += 2);\n    b.shiftKey && (a += 4);\n    b.metaKey && (a += 8);\n    d.modifiers = a;\n    d.button = b.button;\n    void 0 !== b.buttons && (d.buttons = b.buttons);\n    Qa && 0 === b.button && b.ctrlKey && (d.button = 2);\n    d.down = !1;\n    d.up = !1;\n    d.clickCount = 1;\n    d.delta = 0;\n    d.handled = !1;\n    d.bubbles = !1;\n    d.timestamp = b.timeStamp;\n    d.isMultiTouch = !1;\n    d.targetDiagram = ej(b, b.target);\n    d.targetObject = null;\n    return d;\n  }\n\n  function ej(a, b) {\n    if (null === b) return null;\n    if (b = b.H) return b;\n    (b = a.path) || \"function\" !== typeof a.composedPath || (b = a.composedPath());\n    return b && b[0] && b[0].H ? b[0].H : null;\n  }\n\n  function fj(a, b, c, d, e, f) {\n    var g = a.Hg;\n    a.Hg = a.Yi;\n    a.Yi = g;\n    g.diagram = a;\n    g.clickCount = 1;\n    a = g.delta = 0;\n    b.ctrlKey && (a += 1);\n    b.altKey && (a += 2);\n    b.shiftKey && (a += 4);\n    b.metaKey && (a += 8);\n    g.modifiers = a;\n    g.event = b;\n    g.timestamp = b.timeStamp;\n    g.button = b.button;\n    g.buttons = b.buttons;\n    Qa && 0 === b.button && b.ctrlKey && (g.button = 2);\n    g.down = c;\n    g.up = d;\n    g.handled = !1;\n    g.bubbles = e;\n    g.isMultiTouch = f;\n    return g;\n  }\n\n  function gj(a, b) {\n    if (a.bubbles) return !0;\n    void 0 !== b.stopPropagation && b.stopPropagation();\n    !1 !== b.cancelable && b.preventDefault();\n    b.cancelBubble = !0;\n    return !1;\n  }\n\n  Q.prototype.yz = function (a) {\n    var b = this.H;\n    if (!this.H.isEnabled) return !1;\n    var c = cj(b, a, !1);\n    c.key = String.fromCharCode(a.which);\n    c.down = !0;\n\n    switch (a.which) {\n      case 8:\n        c.key = \"Backspace\";\n        break;\n\n      case 33:\n        c.key = \"PageUp\";\n        break;\n\n      case 34:\n        c.key = \"PageDown\";\n        break;\n\n      case 35:\n        c.key = \"End\";\n        break;\n\n      case 36:\n        c.key = \"Home\";\n        break;\n\n      case 37:\n        c.key = \"Left\";\n        break;\n\n      case 38:\n        c.key = \"Up\";\n        break;\n\n      case 39:\n        c.key = \"Right\";\n        break;\n\n      case 40:\n        c.key = \"Down\";\n        break;\n\n      case 45:\n        c.key = \"Insert\";\n        break;\n\n      case 46:\n        c.key = \"Del\";\n        break;\n\n      case 48:\n        c.key = \"0\";\n        break;\n\n      case 187:\n      case 61:\n      case 107:\n        c.key = \"Add\";\n        break;\n\n      case 189:\n      case 173:\n      case 109:\n        c.key = \"Subtract\";\n        break;\n\n      case 27:\n        c.key = \"Esc\";\n    }\n\n    b.doKeyDown();\n    return gj(c, a);\n  };\n\n  Q.prototype.zz = function (a) {\n    var b = this.H;\n    if (!b.isEnabled) return !1;\n    var c = cj(b, a, !1);\n    c.key = String.fromCharCode(a.which);\n    c.up = !0;\n\n    switch (a.which) {\n      case 8:\n        c.key = \"Backspace\";\n        break;\n\n      case 33:\n        c.key = \"PageUp\";\n        break;\n\n      case 34:\n        c.key = \"PageDown\";\n        break;\n\n      case 35:\n        c.key = \"End\";\n        break;\n\n      case 36:\n        c.key = \"Home\";\n        break;\n\n      case 37:\n        c.key = \"Left\";\n        break;\n\n      case 38:\n        c.key = \"Up\";\n        break;\n\n      case 39:\n        c.key = \"Right\";\n        break;\n\n      case 40:\n        c.key = \"Down\";\n        break;\n\n      case 45:\n        c.key = \"Insert\";\n        break;\n\n      case 46:\n        c.key = \"Del\";\n    }\n\n    b.doKeyUp();\n    return gj(c, a);\n  };\n\n  Q.prototype.Jy = function (a) {\n    var b = this.H;\n    if (!b.isEnabled) return !1;\n    var c = cj(b, a, !0);\n    null !== b.mouseEnter && b.mouseEnter(c);\n    return gj(c, a);\n  };\n\n  Q.prototype.Ky = function (a) {\n    var b = this.H;\n    if (!b.isEnabled) return !1;\n    var c = cj(b, a, !0);\n    null !== b.mouseLeave && b.mouseLeave(c);\n    return gj(c, a);\n  };\n\n  Q.prototype.getMouse = function (a) {\n    var b = this.Ha;\n    if (null === b) return new I(0, 0);\n    var c = b.getBoundingClientRect();\n    b = a.clientX - this.Ba / c.width * c.left;\n    a = a.clientY - this.Aa / c.height * c.top;\n    return null !== this.Bb ? yb(new I(b, a), this.Bb) : new I(b, a);\n  };\n\n  function dj(a, b, c) {\n    var d = a.Ha,\n        e = a.Ba,\n        f = a.Aa,\n        g = 0,\n        h = 0;\n    null !== d && (d = d.getBoundingClientRect(), g = b.clientX - e / d.width * d.left, h = b.clientY - f / d.height * d.top);\n    c.viewPoint.h(g, h);\n    null !== a.Bb ? (b = I.allocAt(g, h), a.Bb.Ld(b), c.documentPoint.assign(b), I.free(b)) : c.documentPoint.h(g, h);\n  }\n\n  function ae(a, b, c, d) {\n    if (void 0 !== b.targetTouches) {\n      if (2 > b.targetTouches.length) return;\n      b = b.targetTouches[c];\n    } else if (null !== a.$k[0]) b = a.$k[c];else return;\n\n    c = a.Ha;\n    null !== c && (c = c.getBoundingClientRect(), d.h(b.clientX - a.Ba / c.width * c.left, b.clientY - a.Aa / c.height * c.top));\n  }\n\n  Q.prototype.Va = function () {\n    this.Si || (this.Si = !0, this.Mb(!0));\n  };\n\n  function hj(a) {\n    a.cd || mh(a);\n    a.Za();\n  }\n\n  Q.prototype.redraw = function () {\n    this.wb || this.cd || (this.N(), Wi(this), this.nd());\n  };\n\n  t = Q.prototype;\n\n  t.xz = function () {\n    return this.cg;\n  };\n\n  t.Ey = function (a) {\n    void 0 === a && (a = null);\n    var b = this.animationManager,\n        c = b.isEnabled;\n    b.wc();\n    b.isEnabled = !1;\n    zf(this);\n    this.Qf = !1;\n    this.Jt = new I(NaN, NaN);\n    b.isEnabled = c;\n    this.cd = !0;\n    var d = this;\n    null !== a && ta(function () {\n      d.cd = !1;\n      lh(b, \"Model\");\n      a(d);\n    }, 1);\n  };\n\n  t.Mb = function (a) {\n    void 0 === a && (a = !1);\n\n    if (!0 !== this.cg && !(this.wb || !1 === a && this.cd)) {\n      this.cg = !0;\n      var b = this;\n      x.requestAnimationFrame(function () {\n        b.cg && b.nd();\n      });\n    }\n  };\n\n  t.nd = function () {\n    if (!this.Nm || this.cg) this.Nm && (this.Nm = !1), zf(this);\n  };\n\n  function Xi(a, b, c) {\n    a.animationManager.defaultAnimation.isAnimating || a.wb || !a.Ti || Oi(a) || (b && mh(a), c && Ti(a, !1));\n  }\n\n  function zf(a, b) {\n    if (!a.cd && (a.cg = !1, null !== a.La || a.Zn.v())) {\n      a.cd = !0;\n      var c = a.animationManager,\n          d = a.Fn;\n\n      if (!c.isAnimating && 0 !== d.length) {\n        for (var e = d.s, f = e.length, g = 0; g < f; g++) {\n          var h = e[g];\n          ij(h, !1);\n          h.w();\n        }\n\n        d.clear();\n      }\n\n      d = a.Uv;\n      0 < d.count && (d.each(function (a) {\n        a.rv();\n      }), d.clear());\n      e = d = !1;\n      c.defaultAnimation.isAnimating && (e = !0, d = a.skipsUndoManager, a.skipsUndoManager = !0);\n      c.zb || sh(a);\n      Xi(a, !1, !0);\n      null !== a.Zd && (a.Zd.visible && !a.Op && (jj(a), a.Op = !0), !a.Zd.visible && a.Op && (a.Op = !1));\n      mh(a);\n      f = !1;\n      if (!a.Qf || a.mh) a.Qf ? kj(a, !a.xk) : (a.Da(\"Initial Layout\"), !1 === c.isEnabled && c.wc(), kj(a, !1)), f = !0;\n      a.xk = !1;\n      mh(a);\n      a.Ut || hj(a);\n      Xi(a, !0, !1);\n      g = !1;\n      f ? (c = M.alloc(), c.assign(a.viewportBounds), a.Qf || (g = a.Qf = !0, a.skipsUndoManager || (a.undoManager.isPendingClear = !0), a.undoManager.isPendingUnmodified = !0, lj(a)), a.P(\"LayoutCompleted\"), c.C(a.viewportBounds) || Xi(a, !0, !1), M.free(c)) : c.Dk && c.uw && (a.wg !== rh ? a.scale = Ui(a, a.wg) : a.nh !== rh ? a.scale = Ui(a, a.nh) : (c = a.initialScale, isFinite(c) && 0 < c && (a.scale = c)), Ti(a, !0));\n      mh(a);\n      f && g && a.eb(\"Initial Layout\");\n      a.mu();\n      b || a.tc(a.Zb);\n      e && (a.skipsUndoManager = d);\n      a.cd = !1;\n    }\n  }\n\n  function lj(a) {\n    var b = a.xa;\n    if (a.wg !== rh) a.scale = Ui(a, a.wg);else if (a.nh !== rh) a.scale = Ui(a, a.nh);else {\n      var c = a.initialScale;\n      isFinite(c) && 0 < c && (a.scale = c);\n    }\n    a.xa !== b && (Wi(a), Xi(a, !0, !1));\n    Ti(a, !0);\n    b = a.Ua.s;\n    a.Pd(b, b.length, a, a.viewportBounds);\n    a.P(\"InitialLayoutCompleted\");\n    a.Jt.assign(a.pa);\n    jj(a);\n  }\n\n  function mh(a) {\n    if (0 !== a.te.count && (a.cd || !a.animationManager.isTicking)) {\n      for (var b = 0; 23 > b; b++) {\n        var c = a.te.iterator;\n        if (null === c || 0 === a.te.count) break;\n        a.te = new G();\n        a.rv(c, a.te);\n      }\n\n      a.nodes.each(function (a) {\n        a instanceof qf && 0 !== (a.U & 65536) !== !1 && (a.U = a.U ^ 65536);\n      });\n    }\n  }\n\n  t.rv = function (a, b) {\n    for (a.reset(); a.next();) {\n      var c = a.value;\n      !c.Tc() || c instanceof qf || (c.mi() ? (c.measure(Infinity, Infinity), c.arrange()) : b.add(c));\n    }\n\n    for (a.reset(); a.next();) {\n      c = a.value, c instanceof qf && c.isVisible() && mj(this, c);\n    }\n\n    for (a.reset(); a.next();) {\n      c = a.value, c instanceof T && c.isVisible() && (c.mi() ? (c.measure(Infinity, Infinity), c.arrange()) : b.add(c));\n    }\n\n    for (a.reset(); a.next();) {\n      c = a.value, c instanceof ue && c.isVisible() && (c.mi() ? (c.measure(Infinity, Infinity), c.arrange()) : b.add(c));\n    }\n  };\n\n  function mj(a, b) {\n    for (var c = Ea(), d = Ea(), e = b.memberParts; e.next();) {\n      var f = e.value;\n      f.isVisible() && (f instanceof qf ? (nj(f) || oj(f) || pj(f)) && mj(a, f) : f instanceof T ? f.fromNode === b || f.toNode === b ? d.push(f) : c.push(f) : (f.measure(Infinity, Infinity), f.arrange()));\n    }\n\n    a = c.length;\n\n    for (e = 0; e < a; e++) {\n      f = c[e], f.measure(Infinity, Infinity), f.arrange();\n    }\n\n    Ga(c);\n    b.measure(Infinity, Infinity);\n    b.arrange();\n    a = d.length;\n\n    for (b = 0; b < a; b++) {\n      c = d[b], c.measure(Infinity, Infinity), c.arrange();\n    }\n\n    Ga(d);\n  }\n\n  t.Pd = function (a, b, c, d) {\n    if (this.Ui || this.animationManager.isAnimating) for (var e = 0; e < b; e++) {\n      a[e].Pd(c, d);\n    }\n  };\n\n  t.tc = function (a, b) {\n    if (null !== this.La) {\n      null === this.Ha && C(\"No canvas specified\");\n      var c = this.animationManager;\n\n      if (!c.zb && (!c.isAnimating || c.isTicking)) {\n        var d = new Date();\n        qj(this);\n\n        if (\"0\" !== this.La.style.opacity) {\n          var e = a !== this.Zb,\n              f = this.Ua.s,\n              g = f.length,\n              h = this;\n          this.Pd(f, g, h, h.viewportBounds);\n          if (e) a.Oc(!0), Ri(this);else if (!this.bd && void 0 === b && !c.isAnimating) return;\n          g = this.pa;\n          var k = this.xa,\n              l = Math.round(g.x * k) / k,\n              m = Math.round(g.y * k) / k;\n          c = this.Bb;\n          c.reset();\n          1 !== k && c.scale(k);\n          0 === g.x && 0 === g.y || c.translate(-l, -m);\n          k = this.kc;\n          a.setTransform(k, 0, 0, k, 0, 0);\n          a.clearRect(0, 0, this.Ba, this.Aa);\n          1 !== this.tb && (a.globalAlpha = this.tb);\n          rj(this, a);\n          l = void 0 !== b ? function (c) {\n            if (c.visible && 0 !== c.tb) {\n              var d = c.Ma.s,\n                  e = d.length;\n\n              if (0 !== e) {\n                var f = fi(c, a),\n                    g = c.Bn;\n                g.length = 0;\n\n                for (var k = h.scale, l = M.alloc(), m = 0; m < e; m++) {\n                  var n = d[m];\n                  b.contains(n) || c.$h(a, n, h, g, k, l, !0);\n                }\n\n                M.free(l);\n                a.globalAlpha = f;\n              }\n            }\n          } : function (b) {\n            b.tc(a, h);\n          };\n          g = f.length;\n\n          for (m = 0; m < g; m++) {\n            a.setTransform(k, 0, 0, k, 0, 0), a.transform(c.m11, c.m12, c.m21, c.m22, c.dx, c.dy), a.Pc(), l(f[m]);\n          }\n\n          f = !1;\n          this.vh ? sj(this.vh, this) && (f = this.Qs()) : f = !0;\n          f && (md.prototype.Ld = md.prototype.Fw);\n          e ? (this.Zb.Oc(!0), Ri(this)) : this.bd = this.Ui = !1;\n          f = +new Date() - +d;\n          e = Xa && Xa.Rw;\n          d = this.dw;\n\n          if (e || null === this.Rh) {\n            d[this.sq] = f;\n            this.sq = (this.sq + 1) % d.length;\n\n            for (c = f = 0; c < d.length; c++) {\n              f += d[c];\n            }\n\n            this.rq = f / d.length;\n          }\n\n          1 !== this.tb && (a.globalAlpha = 1);\n          if (e) for (a.setTransform(1, 0, 0, 1, 0, 0), e = 0; e < d.length; e++) {\n            a.fillText(d[e].toString(), 20, 150 + +(20 * e));\n          }\n        }\n      }\n    }\n  };\n\n  function tj(a, b, c, d, e, f, g, h, k, l) {\n    if (null !== a.La) {\n      null === a.Ha && C(\"No canvas specified\");\n      void 0 === g && (g = null);\n      void 0 === h && (h = null);\n      void 0 === k && (k = !1);\n      void 0 === l && (l = !1);\n      qj(a);\n      a.Zb.Oc(!0);\n      Ri(a);\n      a.Vi = !0;\n      var m = a.xa;\n      a.xa = e;\n      var n = a.Ua.s,\n          p = n.length;\n\n      try {\n        var r = new M(f.x, f.y, d.width / e, d.height / e),\n            q = r.copy();\n        q.fo(c);\n        jj(a, q);\n        mh(a);\n        a.Pd(n, p, a, r);\n        b.setTransform(1, 0, 0, 1, 0, 0);\n        b.clearRect(0, 0, d.width, d.height);\n        null !== h && \"\" !== h && (b.fillStyle = h, b.fillRect(0, 0, d.width, d.height));\n        var u = a.kc;\n        b.scale(u, u);\n        var w = md.alloc();\n        w.reset();\n        w.translate(c.left, c.top);\n        w.scale(e);\n        0 === f.x && 0 === f.y || w.translate(-f.x, -f.y);\n        b.setTransform(w.m11, w.m12, w.m21, w.m22, w.dx, w.dy);\n        b.Pc();\n        md.free(w);\n        rj(a, b);\n        b.globalAlpha = a.tb;\n        var v = a.Ij(\"Grid\");\n\n        if (g) {\n          var z = new G(),\n              y = g.iterator;\n\n          for (y.reset(); y.next();) {\n            var A = y.value;\n            A instanceof U && (l || A.layer !== v) && z.add(A);\n          }\n\n          for (l = 0; l < p; l++) {\n            var B = n[l];\n            v = b;\n            var F = a;\n\n            if (B.visible && 0 !== B.tb && (k || !B.isTemporary)) {\n              var L = B.Ma.s,\n                  S = L.length;\n\n              if (0 !== S) {\n                var R = fi(B, v),\n                    P = B.Bn;\n                P.length = 0;\n                var H = F.scale,\n                    da = M.alloc();\n\n                for (c = 0; c < S; c++) {\n                  var X = L[c];\n                  z.contains(X) && B.$h(v, X, F, P, H, da, !1);\n                }\n\n                M.free(da);\n                v.globalAlpha = R;\n              }\n            }\n          }\n        } else for (z = 0; z < p; z++) {\n          F = n[z], F === v ? l && F.tc(b, a, !0) : F.tc(b, a, k);\n        }\n\n        a.Vi = !1;\n        a.vh && sj(a.vh, a) && a.Qs();\n      } finally {\n        a.xa = m, a.Zb.Oc(!0), Ri(a), a.Pd(n, p, a, a.viewportBounds), jj(a);\n      }\n    }\n  }\n\n  t.Ge = function (a) {\n    return this.Ig[a];\n  };\n\n  t.Fx = function (a, b) {\n    \"minDrawingLength\" === a && (this.nq = b);\n    this.Ig[a] = b;\n    this.redraw();\n  };\n\n  t.Ax = function () {\n    this.Ig = new Wa();\n    this.Ig.drawShadows = !0;\n    this.Ig.textGreeking = !0;\n    this.Ig.viewportOptimizations = Qa || Na ? !1 : !0;\n    this.Ig.temporaryPixelRatio = !0;\n    this.Ig.pictureRatioOptimization = !0;\n    this.nq = this.Ig.minDrawingLength = 1;\n  };\n\n  function rj(a, b) {\n    a = a.Ig;\n    null !== a && (void 0 !== a.imageSmoothingEnabled && b.Ex(!!a.imageSmoothingEnabled), a = a.defaultFont, void 0 !== a && null !== a && (b.font = a));\n  }\n\n  t.yl = function (a) {\n    return this.Vm[a];\n  };\n\n  t.Zz = function (a, b) {\n    this.Vm[a] = b;\n  };\n\n  t.zx = function () {\n    this.Vm = new Wa();\n    this.Vm.extraTouchArea = 10;\n    this.Vm.extraTouchThreshold = 10;\n    this.Vm.hasGestureZoom = !0;\n  };\n\n  t.set = function (a) {\n    Object.assign(this, a);\n    return this;\n  };\n\n  t.ku = function (a) {\n    return this.Vl(a);\n  };\n\n  t.Vl = function (a) {\n    uj(this, a);\n    return this;\n  };\n\n  function uj(a, b) {\n    var c = a instanceof W,\n        d = a instanceof Q,\n        e;\n\n    for (e in b) {\n      \"\" === e && C(\"Setting properties requires non-empty property names\");\n      var f = a,\n          g = e;\n\n      if (c || d) {\n        var h = e.indexOf(\".\");\n\n        if (0 < h) {\n          var k = e.substring(0, h);\n          if (c) f = a.fb(k);else if (f = a[k], void 0 === f || null === f) f = a.toolManager[k];\n          ya(f) ? g = e.substr(h + 1) : C(\"Unable to find object named: \" + k + \" in \" + a.toString() + \" when trying to set property: \" + e);\n        }\n      }\n\n      if (\"_\" !== g[0] && !Ja(f, g)) if (d && \"ModelChanged\" === g) {\n        a.Cw(b[g]);\n        continue;\n      } else if (d && \"Changed\" === g) {\n        a.Ug(b[g]);\n        continue;\n      } else if (d && Ja(a.toolManager, g)) f = a.toolManager;else if (d && vj(a, g)) {\n        a.wj(g, b[g]);\n        continue;\n      } else if (a instanceof Z && \"Changed\" === g) {\n        a.Ug(b[g]);\n        continue;\n      } else C('Trying to set undefined property \"' + g + '\" on object: ' + f.toString());\n      f[g] = b[e];\n      \"_\" === g[0] && f instanceof Y && f.zw(g);\n    }\n  }\n\n  t.mu = function () {\n    if (0 === this.undoManager.transactionLevel && 0 !== this.th.count) {\n      for (; 0 < this.th.count;) {\n        var a = this.th;\n        this.th = new pb();\n\n        for (a = a.iterator; a.next();) {\n          var b = a.key;\n          b.Ao(a.value);\n          b.mc(!1);\n        }\n      }\n\n      this.N();\n    }\n  };\n\n  t.N = function (a) {\n    if (void 0 === a) this.bd = !0, this.Mb();else {\n      var b = this.viewportBounds;\n      a.v() && b.Sc(a) && (this.bd = !0, this.Mb());\n    }\n    this.P(\"InvalidateDraw\");\n  };\n\n  Q.prototype.invalidateViewport = function (a, b) {\n    if (!0 !== this.bd) {\n      this.bd = !0;\n      var c = !0 === this.Ge(\"temporaryPixelRatio\");\n\n      if (!0 === this.Ge(\"viewportOptimizations\") && this.scrollMode !== Th && this.mj.bi(0, 0, 0, 0) && b.width === a.width && b.height === a.height) {\n        var d = this.scale,\n            e = Math.max(a.x, b.x),\n            f = Math.max(a.y, b.y);\n        d = M.allocAt(e, f, Math.max(0, Math.min(a.x + a.width, b.x + b.width) - e) * d, Math.max(0, Math.min(a.y + a.height, b.y + b.height) - f) * d);\n\n        if (!this.kr && 0 < d.width && 0 < d.height) {\n          if (!(this.cd || (this.cg = !1, null === this.La || (this.cd = !0, this.mu(), this.documentBounds.v() || (e = M.alloc(), wj(this, this.computeBounds(e)), M.free(e)), e = this.Ha, null === e || e instanceof xj)))) {\n            var g = this.kc;\n            f = this.Ba * g;\n            var h = this.Aa * g,\n                k = this.scale * g,\n                l = Math.round(Math.round(b.x * k) - Math.round(a.x * k));\n            b = Math.round(Math.round(b.y * k) - Math.round(a.y * k));\n            k = this.Ov;\n            a = this.Ux;\n            k.width !== f && (k.width = f);\n            k.height !== h && (k.height = h);\n            a.clearRect(0, 0, f, h);\n            k = 190 * g;\n            var m = 70 * g,\n                n = Math.max(l, 0),\n                p = Math.max(b, 0),\n                r = Math.floor(f - n),\n                q = Math.floor(h - p);\n            a.drawImage(e.Sa, n, p, r, q, 0, 0, r, q);\n            sj(this.vh, this) && a.clearRect(0, 0, k, m);\n            e = Ea();\n            a = Ea();\n            q = Math.abs(l);\n            r = Math.abs(b);\n            var u = 0 === n ? 0 : f - q;\n            n = I.allocAt(u, 0);\n            q = I.allocAt(q + u, h);\n            a.push(new M(Math.min(n.x, q.x), Math.min(n.y, q.y), Math.abs(n.x - q.x), Math.abs(n.y - q.y)));\n            var w = this.Bb;\n            w.reset();\n            w.scale(g, g);\n            1 !== this.xa && w.scale(this.xa);\n            g = this.pa;\n            (0 !== g.x || 0 !== g.y) && isFinite(g.x) && isFinite(g.y) && w.translate(-g.x, -g.y);\n            yb(n, w);\n            yb(q, w);\n            e.push(new M(Math.min(n.x, q.x), Math.min(n.y, q.y), Math.abs(n.x - q.x), Math.abs(n.y - q.y)));\n            u = 0 === p ? 0 : h - r;\n            n.h(0, u);\n            q.h(f, r + u);\n            a.push(new M(Math.min(n.x, q.x), Math.min(n.y, q.y), Math.abs(n.x - q.x), Math.abs(n.y - q.y)));\n            yb(n, w);\n            yb(q, w);\n            e.push(new M(Math.min(n.x, q.x), Math.min(n.y, q.y), Math.abs(n.x - q.x), Math.abs(n.y - q.y)));\n            sj(this.vh, this) && (f = 0 < l ? 0 : -l, h = 0 < b ? 0 : -b, n.h(f, h), q.h(k + f, m + h), a.push(new M(Math.min(n.x, q.x), Math.min(n.y, q.y), Math.abs(n.x - q.x), Math.abs(n.y - q.y))), yb(n, w), yb(q, w), e.push(new M(Math.min(n.x, q.x), Math.min(n.y, q.y), Math.abs(n.x - q.x), Math.abs(n.y - q.y))));\n            I.free(n);\n            I.free(q);\n            Xi(this, !1, !0);\n            null === this.La && C(\"No div specified\");\n            null === this.Ha && C(\"No canvas specified\");\n\n            if (!this.animationManager.zb && (f = this.Zb, this.bd)) {\n              qj(this);\n              h = this.kc;\n              f.setTransform(1, 0, 0, 1, 0, 0);\n              f.clearRect(0, 0, this.Ba * h, this.Aa * h);\n              f.drawImage(this.Ov.Sa, 0 < l ? 0 : Math.round(-l), 0 < b ? 0 : Math.round(-b));\n              l = this.pa;\n              g = this.xa;\n              k = Math.round(l.x * g) / g;\n              m = Math.round(l.y * g) / g;\n              b = this.Bb;\n              b.reset();\n              1 !== g && b.scale(g);\n              0 === l.x && 0 === l.y || b.translate(-k, -m);\n              f.save();\n              f.beginPath();\n              l = a.length;\n\n              for (g = 0; g < l; g++) {\n                k = a[g], 0 !== k.width && 0 !== k.height && f.rect(Math.floor(k.x), Math.floor(k.y), Math.ceil(k.width), Math.ceil(k.height));\n              }\n\n              f.clip();\n              f.setTransform(h, 0, 0, h, 0, 0);\n              f.transform(b.m11, b.m12, b.m21, b.m22, b.dx, b.dy);\n              f.Pc();\n              b = this.Ua.s;\n              l = b.length;\n              this.Pd(b, l, this, this.viewportBounds);\n              rj(this, f);\n              f.globalAlpha = this.tb;\n\n              for (h = 0; h < l; h++) {\n                if (g = b[h], k = e, g.visible && 0 !== g.tb) {\n                  m = fi(g, f);\n                  p = g.Bn;\n                  p.length = 0;\n                  n = this.scale;\n                  r = M.alloc();\n                  q = g.Ma.s;\n                  w = q.length;\n                  u = k.length;\n\n                  for (var v = 0; v < w; v++) {\n                    var z = q[v],\n                        y = yj(z, z.actualBounds);\n\n                    a: {\n                      for (var A = 2 / n, B = 4 / n, F = 0; F < u; F++) {\n                        var L = k[F];\n\n                        if (0 !== L.width && 0 !== L.height && y.Hu(L.x - A, L.y - A, L.width + B, L.height + B)) {\n                          y = !0;\n                          break a;\n                        }\n                      }\n\n                      y = !1;\n                    }\n\n                    y && g.$h(f, z, this, p, n, r, !0);\n                  }\n\n                  M.free(r);\n                  f.globalAlpha = m;\n                }\n              }\n\n              f.restore();\n              f.Oc(!0);\n              this.vh && sj(this.vh, this) && this.Qs();\n              this.bd = this.Ui = !1;\n              this.Jo();\n            }\n\n            Ga(e);\n            Ga(a);\n            this.cd = !1;\n          }\n        } else this.nd();\n\n        M.free(d);\n        c && (Ge(this), this.nd(), Ye(this, !0));\n      } else c ? (Ge(this), this.nd(), Ye(this, !0)) : this.nd();\n    }\n  };\n\n  function Wi(a) {\n    !1 === a.Ti && (a.Ti = !0);\n  }\n\n  function Ri(a) {\n    !1 === a.Ui && (a.Ui = !0);\n  }\n\n  function qj(a) {\n    !1 !== a.Wm && (a.Wm = !1, zj(a, a.Ba, a.Aa));\n  }\n\n  function zj(a, b, c) {\n    Ci(a);\n    var d = a.kc;\n    a.Ha.resize(b * d, c * d, b, c) && (a.bd = !0, a.Zb.Oc(!0));\n  }\n\n  function Oi(a) {\n    var b = a.Ha;\n    if (null === b || a.Zn.v()) return !0;\n    var c = a.Ba,\n        d = a.Aa,\n        e = a.viewportBounds;\n    if (!a.viewportBounds.v()) return !0;\n    var f = e.x,\n        g = e.y,\n        h = e.width,\n        k = e.height,\n        l = a.Qt,\n        m = a.Nt,\n        n = a.La,\n        p = !1,\n        r = a.Of ? a.Ab : 0,\n        q = a.We ? a.Ab : 0,\n        u = n.clientWidth || c + r,\n        w = n.clientHeight || d + q;\n    if (u !== c + r || w !== d + q) a.Of = !1, a.We = !1, q = r = 0, a.Ba = u, a.Aa = w, p = a.Wm = !0, Ci(a);\n    if (!(p || a.Of || a.We || a.Tm || a.Um)) return !0;\n    a.Ti = !1;\n    var v = a.documentBounds,\n        z = 0,\n        y = 0,\n        A = 0,\n        B = 0;\n    n = e.width;\n    var F = e.height,\n        L = a.mj;\n    a.contentAlignment.pb() ? (v.width > n && (z = L.left, y = L.right), v.height > F && (A = L.top, B = L.bottom)) : (z = L.left, y = L.right, A = L.top, B = L.bottom);\n    L = v.width + z + y;\n    var S = v.height + A + B;\n    z = v.x - z;\n    var R = e.x;\n    y = v.right + y;\n    var P = e.right + r;\n    A = v.y - A;\n    var H = e.y;\n    v = v.bottom + B;\n    B = e.bottom + q;\n    var da = \"1px\",\n        X = \"1px\";\n    e = a.scale;\n    u = L > u / e;\n    w = S > w / e;\n    a.scrollMode === Rh && (u || w) && (u && a.hasHorizontalScrollbar && a.allowHorizontalScroll && (u = 1, z + 1 < R && (u = Math.max((R - z) * e + a.Ba, u)), y > P + 1 && (u = Math.max((y - P) * e + a.Ba, u)), n + r + 1 < L && (u = Math.max((L - n) * e + a.Ba, u)), da = u.toString() + \"px\"), w && a.hasVerticalScrollbar && a.allowVerticalScroll && (u = 1, A + 1 < H && (u = Math.max((H - A) * e + a.Aa, u)), v > B + 1 && (u = Math.max((v - B) * e + a.Aa, u)), F + q + 1 < S && (u = Math.max((S - F) * e + a.Aa, u)), X = u.toString() + \"px\"));\n    u = \"1px\" !== da;\n    w = \"1px\" !== X;\n    u && w || !u && !w || (w && (P -= a.Ab), u && (B -= a.Ab), L < n + r || !a.hasHorizontalScrollbar || !a.allowHorizontalScroll || (r = 1, z + 1 < R && (r = Math.max((R - z) * e + a.Ba, r)), y > P + 1 && (r = Math.max((y - P) * e + a.Ba, r)), n + 1 < L && (r = Math.max((L - n) * e + a.Ba, r)), da = r.toString() + \"px\"), u = \"1px\" !== da, r = a.Aa, u !== a.We && (r = u ? a.Aa - a.Ab : a.Aa + a.Ab), S < F + q || !a.hasVerticalScrollbar || !a.allowVerticalScroll || (q = 1, A + 1 < H && (q = Math.max((H - A) * e + r, q)), v > B + 1 && (q = Math.max((v - B) * e + r, q)), F + 1 < S && (q = Math.max((S - F) * e + r, q)), X = q.toString() + \"px\"), w = \"1px\" !== X);\n    if (a.Nq && u === a.We && w === a.Of) return c === a.Ba && d === a.Aa || a.nd(), !1;\n    u !== a.We && (\"1px\" === da ? a.Aa = a.Aa + a.Ab : a.Aa = Math.max(a.Aa - a.Ab, 1), p = !0);\n    a.We = u;\n    m.style.width = da;\n    w !== a.Of && (\"1px\" === X ? a.Ba = a.Ba + a.Ab : a.Ba = Math.max(a.Ba - a.Ab, 1), p = !0, a.$m && (q = I.alloc(), w ? (b.style.left = a.Ab + \"px\", a.position = q.h(a.pa.x + a.Ab / a.scale, a.pa.y)) : (b.style.left = \"0px\", a.position = q.h(a.pa.x - a.Ab / a.scale, a.pa.y)), I.free(q)));\n    p && Ci(a);\n    a.Of = w;\n    m.style.height = X;\n    a.Mt = !0;\n    p && (a.Wm = !0);\n    b = l.scrollLeft;\n    a.hasHorizontalScrollbar && a.allowHorizontalScroll && (n + 1 < L ? b = (a.position.x - z) * e : z + 1 < R ? b = l.scrollWidth - l.clientWidth : y > P + 1 && (b = a.position.x * e));\n    if (a.$m) switch (a.Ht) {\n      case \"negative\":\n        b = -(l.scrollWidth - b - l.clientWidth);\n        break;\n\n      case \"reverse\":\n        b = l.scrollWidth - b - l.clientWidth;\n    }\n    l.scrollLeft = b;\n    a.hasVerticalScrollbar && a.allowVerticalScroll && (F + 1 < S ? l.scrollTop = (a.position.y - A) * e : A + 1 < H ? l.scrollTop = l.scrollHeight - l.clientHeight : v > B + 1 && (l.scrollTop = a.position.y * e));\n    u = a.Ba;\n    w = a.Aa;\n    l.style.width = u + (a.Of ? a.Ab : 0) + \"px\";\n    l.style.height = w + (a.We ? a.Ab : 0) + \"px\";\n    return c !== u || d !== w || a.animationManager.zb ? (c = M.allocAt(f, g, h, k), a.onViewportBoundsChanged(c, a.viewportBounds, e, p), M.free(c), !1) : !0;\n  }\n\n  t = Q.prototype;\n\n  t.add = function (a) {\n    var b = a.diagram;\n\n    if (b !== this && (null !== b && C(\"Cannot add part \" + a.toString() + \" to \" + this.toString() + \". It is already a part of \" + b.toString()), b = this.Ij(a.layerName), null === b && (b = this.Ij(\"\")), null === b && C('Cannot add a Part when unable find a Layer named \"' + a.layerName + '\" and there is no default Layer'), a.layer !== b)) {\n      var c = b.ii(99999999, a, a.diagram === this);\n      0 <= c && this.bb(fe, \"parts\", b, null, a, null, c);\n      b.isTemporary || this.Va();\n      a.D(1);\n      c = a.layerChanged;\n      null !== c && c(a, null, b);\n    }\n  };\n\n  t.ii = function (a) {\n    this.partManager.ii(a);\n    var b = this;\n    Aj(a, function (a) {\n      Bj(b, a);\n    });\n    (a instanceof ue || a instanceof qf && null !== a.placeholder) && a.w();\n    null !== a.data && Aj(a, function (a) {\n      Cj(b.partManager, a);\n    });\n    !0 !== oj(a) && !0 !== pj(a) || this.te.add(a);\n    Dj(a, !0, this);\n    Ej(a) ? (a.actualBounds.v() && this.N(yj(a, a.actualBounds)), this.Va()) : a.isVisible() && a.actualBounds.v() && this.N(yj(a, a.actualBounds));\n    this.Mb();\n  };\n\n  t.lc = function (a) {\n    a.zj();\n    this.partManager.lc(a);\n    var b = this;\n    null !== a.data && Aj(a, function (a) {\n      Fj(b.partManager, a, b);\n    });\n    this.te.remove(a);\n    Ej(a) ? (a.actualBounds.v() && this.N(yj(a, a.actualBounds)), this.Va()) : a.isVisible() && a.actualBounds.v() && this.N(yj(a, a.actualBounds));\n    this.Mb();\n  };\n\n  t.remove = function (a) {\n    Gj(this, a, !0);\n  };\n\n  function Gj(a, b, c) {\n    var d = b.layer;\n    null !== d && d.diagram === a && (b.isSelected = !1, b.isHighlighted = !1, b.D(2), c && b.Fj(), c = d.lc(-1, b, !1), 0 <= c && a.bb(ge, \"parts\", d, b, null, c, null), a = b.layerChanged, null !== a && a(b, d, null));\n  }\n\n  t.hs = function (a, b) {\n    void 0 === b && (b = !1);\n    if (za(a)) for (var c = a.length, d = 0; d < c; d++) {\n      var e = a[d];\n      b && !e.canDelete() || this.remove(e);\n    } else for (c = new G(), c.addAll(a), a = c.iterator; a.next();) {\n      c = a.value, b && !c.canDelete() || this.remove(c);\n    }\n  };\n\n  t.Ej = function (a, b, c) {\n    void 0 === c && (c = !1);\n    return this.partManager.Ej(a, b, c);\n  };\n\n  Q.prototype.moveParts = function (a, b, c, d) {\n    void 0 === c && (c = !1);\n    void 0 === d && (d = Hj(this));\n\n    if (null !== this.toolManager) {\n      var e = new pb();\n      if (null !== a) {\n        if (za(a)) for (var f = 0; f < a.length; f++) {\n          Ij(this, e, a[f], c, d);\n        } else for (a = a.iterator; a.next();) {\n          Ij(this, e, a.value, c, d);\n        }\n      } else {\n        for (a = this.parts; a.next();) {\n          Ij(this, e, a.value, c, d);\n        }\n\n        for (a = this.nodes; a.next();) {\n          Ij(this, e, a.value, c, d);\n        }\n\n        for (a = this.links; a.next();) {\n          Ij(this, e, a.value, c, d);\n        }\n      }\n      ef(this, e, b, d, c);\n    }\n  };\n\n  function Ij(a, b, c, d, e, f) {\n    if (!b.contains(c) && (void 0 === f && (f = !1), !d || f || c.canMove() || c.canCopy())) if (void 0 === e && (e = Hj(a)), c instanceof V) {\n      b.add(c, a.Fd(e, c, c.location));\n      if (c instanceof qf && (null !== c.placeholder || e.dragsMembers)) for (f = c.memberParts; f.next();) {\n        Ij(a, b, f.value, d, e, e.groupsAlwaysMove);\n      }\n\n      for (f = c.linksConnected; f.next();) {\n        var g = f.value;\n\n        if (!b.contains(g)) {\n          var h = g.fromNode,\n              k = g.toNode;\n          null !== h && b.contains(h) && null !== k && b.contains(k) && Ij(a, b, g, d, e);\n        }\n      }\n\n      if (e.dragsTree) for (c = c.Au(); c.next();) {\n        Ij(a, b, c.value, d, e);\n      }\n    } else if (c instanceof T) for (b.add(c, a.Fd(e, c)), c = c.labelNodes; c.next();) {\n      Ij(a, b, c.value, d, e);\n    } else c instanceof ue || b.add(c, a.Fd(e, c, c.location));\n  }\n\n  function ef(a, b, c, d, e) {\n    if (null !== b && 0 !== b.count) {\n      var f = I.alloc(),\n          g = I.alloc();\n      g.assign(c);\n      isNaN(g.x) && (g.x = 0);\n      isNaN(g.y) && (g.y = 0);\n      (c = a.jr) || He(a, b);\n\n      for (var h = Ea(), k = Ea(), l = b.iterator, m = I.alloc(); l.next();) {\n        var n = l.key,\n            p = l.value;\n\n        if (n.Tc()) {\n          var r = Jj(a, n, b);\n          if (null !== r) h.push(new Kj(n, p, r));else if (!e || n.canMove()) r = p.point, f.assign(r), a.computeMove(n, f.add(g), d, m), n.location = m, void 0 === p.shifted && (p.shifted = new I()), p.shifted.assign(m.je(r));\n        } else l.key instanceof T && k.push(l.ra);\n      }\n\n      I.free(m);\n      e = h.length;\n\n      for (l = 0; l < e; l++) {\n        n = h[l], f.assign(n.info.point), void 0 === n.Eu.shifted && (n.Eu.shifted = new I()), n.node.location = f.add(n.Eu.shifted);\n      }\n\n      e = I.alloc();\n      l = I.alloc();\n      n = k.length;\n\n      for (p = 0; p < n; p++) {\n        var q = k[p];\n        r = q.key;\n        if (r instanceof T) if (r.suspendsRouting) {\n          r.ef = null;\n          m = r.fromNode;\n          var u = r.toNode;\n          if (null !== a.draggedLink && d.dragsLink) {\n            if (u = q.value.point, null === r.dragComputation) b.add(r, a.Fd(d, r, g)), cf(r, g.x - u.x, g.y - u.y);else {\n              q = I.allocAt(0, 0);\n              (m = r.i(0)) && m.v() && q.assign(m);\n              var w = m = I.alloc().assign(q).add(g);\n              d.isGridSnapEnabled && (d.isGridSnapRealtime || a.lastInput.up) && (w = I.alloc(), Ag(a, r, m, w, d));\n              m.assign(r.dragComputation(r, m, w)).je(q);\n              b.add(r, a.Fd(d, r, m));\n              cf(r, m.x - u.x, m.y - u.y);\n              I.free(q);\n              I.free(m);\n              w !== m && I.free(w);\n            }\n          } else null !== m && (e.assign(m.location), w = b.I(m), null !== w && e.je(w.point)), null !== u && (l.assign(u.location), w = b.I(u), null !== w && l.je(w.point)), null !== m && null !== u ? e.$a(l) ? (m = q.value.point, u = f, u.assign(e), u.je(m), b.add(r, a.Fd(d, r, e)), cf(r, u.x, u.y)) : (r.suspendsRouting = !1, r.ab()) : (q = q.value.point, m = null !== m ? e : null !== u ? l : g, b.add(r, a.Fd(d, r, m)), cf(r, m.x - q.x, m.y - q.y));\n        } else if (null === r.fromNode || null === r.toNode) m = q.value.point, b.add(r, a.Fd(d, r, g)), cf(r, g.x - m.x, g.y - m.y);\n      }\n\n      I.free(f);\n      I.free(g);\n      I.free(e);\n      I.free(l);\n      Ga(h);\n      Ga(k);\n      c || (mh(a), Ve(a, b));\n    }\n  }\n\n  Q.prototype.computeMove = function (a, b, c, d) {\n    void 0 === d && (d = new I());\n    d.assign(b);\n    if (null === a) return d;\n    var e = b,\n        f = c.isGridSnapEnabled;\n    f && (c.isGridSnapRealtime || this.lastInput.up) && (e = I.alloc(), Ag(this, a, b, e, c));\n    c = null !== a.dragComputation ? a.dragComputation(a, b, e) : e;\n    var g = a.minLocation,\n        h = g.x;\n    isNaN(h) && (h = f ? Math.round(1E3 * a.location.x) / 1E3 : a.location.x);\n    g = g.y;\n    isNaN(g) && (g = f ? Math.round(1E3 * a.location.y) / 1E3 : a.location.y);\n    var k = a.maxLocation,\n        l = k.x;\n    isNaN(l) && (l = f ? Math.round(1E3 * a.location.x) / 1E3 : a.location.x);\n    k = k.y;\n    isNaN(k) && (k = f ? Math.round(1E3 * a.location.y) / 1E3 : a.location.y);\n    d.h(Math.max(h, Math.min(c.x, l)), Math.max(g, Math.min(c.y, k)));\n    e !== b && I.free(e);\n    return d;\n  };\n\n  function Hj(a) {\n    var b = a.toolManager.findTool(\"Dragging\");\n    return null !== b ? b.dragOptions : a.Em;\n  }\n\n  function Ag(a, b, c, d, e) {\n    void 0 === e && (e = Hj(a));\n    d.assign(c);\n\n    if (null !== b) {\n      var f = a.grid;\n      b = e.gridSnapCellSize;\n      a = b.width;\n      b = b.height;\n      var g = e.gridSnapOrigin,\n          h = g.x;\n      g = g.y;\n      e = e.gridSnapCellSpot;\n\n      if (null !== f) {\n        var k = f.gridCellSize;\n        isNaN(a) && (a = k.width);\n        isNaN(b) && (b = k.height);\n        f = f.gridOrigin;\n        isNaN(h) && (h = f.x);\n        isNaN(g) && (g = f.y);\n      }\n\n      f = I.allocAt(0, 0);\n      f.pi(0, 0, a, b, e);\n      J.so(c.x, c.y, h + f.x, g + f.y, a, b, d);\n      I.free(f);\n    }\n  }\n\n  function He(a, b) {\n    if (null !== b) for (a.jr = !0, a = b.iterator; a.next();) {\n      b = a.key, b instanceof T && (b.suspendsRouting = !0);\n    }\n  }\n\n  function Ve(a, b) {\n    if (null !== b) {\n      for (b = b.iterator; b.next();) {\n        var c = b.key;\n        c instanceof T && (c.suspendsRouting = !1, Lj(c) && c.ab());\n      }\n\n      a.jr = !1;\n    }\n  }\n\n  function Jj(a, b, c) {\n    b = b.containingGroup;\n\n    if (null !== b) {\n      a = Jj(a, b, c);\n      if (null !== a) return a;\n      a = c.I(b);\n      if (null !== a) return a;\n    }\n\n    return null;\n  }\n\n  t = Q.prototype;\n\n  t.Fd = function (a, b, c) {\n    if (void 0 === c) return new Te(qb);\n    var d = a.isGridSnapEnabled;\n    a.groupsSnapMembers || null === b.containingGroup || (d = !1);\n    return d ? new Te(new I(Math.round(1E3 * c.x) / 1E3, Math.round(1E3 * c.y) / 1E3)) : new Te(c.copy());\n  };\n\n  function Mj(a, b, c) {\n    null !== b.diagram && b.diagram !== a && C(\"Cannot share a Layer with another Diagram: \" + b + \" of \" + b.diagram);\n    null === c ? null !== b.diagram && C(\"Cannot add an existing Layer to this Diagram again: \" + b) : (c.diagram !== a && C(\"Existing Layer must be in this Diagram: \" + c + \" not in \" + c.diagram), b === c && C(\"Cannot move a Layer before or after itself: \" + b));\n\n    if (b.diagram !== a) {\n      b = b.name;\n      a = a.Ua;\n      c = a.count;\n\n      for (var d = 0; d < c; d++) {\n        a.K(d).name === b && C(\"Cannot add Layer with the name '\" + b + \"'; a Layer with the same name is already present in this Diagram.\");\n      }\n    }\n  }\n\n  t.pl = function (a) {\n    Mj(this, a, null);\n    a.Le(this);\n    var b = this.Ua,\n        c = b.count - 1;\n    if (!a.isTemporary) for (; 0 <= c && b.K(c).isTemporary;) {\n      c--;\n    }\n    b.Cb(c + 1, a);\n    null !== this.ac && this.bb(fe, \"layers\", this, null, a, null, c + 1);\n    this.N();\n    this.Va();\n    return this;\n  };\n\n  t.Aw = function (a, b) {\n    Mj(this, a, b);\n    a.Le(this);\n    var c = this.Ua,\n        d = c.indexOf(a);\n    0 <= d && (c.remove(a), null !== this.ac && this.bb(ge, \"layers\", this, a, null, d, null));\n    var e = c.count,\n        f;\n\n    for (f = 0; f < e; f++) {\n      if (c.K(f) === b) {\n        c.Cb(f, a);\n        break;\n      }\n    }\n\n    null !== this.ac && this.bb(fe, \"layers\", this, null, a, null, f);\n    this.N();\n    0 > d && this.Va();\n    return this;\n  };\n\n  t.jy = function (a, b) {\n    Mj(this, a, b);\n    a.Le(this);\n    var c = this.Ua,\n        d = c.indexOf(a);\n    0 <= d && (c.remove(a), null !== this.ac && this.bb(ge, \"layers\", this, a, null, d, null));\n    var e = c.count,\n        f;\n\n    for (f = 0; f < e; f++) {\n      if (c.K(f) === b) {\n        c.Cb(f + 1, a);\n        break;\n      }\n    }\n\n    null !== this.ac && this.bb(fe, \"layers\", this, null, a, null, f + 1);\n    this.N();\n    0 > d && this.Va();\n    return this;\n  };\n\n  t.Rz = function (a) {\n    a.diagram !== this && C(\"Cannot remove a Layer from another Diagram: \" + a + \" of \" + a.diagram);\n\n    if (\"\" !== a.name) {\n      var b = this.Ua,\n          c = b.indexOf(a);\n\n      if (b.remove(a)) {\n        for (b = a.Ma.copy().iterator; b.next();) {\n          var d = b.value,\n              e = d.layerName;\n          e !== a.name ? d.layerName = e : d.layerName = \"\";\n        }\n\n        null !== this.ac && this.bb(ge, \"layers\", this, a, null, c, null);\n        this.N();\n        this.Va();\n      }\n    }\n  };\n\n  t.Ij = function (a) {\n    for (var b = this.layers; b.next();) {\n      var c = b.value;\n      if (c.name === a) return c;\n    }\n\n    return null;\n  };\n\n  t.Cw = function (a) {\n    null === this.bf && (this.bf = new E());\n    this.bf.add(a);\n    this.model.Ug(a);\n    return this;\n  };\n\n  t.Tz = function (a) {\n    null !== this.bf && (this.bf.remove(a), 0 === this.bf.count && (this.bf = null));\n    this.model.ak(a);\n  };\n\n  t.Ug = function (a) {\n    null === this.qg && (this.qg = new E());\n    this.qg.add(a);\n    return this;\n  };\n\n  t.ak = function (a) {\n    null !== this.qg && (this.qg.remove(a), 0 === this.qg.count && (this.qg = null));\n  };\n\n  t.Cr = function (a) {\n    this.skipsUndoManager || this.model.skipsUndoManager || this.model.undoManager.Fu(a);\n    a.change !== ee && (this.isModified = !0);\n    if (null !== this.qg) for (var b = this.qg, c = b.length, d = 0; d < c; d++) {\n      b.K(d)(a);\n    }\n  };\n\n  t.bb = function (a, b, c, d, e, f, g) {\n    void 0 === f && (f = null);\n    void 0 === g && (g = null);\n    var h = new ce();\n    h.diagram = this;\n    h.change = a;\n    h.propertyName = b;\n    h.object = c;\n    h.oldValue = d;\n    h.oldParam = f;\n    h.newValue = e;\n    h.newParam = g;\n    this.Cr(h);\n  };\n\n  t.g = function (a, b, c, d, e) {\n    this.bb(de, a, this, b, c, d, e);\n  };\n\n  Q.prototype.changeState = function (a, b) {\n    if (null !== a && a.diagram === this) {\n      var c = this.skipsModelSourceBindings;\n\n      try {\n        this.skipsModelSourceBindings = !0;\n        var d = a.change;\n\n        if (d === de) {\n          var e = a.object;\n          Nj(e, a.propertyName, a.I(b));\n\n          if (e instanceof Y) {\n            var f = e.part;\n            null !== f && f.Rb();\n          }\n\n          this.isModified = !0;\n        } else if (d === fe) {\n          var g = a.object,\n              h = a.newParam,\n              k = a.newValue;\n          if (g instanceof W) {\n            if (\"number\" === typeof h && k instanceof Y) {\n              b ? g.lc(h) : g.Cb(h, k);\n              var l = g.part;\n              null !== l && l.Rb();\n            } else \"number\" === typeof h && k instanceof Oj && (k.isRow ? Pj(g, h, b ? void 0 : k) : Qj(g, h, b ? void 0 : k));\n          } else if (g instanceof di) {\n            var m = !0 === a.oldParam;\n            \"number\" === typeof h && k instanceof U && (b ? (k.isSelected = !1, k.isHighlighted = !1, k.Rb(), g.lc(m ? h : -1, k, m)) : g.ii(h, k, m));\n          } else g instanceof Q ? \"number\" === typeof h && k instanceof di && (b ? this.Ua.mb(h) : (k.Le(this), this.Ua.Cb(h, k))) : C(\"unknown ChangedEvent.Insert object: \" + a.toString());\n          this.isModified = !0;\n        } else if (d === ge) {\n          var n = a.object,\n              p = a.oldParam,\n              r = a.oldValue;\n          if (n instanceof W) \"number\" === typeof p && r instanceof Y ? b ? n.Cb(p, r) : n.lc(p) : \"number\" === typeof p && r instanceof Oj && (r.isRow ? Pj(n, p, b ? r : void 0) : Qj(n, p, b ? r : void 0));else if (n instanceof di) {\n            var q = !0 === a.newParam;\n            \"number\" === typeof p && r instanceof U && (b ? 0 > n.Ma.indexOf(r) && n.ii(p, r, q) : (r.isSelected = !1, r.isHighlighted = !1, r.Rb(), n.lc(q ? p : -1, r, q)));\n          } else n instanceof Q ? \"number\" === typeof p && r instanceof di && (b ? (r.Le(this), this.Ua.Cb(p, r)) : this.Ua.mb(p)) : C(\"unknown ChangedEvent.Remove object: \" + a.toString());\n          this.isModified = !0;\n        } else d !== ee && C(\"unknown ChangedEvent: \" + a.toString());\n      } finally {\n        this.skipsModelSourceBindings = c;\n      }\n    }\n  };\n\n  Q.prototype.Da = function (a) {\n    return this.undoManager.Da(a);\n  };\n\n  Q.prototype.eb = function (a) {\n    return this.undoManager.eb(a);\n  };\n\n  Q.prototype.Bf = function () {\n    return this.undoManager.Bf();\n  };\n\n  Q.prototype.commit = function (a, b) {\n    void 0 === b && (b = \"\");\n    var c = this.skipsUndoManager;\n    null === b && (this.skipsUndoManager = !0, b = \"\");\n    this.undoManager.Da(b);\n    var d = !1;\n\n    try {\n      a(this), d = !0;\n    } finally {\n      d ? this.undoManager.eb(b) : this.undoManager.Bf(), this.skipsUndoManager = c;\n    }\n  };\n\n  Q.prototype.updateAllTargetBindings = function (a) {\n    this.partManager.updateAllTargetBindings(a);\n  };\n\n  Q.prototype.Uo = function () {\n    this.partManager.Uo();\n  };\n\n  function Rj(a, b, c) {\n    var d = a.animationManager;\n    if (a.wb || a.cd) a.xa = c, Ci(a), d.zb && (wh(d) || d.Wd.add(d.H, \"scale\", b, a.xa));else if (null === a.Ha) a.xa = c, Ci(a);else {\n      a.wb = !0;\n      var e = a.viewportBounds.copy(),\n          f = a.Ba,\n          g = a.Aa;\n      e.width = a.Ba / b;\n      e.height = a.Aa / b;\n      var h = a.zoomPoint.x,\n          k = a.zoomPoint.y,\n          l = a.contentAlignment;\n      isNaN(h) && (l.Uc() ? l.xf(Ec) ? h = 0 : l.xf(Gc) && (h = f - 1) : h = l.pb() ? l.x * (f - 1) : f / 2);\n      isNaN(k) && (l.Uc() ? l.xf(Dc) ? k = 0 : l.xf(Hc) && (k = g - 1) : k = l.pb() ? l.y * (g - 1) : g / 2);\n      null === a.scaleComputation || a.animationManager.defaultAnimation.isAnimating || (c = a.scaleComputation(a, c));\n      c < a.minScale && (c = a.minScale);\n      c > a.maxScale && (c = a.maxScale);\n      f = I.allocAt(a.pa.x + h / b - h / c, a.pa.y + k / b - k / c);\n      a.position = f;\n      I.free(f);\n      a.xa = c;\n      Ci(a);\n      a.onViewportBoundsChanged(e, a.viewportBounds, b, !1);\n      a.wb = !1;\n      Ti(a, !1);\n      d.zb && (wh(d) || d.Wd.add(d.H, \"scale\", b, a.xa));\n      a.N();\n      Wi(a);\n    }\n  }\n\n  Q.prototype.onViewportBoundsChanged = function (a, b, c, d) {\n    if (!a.C(b)) {\n      void 0 === d && (d = !1);\n      d || Wi(this);\n      Ri(this);\n      var e = this.layout;\n      null === e || !e.isViewportSized || this.autoScale !== rh || d || a.width === b.width && a.height === b.height || e.D();\n      e = this.currentTool;\n      !0 === this.Kk && e instanceof La && (this.lastInput.documentPoint = this.rs(this.lastInput.viewPoint), ye(e, this));\n      this.wb || this.invalidateViewport(a, b);\n      jj(this);\n      this.kd.scale = c;\n      this.kd.position.x = a.x;\n      this.kd.position.y = a.y;\n      this.kd.bounds.assign(a);\n      this.kd.Hw.width = Math.round(a.width * c);\n      this.kd.Hw.height = Math.round(a.height * c);\n      this.kd.sx.width = this.Ba;\n      this.kd.sx.height = this.Aa;\n      this.kd.lx = d;\n      this.P(\"ViewportBoundsChanged\", this.kd, a);\n      this.isVirtualized && this.links.each(function (a) {\n        a.isAvoiding && a.actualBounds.Sc(b) && a.ab();\n      });\n    }\n  };\n\n  function jj(a, b) {\n    var c = a.Zd;\n\n    if (null !== c && c.visible) {\n      for (var d = K.alloc(), e = 1, f = 1, g = c.R.s, h = g.length, k = 0; k < h; k++) {\n        var l = g[k],\n            m = Math.abs(l.interval);\n        2 > m || (Sj(l.figure) ? f = f * m / J.Xw(f, m) : e = e * m / J.Xw(e, m));\n      }\n\n      g = c.gridCellSize;\n      d.h(f * g.width, e * g.height);\n      if (void 0 !== b) e = b.width, f = b.height, a = b.x, g = b.y;else {\n        b = M.alloc();\n        a = a.viewportBounds;\n        b.h(a.x, a.y, a.width, a.height);\n\n        if (!b.v()) {\n          M.free(b);\n          return;\n        }\n\n        e = b.width;\n        f = b.height;\n        a = b.x;\n        g = b.y;\n        M.free(b);\n      }\n      c.width = e + 2 * d.width;\n      c.height = f + 2 * d.height;\n      b = I.alloc();\n      J.so(a, g, 0, 0, d.width, d.height, b);\n      b.offset(-d.width, -d.height);\n      K.free(d);\n      c.part.location = b;\n      I.free(b);\n    }\n  }\n\n  Q.prototype.clearSelection = function (a) {\n    void 0 === a && (a = !1);\n    var b = this.selection;\n\n    if (0 !== b.count) {\n      a || this.P(\"ChangingSelection\", b);\n\n      for (var c = b.Ea(), d = c.length, e = 0; e < d; e++) {\n        c[e].isSelected = !1;\n      }\n\n      b.ja();\n      b.clear();\n      b.freeze();\n      a || this.P(\"ChangedSelection\", b);\n    }\n  };\n\n  Q.prototype.select = function (a) {\n    null !== a && a.diagram === this && (!a.isSelected || 1 < this.selection.count) && (this.P(\"ChangingSelection\", this.selection), this.clearSelection(!0), a.isSelected = !0, this.P(\"ChangedSelection\", this.selection));\n  };\n\n  Q.prototype.Yz = function (a) {\n    this.P(\"ChangingSelection\", this.selection);\n    this.clearSelection(!0);\n    if (za(a)) for (var b = a.length, c = 0; c < b; c++) {\n      var d = a[c];\n      d instanceof U || C(\"Diagram.selectCollection given something that is not a Part: \" + d);\n      d.isSelected = !0;\n    } else for (a = a.iterator; a.next();) {\n      b = a.value, b instanceof U || C(\"Diagram.selectCollection given something that is not a Part: \" + b), b.isSelected = !0;\n    }\n    this.P(\"ChangedSelection\", this.selection);\n  };\n\n  Q.prototype.clearHighlighteds = function () {\n    var a = this.highlighteds;\n\n    if (0 < a.count) {\n      for (var b = a.Ea(), c = b.length, d = 0; d < c; d++) {\n        b[d].isHighlighted = !1;\n      }\n\n      a.ja();\n      a.clear();\n      a.freeze();\n    }\n  };\n\n  t = Q.prototype;\n\n  t.qz = function (a) {\n    null !== a && a.diagram === this && (!a.isHighlighted || 1 < this.highlighteds.count) && (this.clearHighlighteds(), a.isHighlighted = !0);\n  };\n\n  t.rz = function (a) {\n    a = new G().addAll(a);\n\n    for (var b = this.highlighteds.copy().Ko(a).iterator; b.next();) {\n      b.value.isHighlighted = !1;\n    }\n\n    for (a = a.iterator; a.next();) {\n      b = a.value, b instanceof U || C(\"Diagram.highlightCollection given something that is not a Part: \" + b), b.isHighlighted = !0;\n    }\n  };\n\n  t.scroll = function (a, b, c) {\n    void 0 === c && (c = 1);\n    var d = \"up\" === b || \"down\" === b,\n        e = 0;\n    if (\"pixel\" === a) e = c;else if (\"line\" === a) e = c * (d ? this.scrollVerticalLineChange : this.scrollHorizontalLineChange);else if (\"page\" === a) a = d ? this.viewportBounds.height : this.viewportBounds.width, a *= this.scale, 0 !== a && (e = c * Math.max(a - (d ? this.scrollVerticalLineChange : this.scrollHorizontalLineChange), 0));else {\n      if (\"document\" === a) {\n        e = this.documentBounds;\n        c = this.viewportBounds;\n        d = I.alloc();\n        \"up\" === b ? this.position = d.h(c.x, e.y) : \"left\" === b ? this.position = d.h(e.x, c.y) : \"down\" === b ? this.position = d.h(c.x, e.bottom - c.height) : \"right\" === b && (this.position = d.h(e.right - c.width, c.y));\n        I.free(d);\n        return;\n      }\n\n      C(\"scrolling unit must be 'pixel', 'line', 'page', or 'document', not: \" + a);\n    }\n    e /= this.scale;\n    c = this.position.copy();\n    \"up\" === b ? c.y = this.position.y - e : \"down\" === b ? c.y = this.position.y + e : \"left\" === b ? c.x = this.position.x - e : \"right\" === b ? c.x = this.position.x + e : C(\"scrolling direction must be 'up', 'down', 'left', or 'right', not: \" + b);\n    this.position = c;\n  };\n\n  t.bv = function (a) {\n    var b = this.viewportBounds;\n    b.Ee(a) || (a = a.center, a.x -= b.width / 2, a.y -= b.height / 2, this.position = a);\n  };\n\n  t.Dr = function (a) {\n    var b = this.viewportBounds;\n    a = a.center;\n    a.x -= b.width / 2;\n    a.y -= b.height / 2;\n    this.position = a;\n  };\n\n  t.Ro = function (a) {\n    var b = this.Bb;\n    b.reset();\n    1 !== this.xa && b.scale(this.xa);\n    var c = this.pa;\n    (0 !== c.x || 0 !== c.y) && isFinite(c.x) && isFinite(c.y) && b.translate(-c.x, -c.y);\n    return a.copy().transform(this.Bb);\n  };\n\n  t.gA = function (a) {\n    var b = this.Bb,\n        c = a.x,\n        d = a.y,\n        e = c + a.width,\n        f = d + a.height,\n        g = b.m11,\n        h = b.m12,\n        k = b.m21,\n        l = b.m22,\n        m = b.dx,\n        n = b.dy,\n        p = c * g + d * k + m;\n    b = c * h + d * l + n;\n    var r = e * g + d * k + m;\n    a = e * h + d * l + n;\n    d = c * g + f * k + m;\n    c = c * h + f * l + n;\n    g = e * g + f * k + m;\n    e = e * h + f * l + n;\n    f = Math.min(p, r);\n    p = Math.max(p, r);\n    r = Math.min(b, a);\n    b = Math.max(b, a);\n    f = Math.min(f, d);\n    p = Math.max(p, d);\n    r = Math.min(r, c);\n    b = Math.max(b, c);\n    f = Math.min(f, g);\n    p = Math.max(p, g);\n    r = Math.min(r, e);\n    b = Math.max(b, e);\n    return new M(f, r, p - f, b - r);\n  };\n\n  t.rs = function (a) {\n    var b = this.Bb;\n    b.reset();\n    1 !== this.xa && b.scale(this.xa);\n    var c = this.pa;\n    (0 !== c.x || 0 !== c.y) && isFinite(c.x) && isFinite(c.y) && b.translate(-c.x, -c.y);\n    return yb(a.copy(), this.Bb);\n  };\n\n  function Tj(a) {\n    var b = a.isModified;\n    a.xw !== b && (a.xw = b, a.P(\"Modified\"));\n  }\n\n  function Uj(a) {\n    a = li.get(a);\n    return null !== a ? new a() : new mi();\n  }\n\n  Q.prototype.doModelChanged = function (a) {\n    var b = this;\n\n    if (a.model === this.model) {\n      var c = a.change,\n          d = a.propertyName;\n      if (c === ee && \"S\" === d[0]) {\n        if (\"StartingFirstTransaction\" === d) {\n          var e = this;\n          a = this.toolManager;\n          a.mouseDownTools.each(function (a) {\n            a.diagram = e;\n          });\n          a.mouseMoveTools.each(function (a) {\n            a.diagram = e;\n          });\n          a.mouseUpTools.each(function (a) {\n            a.diagram = e;\n          });\n          this.cd || this.Qf || (this.xk = !0, this.Nm && (this.cg = !0));\n        } else \"StartingUndo\" === d || \"StartingRedo\" === d ? (a = this.animationManager, a.defaultAnimation.isAnimating && !this.skipsUndoManager && a.wc(), this.P(\"ChangingSelection\", this.selection)) : \"StartedTransaction\" === d && (a = this.animationManager, a.defaultAnimation.isAnimating && !this.skipsUndoManager && a.wc());\n      } else if (this.$) {\n        this.$ = !1;\n\n        try {\n          if (\"\" === a.modelChange && c === ee) {\n            if (\"FinishedUndo\" === d || \"FinishedRedo\" === d) this.P(\"ChangedSelection\", this.selection), mh(this);\n            var f = this.animationManager;\n            \"RolledBackTransaction\" === d && f.wc();\n            this.xk = !0;\n            this.nd();\n            0 !== this.undoManager.transactionLevel && 1 !== this.undoManager.transactionLevel || nh(f);\n            \"CommittedTransaction\" === d && this.undoManager.isJustDiscarded && (this.se = Math.min(this.se, this.undoManager.historyIndex - 1));\n            \"CommittedTransaction\" !== d && \"RolledBackTransaction\" !== d || !this.undoManager.isPendingUnmodified || setTimeout(function () {\n              b.isModified = !1;\n            }, 1);\n            var g = a.isTransactionFinished;\n            g && (Tj(this), this.Zr.clear(), Ah(this.animationManager));\n\n            if (!this.wt && g && this.lastInput.targetDiagram) {\n              this.wt = !0;\n              var h = this;\n              ta(function () {\n                h.currentTool.standardMouseOver();\n                h.wt = !1;\n              }, 10);\n            }\n          }\n        } finally {\n          this.$ = !0;\n        }\n      }\n    }\n  };\n\n  function Bj(a, b) {\n    b = b.R.s;\n\n    for (var c = b.length, d = 0; d < c; d++) {\n      Vj(a, b[d]);\n    }\n  }\n\n  function Vj(a, b) {\n    if (b instanceof Wj) {\n      var c = b.element;\n\n      if (null !== c && c instanceof HTMLImageElement) {\n        c.sg instanceof G && c.sg.add(a);\n        var d = b.vg;\n        null !== d && !0 === d.Up && null !== b.diagram && b.diagram.Fn.add(b);\n        if (c.Pm) if (c = c.getAttribute(\"src\") || \"\", d = a.Fg.I(c), null === d) d = [], d.push(b), a.Fg.add(c, d);else {\n          for (a = 0; a < d.length; a++) {\n            if (d[a] === b) return;\n          }\n\n          d.push(b);\n        }\n      }\n    }\n  }\n\n  function Xj(a, b) {\n    if (b instanceof Wj) {\n      var c = b.element;\n\n      if (null !== c && c instanceof HTMLImageElement && c.Pm) {\n        var d = c.getAttribute(\"src\") || \"\",\n            e = a.Fg.I(d);\n        if (null !== e) for (var f = 0; f < e.length; f++) {\n          if (e[f] === b) {\n            e.splice(f, 1);\n            0 === e.length && (a.Fg.remove(d), c.fq && c.removeEventListener(\"load\", c.fq), c.Bp && c.removeEventListener(\"error\", c.Bp), delete c.fq, delete c.Bp, c.sg instanceof G && c.sg.remove(a), Bi(d));\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  Q.prototype.Od = function () {\n    this.partManager.Od();\n  };\n\n  Q.prototype.vj = function (a, b) {\n    this.Rd.vj(a, b);\n  };\n\n  Q.prototype.xj = function (a, b) {\n    this.Rd.xj(a, b);\n  };\n\n  Q.prototype.findPartForKey = function (a) {\n    return this.partManager.findPartForKey(a);\n  };\n\n  Q.prototype.Lb = function (a) {\n    return this.partManager.Lb(a);\n  };\n\n  Q.prototype.findLinkForKey = function (a) {\n    return this.partManager.findLinkForKey(a);\n  };\n\n  t = Q.prototype;\n\n  t.Ec = function (a) {\n    return this.partManager.Ec(a);\n  };\n\n  t.ci = function (a) {\n    return this.partManager.ci(a);\n  };\n\n  t.Dc = function (a) {\n    return this.partManager.Dc(a);\n  };\n\n  t.Jr = function (a) {\n    for (var b = [], c = 0; c < arguments.length; ++c) {\n      b[c] = arguments[c];\n    }\n\n    return this.partManager.Jr.apply(this.partManager, b instanceof Array ? b : ca(ba(b)));\n  };\n\n  t.Ir = function (a) {\n    for (var b = [], c = 0; c < arguments.length; ++c) {\n      b[c] = arguments[c];\n    }\n\n    return this.partManager.Ir.apply(this.partManager, b instanceof Array ? b : ca(ba(b)));\n  };\n\n  function Ci(a) {\n    var b = a.pa,\n        c = a.xa;\n    a.vw.h(b.x, b.y, Math.max(a.Ba, 0) / c, Math.max(a.Aa, 0) / c);\n  }\n\n  function wj(a, b) {\n    a.Si = !1;\n    var c = a.wp;\n    c.C(b) || (c = c.copy(), a.wp.assign(b), Ti(a, !1), a.P(\"DocumentBoundsChanged\", void 0, c), Wi(a));\n  }\n\n  t.Za = function () {\n    if (this.Si) {\n      var a = M.alloc();\n      wj(this, this.computeBounds(a));\n      M.free(a);\n    }\n  };\n\n  t.$y = function () {\n    for (var a = new G(), b = this.nodes; b.next();) {\n      var c = b.value;\n      c.isTopLevel && a.add(c);\n    }\n\n    for (b = this.links; b.next();) {\n      c = b.value, c.isTopLevel && a.add(c);\n    }\n\n    return a.iterator;\n  };\n\n  t.Zy = function () {\n    return this.Uh.iterator;\n  };\n\n  t.Bz = function (a) {\n    mh(this);\n    a && Yj(this, !0);\n    this.cd ? kj(this, !1) : (this.xk = !0, zf(this));\n  };\n\n  function Yj(a, b) {\n    for (var c = a.Uh.iterator; c.next();) {\n      Zj(a, c.value, b);\n    }\n\n    a.layout && (b ? a.layout.isValidLayout = !1 : a.layout.D());\n  }\n\n  function Zj(a, b, c) {\n    if (null !== b) {\n      for (var d = b.Vk.iterator; d.next();) {\n        Zj(a, d.value, c);\n      }\n\n      null !== b.layout && (c ? b.layout.isValidLayout = !1 : b.layout.D());\n    }\n  }\n\n  function kj(a, b) {\n    if (a.mh && !a.Ns) {\n      var c = a.$;\n      a.$ = !0;\n      var d = a.undoManager.transactionLevel,\n          e = a.layout,\n          f = a.animationManager;\n\n      try {\n        0 === d && (a.undoManager.isInternalTransaction = !0, a.Da(\"Layout\"));\n        1 >= d && !f.defaultAnimation.isAnimating && !f.zb && (b || lh(f, \"Layout\"));\n        a.mh = !1;\n\n        for (var g = a.Uh.iterator; g.next();) {\n          ak(a, g.value, b, d);\n        }\n\n        e.isValidLayout || (!b || e.isRealtime || null === e.isRealtime || 0 === d ? (e.doLayout(a), mh(a), e.isValidLayout = !0) : a.mh = !0);\n      } finally {\n        b = a.undoManager.isInternalTransaction, 0 === d && (a.eb(\"Layout\"), a.undoManager.isInternalTransaction = !1), !b || 0 !== d && 1 !== d || nh(f), a.$ = c;\n      }\n    }\n  }\n\n  function ak(a, b, c, d) {\n    if (null !== b) {\n      for (var e = b.Vk.iterator; e.next();) {\n        ak(a, e.value, c, d);\n      }\n\n      e = b.layout;\n      null === e || e.isValidLayout || (!c || e.isRealtime || 0 === d ? (b.gh = !b.location.v(), e.doLayout(b), b.D(32), mj(a, b), e.isValidLayout = !0) : a.mh = !0);\n    }\n  }\n\n  t.fz = function () {\n    for (var a = new E(), b = this.nodes; b.next();) {\n      var c = b.value;\n      c.isTopLevel && null === c.$g() && a.add(c);\n    }\n\n    return a.iterator;\n  };\n\n  function ui(a) {\n    function b(a) {\n      var b = a.toLowerCase(),\n          e = new E();\n      c.add(a, e);\n      c.add(b, e);\n      d.add(a, a);\n      d.add(b, a);\n    }\n\n    var c = new pb(),\n        d = new pb();\n    b(\"InitialAnimationStarting\");\n    b(\"AnimationStarting\");\n    b(\"AnimationFinished\");\n    b(\"BackgroundSingleClicked\");\n    b(\"BackgroundDoubleClicked\");\n    b(\"BackgroundContextClicked\");\n    b(\"ClipboardChanged\");\n    b(\"ClipboardPasted\");\n    b(\"DocumentBoundsChanged\");\n    b(\"ExternalObjectsDropped\");\n    b(\"GainedFocus\");\n    b(\"InitialLayoutCompleted\");\n    b(\"LayoutCompleted\");\n    b(\"LinkDrawn\");\n    b(\"LinkRelinked\");\n    b(\"LinkReshaped\");\n    b(\"LostFocus\");\n    b(\"Modified\");\n    b(\"ObjectSingleClicked\");\n    b(\"ObjectDoubleClicked\");\n    b(\"ObjectContextClicked\");\n    b(\"PartCreated\");\n    b(\"PartResized\");\n    b(\"PartRotated\");\n    b(\"SelectionMoved\");\n    b(\"SelectionCopied\");\n    b(\"SelectionDeleting\");\n    b(\"SelectionDeleted\");\n    b(\"SelectionGrouped\");\n    b(\"SelectionUngrouped\");\n    b(\"ChangingSelection\");\n    b(\"ChangedSelection\");\n    b(\"SubGraphCollapsed\");\n    b(\"SubGraphExpanded\");\n    b(\"TextEdited\");\n    b(\"TreeCollapsed\");\n    b(\"TreeExpanded\");\n    b(\"ViewportBoundsChanged\");\n    b(\"InvalidateDraw\");\n    a.Nv = c;\n    a.Mv = d;\n  }\n\n  function vj(a, b) {\n    var c = a.Mv.I(b);\n    return null !== c ? c : a.Mv.I(b.toLowerCase());\n  }\n\n  function bk(a, b) {\n    var c = a.Nv.I(b);\n    if (null !== c) return c;\n    c = a.Nv.I(b.toLowerCase());\n    if (null !== c) return c;\n    C(\"Unknown DiagramEvent name: \" + b);\n  }\n\n  t.wj = function (a, b) {\n    a = bk(this, a);\n    null !== a && a.add(b);\n    return this;\n  };\n\n  t.Il = function (a, b) {\n    a = bk(this, a);\n    null !== a && a.remove(b);\n  };\n\n  t.P = function (a, b, c) {\n    var d = bk(this, a),\n        e = new be();\n    e.diagram = this;\n    a = vj(this, a);\n    null !== a && (e.name = a);\n    void 0 !== b && (e.subject = b);\n    void 0 !== c && (e.parameter = c);\n    b = d.length;\n    if (1 === b) d.K(0)(e);else if (0 !== b) for (d = d.Ea(), c = 0; c < b; c++) {\n      (0, d[c])(e);\n    }\n  };\n\n  function ck(a) {\n    if (a.animationManager.isTicking) return !1;\n    var b = a.currentTool;\n    return b === a.toolManager.findTool(\"Dragging\") ? !a.jr || b.isComplexRoutingRealtime : !0;\n  }\n\n  t.Pj = function (a, b) {\n    return dk(this, !1, null, b || null).Pj(a.x, a.y, a.width, a.height);\n  };\n\n  Q.prototype.computeOccupiedArea = function (a) {\n    return this.isVirtualized ? this.viewportBounds.copy() : this.Si ? Si(this, a) : a.assign(this.documentBounds);\n  };\n\n  function dk(a, b, c, d) {\n    var e = a.Qh;\n    null === e && (a.Qh = e = new ek(a.avoidanceCellSize));\n\n    if (e.Sr || e.group !== c || e.Hx !== d) {\n      e.mx = Math.max(e.ps + 1, Math.floor(a.avoidanceLimit / a.avoidanceCellSize.width));\n      e.nx = Math.max(e.ps + 1, Math.floor(a.avoidanceLimit / a.avoidanceCellSize.height));\n      null !== c && (c = fk(a, c));\n\n      if (null === c) {\n        b = M.alloc();\n        a.computeOccupiedArea(b);\n        b.vc(100, 100);\n        e.initialize(b);\n\n        for (var f = a.nodes; f.next();) {\n          var g = f.value,\n              h = g.layer;\n          null !== h && h.visible && !h.isTemporary && gk(a, g, d, b);\n        }\n\n        M.free(b);\n      } else {\n        0 < c.memberParts.count && (b = a.computePartsBounds(c.memberParts, !1), b.vc(20, 20), e.initialize(b));\n        b = M.alloc();\n\n        for (f = c.memberParts; f.next();) {\n          g = f.value, g instanceof V && gk(a, g, d, b);\n        }\n\n        M.free(b);\n      }\n\n      e.group = c;\n      e.Hx = d;\n      e.Sr = !1;\n    } else b && hk(e);\n\n    return e;\n  }\n\n  function fk(a, b) {\n    return b.avoidable && !b.isLinkLabel ? b : null !== b.containingGroup ? fk(a, b.containingGroup) : null;\n  }\n\n  function gk(a, b, c, d) {\n    if (b !== c && b.isVisible()) if (b.avoidable && !b.isLinkLabel) {\n      b = b.getAvoidableRect(d);\n      a = a.Qh;\n      var e = b.x,\n          f = b.y;\n      if (ik(a, e, f)) for (c = (f - a.Ed) / a.oc | 0, d = Math.min((e + b.width - a.Dd) / a.nc | 0, a.Wh), b = Math.min((f + b.height - a.Ed) / a.oc | 0, a.Xh), e = (e - a.Dd) / a.nc | 0; e <= d; e++) {\n        if (f = a.Xb[e], f.fill) f.fill(jk, c, b + 1);else for (var g = c; g <= b; g++) {\n          f[g] = jk;\n        }\n      }\n    } else if (b instanceof qf) for (b = b.memberParts; b.next();) {\n      e = b.value, e instanceof V && gk(a, e, c, d);\n    }\n  }\n\n  function kk(a, b) {\n    null === a.Qh || a.Qh.Sr || void 0 !== b && (!b.avoidable || b.isLinkLabel) || (a.Qh.Sr = !0);\n  }\n\n  Q.prototype.Fr = function (a) {\n    this.Zo.assign(a);\n    this.computeAutoScrollPosition(this.Zo).$a(this.position) ? this.lg() : lk(this);\n  };\n\n  function lk(a) {\n    -1 === a.ik && (a.ik = ta(function () {\n      if (-1 !== a.ik && (a.lg(), null !== a.lastInput.event)) {\n        var b = a.computeAutoScrollPosition(a.Zo);\n        b.$a(a.position) || (a.position = b, a.lastInput.documentPoint = a.rs(a.Zo), a.doMouseMove(), a.Si = !0, b = M.alloc(), a.computeBounds(b), b.Xc(a.documentBounds), wj(a, b), M.free(b), a.bd = !0, a.nd(), lk(a));\n      }\n    }, a.Yo));\n  }\n\n  Q.prototype.lg = function () {\n    -1 !== this.ik && (x.clearTimeout(this.ik), this.ik = -1);\n  };\n\n  Q.prototype.computeAutoScrollPosition = function (a) {\n    var b = this.position,\n        c = this.$o;\n    if (0 >= c.top && 0 >= c.left && 0 >= c.right && 0 >= c.bottom) return b;\n    var d = this.viewportBounds,\n        e = this.scale;\n    d = M.allocAt(0, 0, d.width * e, d.height * e);\n    var f = I.allocAt(0, 0);\n\n    if (a.x >= d.x && a.x < d.x + c.left && this.allowHorizontalScroll) {\n      var g = Math.max(this.scrollHorizontalLineChange, 1);\n      g |= 0;\n      f.x -= g;\n      a.x < d.x + c.left / 2 && (f.x -= g);\n      a.x < d.x + c.left / 4 && (f.x -= 4 * g);\n    } else a.x <= d.x + d.width && a.x > d.x + d.width - c.right && this.allowHorizontalScroll && (g = Math.max(this.scrollHorizontalLineChange, 1), g |= 0, f.x += g, a.x > d.x + d.width - c.right / 2 && (f.x += g), a.x > d.x + d.width - c.right / 4 && (f.x += 4 * g));\n\n    a.y >= d.y && a.y < d.y + c.top && this.allowVerticalScroll ? (g = Math.max(this.scrollVerticalLineChange, 1), g |= 0, f.y -= g, a.y < d.y + c.top / 2 && (f.y -= g), a.y < d.y + c.top / 4 && (f.y -= 4 * g)) : a.y <= d.y + d.height && a.y > d.y + d.height - c.bottom && this.allowVerticalScroll && (g = Math.max(this.scrollVerticalLineChange, 1), g |= 0, f.y += g, a.y > d.y + d.height - c.bottom / 2 && (f.y += g), a.y > d.y + d.height - c.bottom / 4 && (f.y += 4 * g));\n    f.$a(qb) || (b = new I(b.x + f.x / e, b.y + f.y / e));\n    M.free(d);\n    I.free(f);\n    return b;\n  };\n\n  t = Q.prototype;\n\n  t.bs = function () {\n    return null;\n  };\n\n  t.Nu = function () {\n    return null;\n  };\n\n  t.ny = function (a, b) {\n    this.Yx.add(a, b);\n  };\n\n  t.lu = function (a) {\n    (this.tw = a) || this.nodes.each(function (a) {\n      a instanceof qf && (a.Dp = null);\n    });\n  };\n\n  function uk(a, b, c) {\n    function d() {\n      var a = +new Date();\n      f = !0;\n\n      for (g.reset(); g.next();) {\n        if (!g.value[0].Qk) {\n          f = !1;\n          break;\n        }\n      }\n\n      f || a - l > k ? b(c, e, h) : x.requestAnimationFrame(d);\n    }\n\n    for (var e = c.callback, f = !0, g = a.Fg.iterator; g.next();) {\n      if (!g.value[0].Qk) {\n        f = !1;\n        break;\n      }\n    }\n\n    if (\"function\" !== typeof e || f) return b(c, e, a);\n    var h = a,\n        k = c.callbackTimeout || 300,\n        l = +new Date();\n    x.requestAnimationFrame(function () {\n      d();\n    });\n    return null;\n  }\n\n  t.Dz = function (a) {\n    if (!Og) return null;\n    void 0 === a && (a = {});\n    a.returnType = \"Image\";\n    return this.ox(a);\n  };\n\n  t.ox = function (a) {\n    void 0 === a && (a = {});\n    return uk(this, this.Ez, a);\n  };\n\n  t.Ez = function (a, b, c) {\n    var d = yk(c, a, \"canvas\", null);\n    if (null === d) return null;\n    c = d.Z.canvas;\n    var e = null;\n    if (null !== c) switch (e = a.returnType, void 0 === e ? e = \"string\" : e = e.toLowerCase(), e) {\n      case zk + \"data\":\n        e = d.getImageData(0, 0, c.width, c.height);\n        break;\n\n      case zk:\n        d = (a.document || document).createElement(\"img\");\n        d.src = c.toDataURL(a.type, a.details);\n        e = d;\n        break;\n\n      case \"blob\":\n        \"function\" !== typeof b && C('Error: Diagram.makeImageData called with \"returnType: toBlob\", but no required \"callback\" function property defined.');\n        if (\"function\" === typeof c.toBlob) return c.toBlob(b, a.type, a.details), \"toBlob\";\n        if (\"function\" === typeof c.msToBlob) return b(c.msToBlob()), \"msToBlob\";\n        b(null);\n        return null;\n\n      default:\n        e = c.toDataURL(a.type, a.details);\n    }\n    return \"function\" === typeof b ? (b(e), null) : e;\n  };\n\n  function yk(a, b, c, d) {\n    a.animationManager.wc();\n    a.nd();\n    if (null === a.Ha) return null;\n    \"object\" !== typeof b && C(\"properties argument must be an Object.\");\n    var e = b.size || null,\n        f = b.scale || null;\n    void 0 !== b.scale && isNaN(b.scale) && (f = \"NaN\");\n    var g = b.maxSize;\n    void 0 === b.maxSize && (g = \"SVG\" === c ? new K(Infinity, Infinity) : new K(2E3, 2E3));\n    var h = b.position || null,\n        k = b.parts || null,\n        l = void 0 === b.padding ? 1 : b.padding,\n        m = b.background || null,\n        n = b.omitTemporary;\n    void 0 === n && (n = !0);\n    var p = b.document || document,\n        r = b.elementFinished || null,\n        q = b.showTemporary;\n    void 0 === q && (q = !n);\n    b = b.showGrid;\n    void 0 === b && (b = q);\n    null !== e && isNaN(e.width) && isNaN(e.height) && (e = null);\n    \"number\" === typeof l ? l = new ec(l) : l instanceof ec || C(\"MakeImage padding must be a Margin or a number.\");\n    l.left = Math.max(l.left, 0);\n    l.right = Math.max(l.right, 0);\n    l.top = Math.max(l.top, 0);\n    l.bottom = Math.max(l.bottom, 0);\n    a.Zb.Oc(!0);\n    n = new Ak(null, p);\n    var u = n.context;\n\n    if (!(e || f || k || h)) {\n      n.width = a.Ba + Math.ceil(l.left + l.right);\n      n.height = a.Aa + Math.ceil(l.top + l.bottom);\n\n      if (\"SVG\" === c) {\n        if (null === d) return null;\n        d.resize(n.width, n.height, n.width, n.height);\n        d.ownerDocument = p;\n        d.po = r;\n        tj(a, d.context, l, new K(n.width, n.height), a.xa, a.pa, k, m, q, b);\n        return d.context;\n      }\n\n      a.Fm = !1;\n      tj(a, u, l, new K(n.width, n.height), a.xa, a.pa, k, m, q, b);\n      a.Fm = !0;\n      return n.context;\n    }\n\n    var w = a.sp,\n        v = a.documentBounds.copy();\n    v.jv(a.ub);\n    if (q) for (var z = a.Ua.s, y = z.length, A = 0; A < y; A++) {\n      var B = z[A];\n\n      if (B.visible && B.isTemporary) {\n        B = B.Ma.s;\n\n        for (var F = B.length, L = 0; L < F; L++) {\n          var S = B[L];\n          S.isInDocumentBounds && S.isVisible() && (S = S.actualBounds, S.v() && v.Xc(S));\n        }\n      }\n    }\n    z = new I(v.x, v.y);\n\n    if (null !== k) {\n      y = new M(0, 0, 0, 0);\n      A = !0;\n      B = k.iterator;\n\n      for (B.reset(); B.next();) {\n        F = B.value, F instanceof U && (L = F.layer, null !== L && !L.visible || null !== L && !q && L.isTemporary || !F.isVisible() || (F = F.actualBounds, F.v() && (A ? (A = !1, y.assign(F)) : y.Xc(F))));\n      }\n\n      v.width = y.width;\n      v.height = y.height;\n      z.x = y.x;\n      z.y = y.y;\n    }\n\n    null !== h && h.v() && (z = h, f || (f = w));\n    y = h = 0;\n    null !== l && (h = l.left + l.right, y = l.top + l.bottom);\n    A = B = 0;\n    null !== e && (B = e.width, A = e.height, isFinite(B) && (B = Math.max(0, B - h)), isFinite(A) && (A = Math.max(0, A - y)));\n    null !== e && null !== f ? (\"NaN\" === f && (f = w), e.v() ? (e = B, v = A) : isNaN(A) ? (e = B, v = v.height * f) : (e = v.width * f, v = A)) : null !== e ? e.v() ? (f = Math.min(B / v.width, A / v.height), e = B, v = A) : isNaN(A) ? (f = B / v.width, e = B, v = v.height * f) : (f = A / v.height, e = v.width * f, v = A) : null !== f ? \"NaN\" === f && g.v() ? (f = Math.min((g.width - h) / v.width, (g.height - y) / v.height), f > w ? (f = w, e = v.width, v = v.height) : (e = g.width, v = g.height)) : (e = v.width * f, v = v.height * f) : (f = w, e = v.width, v = v.height);\n    null !== l ? (e += h, v += y) : l = new ec(0);\n    null !== g && (w = g.width, g = g.height, isNaN(w) && (w = 2E3), isNaN(g) && (g = 2E3), isFinite(w) && (e = Math.min(e, w)), isFinite(g) && (v = Math.min(v, g)));\n    n.width = Math.ceil(e);\n    n.height = Math.ceil(v);\n\n    if (\"SVG\" === c) {\n      if (null === d) return null;\n      d.resize(n.width, n.height, n.width, n.height);\n      d.ownerDocument = p;\n      d.po = r;\n      tj(a, d.context, l, new K(Math.ceil(e), Math.ceil(v)), f, z, k, m, q, b);\n      return d.context;\n    }\n\n    a.Fm = !1;\n    tj(a, u, l, new K(Math.ceil(e), Math.ceil(v)), f, z, k, m, q, b);\n    a.Fm = !0;\n    return n.context;\n  }\n\n  ma.Object.defineProperties(Q.prototype, {\n    div: {\n      get: function get() {\n        return this.La;\n      },\n      set: function set(a) {\n        if (this.La !== a) {\n          var b = this.La;\n          null !== b ? (b.H = void 0, b.goDiagram = void 0, b.go = void 0, b.innerHTML = \"\", null !== this.Ha && (b = this.Ha.Sa, this.removeEventListener(b, \"pointermove\", this.Xj, !1), this.removeEventListener(b, \"pointerdown\", this.Wj, !1), this.removeEventListener(b, \"pointerup\", this.Zj, !1), this.removeEventListener(b, \"pointerout\", this.Yj, !1), this.Ha.Pw()), this.cl && (this.cl.disconnect(), this.cl = null), b = this.toolManager, null !== b && (b.mouseDownTools.each(function (a) {\n            a.cancelWaitAfter();\n          }), b.mouseMoveTools.each(function (a) {\n            a.cancelWaitAfter();\n          }), b.mouseUpTools.each(function (a) {\n            a.cancelWaitAfter();\n          })), b.cancelWaitAfter(), this.currentTool.doCancel(), this.Ha = null, this.removeEventListener(x, \"resize\", this.sv, !1), this.removeEventListener(x, \"wheel\", this.Sj, !0), le === this && (le = null)) : this.Qf = !1;\n          this.La = null;\n\n          if (null !== a) {\n            if (b = a.H) b.div = null;\n            si(this, a);\n            this.redraw();\n          }\n        }\n      }\n    },\n    Ew: {\n      get: function get() {\n        return this.rq;\n      }\n    },\n    ji: {\n      get: function get() {\n        return this.Qf;\n      }\n    },\n    draggedLink: {\n      get: function get() {\n        return this.Ps;\n      },\n      set: function set(a) {\n        this.Ps !== a && (this.Ps = a, null !== a && (this.At = a.fromPort, this.Bt = a.toPort));\n      }\n    },\n    tx: {\n      get: function get() {\n        return this.At;\n      },\n      set: function set(a) {\n        this.At = a;\n      }\n    },\n    ux: {\n      get: function get() {\n        return this.Bt;\n      },\n      set: function set(a) {\n        this.Bt = a;\n      }\n    },\n    animationManager: {\n      get: function get() {\n        return this.Rd;\n      }\n    },\n    undoManager: {\n      get: function get() {\n        return this.ac.undoManager;\n      }\n    },\n    skipsUndoManager: {\n      get: function get() {\n        return this.Mg;\n      },\n      set: function set(a) {\n        this.Mg = a;\n        this.ac.skipsUndoManager = a;\n      }\n    },\n    delaysLayout: {\n      get: function get() {\n        return this.Ns;\n      },\n      set: function set(a) {\n        this.Ns = a;\n      }\n    },\n    opacity: {\n      get: function get() {\n        return this.tb;\n      },\n      set: function set(a) {\n        var b = this.tb;\n        b !== a && ((0 > a || 1 < a) && wa(a, \"0 <= value <= 1\", Q, \"opacity\"), this.tb = a, this.g(\"opacity\", b, a), this.N());\n      }\n    },\n    validCycle: {\n      get: function get() {\n        return this.bu;\n      },\n      set: function set(a) {\n        var b = this.bu;\n        b !== a && (this.bu = a, this.g(\"validCycle\", b, a));\n      }\n    },\n    layers: {\n      get: function get() {\n        return this.Ua.iterator;\n      }\n    },\n    isModelReadOnly: {\n      get: function get() {\n        var a = this.ac;\n        return null === a ? !1 : a.isReadOnly;\n      },\n      set: function set(a) {\n        var b = this.ac;\n        null !== b && (b.isReadOnly = a);\n      }\n    },\n    isReadOnly: {\n      get: function get() {\n        return this.xg;\n      },\n      set: function set(a) {\n        var b = this.xg;\n        b !== a && (this.xg = a, this.g(\"isReadOnly\", b, a));\n      }\n    },\n    isEnabled: {\n      get: function get() {\n        return this.Ad;\n      },\n      set: function set(a) {\n        var b = this.Ad;\n        b !== a && (this.Ad = a, this.g(\"isEnabled\", b, a));\n      }\n    },\n    allowClipboard: {\n      get: function get() {\n        return this.ws;\n      },\n      set: function set(a) {\n        var b = this.ws;\n        b !== a && (this.ws = a, this.g(\"allowClipboard\", b, a));\n      }\n    },\n    allowCopy: {\n      get: function get() {\n        return this.zi;\n      },\n      set: function set(a) {\n        var b = this.zi;\n        b !== a && (this.zi = a, this.g(\"allowCopy\", b, a));\n      }\n    },\n    allowDelete: {\n      get: function get() {\n        return this.Ai;\n      },\n      set: function set(a) {\n        var b = this.Ai;\n        b !== a && (this.Ai = a, this.g(\"allowDelete\", b, a));\n      }\n    },\n    allowDragOut: {\n      get: function get() {\n        return this.xs;\n      },\n      set: function set(a) {\n        var b = this.xs;\n        b !== a && (this.xs = a, this.g(\"allowDragOut\", b, a));\n      }\n    },\n    allowDrop: {\n      get: function get() {\n        return this.ys;\n      },\n      set: function set(a) {\n        var b = this.ys;\n        b !== a && (this.ys = a, this.g(\"allowDrop\", b, a));\n      }\n    },\n    allowTextEdit: {\n      get: function get() {\n        return this.Ji;\n      },\n      set: function set(a) {\n        var b = this.Ji;\n        b !== a && (this.Ji = a, this.g(\"allowTextEdit\", b, a));\n      }\n    },\n    allowGroup: {\n      get: function get() {\n        return this.Bi;\n      },\n      set: function set(a) {\n        var b = this.Bi;\n        b !== a && (this.Bi = a, this.g(\"allowGroup\", b, a));\n      }\n    },\n    allowUngroup: {\n      get: function get() {\n        return this.Ki;\n      },\n      set: function set(a) {\n        var b = this.Ki;\n        b !== a && (this.Ki = a, this.g(\"allowUngroup\", b, a));\n      }\n    },\n    allowInsert: {\n      get: function get() {\n        return this.As;\n      },\n      set: function set(a) {\n        var b = this.As;\n        b !== a && (this.As = a, this.g(\"allowInsert\", b, a));\n      }\n    },\n    allowLink: {\n      get: function get() {\n        return this.Ci;\n      },\n      set: function set(a) {\n        var b = this.Ci;\n        b !== a && (this.Ci = a, this.g(\"allowLink\", b, a));\n      }\n    },\n    allowRelink: {\n      get: function get() {\n        return this.Ei;\n      },\n      set: function set(a) {\n        var b = this.Ei;\n        b !== a && (this.Ei = a, this.g(\"allowRelink\", b, a));\n      }\n    },\n    allowMove: {\n      get: function get() {\n        return this.Di;\n      },\n      set: function set(a) {\n        var b = this.Di;\n        b !== a && (this.Di = a, this.g(\"allowMove\", b, a));\n      }\n    },\n    allowReshape: {\n      get: function get() {\n        return this.Fi;\n      },\n      set: function set(a) {\n        var b = this.Fi;\n        b !== a && (this.Fi = a, this.g(\"allowReshape\", b, a));\n      }\n    },\n    allowResize: {\n      get: function get() {\n        return this.Gi;\n      },\n      set: function set(a) {\n        var b = this.Gi;\n        b !== a && (this.Gi = a, this.g(\"allowResize\", b, a));\n      }\n    },\n    allowRotate: {\n      get: function get() {\n        return this.Hi;\n      },\n      set: function set(a) {\n        var b = this.Hi;\n        b !== a && (this.Hi = a, this.g(\"allowRotate\", b, a));\n      }\n    },\n    allowSelect: {\n      get: function get() {\n        return this.Ii;\n      },\n      set: function set(a) {\n        var b = this.Ii;\n        b !== a && (this.Ii = a, this.g(\"allowSelect\", b, a));\n      }\n    },\n    allowUndo: {\n      get: function get() {\n        return this.Bs;\n      },\n      set: function set(a) {\n        var b = this.Bs;\n        b !== a && (this.Bs = a, this.g(\"allowUndo\", b, a));\n      }\n    },\n    allowZoom: {\n      get: function get() {\n        return this.Ds;\n      },\n      set: function set(a) {\n        var b = this.Ds;\n        b !== a && (this.Ds = a, this.g(\"allowZoom\", b, a));\n      }\n    },\n    hasVerticalScrollbar: {\n      get: function get() {\n        return this.Um;\n      },\n      set: function set(a) {\n        var b = this.Um;\n        b !== a && (this.Um = a, Wi(this), this.N(), this.g(\"hasVerticalScrollbar\", b, a), Ti(this, !1));\n      }\n    },\n    hasHorizontalScrollbar: {\n      get: function get() {\n        return this.Tm;\n      },\n      set: function set(a) {\n        var b = this.Tm;\n        b !== a && (this.Tm = a, Wi(this), this.N(), this.g(\"hasHorizontalScrollbar\", b, a), Ti(this, !1));\n      }\n    },\n    allowHorizontalScroll: {\n      get: function get() {\n        return this.zs;\n      },\n      set: function set(a) {\n        var b = this.zs;\n        b !== a && (this.zs = a, this.g(\"allowHorizontalScroll\", b, a), Ti(this, !1));\n      }\n    },\n    allowVerticalScroll: {\n      get: function get() {\n        return this.Cs;\n      },\n      set: function set(a) {\n        var b = this.Cs;\n        b !== a && (this.Cs = a, this.g(\"allowVerticalScroll\", b, a), Ti(this, !1));\n      }\n    },\n    scrollHorizontalLineChange: {\n      get: function get() {\n        return this.Ot;\n      },\n      set: function set(a) {\n        var b = this.Ot;\n        b !== a && (0 > a && wa(a, \">= 0\", Q, \"scrollHorizontalLineChange\"), this.Ot = a, this.g(\"scrollHorizontalLineChange\", b, a));\n      }\n    },\n    scrollVerticalLineChange: {\n      get: function get() {\n        return this.St;\n      },\n      set: function set(a) {\n        var b = this.St;\n        b !== a && (0 > a && wa(a, \">= 0\", Q, \"scrollVerticalLineChange\"), this.St = a, this.g(\"scrollVerticalLineChange\", b, a));\n      }\n    },\n    lastInput: {\n      get: function get() {\n        return this.Yi;\n      },\n      set: function set(a) {\n        this.Yi = a;\n      }\n    },\n    previousInput: {\n      get: function get() {\n        return this.Hg;\n      },\n      set: function set(a) {\n        this.Hg = a;\n      }\n    },\n    firstInput: {\n      get: function get() {\n        return this.Fp;\n      },\n      set: function set(a) {\n        this.Fp = a;\n      }\n    },\n    currentCursor: {\n      get: function get() {\n        return this.Ks;\n      },\n      set: function set(a) {\n        \"\" === a && (a = this.rp);\n\n        if (this.Ks !== a) {\n          var b = this.Ha,\n              c = this.La;\n\n          if (null !== b && null !== c) {\n            this.Ks = a;\n            var d = b.style.cursor;\n            b.style.cursor = a;\n            c.style.cursor = a;\n            b.style.cursor === d && (b.style.cursor = \"-webkit-\" + a, c.style.cursor = \"-webkit-\" + a, b.style.cursor === d && (b.style.cursor = \"-moz-\" + a, c.style.cursor = \"-moz-\" + a, b.style.cursor === d && (b.style.cursor = a, c.style.cursor = a)));\n          }\n        }\n      }\n    },\n    defaultCursor: {\n      get: function get() {\n        return this.rp;\n      },\n      set: function set(a) {\n        \"\" === a && (a = \"auto\");\n        var b = this.rp;\n        b !== a && (this.rp = a, this.g(\"defaultCursor\", b, a));\n      }\n    },\n    click: {\n      get: function get() {\n        return this.oh;\n      },\n      set: function set(a) {\n        var b = this.oh;\n        b !== a && (this.oh = a, this.g(\"click\", b, a));\n      }\n    },\n    doubleClick: {\n      get: function get() {\n        return this.uh;\n      },\n      set: function set(a) {\n        var b = this.uh;\n        b !== a && (this.uh = a, this.g(\"doubleClick\", b, a));\n      }\n    },\n    contextClick: {\n      get: function get() {\n        return this.qh;\n      },\n      set: function set(a) {\n        var b = this.qh;\n        b !== a && (this.qh = a, this.g(\"contextClick\", b, a));\n      }\n    },\n    mouseOver: {\n      get: function get() {\n        return this.Jh;\n      },\n      set: function set(a) {\n        var b = this.Jh;\n        b !== a && (this.Jh = a, this.g(\"mouseOver\", b, a));\n      }\n    },\n    mouseHover: {\n      get: function get() {\n        return this.Hh;\n      },\n      set: function set(a) {\n        var b = this.Hh;\n        b !== a && (this.Hh = a, this.g(\"mouseHover\", b, a));\n      }\n    },\n    mouseHold: {\n      get: function get() {\n        return this.Gh;\n      },\n      set: function set(a) {\n        var b = this.Gh;\n        b !== a && (this.Gh = a, this.g(\"mouseHold\", b, a));\n      }\n    },\n    mouseDragOver: {\n      get: function get() {\n        return this.vt;\n      },\n      set: function set(a) {\n        var b = this.vt;\n        b !== a && (this.vt = a, this.g(\"mouseDragOver\", b, a));\n      }\n    },\n    mouseDrop: {\n      get: function get() {\n        return this.Eh;\n      },\n      set: function set(a) {\n        var b = this.Eh;\n        b !== a && (this.Eh = a, this.g(\"mouseDrop\", b, a));\n      }\n    },\n    handlesDragDropForTopLevelParts: {\n      get: function get() {\n        return this.$s;\n      },\n      set: function set(a) {\n        var b = this.$s;\n        b !== a && (this.$s = a, this.g(\"handlesDragDropForTopLevelParts\", b, a));\n      }\n    },\n    mouseEnter: {\n      get: function get() {\n        return this.Fh;\n      },\n      set: function set(a) {\n        var b = this.Fh;\n        b !== a && (this.Fh = a, this.g(\"mouseEnter\", b, a));\n      }\n    },\n    mouseLeave: {\n      get: function get() {\n        return this.Ih;\n      },\n      set: function set(a) {\n        var b = this.Ih;\n        b !== a && (this.Ih = a, this.g(\"mouseLeave\", b, a));\n      }\n    },\n    toolTip: {\n      get: function get() {\n        return this.Th;\n      },\n      set: function set(a) {\n        var b = this.Th;\n        b !== a && (this.Th = a, this.g(\"toolTip\", b, a));\n      }\n    },\n    contextMenu: {\n      get: function get() {\n        return this.rh;\n      },\n      set: function set(a) {\n        var b = this.rh;\n        b !== a && (this.rh = a, this.g(\"contextMenu\", b, a));\n      }\n    },\n    commandHandler: {\n      get: function get() {\n        return this.hb;\n      },\n      set: function set(a) {\n        this.hb !== a && (this.hb = a, a.Le(this));\n      }\n    },\n    toolManager: {\n      get: function get() {\n        return this.le;\n      },\n      set: function set(a) {\n        this.le !== a && (this.le = a, a.diagram = this);\n      }\n    },\n    defaultTool: {\n      get: function get() {\n        return this.nb;\n      },\n      set: function set(a) {\n        var b = this.nb;\n        b !== a && (this.nb = a, a.diagram = this, this.currentTool === b && (this.currentTool = a));\n      }\n    },\n    currentTool: {\n      get: function get() {\n        return this.cb;\n      },\n      set: function set(a) {\n        var b = this.cb;\n        b && (b.isActive && b.doDeactivate(), b.cancelWaitAfter(), b.doStop());\n        null === a && (a = this.defaultTool);\n        null !== a && (this.cb = a, a.diagram = this, a.doStart());\n      }\n    },\n    selection: {\n      get: function get() {\n        return this.lw;\n      }\n    },\n    maxSelectionCount: {\n      get: function get() {\n        return this.qt;\n      },\n      set: function set(a) {\n        var b = this.qt;\n        if (b !== a) if (0 <= a && !isNaN(a)) {\n          if (this.qt = a, this.g(\"maxSelectionCount\", b, a), !this.undoManager.isUndoingRedoing && (a = this.selection.count - a, 0 < a)) {\n            this.P(\"ChangingSelection\", this.selection);\n            b = this.selection.Ea();\n\n            for (var c = 0; c < a; c++) {\n              b[c].isSelected = !1;\n            }\n\n            this.P(\"ChangedSelection\", this.selection);\n          }\n        } else wa(a, \">= 0\", Q, \"maxSelectionCount\");\n      }\n    },\n    nodeSelectionAdornmentTemplate: {\n      get: function get() {\n        return this.xt;\n      },\n      set: function set(a) {\n        var b = this.xt;\n        b !== a && (this.xt = a, this.g(\"nodeSelectionAdornmentTemplate\", b, a));\n      }\n    },\n    groupSelectionAdornmentTemplate: {\n      get: function get() {\n        return this.Zs;\n      },\n      set: function set(a) {\n        var b = this.Zs;\n        b !== a && (this.Zs = a, this.g(\"groupSelectionAdornmentTemplate\", b, a));\n      }\n    },\n    linkSelectionAdornmentTemplate: {\n      get: function get() {\n        return this.nt;\n      },\n      set: function set(a) {\n        var b = this.nt;\n        b !== a && (this.nt = a, this.g(\"linkSelectionAdornmentTemplate\", b, a));\n      }\n    },\n    highlighteds: {\n      get: function get() {\n        return this.Tv;\n      }\n    },\n    isModified: {\n      get: function get() {\n        var a = this.undoManager;\n        return a.isEnabled ? null !== a.currentTransaction ? !0 : this.Ym && this.se !== a.historyIndex : this.Ym;\n      },\n      set: function set(a) {\n        if (this.Ym !== a) {\n          this.Ym = a;\n          var b = this.undoManager;\n          !a && b.isEnabled && (this.se = b.historyIndex);\n          a || Tj(this);\n        }\n      }\n    },\n    model: {\n      get: function get() {\n        return this.ac;\n      },\n      set: function set(a) {\n        var b = this.ac;\n\n        if (b !== a) {\n          this.currentTool.doCancel();\n          b && b.undoManager !== a.undoManager && b.undoManager.isInTransaction && C(\"Do not replace a Diagram.model while a transaction is in progress.\");\n          this.animationManager.wc(!0);\n          var c = Ai(this, !0);\n          this.Qf = !1;\n          this.Nm = !0;\n          this.se = -2;\n          this.cg = !1;\n          var d = this.wb;\n          this.wb = !0;\n          lh(this.animationManager, \"Model\");\n          b && (null !== this.bf && this.bf.each(function (a) {\n            b.ak(a);\n          }), b.ak(this.Hc));\n          this.ac = a;\n          this.partManager = Uj(this.ac.type);\n\n          for (var e = 0; e < c.length; e++) {\n            this.add(c[e]);\n          }\n\n          a.Ug(this.Db);\n          this.partManager.addAllModeledParts();\n          a.ak(this.Db);\n          a.Ug(this.Hc);\n          null !== this.bf && this.bf.each(function (b) {\n            a.Ug(b);\n          });\n          this.wb = d;\n          this.Va();\n          this.wb || this.N();\n          b && a.undoManager.copyProperties(b.undoManager);\n        }\n      }\n    },\n    $: {\n      get: function get() {\n        return this.Xv;\n      },\n      set: function set(a) {\n        this.Xv = a;\n      }\n    },\n    Zr: {\n      get: function get() {\n        return this.Xx;\n      }\n    },\n    skipsModelSourceBindings: {\n      get: function get() {\n        return this.mw;\n      },\n      set: function set(a) {\n        this.mw = a;\n      }\n    },\n    os: {\n      get: function get() {\n        return this.Ut;\n      },\n      set: function set(a) {\n        this.Ut = a;\n      }\n    },\n    nodeTemplate: {\n      get: function get() {\n        return this.Dg.I(\"\");\n      },\n      set: function set(a) {\n        var b = this.Dg.I(\"\");\n        b !== a && (this.Dg.add(\"\", a), this.g(\"nodeTemplate\", b, a), this.undoManager.isUndoingRedoing || this.Od());\n      }\n    },\n    nodeTemplateMap: {\n      get: function get() {\n        return this.Dg;\n      },\n      set: function set(a) {\n        var b = this.Dg;\n        b !== a && (this.Dg = a, this.g(\"nodeTemplateMap\", b, a), this.undoManager.isUndoingRedoing || this.Od());\n      }\n    },\n    groupTemplate: {\n      get: function get() {\n        return this.Ri.I(\"\");\n      },\n      set: function set(a) {\n        var b = this.Ri.I(\"\");\n        b !== a && (this.Ri.add(\"\", a), this.g(\"groupTemplate\", b, a), this.undoManager.isUndoingRedoing || this.Od());\n      }\n    },\n    groupTemplateMap: {\n      get: function get() {\n        return this.Ri;\n      },\n      set: function set(a) {\n        var b = this.Ri;\n        b !== a && (this.Ri = a, this.g(\"groupTemplateMap\", b, a), this.undoManager.isUndoingRedoing || this.Od());\n      }\n    },\n    linkTemplate: {\n      get: function get() {\n        return this.Ch.I(\"\");\n      },\n      set: function set(a) {\n        var b = this.Ch.I(\"\");\n        b !== a && (this.Ch.add(\"\", a), this.g(\"linkTemplate\", b, a), this.undoManager.isUndoingRedoing || this.Od());\n      }\n    },\n    linkTemplateMap: {\n      get: function get() {\n        return this.Ch;\n      },\n      set: function set(a) {\n        var b = this.Ch;\n        b !== a && (this.Ch = a, this.g(\"linkTemplateMap\", b, a), this.undoManager.isUndoingRedoing || this.Od());\n      }\n    },\n    isMouseCaptured: {\n      get: function get() {\n        return this.Wv;\n      },\n      set: function set(a) {\n        var b = this.Ha;\n        null !== b && (b = b.Sa, b instanceof SVGElement || (a ? (this.lastInput.bubbles = !1, this.removeEventListener(b, \"pointermove\", this.Xj, !1), this.removeEventListener(b, \"pointerdown\", this.Wj, !1), this.removeEventListener(b, \"pointerup\", this.Zj, !1), this.removeEventListener(b, \"pointerout\", this.Yj, !1), this.addEventListener(x, \"pointermove\", this.Xj, !0), this.addEventListener(x, \"pointerdown\", this.Wj, !0), this.addEventListener(x, \"pointerup\", this.Zj, !0), this.addEventListener(x, \"pointerout\", this.Yj, !0), this.removeEventListener(b, \"wheel\", this.Sj, !1), this.addEventListener(x, \"wheel\", this.Sj, !0), this.addEventListener(x, \"selectstart\", this.preventDefault, !1)) : (this.removeEventListener(x, \"pointermove\", this.Xj, !0), this.removeEventListener(x, \"pointerdown\", this.Wj, !0), this.removeEventListener(x, \"pointerup\", this.Zj, !0), this.removeEventListener(x, \"pointerout\", this.Yj, !0), this.addEventListener(b, \"pointermove\", this.Xj, !1), this.addEventListener(b, \"pointerdown\", this.Wj, !1), this.addEventListener(b, \"pointerup\", this.Zj, !1), this.addEventListener(b, \"pointerout\", this.Yj, !1), this.removeEventListener(x, \"wheel\", this.Sj, !0), this.removeEventListener(x, \"selectstart\", this.preventDefault, !1), this.addEventListener(b, \"wheel\", this.Sj, !1)), this.Wv = a));\n      }\n    },\n    position: {\n      get: function get() {\n        return this.pa;\n      },\n      set: function set(a) {\n        var b = I.alloc().assign(this.pa);\n\n        if (!b.C(a)) {\n          var c = this.viewportBounds.copy();\n          this.pa.assign(a);\n          Nh(this.animationManager, b, this.pa);\n          this.wb || null === this.Ha && !this.Zn.v() ? Ci(this) : (this.wb = !0, a = this.scale, Vi(this, this.wp, this.Ba / a, this.Aa / a, this.mk, !1), this.wb = !1);\n          if (!this.wb) this.onViewportBoundsChanged(c, this.viewportBounds, this.xa, !1);\n        }\n\n        I.free(b);\n      }\n    },\n    initialPosition: {\n      get: function get() {\n        return this.bt;\n      },\n      set: function set(a) {\n        this.bt.C(a) || (this.bt = a.J());\n      }\n    },\n    initialScale: {\n      get: function get() {\n        return this.ct;\n      },\n      set: function set(a) {\n        this.ct !== a && (this.ct = a);\n      }\n    },\n    grid: {\n      get: function get() {\n        null === this.Zd && (this.Zd = Fi(this));\n        return this.Zd;\n      },\n      set: function set(a) {\n        var b = this.Zd;\n\n        if (b !== a) {\n          null === b && (b = this.Zd = Fi(this));\n          a.type !== W.Grid && C(\"Diagram.grid must be a Panel of type Panel.Grid\");\n          var c = b.panel;\n          null !== c && c.remove(b);\n          this.Zd = a;\n          a.name = \"GRID\";\n          null !== c && c.add(a);\n          jj(this);\n          this.N();\n          this.g(\"grid\", b, a);\n        }\n      }\n    },\n    viewportBounds: {\n      get: function get() {\n        return this.vw;\n      }\n    },\n    viewSize: {\n      get: function get() {\n        return this.Zn;\n      },\n      set: function set(a) {\n        var b = this.viewSize;\n        b.C(a) || (this.Zn = a = a.J(), this.Aa = this.Ba = 0, a.v() ? (this.Ba = a.width, this.Aa = a.height) : null !== this.La && (this.Ba = this.La.clientWidth || 1, this.Aa = this.La.clientHeight || 1), Ci(this), this.Va(), this.g(\"viewSize\", b, a), this.redraw());\n      }\n    },\n    fixedBounds: {\n      get: function get() {\n        return this.Xs;\n      },\n      set: function set(a) {\n        var b = this.Xs;\n        b.C(a) || (-Infinity !== a.width && Infinity !== a.height && -Infinity !== a.height || C(\"fixedBounds width/height must not be Infinity\"), this.Xs = a = a.J(), this.Va(), this.g(\"fixedBounds\", b, a));\n      }\n    },\n    scrollMargin: {\n      get: function get() {\n        return this.mj;\n      },\n      set: function set(a) {\n        \"number\" === typeof a && (a = new ec(a));\n        var b = this.mj;\n        b.C(a) || (this.mj = a = a.J(), this.g(\"scrollMargin\", b, a), this.Jo());\n      }\n    },\n    scrollMode: {\n      get: function get() {\n        return this.nj;\n      },\n      set: function set(a) {\n        var b = this.nj;\n        b !== a && (this.nj = a, a === Rh && Ti(this, !1), this.g(\"scrollMode\", b, a), this.N());\n      }\n    },\n    scrollsPageOnFocus: {\n      get: function get() {\n        return this.Tt;\n      },\n      set: function set(a) {\n        var b = this.Tt;\n        b !== a && (this.Tt = a, this.g(\"scrollsPageOnFocus\", b, a));\n      }\n    },\n    positionComputation: {\n      get: function get() {\n        return this.Et;\n      },\n      set: function set(a) {\n        var b = this.Et;\n        b !== a && (this.Et = a, Ti(this, !1), this.g(\"positionComputation\", b, a));\n      }\n    },\n    scaleComputation: {\n      get: function get() {\n        return this.Lt;\n      },\n      set: function set(a) {\n        var b = this.Lt;\n        b !== a && (this.Lt = a, Rj(this, this.scale, this.scale), this.g(\"scaleComputation\", b, a));\n      }\n    },\n    documentBounds: {\n      get: function get() {\n        return this.wp;\n      }\n    },\n    isVirtualized: {\n      get: function get() {\n        return this.lt;\n      },\n      set: function set(a) {\n        var b = this.lt;\n        b !== a && (this.lt = a, this.g(\"isVirtualized\", b, a));\n      }\n    },\n    scale: {\n      get: function get() {\n        return this.xa;\n      },\n      set: function set(a) {\n        var b = this.xa;\n        b !== a && Rj(this, b, a);\n      }\n    },\n    defaultScale: {\n      get: function get() {\n        return this.sp;\n      },\n      set: function set(a) {\n        this.sp = a;\n      }\n    },\n    autoScale: {\n      get: function get() {\n        return this.nh;\n      },\n      set: function set(a) {\n        var b = this.nh;\n        b !== a && (this.nh = a, this.g(\"autoScale\", b, a), a !== rh && Ti(this, !1));\n      }\n    },\n    initialAutoScale: {\n      get: function get() {\n        return this.wg;\n      },\n      set: function set(a) {\n        var b = this.wg;\n        b !== a && (this.wg = a, this.g(\"initialAutoScale\", b, a));\n      }\n    },\n    initialViewportSpot: {\n      get: function get() {\n        return this.dt;\n      },\n      set: function set(a) {\n        var b = this.dt;\n        b !== a && (a.pb() || C(\"initialViewportSpot must be a specific Spot: \" + a), this.dt = a, this.g(\"initialViewportSpot\", b, a));\n      }\n    },\n    initialDocumentSpot: {\n      get: function get() {\n        return this.at;\n      },\n      set: function set(a) {\n        var b = this.at;\n        b !== a && (a.pb() || C(\"initialViewportSpot must be a specific Spot: \" + a), this.at = a, this.g(\"initialDocumentSpot\", b, a));\n      }\n    },\n    minScale: {\n      get: function get() {\n        return this.tt;\n      },\n      set: function set(a) {\n        var b = this.tt;\n        b !== a && (0 < a ? (this.tt = a, this.g(\"minScale\", b, a), a > this.scale && (this.scale = a)) : wa(a, \"> 0\", Q, \"minScale\"));\n      }\n    },\n    maxScale: {\n      get: function get() {\n        return this.pt;\n      },\n      set: function set(a) {\n        var b = this.pt;\n        b !== a && (0 < a ? (this.pt = a, this.g(\"maxScale\", b, a), a < this.scale && (this.scale = a)) : wa(a, \"> 0\", Q, \"maxScale\"));\n      }\n    },\n    zoomPoint: {\n      get: function get() {\n        return this.eu;\n      },\n      set: function set(a) {\n        this.eu.C(a) || (this.eu = a = a.J());\n      }\n    },\n    contentAlignment: {\n      get: function get() {\n        return this.mk;\n      },\n      set: function set(a) {\n        var b = this.mk;\n        b.C(a) || (this.mk = a = a.J(), this.g(\"contentAlignment\", b, a), Ti(this, !1));\n      }\n    },\n    initialContentAlignment: {\n      get: function get() {\n        return this.Rp;\n      },\n      set: function set(a) {\n        var b = this.Rp;\n        b.C(a) || (this.Rp = a = a.J(), this.g(\"initialContentAlignment\", b, a));\n      }\n    },\n    padding: {\n      get: function get() {\n        return this.ub;\n      },\n      set: function set(a) {\n        \"number\" === typeof a && (a = new ec(a));\n        var b = this.ub;\n        b.C(a) || (this.ub = a = a.J(), this.Va(), this.g(\"padding\", b, a));\n      }\n    },\n    partManager: {\n      get: function get() {\n        return this.Ic;\n      },\n      set: function set(a) {\n        var b = this.Ic;\n        b !== a && (null !== a.diagram && C(\"Cannot share PartManagers between Diagrams: \" + a.toString()), b && b.Le(null), this.Ic = a, a.Le(this));\n      }\n    },\n    nodes: {\n      get: function get() {\n        return this.partManager.nodes.iterator;\n      }\n    },\n    links: {\n      get: function get() {\n        return this.partManager.links.iterator;\n      }\n    },\n    parts: {\n      get: function get() {\n        return this.partManager.parts.iterator;\n      }\n    },\n    layout: {\n      get: function get() {\n        return this.Kc;\n      },\n      set: function set(a) {\n        var b = this.Kc;\n        b !== a && (this.Kc = a, a.diagram = this, a.group = null, this.mh = !0, this.g(\"layout\", b, a), this.Mb());\n      }\n    },\n    isTreePathToChildren: {\n      get: function get() {\n        return this.kt;\n      },\n      set: function set(a) {\n        var b = this.kt;\n        if (b !== a && (this.kt = a, this.g(\"isTreePathToChildren\", b, a), !this.undoManager.isUndoingRedoing)) for (a = this.nodes; a.next();) {\n          Bk(a.value);\n        }\n      }\n    },\n    treeCollapsePolicy: {\n      get: function get() {\n        return this.$t;\n      },\n      set: function set(a) {\n        var b = this.$t;\n        b !== a && (a !== vi && a !== Ck && a !== Dk && C(\"Unknown Diagram.treeCollapsePolicy: \" + a), this.$t = a, this.g(\"treeCollapsePolicy\", b, a));\n      }\n    },\n    Ie: {\n      get: function get() {\n        return this.Vv;\n      },\n      set: function set(a) {\n        this.Vv = a;\n      }\n    },\n    avoidanceCellSize: {\n      get: function get() {\n        return this.Fv;\n      },\n      set: function set(a) {\n        this.Qh = null;\n        this.Fv = new K(Math.max(1, a.width), Math.max(1, a.height));\n      }\n    },\n    avoidanceLimit: {\n      get: function get() {\n        return this.Gv;\n      },\n      set: function set(a) {\n        this.Gv = Math.max(1, a);\n      }\n    },\n    autoScrollInterval: {\n      get: function get() {\n        return this.Yo;\n      },\n      set: function set(a) {\n        var b = this.Yo;\n        b !== a && (this.Yo = a, this.g(\"autoScrollInterval\", b, a));\n      }\n    },\n    autoScrollRegion: {\n      get: function get() {\n        return this.$o;\n      },\n      set: function set(a) {\n        \"number\" === typeof a && (a = new ec(a));\n        var b = this.$o;\n        b.C(a) || (this.$o = a = a.J(), this.Va(), this.g(\"autoScrollRegion\", b, a));\n      }\n    }\n  });\n  ma.Object.defineProperties(Q, {\n    licenseKey: {\n      get: function get() {\n        return Ek.fc();\n      },\n      set: function set(a) {\n        Ek.add(a.replace(/\\s/g, \"\"));\n      }\n    },\n    version: {\n      get: function get() {\n        return Fk;\n      }\n    }\n  });\n  Q.prototype.makeImageData = Q.prototype.ox;\n  Q.prototype.makeImage = Q.prototype.Dz;\n  Q.prototype.cacheGroupExternalLinks = Q.prototype.lu;\n  Q.prototype.addRenderer = Q.prototype.ny;\n  Q.prototype.makeSVG = Q.prototype.Nu;\n  Q.prototype.makeSvg = Q.prototype.bs;\n  Q.prototype.stopAutoScroll = Q.prototype.lg;\n  Q.prototype.doAutoScroll = Q.prototype.Fr;\n  Q.prototype.isUnoccupied = Q.prototype.Pj;\n  Q.prototype.raiseDiagramEvent = Q.prototype.P;\n  Q.prototype.removeDiagramListener = Q.prototype.Il;\n  Q.prototype.addDiagramListener = Q.prototype.wj;\n  Q.prototype.findTreeRoots = Q.prototype.fz;\n  Q.prototype.layoutDiagram = Q.prototype.Bz;\n  Q.prototype.findTopLevelGroups = Q.prototype.Zy;\n  Q.prototype.findTopLevelNodesAndLinks = Q.prototype.$y;\n  Q.prototype.ensureBounds = Q.prototype.Za;\n  Q.prototype.findLinksByExample = Q.prototype.Ir;\n  Q.prototype.findNodesByExample = Q.prototype.Jr;\n  Q.prototype.findLinkForData = Q.prototype.Dc;\n  Q.prototype.findNodeForData = Q.prototype.ci;\n  Q.prototype.findPartForData = Q.prototype.Ec;\n  Q.prototype.findLinkForKey = Q.prototype.findLinkForKey;\n  Q.prototype.findNodeForKey = Q.prototype.Lb;\n  Q.prototype.findPartForKey = Q.prototype.findPartForKey;\n  Q.prototype.rebuildParts = Q.prototype.Od;\n  Q.prototype.transformViewToDoc = Q.prototype.rs;\n  Q.prototype.transformRectDocToView = Q.prototype.gA;\n  Q.prototype.transformDocToView = Q.prototype.Ro;\n  Q.prototype.centerRect = Q.prototype.Dr;\n  Q.prototype.scrollToRect = Q.prototype.bv;\n  Q.prototype.scroll = Q.prototype.scroll;\n  Q.prototype.highlightCollection = Q.prototype.rz;\n  Q.prototype.highlight = Q.prototype.qz;\n  Q.prototype.selectCollection = Q.prototype.Yz;\n  Q.prototype.select = Q.prototype.select;\n  Q.prototype.updateAllRelationshipsFromData = Q.prototype.Uo;\n  Q.prototype.updateAllTargetBindings = Q.prototype.updateAllTargetBindings;\n  Q.prototype.commit = Q.prototype.commit;\n  Q.prototype.rollbackTransaction = Q.prototype.Bf;\n  Q.prototype.commitTransaction = Q.prototype.eb;\n  Q.prototype.startTransaction = Q.prototype.Da;\n  Q.prototype.raiseChanged = Q.prototype.g;\n  Q.prototype.raiseChangedEvent = Q.prototype.bb;\n  Q.prototype.removeChangedListener = Q.prototype.ak;\n  Q.prototype.addChangedListener = Q.prototype.Ug;\n  Q.prototype.removeModelChangedListener = Q.prototype.Tz;\n  Q.prototype.addModelChangedListener = Q.prototype.Cw;\n  Q.prototype.findLayer = Q.prototype.Ij;\n  Q.prototype.removeLayer = Q.prototype.Rz;\n  Q.prototype.addLayerAfter = Q.prototype.jy;\n  Q.prototype.addLayerBefore = Q.prototype.Aw;\n  Q.prototype.addLayer = Q.prototype.pl;\n  Q.prototype.moveParts = Q.prototype.moveParts;\n  Q.prototype.copyParts = Q.prototype.Ej;\n  Q.prototype.removeParts = Q.prototype.hs;\n  Q.prototype.remove = Q.prototype.remove;\n  Q.prototype.add = Q.prototype.add;\n  Q.prototype.clearDelayedGeometries = Q.prototype.mu;\n  Q.prototype.setProperties = Q.prototype.Vl;\n  Q.prototype.attach = Q.prototype.ku;\n  Q.prototype.set = Q.prototype.set;\n  Q.prototype.resetInputOptions = Q.prototype.zx;\n  Q.prototype.setInputOption = Q.prototype.Zz;\n  Q.prototype.getInputOption = Q.prototype.yl;\n  Q.prototype.resetRenderingHints = Q.prototype.Ax;\n  Q.prototype.setRenderingHint = Q.prototype.Fx;\n  Q.prototype.getRenderingHint = Q.prototype.Ge;\n  Q.prototype.maybeUpdate = Q.prototype.nd;\n  Q.prototype.requestUpdate = Q.prototype.Mb;\n  Q.prototype.delayInitialization = Q.prototype.Ey;\n  Q.prototype.isUpdateRequested = Q.prototype.xz;\n  Q.prototype.invalidateDocumentBounds = Q.prototype.Va;\n  Q.prototype.findObjectsNear = Q.prototype.hg;\n  Q.prototype.findPartsNear = Q.prototype.Vy;\n  Q.prototype.findObjectsIn = Q.prototype.tf;\n  Q.prototype.findPartsIn = Q.prototype.Ww;\n  Q.prototype.findObjectsAt = Q.prototype.di;\n  Q.prototype.findPartsAt = Q.prototype.Uy;\n  Q.prototype.findObjectAt = Q.prototype.ec;\n  Q.prototype.findPartAt = Q.prototype.wl;\n  Q.prototype.focusObject = Q.prototype.gz;\n  Q.prototype.alignDocument = Q.prototype.py;\n  Q.prototype.zoomToRect = Q.prototype.kA;\n  Q.prototype.zoomToFit = Q.prototype.zoomToFit;\n  Q.prototype.diagramScroll = Q.prototype.Nw;\n  Q.prototype.focus = Q.prototype.focus;\n  var li = new pb(),\n      Di = null,\n      Og = void 0 !== x.document,\n      yi = null,\n      zi = \"\",\n      rh = new D(Q, \"None\", 0),\n      Yi = new D(Q, \"Uniform\", 1),\n      Zi = new D(Q, \"UniformToFill\", 2),\n      Ef = new D(Q, \"CycleAll\", 10),\n      If = new D(Q, \"CycleNotDirected\", 11),\n      Kf = new D(Q, \"CycleNotDirectedFast\", 12),\n      Lf = new D(Q, \"CycleNotUndirected\", 13),\n      Ff = new D(Q, \"CycleDestinationTree\", 14),\n      Hf = new D(Q, \"CycleSourceTree\", 15),\n      Rh = new D(Q, \"DocumentScroll\", 1),\n      Th = new D(Q, \"InfiniteScroll\", 2),\n      vi = new D(Q, \"TreeParentCollapsed\", 21),\n      Ck = new D(Q, \"AllParentsCollapsed\", 22),\n      Dk = new D(Q, \"AnyParentsCollapsed\", 23),\n      Ek = new E(),\n      Fk = \"2.2.16\",\n      zk = \"image\",\n      Gk = null,\n      ji = !1;\n\n  function ki() {\n    if (Og) {\n      var a = x.document.createElement(\"canvas\"),\n          b = a.getContext(\"2d\"),\n          c = Ma(\"7ca11abfd022028846\");\n      b[c] = Ma(\"398c3597c01238\");\n\n      for (var d = [\"5da73c80a36455d6038e4972187c3cae51fd22\", ra.Dx + \"4ae6247590da4bb21c324ba3a84e385776\", md.xF + \"fb236cdfda5de14c134ba1a95a2d4c7cc6f93c1387\", J.za], e = 1; 5 > e; e++) {\n        b[Ma(\"7ca11abfd7330390\")](Ma(d[e - 1]), 10, 15 * e);\n      }\n\n      b[c] = Ma(\"39f046ebb36e4b\");\n\n      for (c = 1; 5 > c; c++) {\n        b[Ma(\"7ca11abfd7330390\")](Ma(d[c - 1]), 10, 15 * c);\n      }\n\n      if (4 !== d.length || \"5\" !== d[0][0] || \"7\" !== d[3][0]) md.prototype.Ld = md.prototype.Fw;\n      Gk = a;\n    }\n  }\n\n  Q.className = \"Diagram\";\n\n  Q.fromDiv = function (a) {\n    var b = a;\n    \"string\" === typeof a && (b = x.document.getElementById(a));\n    return b instanceof HTMLDivElement && b.H instanceof Q ? b.H : null;\n  };\n\n  Q.inherit = function (a, b) {\n    function c() {}\n\n    if (Object.getPrototypeOf(a).prototype) throw Error(\"Used go.Diagram.inherit defining already defined class \\n\" + a);\n    c.prototype = b.prototype;\n    a.prototype = new c();\n    a.prototype.constructor = a;\n  };\n\n  Q.useDOM = function (a) {\n    Og = a ? void 0 !== x.document : !1;\n  };\n\n  Q.isUsingDOM = function () {\n    return Og;\n  };\n\n  Q.None = rh;\n  Q.Uniform = Yi;\n  Q.UniformToFill = Zi;\n  Q.CycleAll = Ef;\n  Q.CycleNotDirected = If;\n  Q.CycleNotDirectedFast = Kf;\n  Q.CycleNotUndirected = Lf;\n  Q.CycleDestinationTree = Ff;\n  Q.CycleSourceTree = Hf;\n  Q.DocumentScroll = Rh;\n  Q.InfiniteScroll = Th;\n  Q.TreeParentCollapsed = vi;\n  Q.AllParentsCollapsed = Ck;\n  Q.AnyParentsCollapsed = Dk;\n\n  function ri() {\n    this.by = null;\n    this.j = \"zz@orderNum\";\n    \"63ad05bbe23a1786468a4c741b6d2\" === this._tk ? this.pd = this.j = !0 : this.pd = null;\n  }\n\n  function sj(a, b) {\n    b.Zb.setTransform(b.kc, 0, 0, b.kc, 0, 0);\n    b.Zb.Pc();\n    if (null === a.pd) a: {\n      b = \"f\";\n      var c = x[Ma(\"76a715b2f73f148a\")][Ma(\"72ba13b5\")];\n      a.pd = !0;\n\n      if (Og) {\n        var d = Q[Ma(\"76a115b6ed251eaf4692\")];\n        if (d) for (var e = Ek.iterator; e.next();) {\n          d = e.value;\n          d = Ma(d).split(Ma(\"39e9\"));\n          if (6 > d.length) break;\n          var f = Ma(d[1]).split(\".\");\n          if (\"7da71ca0\" !== d[4]) break;\n          var g = Ma(ra[Ma(\"6cae19\")]).split(\".\");\n\n          if (f[0] > g[0] || f[0] === g[0] && f[1] >= g[1]) {\n            var h = x[Ma(\"74a900bae4370f8b51\")][Ma(\"6fbb13a1c2311e8a57\")].toLowerCase();\n            g = h[Ma(\"73a612b6fb191d\")](Ma(\"3aad1ab6e022098b4dc4\"));\n            f = Ma(d[2]);\n            if (-1 < g && (h = h[Ma(\"73a612b6fb191d\")](f.toLowerCase() + \"/\"), a.pd = !(-1 < h && h < g), !a.pd)) break;\n            g = c[Ma(\"76ad18b4f73e\")];\n\n            for (h = c[Ma(\"73a612b6fb191d\")](Ma(\"35e7\")) + 2; h < g; h++) {\n              b += c[h];\n            }\n\n            g = b[Ma(\"73a612b6fb191d\")](f);\n            0 > g && f !== Ma(\"7da71ca0ad381e90\") && (g = b[Ma(\"73a612b6fb191d\")](Ma(\"76a715b2ef3e149757\")));\n            0 > g && (g = b[Ma(\"73a612b6fb191d\")](Ma(\"76a715b2ef3e149757\")));\n            0 > g && (g = c[Ma(\"73a612b6fb191d\")](Ma(\"7baa19a6f76c1988428554\")));\n            a.pd = !(0 <= g && g < b[Ma(\"73a612b6fb191d\")](Ma(\"35\")) || -1 === b[Ma(\"73a612b6fb191d\")](Ma(\"35\")));\n            if (!a.pd) break;\n            if (c[Ma(\"73a612b6fb191d\")](Ma(\"7fb002b6ed25128b4da25b2e\")) && c[Ma(\"73a612b6fb191d\")](Ma(\"75ba1beee63a1e875799507d\")) && (a.pd = !(-1 < c[Ma(\"73a612b6fb191d\")](f)), !a.pd)) break;\n\n            if (\"#\" === f[0]) {\n              g = x.document.createElement(\"div\");\n\n              for (var k = d[0].replace(/[A-Za-z]/g, \"\"); 4 > k.length;) {\n                k += \"9\";\n              }\n\n              h = k;\n              k = k.substr(k.length - 4);\n              d = \"\";\n              d += [\"gsh\", \"gsf\"][parseInt(k.substr(0, 1), 10) % 2];\n              d += [\"Header\", \"Background\", \"Display\", \"Feedback\"][parseInt(k.substr(0, 1), 10) % 4];\n              g[Ma(\"79a417a0f0181a8946\")] = d;\n\n              if (x.document[Ma(\"78a712aa\")]) {\n                x.document[Ma(\"78a712aa\")][Ma(\"7bb806b6ed32388c4a875b\")](g);\n                k = x.getComputedStyle(g).getPropertyValue(Ma(\"78a704b7e62456904c9b12701b6532a8\"));\n                var l = x.getComputedStyle(g).getPropertyValue(Ma(\"75b817b0ea2202\"));\n                x.document[Ma(\"78a712aa\")][Ma(\"68ad1bbcf533388c4a875b\")](g);\n                if (k) if (g = x[Ma(\"77a902b0eb1b1e804a8a\")], l === \"0.\" + parseInt(h, 10) % 100 || -1 !== k.indexOf(parseInt(f[1] + f[2], 16)) && -1 !== k.indexOf(parseInt(f[3] + f[4], 16))) {\n                  a.pd = !1;\n                  break;\n                } else if (g && g(Ma(\"32ae19a1e0331fc94084537c067a67fa59f1386b89d006\")).matches) for (d = \".\" + d, f = 0; f < document.styleSheets.length; f++) {\n                  g = document.styleSheets[f].rules || document.styleSheets[f].cssRules;\n\n                  for (var m in g) {\n                    if (d === g[m].selectorText) {\n                      a.pd = !1;\n                      break a;\n                    }\n                  }\n                }\n              } else a.pd = null, a.pd = !1;\n            }\n          }\n        } else {\n          m = c[Ma(\"76ad18b4f73e\")];\n\n          for (e = c[Ma(\"73a612b6fb191d\")](Ma(\"35e7\")) + 2; e < m; e++) {\n            b += c[e];\n          }\n\n          c = b[Ma(\"73a612b6fb191d\")](Ma(\"7da71ca0ad381e90\"));\n          a.pd = !(0 <= c && c < b[Ma(\"73a612b6fb191d\")](Ma(\"35\")));\n        }\n      }\n    }\n    return 0 < a.pd && a !== a.by ? !0 : !1;\n  }\n\n  function si(a, b) {\n    if (Og) {\n      void 0 !== b && null !== b || C(\"Diagram setup requires an argument DIV.\");\n      null !== a.La && C(\"Diagram has already completed setup.\");\n      \"string\" === typeof b ? a.La = x.document.getElementById(b) : b instanceof HTMLDivElement ? a.La = b : C(\"No DIV or DIV id supplied: \" + b);\n      null === a.La && C(\"Invalid DIV id; could not get element with id: \" + b);\n      void 0 !== a.La.H && C(\"Invalid div id; div already has a Diagram associated with it.\");\n\n      if (!a.cl && x.ResizeObserver) {\n        var c = sa(function () {\n          a.Mb();\n        }, 250);\n        a.cl = new x.ResizeObserver(function () {\n          c();\n        });\n        a.cl.observe(a.La);\n      }\n\n      \"static\" === x.getComputedStyle(a.La, null).position && (a.La.style.position = \"relative\");\n      b = 5;\n      var d = \"rgba(2\" + b + \"5, 255, 255, 0)\";\n      b--;\n      a.La.style[\"-webkit-tap-highlight-color\"] = d;\n      a.La.innerHTML = \"\";\n      a.La.H = a;\n      a.La.goDiagram = a;\n      a.La.go = x.go;\n      var e = a.kr ? new xj(a) : new Ak(a);\n      void 0 !== e.style && (e.style.position = \"absolute\", e.style.top = \"0px\", e.style.left = \"0px\", \"rtl\" === x.getComputedStyle(a.La, null).getPropertyValue(\"direction\") && (a.$m = !0), e.style.zIndex = \"2\", e.style.userSelect = \"none\", e.style.MozUserSelect = \"none\", e.style.touchAction = \"none\");\n      a.Ha = e;\n      a.Zb = e.context;\n      d = a.Zb;\n      a.kc = a.computePixelRatio();\n      a.viewSize.v() || (a.Ba = a.La.clientWidth || 1, a.Aa = a.La.clientHeight || 1);\n      zj(a, a.Ba, a.Aa);\n      a.La.insertBefore(e.Sa, a.La.firstChild);\n      e = new Ak(null);\n      e.width = 1;\n      e.height = 1;\n      a.Ov = e;\n      a.Ux = e.context;\n\n      if (Og) {\n        e = ua(\"div\");\n        var f = ua(\"div\");\n        e.style.position = \"absolute\";\n        e.style.overflow = \"auto\";\n        e.style.width = a.Ba + \"px\";\n        e.style.height = a.Aa + \"px\";\n        e.style.zIndex = \"1\";\n        f.style.position = \"absolute\";\n        f.style.width = \"1px\";\n        f.style.height = \"1px\";\n        a.La.appendChild(e);\n        e.appendChild(f);\n        e.onscroll = Gi;\n        e.addEventListener(\"pointerdown\", Qi);\n        e.H = a;\n        e.$x = !0;\n        e.ay = !0;\n        a.Qt = e;\n        a.Nt = f;\n      }\n\n      a.Jo = sa(function () {\n        a.Rh = null;\n        a.N();\n      }, 300);\n      a.sv = sa(function () {\n        sh(a);\n      }, 250);\n\n      a.preventDefault = function (a) {\n        a.preventDefault();\n        return !1;\n      };\n\n      a.Sj = function (b) {\n        if (a.isEnabled) {\n          var c = cj(a, b, !0);\n          c.bubbles = !0;\n          var d = 0,\n              e = 0;\n          c.delta = 0;\n          void 0 !== b.deltaX ? (0 !== b.deltaX && (d = 0 < b.deltaX ? 1 : -1), 0 !== b.deltaY && (e = 0 < b.deltaY ? 1 : -1), c.delta = Math.abs(b.deltaX) > Math.abs(b.deltaY) ? -d : -e) : void 0 !== b.wheelDeltaX ? (0 !== b.wheelDeltaX && (d = 0 < b.wheelDeltaX ? -1 : 1), 0 !== b.wheelDeltaY && (e = 0 < b.wheelDeltaY ? -1 : 1), c.delta = Math.abs(b.wheelDeltaX) > Math.abs(b.wheelDeltaY) ? -d : -e) : void 0 !== b.wheelDelta && 0 !== b.wheelDelta && (c.delta = 0 < b.wheelDelta ? 1 : -1);\n          a.doMouseWheel();\n          gj(c, b);\n        }\n      };\n\n      a.Iz = function (b) {\n        a.isEnabled && (a.Kk = !1, cj(a, b, !0), b = a.currentTool, b.cancelWaitAfter(), b.standardMouseOver());\n      };\n\n      a.Wj = function (b) {\n        if (a.isEnabled) {\n          a.Kk = !0;\n          var c = a.Dt;\n          void 0 === c[b.pointerId] && (c[b.pointerId] = b);\n          c = a.$k;\n          var d = !1;\n          if (null !== c[0] && c[0].pointerId === b.pointerId) c[0] = b;else if (null !== c[1] && c[1].pointerId === b.pointerId) c[1] = b, d = !0;else if (null === c[0]) c[0] = b;else if (null === c[1]) c[1] = b, d = !0;else {\n            b.preventDefault();\n            return;\n          }\n          if (c = \"touch\" === b.pointerType || \"pen\" === b.pointerType) a.Wt = !1, a.jt = !0;\n          var e = d;\n          d = fj(a, b, !0, !1, !0, e);\n          dj(a, b, d);\n          d.targetDiagram = ej(b, b.target);\n          d.targetObject = null;\n          e || d.clone(a.Fp);\n          e = a.$v;\n          c = c ? 25 : 10;\n          b.timeStamp - a.Zv < a.hy && !(Math.abs(e.x - b.screenX) > c || Math.abs(e.y - b.screenY) > c) ? a.Yp++ : a.Yp = 1;\n          d.clickCount = a.Yp;\n          a.Zv = b.timeStamp;\n          a.$v.kg(b.screenX, b.screenY);\n          a.doMouseDown();\n          1 === b.button ? b.preventDefault() : gj(d, b);\n        }\n      };\n\n      a.Xj = function (b) {\n        if (a.isEnabled) {\n          a.Kk = !0;\n          var c = a.$k;\n          if (null !== c[0] && c[0].pointerId === b.pointerId) c[0] = b;else {\n            if (null !== c[1] && c[1].pointerId === b.pointerId) {\n              c[1] = b;\n              return;\n            }\n\n            if (null === c[0]) c[0] = b;else return;\n          }\n\n          if (c[0].pointerId === b.pointerId) {\n            c = fj(a, b, !1, !1, !1, null !== c[1]);\n            var d = x.document.elementFromPoint(b.clientX, b.clientY);\n            null !== d && void 0 !== d.shadowRoot && null !== d.shadowRoot && (d = d.shadowRoot.elementFromPoint(b.clientX, b.clientY));\n            var e = a,\n                f = b;\n            d && d.H && (f = b, e = d.H);\n            c.targetDiagram = e;\n            dj(a, f, c);\n            c.targetObject = null;\n            a.doMouseMove();\n            gj(c, b);\n          }\n        }\n      };\n\n      a.Zj = function (b) {\n        if (a.isEnabled) {\n          a.Kk = !0;\n          var c = \"touch\" === b.pointerType || \"pen\" === b.pointerType,\n              d = a.Dt;\n          if (c && a.Wt) delete d[b.pointerId], b.preventDefault();else if (d = a.$k, null !== d[0] && d[0].pointerId === b.pointerId) {\n            d[0] = null;\n            d = fj(a, b, !1, !0, !0, !1);\n            var e = x.document.elementFromPoint(b.clientX, b.clientY);\n            null !== e && void 0 !== e.shadowRoot && null !== e.shadowRoot && (e = e.shadowRoot.elementFromPoint(b.clientX, b.clientY));\n            null !== e && e.H instanceof Q && e.H !== a && dj(e.H, b, d);\n            null === e && (e = b.target);\n            dj(a, b, d);\n            d.clickCount = a.Yp;\n            d.targetDiagram = ej(b, e);\n            d.targetObject = null;\n            a.doMouseUp();\n            gj(d, b);\n            c && (a.jt = !1);\n          } else null !== d[1] && d[1].pointerId === b.pointerId && (d[1] = null);\n        }\n      };\n\n      a.Yj = function (b) {\n        if (a.isEnabled) {\n          a.Kk = !1;\n          var c = a.Dt;\n          c[b.pointerId] && delete c[b.pointerId];\n          c = a.$k;\n          null !== c[0] && c[0].pointerId === b.pointerId && (c[0] = null);\n          null !== c[1] && c[1].pointerId === b.pointerId && (c[1] = null);\n          \"touch\" !== b.pointerType && \"pen\" !== b.pointerType && (b = a.currentTool, b.cancelWaitAfter(), b.standardMouseOver());\n        }\n      };\n\n      a.Qs = d.Z[\"d\" + Hk[1] + Hk[2] + \"wI\" + zk.slice(1, 5)][\"b\" + Ik.slice(1, b)](d.Z, Gk, b, b);\n      d.Oc(!0);\n      Ei(a);\n    }\n  }\n\n  ri.className = \"DiagramHelper\";\n\n  function Te(a) {\n    this.j = void 0 === a ? new I() : a;\n    this.m = new I();\n  }\n\n  ma.Object.defineProperties(Te.prototype, {\n    point: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        this.j = a;\n      }\n    },\n    shifted: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        this.m = a;\n      }\n    }\n  });\n  var Hk = \"DraggingInfo\";\n  Te.className = \"DraggingInfo\";\n\n  function Kj(a, b, c) {\n    this.node = a;\n    this.info = b;\n    this.Eu = c;\n  }\n\n  Kj.className = \"DraggingNodeInfoPair\";\n\n  function Ce() {\n    this.reset();\n  }\n\n  Ce.prototype.reset = function () {\n    this.isGridSnapEnabled = !1;\n    this.isGridSnapRealtime = !0;\n    this.gridSnapCellSize = new K(NaN, NaN).freeze();\n    this.gridSnapCellSpot = tc;\n    this.gridSnapOrigin = new I(NaN, NaN).freeze();\n    this.groupsSnapMembers = this.dragsTree = this.dragsLink = !1;\n    this.dragsMembers = this.groupsAlwaysMove = !0;\n  };\n\n  Ce.className = \"DraggingOptions\";\n\n  function Jk(a, b) {\n    if (\"string\" === typeof a || x.Element && a instanceof Element) var c = Q.call(this, a) || this;else c = Q.call(this) || this, b = a;\n    Kk(c);\n    b && c.Vl(b);\n    return c;\n  }\n\n  la(Jk, Q);\n\n  function Kk(a) {\n    a.allowDragOut = !0;\n    a.allowMove = !1;\n    a.isReadOnly = !0;\n    a.contentAlignment = uc;\n    a.layout = new Lk();\n  }\n\n  Jk.prototype.reset = function () {\n    Q.prototype.reset.call(this);\n    Kk(this);\n  };\n\n  Jk.className = \"Palette\";\n\n  function Mk(a, b) {\n    if (\"string\" === typeof a || x.Element && a instanceof Element) var c = Q.call(this, a) || this;else c = Q.call(this) || this, b = a;\n    var d = c;\n    c.animationManager.isEnabled = !1;\n    c.wb = !0;\n    c.W = null;\n    c.Tm = !1;\n    c.Um = !1;\n    c.F = !0;\n    c.u = !0;\n    c.ga = 0;\n    c.m = !1;\n    c.fl = null;\n    c.Fx(\"drawShadows\", !1);\n    a = new U();\n    var e = new Cf();\n    e.stroke = \"magenta\";\n    e.strokeWidth = 2;\n    e.fill = \"transparent\";\n    e.name = \"BOXSHAPE\";\n    a.selectable = !0;\n    a.selectionAdorned = !1;\n    a.selectionObjectName = \"BOXSHAPE\";\n    a.locationObjectName = \"BOXSHAPE\";\n    a.resizeObjectName = \"BOXSHAPE\";\n    a.cursor = \"move\";\n    a.add(e);\n    c.j = a;\n    c.allowCopy = !1;\n    c.allowDelete = !1;\n    c.allowSelect = !0;\n    c.autoScrollRegion = new ec(0, 0, 0, 0);\n    c.pa.h(0, 0);\n    c.toolManager.gb(\"Dragging\", new Nk(), c.toolManager.mouseMoveTools);\n\n    c.click = function () {\n      var a = d.observed;\n\n      if (null !== a) {\n        var b = a.viewportBounds,\n            c = d.lastInput.documentPoint;\n        a.position = new I(c.x - b.width / 2, c.y - b.height / 2);\n      }\n    };\n\n    c.Gf = function () {\n      d.Va();\n      Ok(d);\n    };\n\n    c.Qd = function () {\n      null !== d.observed && (d.Va(), d.N());\n    };\n\n    c.Ga = function () {\n      1 > d.updateDelay ? d.N() : d.m || (d.m = !0, setTimeout(function () {\n        return d.redraw();\n      }, d.updateDelay));\n    };\n\n    c.Ff = function () {\n      null !== d.observed && Ok(d);\n    };\n\n    c.autoScale = Yi;\n    c.wb = !1;\n    b && Object.assign(c, b);\n    return c;\n  }\n\n  la(Mk, Q);\n\n  Mk.prototype.computePixelRatio = function () {\n    return 1;\n  };\n\n  Mk.prototype.redraw = function () {\n    if (this.m && 1 <= this.updateDelay) {\n      this.m = !1;\n      var a = this.Ha,\n          b = this.Zb;\n\n      if (null !== a && null !== b) {\n        qj(this);\n\n        if (null === this.fl) {\n          var c = new Ak(null);\n          c.width = a.width;\n          c.height = a.height;\n          this.fl = c;\n        }\n\n        try {\n          this.Ha = this.fl, this.Zb = this.Ha.context, this.Zb.Oc(!0), this.Zb.setTransform(1, 0, 0, 1, 0, 0), this.Zb.clearRect(0, 0, this.Ha.width, this.Ha.height), Pk(this);\n        } finally {\n          this.Ha = a, this.Zb = b;\n        }\n      }\n    }\n\n    Q.prototype.redraw.call(this);\n  };\n\n  Mk.prototype.tc = function () {\n    null === this.La && C(\"No div specified\");\n    null === this.Ha && C(\"No canvas specified\");\n\n    if (!(this.Ha instanceof xj) && (ei(this.box), this.bd)) {\n      var a = this.observed;\n\n      if (null !== a && !a.animationManager.defaultAnimation.isAnimating && a.ji) {\n        qj(this);\n        var b = this.Ha;\n        a = this.Zb;\n        a.Oc(!0);\n        a.setTransform(1, 0, 0, 1, 0, 0);\n        a.clearRect(0, 0, b.width, b.height);\n        1 > this.updateDelay ? Pk(this) : null !== this.fl && (a.drawImage(this.fl.Sa, 0, 0), b = this.Bb, b.reset(), 1 !== this.scale && b.scale(this.scale), 0 === this.position.x && 0 === this.position.y || b.translate(-this.position.x, -this.position.y), a.scale(this.kc, this.kc), a.transform(b.m11, b.m12, b.m21, b.m22, b.dx, b.dy));\n        b = this.Ua.s;\n\n        for (var c = b.length, d = 0; d < c; d++) {\n          b[d].tc(a, this);\n        }\n\n        this.bd = this.Ui = !1;\n      }\n    }\n  };\n\n  function Pk(a) {\n    var b = a.observed;\n\n    if (null !== b) {\n      var c = a.drawsTemporaryLayers,\n          d = a.drawsGrid && c,\n          e = b.grid;\n      d && null !== e && e.visible && !isNaN(e.width) && !isNaN(e.height) && (e = M.alloc().assign(a.viewportBounds).Xc(b.viewportBounds), jj(b, e), M.free(e), mh(b));\n      var f = a.Bb;\n      f.reset();\n      1 !== a.scale && f.scale(a.scale);\n      0 === a.position.x && 0 === a.position.y || f.translate(-a.position.x, -a.position.y);\n      e = a.Zb;\n      e.scale(a.kc, a.kc);\n      e.transform(f.m11, f.m12, f.m21, f.m22, f.dx, f.dy);\n      b = b.Ua.s;\n      f = b.length;\n\n      for (var g = 0; g < f; g++) {\n        var h = b[g],\n            k = a;\n\n        if (h.visible && 0 !== h.opacity) {\n          var l = h.diagram.grid.part;\n          if (!c && h.isTemporary) d && l.layer === h && (h = fi(h, e), l.tc(e, k), e.globalAlpha = h);else {\n            for (var m = fi(h, e), n = k.scale, p = M.alloc(), r = h.Ma.s, q = r.length, u = 0; u < q; u++) {\n              var w = r[u];\n              (d || w !== l) && h.$h(e, w, k, null, n, p, !1);\n            }\n\n            M.free(p);\n            e.globalAlpha = m;\n          }\n        }\n      }\n    }\n  }\n\n  function Ok(a) {\n    var b = a.box;\n\n    if (null !== b) {\n      var c = a.observed;\n\n      if (null !== c) {\n        a.bd = !0;\n        c = c.viewportBounds;\n        var d = b.selectionObject,\n            e = K.alloc();\n        e.h(c.width, c.height);\n        d.desiredSize = e;\n        K.free(e);\n        a = 2 / a.scale;\n        d instanceof Cf && (d.strokeWidth = a);\n        b.location = new I(c.x - a / 2, c.y - a / 2);\n        b.isSelected = !0;\n      }\n    }\n  }\n\n  Mk.prototype.computeBounds = function () {\n    var a = this.observed;\n    if (null === a) return cc;\n    var b = a.documentBounds.copy();\n    b.Xc(a.viewportBounds);\n    return b;\n  };\n\n  Mk.prototype.invalidateViewport = function () {\n    !0 !== this.bd && (this.bd = !0, this.Mb());\n  };\n\n  Mk.prototype.onViewportBoundsChanged = function (a, b, c, d) {\n    this.wb || (Ri(this), this.N(), Wi(this), this.Va(), Ok(this), this.kd.scale = c, this.kd.position.x = a.x, this.kd.position.y = a.y, this.kd.bounds.assign(a), this.kd.lx = d, this.P(\"ViewportBoundsChanged\", this.kd, a));\n  };\n\n  ma.Object.defineProperties(Mk.prototype, {\n    observed: {\n      get: function get() {\n        return this.W;\n      },\n      set: function set(a) {\n        var b = this.W;\n        a instanceof Mk && C(\"Overview.observed Diagram may not be an Overview itself: \" + a);\n\n        if (b !== a) {\n          null !== b && (this.remove(this.box), b.Il(\"ViewportBoundsChanged\", this.Gf), b.Il(\"DocumentBoundsChanged\", this.Qd), b.Il(\"InvalidateDraw\", this.Ga), b.Il(\"AnimationFinished\", this.Ff));\n          this.W = a;\n          null !== a && (a.wj(\"ViewportBoundsChanged\", this.Gf), a.wj(\"DocumentBoundsChanged\", this.Qd), a.wj(\"InvalidateDraw\", this.Ga), a.wj(\"AnimationFinished\", this.Ff), this.add(this.box));\n          this.Va();\n\n          if (null === a) {\n            this.fl = null;\n            var c = this.Ha,\n                d = this.Zb;\n            c && d && (d.setTransform(1, 0, 0, 1, 0, 0), d.clearRect(0, 0, c.width, c.height));\n          } else this.Ga(null), Ok(this), this.N();\n\n          this.g(\"observed\", b, a);\n        }\n      }\n    },\n    box: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        var b = this.j;\n        b !== a && (this.j = a, this.remove(b), this.add(this.j), Ok(this), this.g(\"box\", b, a));\n      }\n    },\n    drawsTemporaryLayers: {\n      get: function get() {\n        return this.F;\n      },\n      set: function set(a) {\n        this.F !== a && (this.F = a, this.redraw());\n      }\n    },\n    drawsGrid: {\n      get: function get() {\n        return this.u;\n      },\n      set: function set(a) {\n        this.u !== a && (this.u = a, this.redraw());\n      }\n    },\n    updateDelay: {\n      get: function get() {\n        return this.ga;\n      },\n      set: function set(a) {\n        0 > a && (a = 0);\n        this.ga !== a && (this.ga = a);\n      }\n    }\n  });\n  Mk.className = \"Overview\";\n\n  function Nk() {\n    Be.call(this);\n    this.j = null;\n  }\n\n  la(Nk, Be);\n\n  Nk.prototype.canStart = function () {\n    if (!this.isEnabled) return !1;\n    var a = this.diagram;\n    if (null === a || !a.allowMove || !a.allowSelect) return !1;\n    var b = a.observed;\n    if (null === b) return !1;\n    var c = a.lastInput;\n    if (!c.left || a.currentTool !== this && (!this.isBeyondDragSize() || c.isTouchEvent && c.timestamp - a.firstInput.timestamp < this.delay)) return !1;\n    null === this.findDraggablePart() && (c = b.viewportBounds, this.j = new I(c.width / 2, c.height / 2), a = a.firstInput.documentPoint, b.position = new I(a.x - this.j.x, a.y - this.j.y));\n    return !0;\n  };\n\n  Nk.prototype.doActivate = function () {\n    this.j = null;\n    Be.prototype.doActivate.call(this);\n  };\n\n  Nk.prototype.doUpdateCursor = function () {\n    var a = this.diagram,\n        b = a.box;\n    null !== b && b.cursor && (a.currentCursor = b.cursor);\n  };\n\n  Nk.prototype.moveParts = function () {\n    var a = this.diagram,\n        b = a.observed;\n\n    if (null !== b) {\n      var c = a.box;\n\n      if (null !== c) {\n        if (null === this.j) {\n          var d = a.firstInput.documentPoint;\n          c = c.location;\n          this.j = new I(d.x - c.x, d.y - c.y);\n        }\n\n        a = a.lastInput.documentPoint;\n        b.position = new I(a.x - this.j.x, a.y - this.j.y);\n      }\n    }\n  };\n\n  Nk.className = \"OverviewDraggingTool\";\n\n  function Qk() {\n    Ra(this);\n    this.H = le;\n    this.Ga = this.u = this.m = !0;\n    this.F = this.W = this.hb = this.ga = !1;\n    this.dj = this.j = null;\n    this.Db = 1.05;\n    this.mt = NaN;\n    this.Yv = null;\n    this.fu = NaN;\n    this.du = cc;\n    this.cb = !0;\n    this.Vf = null;\n    this.nb = 200;\n  }\n\n  Qk.prototype.toString = function () {\n    return \"CommandHandler\";\n  };\n\n  Qk.prototype.Le = function (a) {\n    this.H = a;\n  };\n\n  Qk.prototype.doKeyDown = function () {\n    var a = this.diagram,\n        b = a.lastInput,\n        c = Qa ? b.meta : b.control,\n        d = b.shift,\n        e = b.alt,\n        f = b.key;\n    !c || \"C\" !== f && \"Insert\" !== f ? c && \"X\" === f || d && \"Del\" === f ? this.canCutSelection() && this.cutSelection() : c && \"V\" === f || d && \"Insert\" === f ? this.canPasteSelection() && this.pasteSelection() : c && \"Y\" === f || e && d && \"Backspace\" === f ? this.canRedo() && this.redo() : c && \"Z\" === f || e && \"Backspace\" === f ? this.canUndo() && this.undo() : \"Del\" === f || \"Backspace\" === f ? this.canDeleteSelection() && this.deleteSelection() : c && \"A\" === f ? this.canSelectAll() && this.selectAll() : \"Esc\" === f ? this.canStopCommand() && this.stopCommand() : \"Up\" === f ? a.allowVerticalScroll && (c ? a.scroll(\"pixel\", \"up\") : a.scroll(\"line\", \"up\")) : \"Down\" === f ? a.allowVerticalScroll && (c ? a.scroll(\"pixel\", \"down\") : a.scroll(\"line\", \"down\")) : \"Left\" === f ? a.allowHorizontalScroll && (c ? a.scroll(\"pixel\", \"left\") : a.scroll(\"line\", \"left\")) : \"Right\" === f ? a.allowHorizontalScroll && (c ? a.scroll(\"pixel\", \"right\") : a.scroll(\"line\", \"right\")) : \"PageUp\" === f ? d && a.allowHorizontalScroll ? a.scroll(\"page\", \"left\") : a.allowVerticalScroll && a.scroll(\"page\", \"up\") : \"PageDown\" === f ? d && a.allowHorizontalScroll ? a.scroll(\"page\", \"right\") : a.allowVerticalScroll && a.scroll(\"page\", \"down\") : \"Home\" === f ? c && a.allowVerticalScroll ? a.scroll(\"document\", \"up\") : !c && a.allowHorizontalScroll && a.scroll(\"document\", \"left\") : \"End\" === f ? c && a.allowVerticalScroll ? a.scroll(\"document\", \"down\") : !c && a.allowHorizontalScroll && a.scroll(\"document\", \"right\") : \" \" === f ? this.canScrollToPart() && this.scrollToPart() : \"Subtract\" === f ? this.canDecreaseZoom() && this.decreaseZoom() : \"Add\" === f ? this.canIncreaseZoom() && this.increaseZoom() : c && \"0\" === f ? this.canResetZoom() && this.resetZoom() : d && \"Z\" === f ? this.canZoomToFit() && this.zoomToFit() : c && !d && \"G\" === f ? this.canGroupSelection() && this.groupSelection() : c && d && \"G\" === f ? this.canUngroupSelection() && this.ungroupSelection() : \"F2\" === f || b.event && \"F2\" === b.event.key ? this.canEditTextBlock() && this.editTextBlock() : \"ContextMenu\" === f || b.event && \"ContextMenu\" === b.event.key ? this.canShowContextMenu() && this.showContextMenu() : b.bubbles = !0 : this.canCopySelection() && this.copySelection();\n  };\n\n  Qk.prototype.doKeyUp = function () {\n    this.diagram.lastInput.bubbles = !0;\n  };\n\n  Qk.prototype.stopCommand = function () {\n    var a = this.diagram,\n        b = a.currentTool;\n    b instanceof La && a.allowSelect && a.clearSelection();\n    null !== b && b.doCancel();\n  };\n\n  Qk.prototype.canStopCommand = function () {\n    return !0;\n  };\n\n  Qk.prototype.selectAll = function () {\n    var a = this.diagram;\n    a.N();\n\n    try {\n      a.currentCursor = \"wait\";\n      a.P(\"ChangingSelection\", a.selection);\n\n      for (var b = a.parts; b.next();) {\n        b.value.isSelected = !0;\n      }\n\n      for (var c = a.nodes; c.next();) {\n        c.value.isSelected = !0;\n      }\n\n      for (var d = a.links; d.next();) {\n        d.value.isSelected = !0;\n      }\n    } finally {\n      a.P(\"ChangedSelection\", a.selection), a.currentCursor = \"\";\n    }\n  };\n\n  Qk.prototype.canSelectAll = function () {\n    return this.diagram.allowSelect;\n  };\n\n  Qk.prototype.deleteSelection = function () {\n    var a = this.diagram;\n\n    try {\n      a.currentCursor = \"wait\";\n      a.P(\"ChangingSelection\", a.selection);\n      a.Da(\"Delete\");\n      a.P(\"SelectionDeleting\", a.selection);\n\n      for (var b = new G(), c = a.selection.iterator; c.next();) {\n        Rk(b, c.value, !0, this.deletesTree ? Infinity : 0, this.deletesConnectedLinks ? null : !1, function (a) {\n          return a.canDelete();\n        });\n      }\n\n      a.hs(b, !0);\n      a.P(\"SelectionDeleted\", b);\n    } finally {\n      a.eb(\"Delete\"), a.P(\"ChangedSelection\", a.selection), a.currentCursor = \"\";\n    }\n  };\n\n  Qk.prototype.canDeleteSelection = function () {\n    var a = this.diagram;\n    return a.isReadOnly || a.isModelReadOnly || !a.allowDelete || 0 === a.selection.count ? !1 : !0;\n  };\n\n  Qk.prototype.copySelection = function () {\n    var a = this.diagram,\n        b = new G();\n\n    for (a = a.selection.iterator; a.next();) {\n      Rk(b, a.value, !0, this.copiesTree ? Infinity : 0, this.copiesConnectedLinks, function (a) {\n        return a.canCopy();\n      });\n    }\n\n    this.copyToClipboard(b);\n  };\n\n  Qk.prototype.canCopySelection = function () {\n    var a = this.diagram;\n    return a.allowCopy && a.allowClipboard && 0 !== a.selection.count ? !0 : !1;\n  };\n\n  Qk.prototype.cutSelection = function () {\n    this.copySelection();\n    this.deleteSelection();\n  };\n\n  Qk.prototype.canCutSelection = function () {\n    var a = this.diagram;\n    return !a.isReadOnly && !a.isModelReadOnly && a.allowCopy && a.allowDelete && a.allowClipboard && 0 !== a.selection.count ? !0 : !1;\n  };\n\n  Qk.prototype.copyToClipboard = function (a) {\n    var b = this.diagram,\n        c = null;\n    if (null === a) yi = null, zi = \"\";else {\n      c = b.model;\n      var d = !1,\n          e = !1,\n          f = null;\n\n      try {\n        c.Bl() && (d = c.Dj, c.Dj = this.copiesParentKey), c.Nj() && (e = c.Cj, c.Cj = this.copiesGroupKey), f = b.Ej(a, null, !0);\n      } finally {\n        c.Bl() && (c.Dj = d), c.Nj() && (c.Cj = e), c = new E(), c.addAll(f), yi = c, zi = b.model.dataFormat;\n      }\n    }\n    b.P(\"ClipboardChanged\", c);\n  };\n\n  Qk.prototype.pasteFromClipboard = function () {\n    var a = new G(),\n        b = yi;\n    if (null === b) return a;\n    var c = this.diagram;\n    if (zi !== c.model.dataFormat) return a;\n    var d = c.model,\n        e = !1,\n        f = !1,\n        g = null;\n\n    try {\n      d.Bl() && (e = d.Dj, d.Dj = this.copiesParentKey), d.Nj() && (f = d.Cj, d.Cj = this.copiesGroupKey), g = c.Ej(b, c, !1);\n    } finally {\n      for (d.Bl() && (d.Dj = e), d.Nj() && (d.Cj = f), b = g.iterator; b.next();) {\n        c = b.value, d = b.key, c.location.v() || (d.location.v() ? c.location = d.location : !c.position.v() && d.position.v() && (c.position = d.position)), a.add(c);\n      }\n    }\n\n    return a;\n  };\n\n  Qk.prototype.pasteSelection = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n\n    try {\n      b.currentCursor = \"wait\";\n      b.P(\"ChangingSelection\", b.selection);\n      b.Da(\"Paste\");\n      var c = this.pasteFromClipboard();\n      0 < c.count && b.clearSelection(!0);\n\n      for (var d = c.iterator; d.next();) {\n        d.value.isSelected = !0;\n      }\n\n      if (null !== a) {\n        var e = b.computePartsBounds(b.selection);\n\n        if (e.v()) {\n          var f = this.computeEffectiveCollection(b.selection, b.Em);\n          ef(b, f, new I(a.x - e.centerX, a.y - e.centerY), b.Em, !1);\n        }\n      }\n\n      b.P(\"ClipboardPasted\", c);\n    } finally {\n      b.eb(\"Paste\"), b.P(\"ChangedSelection\", b.selection), b.currentCursor = \"\";\n    }\n  };\n\n  Qk.prototype.canPasteSelection = function () {\n    var a = this.diagram;\n    return a.isReadOnly || a.isModelReadOnly || !a.allowInsert || !a.allowClipboard || null === yi || 0 === yi.count || zi !== a.model.dataFormat ? !1 : !0;\n  };\n\n  Qk.prototype.undo = function () {\n    this.diagram.undoManager.undo();\n  };\n\n  Qk.prototype.canUndo = function () {\n    var a = this.diagram;\n    return a.isReadOnly || a.isModelReadOnly ? !1 : a.allowUndo && a.undoManager.canUndo();\n  };\n\n  Qk.prototype.redo = function () {\n    this.diagram.undoManager.redo();\n  };\n\n  Qk.prototype.canRedo = function () {\n    var a = this.diagram;\n    return a.isReadOnly || a.isModelReadOnly ? !1 : a.allowUndo && a.undoManager.canRedo();\n  };\n\n  Qk.prototype.decreaseZoom = function (a) {\n    void 0 === a && (a = 1 / this.zoomFactor);\n    var b = this.diagram;\n    b.autoScale === rh && (a = b.scale * a, a < b.minScale || a > b.maxScale || (b.scale = a));\n  };\n\n  Qk.prototype.canDecreaseZoom = function (a) {\n    void 0 === a && (a = 1 / this.zoomFactor);\n    var b = this.diagram;\n    if (b.autoScale !== rh) return !1;\n    a = b.scale * a;\n    return a < b.minScale || a > b.maxScale ? !1 : b.allowZoom;\n  };\n\n  Qk.prototype.increaseZoom = function (a) {\n    void 0 === a && (a = this.zoomFactor);\n    var b = this.diagram;\n    b.autoScale === rh && (a = b.scale * a, a < b.minScale || a > b.maxScale || (b.scale = a));\n  };\n\n  Qk.prototype.canIncreaseZoom = function (a) {\n    void 0 === a && (a = this.zoomFactor);\n    var b = this.diagram;\n    if (b.autoScale !== rh) return !1;\n    a = b.scale * a;\n    return a < b.minScale || a > b.maxScale ? !1 : b.allowZoom;\n  };\n\n  Qk.prototype.resetZoom = function (a) {\n    void 0 === a && (a = this.defaultScale);\n    var b = this.diagram;\n    a < b.minScale || a > b.maxScale || (b.scale = a);\n  };\n\n  Qk.prototype.canResetZoom = function (a) {\n    void 0 === a && (a = this.defaultScale);\n    var b = this.diagram;\n    return a < b.minScale || a > b.maxScale ? !1 : b.allowZoom;\n  };\n\n  Qk.prototype.zoomToFit = function () {\n    var a = this.diagram,\n        b = a.animationManager;\n    b.wc();\n    a.redraw();\n    var c = a.position,\n        d = a.scale;\n    lh(b, \"Zoom To Fit\");\n    this.isZoomToFitRestoreEnabled && d === this.fu && !isNaN(this.mt) && a.documentBounds.C(this.du) ? (a.scale = this.mt, a.position = this.Yv, this.fu = NaN, this.du = cc) : (this.mt = d, this.Yv = c.copy(), a.zoomToFit(), this.fu = a.scale, this.du = a.documentBounds.copy());\n    nh(b);\n  };\n\n  Qk.prototype.canZoomToFit = function () {\n    return this.diagram.allowZoom;\n  };\n\n  Qk.prototype.scrollToPart = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n    b.Za();\n\n    if (null === a) {\n      try {\n        null !== this.Vf && (this.Vf.next() ? a = this.Vf.value : this.Vf = null);\n      } catch (k) {\n        this.Vf = null;\n      }\n\n      null === a && (0 < b.highlighteds.count ? this.Vf = b.highlighteds.iterator : 0 < b.selection.count && (this.Vf = b.selection.iterator), null !== this.Vf && this.Vf.next() && (a = this.Vf.value));\n    }\n\n    if (null !== a) {\n      var c = b.animationManager;\n      lh(c, \"Scroll To Part\");\n      var d = this.scrollToPartPause;\n\n      if (0 < d) {\n        var e = Sk(this, a, [a]);\n        if (1 === e.length) b.Da(), b.Dr(a.actualBounds), b.eb(\"Scroll To Part\");else {\n          var f = function f() {\n            b.Da();\n\n            for (var a = e.pop(); 0 < e.length && a instanceof V && a.isTreeExpanded && (!(a instanceof qf) || a.isSubGraphExpanded);) {\n              a = e.pop();\n            }\n\n            0 < e.length ? (a instanceof U && b.bv(a.actualBounds), a instanceof V && !a.isTreeExpanded && (a.isTreeExpanded = !0), a instanceof qf && !a.isSubGraphExpanded && (a.isSubGraphExpanded = !0)) : (a instanceof U && b.Dr(a.actualBounds), b.Il(\"LayoutCompleted\", g));\n            b.eb(\"Scroll To Part\");\n          },\n              g = function g() {\n            ta(f, (c.isEnabled ? c.duration : 0) + d);\n          };\n\n          b.wj(\"LayoutCompleted\", g);\n          f();\n        }\n      } else {\n        var h = b.position.copy();\n        b.Dr(a.actualBounds);\n        h.$a(b.position) && c.wc();\n      }\n    }\n  };\n\n  function Sk(a, b, c) {\n    if (b.isVisible()) return c;\n    if (b instanceof ue) Sk(a, b.adornedPart, c);else if (b instanceof T) {\n      var d = b.fromNode;\n      null !== d && Sk(a, d, c);\n      b = b.toNode;\n      null !== b && Sk(a, b, c);\n    } else b instanceof V && (d = b.labeledLink, null !== d && Sk(a, d, c), d = b.ig(), null !== d && (d.isTreeExpanded || d.wasTreeExpanded || c.push(d), Sk(a, d, c))), b = b.containingGroup, null !== b && (b.isSubGraphExpanded || b.wasSubGraphExpanded || c.push(b), Sk(a, b, c));\n    return c;\n  }\n\n  Qk.prototype.canScrollToPart = function (a) {\n    void 0 === a && (a = null);\n    if (null !== a && !(a instanceof U)) return !1;\n    a = this.diagram;\n    return 0 === a.selection.count && 0 === a.highlighteds.count ? !1 : a.allowHorizontalScroll && a.allowVerticalScroll;\n  };\n\n  Qk.prototype.collapseTree = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n\n    try {\n      b.Da(\"Collapse Tree\");\n      lh(b.animationManager, \"Collapse Tree\");\n      var c = new E();\n      if (null !== a && a.isTreeExpanded) a.collapseTree(), c.add(a);else if (null === a) for (var d = b.selection.iterator; d.next();) {\n        var e = d.value;\n        e instanceof V && e.isTreeExpanded && (e.collapseTree(), c.add(e));\n      }\n      b.P(\"TreeCollapsed\", c);\n    } finally {\n      b.eb(\"Collapse Tree\");\n    }\n  };\n\n  Qk.prototype.canCollapseTree = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n    if (b.isReadOnly) return !1;\n\n    if (null !== a) {\n      if (!(a instanceof V && a.isTreeExpanded)) return !1;\n      if (0 < a.to().count) return !0;\n    } else for (a = b.selection.iterator; a.next();) {\n      if (b = a.value, b instanceof V && b.isTreeExpanded && 0 < b.to().count) return !0;\n    }\n\n    return !1;\n  };\n\n  Qk.prototype.expandTree = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n\n    try {\n      b.Da(\"Expand Tree\");\n      lh(b.animationManager, \"Expand Tree\");\n      var c = new E();\n      if (null !== a && !a.isTreeExpanded) a.expandTree(), c.add(a);else if (null === a) for (var d = b.selection.iterator; d.next();) {\n        var e = d.value;\n        e instanceof V && !e.isTreeExpanded && (e.expandTree(), c.add(e));\n      }\n      b.P(\"TreeExpanded\", c);\n    } finally {\n      b.eb(\"Expand Tree\");\n    }\n  };\n\n  Qk.prototype.canExpandTree = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n    if (b.isReadOnly) return !1;\n\n    if (null !== a) {\n      if (!(a instanceof V) || a.isTreeExpanded) return !1;\n      if (0 < a.to().count) return !0;\n    } else for (a = b.selection.iterator; a.next();) {\n      if (b = a.value, b instanceof V && !b.isTreeExpanded && 0 < b.to().count) return !0;\n    }\n\n    return !1;\n  };\n\n  Qk.prototype.groupSelection = function () {\n    var a = this.diagram,\n        b = a.model;\n\n    if (b.Oj()) {\n      var c = this.archetypeGroupData;\n\n      if (null !== c) {\n        var d = null;\n\n        try {\n          a.currentCursor = \"wait\";\n          a.P(\"ChangingSelection\", a.selection);\n          a.Da(\"Group\");\n\n          for (var e = new E(), f = a.selection.iterator; f.next();) {\n            var g = f.value;\n            g.Tc() && g.canGroup() && e.add(g);\n          }\n\n          for (var h = new E(), k = e.iterator; k.next();) {\n            var l = k.value;\n            f = !1;\n\n            for (var m = e.iterator; m.next();) {\n              if (l.Md(m.value)) {\n                f = !0;\n                break;\n              }\n            }\n\n            f || h.add(l);\n          }\n\n          if (0 < h.count) {\n            var n = h.first().containingGroup;\n            if (null !== n) for (; null !== n;) {\n              e = !1;\n\n              for (var p = h.iterator; p.next();) {\n                if (!p.value.Md(n)) {\n                  e = !0;\n                  break;\n                }\n              }\n\n              if (e) n = n.containingGroup;else break;\n            }\n            if (c instanceof qf) kg(c), d = c.copy(), null !== d && a.add(d);else if (b.Ku(c)) {\n              var r = b.copyNodeData(c);\n              ya(r) && (b.lf(r), d = a.ci(r));\n            }\n\n            if (null !== d) {\n              null !== n && this.isValidMember(n, d) && (d.containingGroup = n);\n\n              for (var q = h.iterator; q.next();) {\n                var u = q.value;\n                this.isValidMember(d, u) && (u.containingGroup = d);\n              }\n\n              a.clearSelection(!0);\n              d.isSelected = !0;\n            }\n          }\n\n          a.P(\"SelectionGrouped\", d);\n        } finally {\n          a.eb(\"Group\"), a.P(\"ChangedSelection\", a.selection), a.currentCursor = \"\";\n        }\n      }\n    }\n  };\n\n  Qk.prototype.canGroupSelection = function () {\n    var a = this.diagram;\n    if (a.isReadOnly || a.isModelReadOnly || !a.allowInsert || !a.allowGroup || !a.model.Oj() || null === this.archetypeGroupData) return !1;\n\n    for (a = a.selection.iterator; a.next();) {\n      var b = a.value;\n      if (b.Tc() && b.canGroup()) return !0;\n    }\n\n    return !1;\n  };\n\n  function Tk(a) {\n    var b = Ea();\n\n    for (a = a.iterator; a.next();) {\n      var c = a.value;\n      c instanceof T || b.push(c);\n    }\n\n    a = new G();\n    c = b.length;\n\n    for (var d = 0; d < c; d++) {\n      for (var e = b[d], f = !0, g = 0; g < c; g++) {\n        if (e.Md(b[g])) {\n          f = !1;\n          break;\n        }\n      }\n\n      f && a.add(e);\n    }\n\n    Ga(b);\n    return a;\n  }\n\n  Qk.prototype.isValidMember = function (a, b) {\n    if (null === b || a === b || b instanceof T) return !1;\n\n    if (null !== a) {\n      if (a === b || a.Md(b)) return !1;\n      var c = a.memberValidation;\n      if (null !== c && !c(a, b) || null === a.data && null !== b.data || null !== a.data && null === b.data) return !1;\n    }\n\n    c = this.memberValidation;\n    return null !== c ? c(a, b) : !0;\n  };\n\n  Qk.prototype.ungroupSelection = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram,\n        c = b.model;\n    if (c.Oj()) try {\n      b.currentCursor = \"wait\";\n      b.P(\"ChangingSelection\", b.selection);\n      b.Da(\"Ungroup\");\n      var d = new E();\n      if (null !== a) d.add(a);else for (var e = b.selection.iterator; e.next();) {\n        var f = e.value;\n        f instanceof qf && f.canUngroup() && d.add(f);\n      }\n      var g = new E();\n\n      if (0 < d.count) {\n        b.clearSelection(!0);\n\n        for (var h = d.iterator; h.next();) {\n          var k = h.value;\n          k.expandSubGraph();\n          var l = k.containingGroup,\n              m = null !== l && null !== l.data ? c.ua(l.data) : void 0;\n          g.addAll(k.memberParts);\n\n          for (var n = g.iterator; n.next();) {\n            var p = n.value;\n            p.isSelected = !0;\n\n            if (!(p instanceof T)) {\n              var r = p.data;\n              null !== r ? c.Po(r, m) : p.containingGroup = l;\n            }\n          }\n\n          b.remove(k);\n        }\n      }\n\n      b.P(\"SelectionUngrouped\", d, g);\n    } finally {\n      b.eb(\"Ungroup\"), b.P(\"ChangedSelection\", b.selection), b.currentCursor = \"\";\n    }\n  };\n\n  Qk.prototype.canUngroupSelection = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n    if (b.isReadOnly || b.isModelReadOnly || !b.allowDelete || !b.allowUngroup || !b.model.Oj()) return !1;\n\n    if (null !== a) {\n      if (!(a instanceof qf)) return !1;\n      if (a.canUngroup()) return !0;\n    } else for (a = b.selection.iterator; a.next();) {\n      if (b = a.value, b instanceof qf && b.canUngroup()) return !0;\n    }\n\n    return !1;\n  };\n\n  Qk.prototype.addTopLevelParts = function (a, b) {\n    var c = !0;\n\n    for (a = Tk(a).iterator; a.next();) {\n      var d = a.value;\n      null !== d.containingGroup && (!b || this.isValidMember(null, d) ? d.containingGroup = null : c = !1);\n    }\n\n    return c;\n  };\n\n  Qk.prototype.collapseSubGraph = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n\n    try {\n      b.Da(\"Collapse SubGraph\");\n      lh(b.animationManager, \"Collapse SubGraph\");\n      var c = new E();\n      if (null !== a && a.isSubGraphExpanded) a.collapseSubGraph(), c.add(a);else if (null === a) for (var d = b.selection.iterator; d.next();) {\n        var e = d.value;\n        e instanceof qf && e.isSubGraphExpanded && (e.collapseSubGraph(), c.add(e));\n      }\n      b.P(\"SubGraphCollapsed\", c);\n    } finally {\n      b.eb(\"Collapse SubGraph\");\n    }\n  };\n\n  Qk.prototype.canCollapseSubGraph = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n    if (b.isReadOnly) return !1;\n    if (null !== a) return a instanceof qf && a.isSubGraphExpanded ? !0 : !1;\n\n    for (a = b.selection.iterator; a.next();) {\n      if (b = a.value, b instanceof qf && b.isSubGraphExpanded) return !0;\n    }\n\n    return !1;\n  };\n\n  Qk.prototype.expandSubGraph = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n\n    try {\n      b.Da(\"Expand SubGraph\");\n      lh(b.animationManager, \"Expand SubGraph\");\n      var c = new E();\n      if (null !== a && !a.isSubGraphExpanded) a.expandSubGraph(), c.add(a);else if (null === a) for (var d = b.selection.iterator; d.next();) {\n        var e = d.value;\n        e instanceof qf && !e.isSubGraphExpanded && (e.expandSubGraph(), c.add(e));\n      }\n      b.P(\"SubGraphExpanded\", c);\n    } finally {\n      b.eb(\"Expand SubGraph\");\n    }\n  };\n\n  Qk.prototype.canExpandSubGraph = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n    if (b.isReadOnly) return !1;\n    if (null !== a) return a instanceof qf && !a.isSubGraphExpanded ? !0 : !1;\n\n    for (a = b.selection.iterator; a.next();) {\n      if (b = a.value, b instanceof qf && !b.isSubGraphExpanded) return !0;\n    }\n\n    return !1;\n  };\n\n  Qk.prototype.editTextBlock = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram,\n        c = b.toolManager.findTool(\"TextEditing\");\n\n    if (null !== c) {\n      if (null === a) {\n        a = null;\n\n        for (var d = b.selection.iterator; d.next();) {\n          var e = d.value;\n\n          if (e.canEdit()) {\n            a = e;\n            break;\n          }\n        }\n\n        if (null === a) return;\n        a = a.vl(function (a) {\n          return a instanceof Qg && a.editable;\n        });\n      }\n\n      null !== a && (b.currentTool = null, c.textBlock = a, b.currentTool = c);\n    }\n  };\n\n  Qk.prototype.canEditTextBlock = function (a) {\n    void 0 === a && (a = null);\n    var b = this.diagram;\n    if (b.isReadOnly || b.isModelReadOnly || !b.allowTextEdit || null === b.toolManager.findTool(\"TextEditing\")) return !1;\n\n    if (null !== a) {\n      if (!(a instanceof Qg)) return !1;\n      a = a.part;\n      if (null !== a && a.canEdit()) return !0;\n    } else for (b = b.selection.iterator; b.next();) {\n      if (a = b.value, a.canEdit() && (a = a.vl(function (a) {\n        return a instanceof Qg && a.editable;\n      }), null !== a)) return !0;\n    }\n\n    return !1;\n  };\n\n  Qk.prototype.showContextMenu = function (a) {\n    var b = this.diagram,\n        c = b.toolManager.findTool(\"ContextMenu\");\n\n    if (null !== c && (void 0 === a && (a = 0 < b.selection.count ? b.selection.first() : b), a = c.findObjectWithContextMenu(a), null !== a)) {\n      var d = b.lastInput,\n          e = null;\n      a instanceof Y ? e = a.ia(yc) : b.viewportBounds.ba(d.documentPoint) || (e = b.viewportBounds, e = new I(e.x + e.width / 2, e.y + e.height / 2));\n      null !== e && (d.viewPoint = b.Ro(e), d.documentPoint = e, d.left = !1, d.right = !0, d.up = !0);\n      b.currentTool = c;\n      Mg(c, !1, a);\n    }\n  };\n\n  Qk.prototype.canShowContextMenu = function (a) {\n    var b = this.diagram,\n        c = b.toolManager.findTool(\"ContextMenu\");\n    if (null === c) return !1;\n    void 0 === a && (a = 0 < b.selection.count ? b.selection.first() : b);\n    return null === c.findObjectWithContextMenu(a) ? !1 : !0;\n  };\n\n  Qk.prototype.computeEffectiveCollection = function (a, b) {\n    var c = this.diagram,\n        d = c.toolManager.findTool(\"Dragging\"),\n        e = c.currentTool === d;\n    void 0 === b && (b = e ? d.dragOptions : c.Em);\n    d = new pb();\n    if (null === a) return d;\n\n    for (var f = a.iterator; f.next();) {\n      Ij(c, d, f.value, e, b);\n    }\n\n    if (null !== c.draggedLink && b.dragsLink) return d;\n\n    for (f = a.iterator; f.next();) {\n      a = f.value, a instanceof T && (b = a.fromNode, null === b || d.contains(b) ? (b = a.toNode, null === b || d.contains(b) || d.remove(a)) : d.remove(a));\n    }\n\n    return d;\n  };\n\n  ma.Object.defineProperties(Qk.prototype, {\n    diagram: {\n      get: function get() {\n        return this.H;\n      }\n    },\n    copiesClipboardData: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        this.m = a;\n      }\n    },\n    copiesConnectedLinks: {\n      get: function get() {\n        return this.u;\n      },\n      set: function set(a) {\n        this.u = a;\n      }\n    },\n    deletesConnectedLinks: {\n      get: function get() {\n        return this.Ga;\n      },\n      set: function set(a) {\n        this.Ga = a;\n      }\n    },\n    copiesTree: {\n      get: function get() {\n        return this.ga;\n      },\n      set: function set(a) {\n        this.ga = a;\n      }\n    },\n    deletesTree: {\n      get: function get() {\n        return this.hb;\n      },\n      set: function set(a) {\n        this.hb = a;\n      }\n    },\n    copiesParentKey: {\n      get: function get() {\n        return this.W;\n      },\n      set: function set(a) {\n        this.W = a;\n      }\n    },\n    copiesGroupKey: {\n      get: function get() {\n        return this.F;\n      },\n      set: function set(a) {\n        this.F = a;\n      }\n    },\n    archetypeGroupData: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        this.j = a;\n      }\n    },\n    memberValidation: {\n      get: function get() {\n        return this.dj;\n      },\n      set: function set(a) {\n        this.dj = a;\n      }\n    },\n    defaultScale: {\n      get: function get() {\n        return this.diagram.defaultScale;\n      },\n      set: function set(a) {\n        this.diagram.defaultScale = a;\n      }\n    },\n    zoomFactor: {\n      get: function get() {\n        return this.Db;\n      },\n      set: function set(a) {\n        1 < a || C(\"zoomFactor must be larger than 1.0, not: \" + a);\n        this.Db = a;\n      }\n    },\n    isZoomToFitRestoreEnabled: {\n      get: function get() {\n        return this.cb;\n      },\n      set: function set(a) {\n        this.cb = a;\n      }\n    },\n    scrollToPartPause: {\n      get: function get() {\n        return this.nb;\n      },\n      set: function set(a) {\n        this.nb = a;\n      }\n    }\n  });\n  Qk.className = \"CommandHandler\";\n\n  xi = function xi() {\n    return new Qk();\n  };\n\n  function Y() {\n    Ra(this);\n    this.o = 30723;\n    this.tb = 1;\n    this.Yb = this.Uf = null;\n    this.pa = new I(NaN, NaN).freeze();\n    this.$c = Mb;\n    this.Bb = new md();\n    this.lh = new md();\n    this.Ib = null;\n    this.xa = this.yk = 1;\n    this.Gb = 0;\n    this.Ag = qc;\n    this.qc = new M(NaN, NaN, NaN, NaN).freeze();\n    this.Eb = new M(NaN, NaN, NaN, NaN).freeze();\n    this.bc = new M(0, 0, NaN, NaN).freeze();\n    this.aa = this.Gn = this.Hn = null;\n    this.fk = this.Fb = Wc;\n    this.rg = this.Ln = 0;\n    this.Mn = this.jj = this.ib = this.sh = this.A = this.Ra = null;\n  }\n\n  var td, lg, ng, Uk, Vk, Wk, Xk, Yk, Zk, $k;\n\n  Y.prototype.cloneProtected = function (a) {\n    a.o = this.o | 6144;\n    a.tb = this.tb;\n    a.Yb = this.Yb;\n    a.pa.assign(this.pa);\n    a.$c = this.$c.J();\n    null !== this.Ib ? a.Ib = this.Ib.copy() : a.Ib = null;\n    a.xa = this.xa;\n    a.Gb = this.Gb;\n    a.Ag = this.Ag.J();\n    a.qc.assign(this.qc);\n    a.Eb.assign(this.Eb);\n    a.bc.assign(this.bc);\n    a.Gn = this.Gn;\n    null !== this.aa && (a.aa = this.aa.copy());\n    a.Fb = this.Fb.J();\n    a.fk = this.fk.J();\n    a.Ln = this.Ln;\n    a.rg = this.rg;\n    null !== this.Ra && (a.Ra = this.Ra.copy());\n    null !== this.A && (a.A = this.A.ic ? this.A : this.A.copy());\n    null !== this.sh && (a.sh = Aa(this.sh));\n    null !== this.ib && (a.ib = this.ib.copy());\n  };\n\n  Y.prototype.zw = function (a) {\n    var b = this.sh;\n    if (za(b)) for (var c = 0; c < b.length; c++) {\n      if (b[c] === a) return;\n    } else this.sh = b = [];\n    b.push(a);\n  };\n\n  Y.prototype.qf = function (a) {\n    a.Hn = null;\n    a.jj = null;\n    a.w();\n  };\n\n  Y.prototype.clone = function () {\n    var a = new this.constructor();\n    this.cloneProtected(a);\n    if (null !== this.sh) for (var b = 0; b < this.sh.length; b++) {\n      var c = this.sh[b];\n      a[c] = this[c];\n    }\n    return a;\n  };\n\n  Y.prototype.copy = function () {\n    return this.clone();\n  };\n\n  t = Y.prototype;\n\n  t.ob = function (a) {\n    a.classType === T ? 0 === a.name.indexOf(\"Orient\") ? this.segmentOrientation = a : C(\"Unknown Link enum value for GraphObject.segmentOrientation property: \" + a) : a.classType === Y && (this.stretch = a);\n  };\n\n  t.toString = function () {\n    return Ha(this.constructor) + \"#\" + cb(this);\n  };\n\n  t.ih = function () {\n    null !== this.A && (this.A.ic = !0);\n  };\n\n  function al(a) {\n    null === a.A ? a.A = new bl() : a.A.ic && (a.A = a.A.copy());\n  }\n\n  t.Rc = function () {\n    if (null === this.aa) {\n      var a = new cl();\n      a.Qi = sc;\n      a.tj = sc;\n      a.Oi = 10;\n      a.rj = 10;\n      a.Pi = 0;\n      a.sj = 0;\n      this.aa = a;\n    }\n  };\n\n  t.bb = function (a, b, c, d, e, f, g) {\n    var h = this.part;\n    if (null !== h && (h.$j(a, b, c, d, e, f, g), c === this && a === de && dl(this) && el(this, h, b), f = this.diagram, null === this.animationTriggers || null === f || !f.ji || f.undoManager.isUndoingRedoing || f.animationManager.lm || (a = this.animationTriggers.get(b), null !== a && f.animationManager.isEnabled && !f.animationManager.isTicking && (null === this.Mn && (this.Mn = new pb()), g = 0 === f.undoManager.transactionLevel, a.startCondition === ai ? g = !0 : a.startCondition === ci && (g = !1), g ? (f = new kh(), bi(a, f), g = this.Mn.get(a), null !== g && g.stop(), this.Mn.add(a, f), f.au = this, f.rw = a, f.add(this, b, d, e), f.start()) : (lh(f.animationManager, \"Trigger\"), f.animationManager.defaultAnimation.add(this, b, d, e)))), this instanceof W && c === h && 0 !== (h.o & 16777216) && null !== h.data)) for (c = this.R.s, d = c.length, e = 0; e < d; e++) {\n      h = c[e], h instanceof W && Aj(h, function (a) {\n        null !== a.data && 0 !== (a.o & 16777216) && a.Ka(b);\n      });\n    }\n  };\n\n  function el(a, b, c) {\n    var d = a.Yg();\n    if (null !== d) for (var e = a.localBindings.iterator; e.next();) {\n      var f = e.value,\n          g = null;\n\n      if (null !== f.sourceName) {\n        g = fl(f, d, a);\n        if (null === g) continue;\n        f.Vo(a, g, c, null);\n      } else if (f.isToModel) {\n        var h = b.diagram;\n        null === h || h.skipsModelSourceBindings || f.Vo(a, h.model.modelData, c, d);\n      } else {\n        h = d.data;\n        if (null === h) continue;\n        var k = b.diagram;\n        null === k || k.skipsModelSourceBindings || f.Vo(a, h, c, d);\n      }\n\n      g === a && (h = d.Hr(f.ti), null !== h && f.pv(h, g, c));\n    }\n  }\n\n  t.Hr = function (a) {\n    return this.bindingId === a ? this : null;\n  };\n\n  t.g = function (a, b, c) {\n    this.bb(de, a, this, b, c);\n  };\n\n  t.ve = function (a, b, c, d) {\n    var e = this.qc;\n    e.h(a, b, c, d);\n\n    if (1 !== this.xa || 0 !== this.Gb) {\n      null === this.Ib && (this.Ib = new md());\n      var f = this.Ib;\n      f.reset();\n      this.Qn(f, a, b, c, d);\n      f.So(e);\n    }\n  };\n\n  function gl(a, b, c, d) {\n    if (!1 === a.pickable) return !1;\n    d.multiply(a.transform);\n    return c ? a.Sc(b, d) : a.Wg(b, d);\n  }\n\n  t.Vw = function (a, b, c) {\n    if (!1 === this.pickable) return !1;\n    var d = this.naturalBounds;\n    b = a.rf(b);\n    return c ? zb(a.x, a.y, 0, 0, 0, d.height) <= b || zb(a.x, a.y, 0, d.height, d.width, d.height) <= b || zb(a.x, a.y, d.width, d.height, d.width, 0) <= b || zb(a.x, a.y, d.width, 0, 0, 0) <= b : a.td(0, 0) <= b && a.td(0, d.height) <= b && a.td(d.width, 0) <= b && a.td(d.width, d.height) <= b;\n  };\n\n  t.ke = function () {\n    return !0;\n  };\n\n  t.ba = function (a) {\n    var b = I.alloc();\n    b.assign(a);\n    this.transform.Fa(b);\n    var c = this.actualBounds;\n    if (!c.v()) return I.free(b), !1;\n    var d = this.diagram;\n\n    if (null !== d && d.jt) {\n      var e = d.yl(\"extraTouchThreshold\"),\n          f = d.yl(\"extraTouchArea\"),\n          g = f / 2,\n          h = this.naturalBounds;\n      d = this.uf() * d.scale;\n      var k = 1 / d;\n      if (h.width * d < e && h.height * d < e) return a = $b(c.x - g * k, c.y - g * k, c.width + f * k, c.height + f * k, b.x, b.y), I.free(b), a;\n    }\n\n    e = !1;\n    if (this instanceof ue || this instanceof Cf ? $b(c.x - 5, c.y - 5, c.width + 10, c.height + 10, b.x, b.y) : c.ba(b)) this.ib && !this.ib.ba(b) ? e = !1 : null !== this.areaBackground && c.ba(b) ? e = !0 : null !== this.Yb && this.bc.ba(a) ? e = !0 : e = this.Xg(a);\n    I.free(b);\n    return e;\n  };\n\n  t.Xg = function (a) {\n    var b = this.naturalBounds;\n    return $b(0, 0, b.width, b.height, a.x, a.y);\n  };\n\n  t.Ee = function (a) {\n    if (0 === this.angle) return this.actualBounds.Ee(a);\n    var b = this.naturalBounds;\n    b = M.allocAt(0, 0, b.width, b.height);\n    var c = this.transform,\n        d = !1,\n        e = I.allocAt(a.x, a.y);\n    b.ba(c.Ld(e)) && (e.h(a.x, a.bottom), b.ba(c.Ld(e)) && (e.h(a.right, a.bottom), b.ba(c.Ld(e)) && (e.h(a.right, a.y), b.ba(c.Ld(e)) && (d = !0))));\n    I.free(e);\n    M.free(b);\n    return d;\n  };\n\n  t.Wg = function (a, b) {\n    if (void 0 === b) return a.Ee(this.actualBounds);\n    var c = this.naturalBounds,\n        d = !1,\n        e = I.allocAt(0, 0);\n    a.ba(b.Fa(e)) && (e.h(0, c.height), a.ba(b.Fa(e)) && (e.h(c.width, c.height), a.ba(b.Fa(e)) && (e.h(c.width, 0), a.ba(b.Fa(e)) && (d = !0))));\n    I.free(e);\n    return d;\n  };\n\n  t.Sc = function (a, b) {\n    if (void 0 === b && (b = this.transform, 0 === this.angle)) return a.Sc(this.actualBounds);\n    var c = this.naturalBounds,\n        d = I.allocAt(0, 0),\n        e = I.allocAt(0, c.height),\n        f = I.allocAt(c.width, c.height),\n        g = I.allocAt(c.width, 0),\n        h = !1;\n    if (a.ba(b.Fa(d)) || a.ba(b.Fa(e)) || a.ba(b.Fa(f)) || a.ba(b.Fa(g))) h = !0;else {\n      c = M.allocAt(0, 0, c.width, c.height);\n      var k = I.allocAt(a.x, a.y);\n      c.ba(b.Ld(k)) ? h = !0 : (k.h(a.x, a.bottom), c.ba(b.Ld(k)) ? h = !0 : (k.h(a.right, a.bottom), c.ba(b.Ld(k)) ? h = !0 : (k.h(a.right, a.y), c.ba(b.Ld(k)) && (h = !0))));\n      I.free(k);\n      M.free(c);\n      !h && (J.Rr(a, d, e) || J.Rr(a, e, f) || J.Rr(a, f, g) || J.Rr(a, g, d)) && (h = !0);\n    }\n    I.free(d);\n    I.free(e);\n    I.free(f);\n    I.free(g);\n    return h;\n  };\n\n  t.ia = function (a, b) {\n    void 0 === b && (b = new I());\n\n    if (a instanceof N) {\n      var c = this.naturalBounds;\n      b.h(a.x * c.width + a.offsetX, a.y * c.height + a.offsetY);\n    } else b.set(a);\n\n    this.ge.Fa(b);\n    return b;\n  };\n\n  t.gi = function (a) {\n    void 0 === a && (a = new M());\n    var b = this.naturalBounds,\n        c = this.ge,\n        d = I.allocAt(0, 0).transform(c);\n    a.h(d.x, d.y, 0, 0);\n    d.h(b.width, 0).transform(c);\n    Zb(a, d.x, d.y, 0, 0);\n    d.h(b.width, b.height).transform(c);\n    Zb(a, d.x, d.y, 0, 0);\n    d.h(0, b.height).transform(c);\n    Zb(a, d.x, d.y, 0, 0);\n    I.free(d);\n    return a;\n  };\n\n  t.fi = function () {\n    var a = this.ge;\n    1 === a.m11 && 0 === a.m12 ? a = 0 : (a = 180 * Math.atan2(a.m12, a.m11) / Math.PI, 0 > a && (a += 360));\n    return a;\n  };\n\n  t.uf = function () {\n    if (0 !== (this.o & 4096) === !1) return this.yk;\n    var a = this.xa;\n    return null !== this.panel ? a * this.panel.uf() : a;\n  };\n\n  t.Nr = function (a, b) {\n    void 0 === b && (b = new I());\n    b.assign(a);\n    this.ge.Ld(b);\n    return b;\n  };\n\n  t.Or = function (a, b, c) {\n    return this.Kj(a.x, a.y, b.x, b.y, c);\n  };\n\n  t.Kj = function (a, b, c, d, e) {\n    var f = this.transform,\n        g = 1 / (f.m11 * f.m22 - f.m12 * f.m21),\n        h = f.m22 * g,\n        k = -f.m12 * g,\n        l = -f.m21 * g,\n        m = f.m11 * g,\n        n = g * (f.m21 * f.dy - f.m22 * f.dx),\n        p = g * (f.m12 * f.dx - f.m11 * f.dy);\n    if (null !== this.areaBackground) return f = this.actualBounds, J.wf(f.left, f.top, f.right, f.bottom, a, b, c, d, e);\n    g = a * h + b * l + n;\n    a = a * k + b * m + p;\n    b = c * h + d * l + n;\n    c = c * k + d * m + p;\n    e.h(0, 0);\n    d = this.naturalBounds;\n    c = J.wf(0, 0, d.width, d.height, g, a, b, c, e);\n    e.transform(f);\n    return c;\n  };\n\n  Y.prototype.measure = function (a, b, c, d) {\n    if (!1 !== nj(this)) {\n      var e = this.Ag,\n          f = e.right + e.left;\n      e = e.top + e.bottom;\n      a = Math.max(a - f, 0);\n      b = Math.max(b - e, 0);\n      c = Math.max((c || 0) - f, 0);\n      d = Math.max((d || 0) - e, 0);\n      f = this.angle;\n      e = this.desiredSize;\n      var g = 0;\n      this instanceof Cf && (g = this.strokeWidth);\n      90 === f || 270 === f ? (a = isFinite(e.height) ? e.height + g : a, b = isFinite(e.width) ? e.width + g : b) : (a = isFinite(e.width) ? e.width + g : a, b = isFinite(e.height) ? e.height + g : b);\n      e = c || 0;\n      g = d || 0;\n      var h = this instanceof W;\n\n      switch (hl(this, !0)) {\n        case lg:\n          g = e = 0;\n          h && (b = a = Infinity);\n          break;\n\n        case td:\n          isFinite(a) && a > c && (e = a);\n          isFinite(b) && b > d && (g = b);\n          break;\n\n        case Uk:\n          isFinite(a) && a > c && (e = a);\n          g = 0;\n          h && (b = Infinity);\n          break;\n\n        case Vk:\n          isFinite(b) && b > d && (g = b), e = 0, h && (a = Infinity);\n      }\n\n      h = this.maxSize;\n      var k = this.minSize;\n      e > h.width && k.width < h.width && (e = h.width);\n      g > h.height && k.height < h.height && (g = h.height);\n      c = Math.max(e / this.scale, k.width);\n      d = Math.max(g / this.scale, k.height);\n      h.width < c && (c = Math.min(k.width, c));\n      h.height < d && (d = Math.min(k.height, d));\n      a = Math.min(h.width, a);\n      b = Math.min(h.height, b);\n      a = Math.max(c, a);\n      b = Math.max(d, b);\n      if (90 === f || 270 === f) f = a, a = b, b = f, f = c, c = d, d = f;\n      this.qc.ja();\n      this.El(a, b, c, d);\n      this.qc.freeze();\n      this.qc.v() || C(\"Non-real measuredBounds has been set. Object \" + this + \", measuredBounds: \" + this.qc.toString());\n      ij(this, !1);\n    }\n  };\n\n  Y.prototype.El = function () {};\n\n  Y.prototype.li = function () {\n    return !1;\n  };\n\n  Y.prototype.arrange = function (a, b, c, d, e) {\n    this.Jk();\n    var f = M.alloc();\n    f.assign(this.Eb);\n    this.Eb.ja();\n    !1 === oj(this) ? this.Eb.h(a, b, c, d) : this.Vg(a, b, c, d);\n    this.Eb.freeze();\n    void 0 === e ? this.ib = null : this.ib = e;\n    c = !1;\n    if (void 0 !== e) c = !0;else if (e = this.panel, null === e || e.type !== W.TableRow && e.type !== W.TableColumn || (e = e.panel), null !== e && (e = e.bc, d = this.measuredBounds, null !== this.areaBackground && (d = this.Eb), c = b + d.height, d = a + d.width, c = !(0 <= a + .05 && d <= e.width + .05 && 0 <= b + .05 && c <= e.height + .05), this instanceof Qg && (a = this.naturalBounds, this.kq > a.height || this.yb > a.width))) c = !0;\n    this.o = c ? this.o | 256 : this.o & -257;\n    this.Eb.v() || C(\"Non-real actualBounds has been set. Object \" + this + \", actualBounds: \" + this.Eb.toString());\n    this.Fl(f, this.Eb);\n    il(this, !1);\n    M.free(f);\n  };\n\n  t = Y.prototype;\n\n  t.Vg = function () {};\n\n  function jl(a, b, c, d, e) {\n    a.Eb.h(b, c, d, e);\n\n    if (!a.desiredSize.v()) {\n      var f = a.qc;\n      c = a.Ag;\n      b = c.right + c.left;\n      var g = c.top + c.bottom;\n      c = f.width + b;\n      f = f.height + g;\n      d += b;\n      e += g;\n      b = hl(a, !0);\n      c === d && f === e && (b = lg);\n\n      switch (b) {\n        case lg:\n          if (c > d || f > e) ij(a, !0), a.measure(c > d ? d : c, f > e ? e : f, 0, 0);\n          break;\n\n        case td:\n          ij(a, !0);\n          a.measure(d, e, 0, 0);\n          break;\n\n        case Uk:\n          ij(a, !0);\n          a.measure(d, f, 0, 0);\n          break;\n\n        case Vk:\n          ij(a, !0), a.measure(c, e, 0, 0);\n      }\n    }\n  }\n\n  t.Fl = function (a, b) {\n    var c = this.part;\n    null !== c && null !== c.diagram && (c.selectionObject !== this && c.resizeObject !== this && c.rotateObject !== this || kl(c, !0), this.N(), Tb(a, b) || (c.dh(), this.wn(c)));\n  };\n\n  t.wn = function (a) {\n    null !== this.portId && (kl(a, !0), a instanceof V && ll(a, this));\n  };\n\n  t.tc = function (a, b) {\n    if (this.visible) {\n      var c = this.opacity;\n\n      if (0 !== c) {\n        var d = this instanceof W && (this.type === W.TableRow || this.type === W.TableColumn),\n            e = this.Eb;\n\n        if (d || 0 !== e.width && 0 !== e.height && !isNaN(e.x) && !isNaN(e.y)) {\n          var f = 1;\n          1 !== c && (f = a.globalAlpha, a.globalAlpha = f * c);\n\n          if (d) {\n            e = this.Eb;\n            d = this.bc;\n            var g = this.areaBackground,\n                h = this.Yb;\n            null === g && null === h || a.Pc();\n            null !== g && (gi(this, a, g, !0, !0, d, e), g instanceof ml && g.type === nl ? (a.beginPath(), a.rect(e.x, e.y, e.width, e.height), a.sf(g)) : a.fillRect(e.x, e.y, e.width, e.height));\n            null !== h && (gi(this, a, h, !0, !1, d, e), h instanceof ml && h.type === nl ? (a.beginPath(), a.rect(e.x, e.y, e.width, e.height), a.sf(h)) : a.fillRect(e.x, e.y, e.width, e.height));\n            this.ai(a, b);\n          } else if (!this.Qw(a, b)) {\n            this instanceof T && this.Rj(!1);\n            d = this.transform;\n            g = this.panel;\n            0 !== (this.o & 4096) === !0 && ol(this);\n            var k = this.part;\n            h = !1;\n            var l = 0;\n\n            if (k && b.Ge(\"drawShadows\") && (h = k.isShadowed)) {\n              var m = k.shadowOffset;\n              l = Math.max(m.y, m.x) * b.scale * b.kc;\n            }\n\n            m = this.li();\n            var n;\n\n            if (!(n = b.Vi || !m)) {\n              var p = this.naturalBounds;\n              n = this.lh;\n              var r = n.m11,\n                  q = n.m21,\n                  u = n.dx,\n                  w = n.m12,\n                  v = n.m22,\n                  z = n.dy,\n                  y,\n                  A = y = 0;\n              n = y * r + A * q + u;\n              var B = y * w + A * v + z;\n              y = p.width + l;\n              A = 0;\n              var F = y * r + A * q + u;\n              y = y * w + A * v + z;\n              A = Math.min(n, F);\n              var L = Math.min(B, y);\n              var S = Math.max(n + 0, F) - A;\n              var R = Math.max(B + 0, y) - L;\n              n = A;\n              B = L;\n              y = p.width + l;\n              A = p.height + l;\n              F = y * r + A * q + u;\n              y = y * w + A * v + z;\n              A = Math.min(n, F);\n              L = Math.min(B, y);\n              S = Math.max(n + S, F) - A;\n              R = Math.max(B + R, y) - L;\n              n = A;\n              B = L;\n              y = 0;\n              A = p.height + l;\n              F = y * r + A * q + u;\n              y = y * w + A * v + z;\n              A = Math.min(n, F);\n              L = Math.min(B, y);\n              S = Math.max(n + S, F) - A;\n              R = Math.max(B + R, y) - L;\n              n = A;\n              B = L;\n              l = b.viewportBounds;\n              p = l.x;\n              r = l.y;\n              n = !(n > l.width + p || p > S + n || B > l.height + r || r > R + B);\n            }\n\n            if (n) {\n              n = 0 !== (this.o & 256);\n              a.clipInsteadOfFill && (n = !1);\n              this instanceof Qg && (a.font = this.font);\n\n              if (n) {\n                B = g.ke() ? g.naturalBounds : g.actualBounds;\n                null !== this.ib ? (p = this.ib, S = p.x, R = p.y, l = p.width, p = p.height) : (S = Math.max(e.x, B.x), R = Math.max(e.y, B.y), l = Math.min(e.right, B.right) - S, p = Math.min(e.bottom, B.bottom) - R);\n\n                if (S > e.width + e.x || e.x > B.width + B.x) {\n                  1 !== c && (a.globalAlpha = f);\n                  return;\n                }\n\n                a.save();\n                a.beginPath();\n                a.rect(S, R, l, p);\n                a.clip();\n              }\n\n              if (m) {\n                if (!k.isVisible()) {\n                  1 !== c && (a.globalAlpha = f);\n                  return;\n                }\n\n                h && (B = k.shadowOffset, a.iv(B.x * b.scale * b.kc, B.y * b.scale * b.kc, k.shadowBlur), pl(a), a.shadowColor = k.shadowColor);\n              }\n\n              h && !0 === this.shadowVisible ? pl(a) : h && !1 === this.shadowVisible && ql(a);\n              k = this.naturalBounds;\n              null !== this.areaBackground && (a.Pc(), gi(this, a, this.areaBackground, !0, !0, k, e), this.areaBackground instanceof ml && this.areaBackground.type === nl ? (a.beginPath(), a.rect(e.x, e.y, e.width, e.height), a.sf(this.areaBackground)) : a.fillRect(e.x, e.y, e.width, e.height));\n              a.transform(d.m11, d.m12, d.m21, d.m22, d.dx, d.dy);\n              h && (null !== g && 0 !== (g.o & 512) || null !== g && (g.type === W.Auto || g.type === W.Spot) && g.vb() !== this) && null === this.shadowVisible && ql(a);\n              null !== this.Yb && (a.Pc(), rl(this, a, k, e));\n              h && (null !== this.Yb || null !== this.areaBackground || null !== g && 0 !== (g.o & 512) || null !== g && (g.type === W.Auto || g.type === W.Spot) && g.vb() !== this) ? (sl(this, !0), null === this.shadowVisible && ql(a)) : sl(this, !1);\n              this.ai(a, b);\n              h && 0 !== (this.o & 512) === !0 && pl(a);\n              m && h && ql(a);\n              n && (a.restore(), a.Oc(this instanceof W));\n              d.Ur() || (b = 1 / (d.m11 * d.m22 - d.m12 * d.m21), a.transform(d.m22 * b, -d.m12 * b, -d.m21 * b, d.m11 * b, b * (d.m21 * d.dy - d.m22 * d.dx), b * (d.m12 * d.dx - d.m11 * d.dy)));\n            }\n          }\n\n          1 !== c && (a.globalAlpha = f);\n        }\n      }\n    }\n  };\n\n  function rl(a, b, c, d) {\n    var e = a.naturalBounds,\n        f = 0,\n        g = 0,\n        h = e.width;\n    e = e.height;\n    var k = a.Sv();\n    a instanceof Cf && (e = a.sa.bounds, f = e.x, g = e.y, h = e.width, e = e.height);\n    gi(a, b, a.Yb, !0, !1, c, d);\n    a.Yb instanceof ml && a.Yb.type === nl ? (b.beginPath(), b.rect(f - k / 2, g - k / 2, h + k, e + k), b.sf(a.Yb)) : b.fillRect(f - k / 2, g - k / 2, h + k, e + k);\n  }\n\n  t.Qw = function () {\n    return !1;\n  };\n\n  t.ai = function () {};\n\n  function gi(a, b, c, d, e, f, g) {\n    if (null !== c) {\n      var h = 1,\n          k = 1;\n      if (\"string\" === typeof c) d ? b.fillStyle = c : b.strokeStyle = c;else if (c.type === tl) d ? b.fillStyle = c.color : b.strokeStyle = c.color;else {\n        var l = 0;\n        a instanceof Cf && (l = a.strokeWidth);\n        h = f.width;\n        k = f.height;\n        e ? (h = g.width, k = g.height) : d || (h += l, k += l);\n        if ((f = b instanceof ul) && c.oe && (c.type === vl || c.lk === h && c.Hs === k)) var m = c.oe;else {\n          var n = 0,\n              p = 0,\n              r = 0,\n              q = 0,\n              u = 0,\n              w = 0;\n          w = u = 0;\n          e ? (u = g.x, w = g.y) : d || (u -= l / 2, w -= l / 2);\n          n = c.start.x * h + c.start.offsetX;\n          p = c.start.y * k + c.start.offsetY;\n          r = c.end.x * h + c.end.offsetX;\n          q = c.end.y * k + c.end.offsetY;\n          n += u;\n          r += u;\n          p += w;\n          q += w;\n          if (c.type === wl) m = b.createLinearGradient(n, p, r, q);else if (c.type === nl) w = isNaN(c.endRadius) ? Math.max(h, k) / 2 : c.endRadius, isNaN(c.startRadius) ? (u = 0, w = Math.max(h, k) / 2) : u = c.startRadius, m = b.createRadialGradient(n, p, u, r, q, w);else if (c.type === vl) try {\n            m = b.createPattern(c.pattern, \"repeat\");\n          } catch (z) {\n            m = null;\n          }\n          if (c.type !== vl && (e = c.colorStops, null !== e)) for (e = e.iterator; e.next();) {\n            m.addColorStop(e.key, e.value);\n          }\n\n          if (f && (c.oe = m, null !== m && (c.lk = h, c.Hs = k), null === m && c.type === vl && -1 !== c.lk)) {\n            c.lk = -1;\n            var v = a.diagram;\n            null !== v && -1 === c.lk && ta(function () {\n              v.redraw();\n            }, 600);\n          }\n        }\n        d ? b.fillStyle = m : b.strokeStyle = m;\n      }\n    }\n  }\n\n  t.jg = function (a) {\n    if (a instanceof W) a: {\n      if (this !== a && null !== a) for (var b = this.panel; null !== b;) {\n        if (b === a) {\n          a = !0;\n          break a;\n        }\n\n        b = b.panel;\n      }\n      a = !1;\n    } else a = !1;\n    return a;\n  };\n\n  t.zf = function () {\n    if (!this.visible) return !1;\n    var a = this.panel;\n    return null !== a ? a.zf() : !0;\n  };\n\n  t.yf = function () {\n    for (var a = this instanceof W ? this : this.panel; null !== a && a.isEnabled;) {\n      a = a.panel;\n    }\n\n    return null === a;\n  };\n\n  function ol(a) {\n    if (0 !== (a.o & 2048) === !0) {\n      var b = a.Bb;\n      b.reset();\n\n      if (!a.Eb.v() || !a.qc.v()) {\n        xl(a, !1);\n        return;\n      }\n\n      b.translate(a.Eb.x - a.qc.x, a.Eb.y - a.qc.y);\n\n      if (1 !== a.scale || 0 !== a.angle) {\n        var c = a.naturalBounds;\n        a.Qn(b, c.x, c.y, c.width, c.height);\n      }\n\n      xl(a, !1);\n      yl(a, !0);\n    }\n\n    0 !== (a.o & 4096) === !0 && (b = a.panel, null === b ? (a.lh.set(a.Bb), a.yk = a.scale, yl(a, !1)) : null !== b.ge && (c = a.lh, c.reset(), b.ke() ? c.multiply(b.lh) : null !== b.panel && c.multiply(b.panel.lh), c.multiply(a.Bb), a.yk = a.scale * b.yk, yl(a, !1)));\n  }\n\n  t.Qn = function (a, b, c, d, e) {\n    1 !== this.xa && a.scale(this.xa);\n\n    if (0 !== this.Gb) {\n      var f = I.alloc();\n      f.pi(b, c, d, e, yc);\n      a.rotate(this.Gb, f.x, f.y);\n      I.free(f);\n    }\n  };\n\n  t.w = function (a) {\n    if (!nj(this)) {\n      void 0 === a && (a = !1);\n      ij(this, !0);\n      il(this, !0);\n      var b = this.panel;\n      null === b || a || b.w();\n    }\n  };\n\n  t.Mj = function () {\n    nj(this) || (ij(this, !0), il(this, !0));\n  };\n\n  function zl(a) {\n    if (!oj(a)) {\n      var b = a.panel;\n      null !== b ? b.w() : a.li() && (b = a.diagram, null !== b && (b.te.add(a), a instanceof V && a.vd(), b.Mb()));\n      il(a, !0);\n    }\n  }\n\n  t.Jk = function () {\n    0 !== (this.o & 2048) === !1 && (xl(this, !0), yl(this, !0));\n  };\n\n  t.Iu = function () {\n    yl(this, !0);\n  };\n\n  t.N = function () {\n    var a = this.part;\n    null !== a && a.N();\n  };\n\n  function hl(a, b) {\n    var c = a.stretch,\n        d = a.panel;\n    if (null !== d && d.type === W.Table) return Al(a, d.getRowDefinition(a.row), d.getColumnDefinition(a.column), b);\n    if (null !== d && d.type === W.Auto && d.vb() === a) return Bl(a, td, b);\n\n    if (c === Wk) {\n      if (null !== d) {\n        if (d.type === W.Spot && d.vb() === a) return Bl(a, td, b);\n        c = d.defaultStretch;\n        return c === Wk ? Bl(a, lg, b) : Bl(a, c, b);\n      }\n\n      return Bl(a, lg, b);\n    }\n\n    return Bl(a, c, b);\n  }\n\n  function Al(a, b, c, d) {\n    var e = a.stretch;\n    if (e !== Wk) return Bl(a, e, d);\n    var f = e = null;\n\n    switch (b.stretch) {\n      case Vk:\n        f = !0;\n        break;\n\n      case td:\n        f = !0;\n    }\n\n    switch (c.stretch) {\n      case Uk:\n        e = !0;\n        break;\n\n      case td:\n        e = !0;\n    }\n\n    b = a.panel.defaultStretch;\n    null === e && (e = b === Uk || b === td);\n    null === f && (f = b === Vk || b === td);\n    return !0 === e && !0 === f ? Bl(a, td, d) : !0 === e ? Bl(a, Uk, d) : !0 === f ? Bl(a, Vk, d) : Bl(a, lg, d);\n  }\n\n  function Bl(a, b, c) {\n    if (c) return b;\n    if (b === lg) return lg;\n    c = a.desiredSize;\n    if (c.v()) return lg;\n    a = a.angle;\n    if (!isNaN(c.width)) if (90 !== a && 270 !== a) {\n      if (b === Uk) return lg;\n      if (b === td) return Vk;\n    } else {\n      if (b === Vk) return lg;\n      if (b === td) return Uk;\n    }\n    if (!isNaN(c.height)) if (90 !== a && 270 !== a) {\n      if (b === Vk) return lg;\n      if (b === td) return Uk;\n    } else {\n      if (b === Uk) return lg;\n      if (b === td) return Vk;\n    }\n    return b;\n  }\n\n  function sl(a, b) {\n    a.o = b ? a.o | 512 : a.o & -513;\n  }\n\n  function dl(a) {\n    return 0 !== (a.o & 1024);\n  }\n\n  function Cl(a, b) {\n    a.o = b ? a.o | 1024 : a.o & -1025;\n  }\n\n  function xl(a, b) {\n    a.o = b ? a.o | 2048 : a.o & -2049;\n  }\n\n  function yl(a, b) {\n    a.o = b ? a.o | 4096 : a.o & -4097;\n  }\n\n  function nj(a) {\n    return 0 !== (a.o & 8192);\n  }\n\n  function ij(a, b) {\n    a.o = b ? a.o | 8192 : a.o & -8193;\n  }\n\n  function oj(a) {\n    return 0 !== (a.o & 16384);\n  }\n\n  function il(a, b) {\n    a.o = b ? a.o | 16384 : a.o & -16385;\n  }\n\n  t.ni = function (a) {\n    this.Uf = a;\n  };\n\n  t.ns = function () {};\n\n  t.fv = function (a) {\n    this.pa = a;\n    zl(this);\n    return !0;\n  };\n\n  t.Ul = function (a, b) {\n    if (this.pa.x !== a || this.pa.y !== b) this.pa.h(a, b), this.Jk();\n  };\n\n  t.Sv = function () {\n    return 0;\n  };\n\n  function Dl(a) {\n    var b = a.part;\n\n    if (b instanceof V && (null !== a.portId || a === b.port)) {\n      var c = b.diagram;\n      null === c || c.undoManager.isUndoingRedoing || ll(b, a);\n    }\n  }\n\n  function El(a) {\n    var b = a.diagram;\n    null === b || b.undoManager.isUndoingRedoing || (a instanceof W ? a instanceof V ? a.vd() : a.$l(a, function (a) {\n      Dl(a);\n    }) : Dl(a));\n  }\n\n  t.bind = function (a, b, c, d) {\n    var e = null;\n    \"string\" === typeof a ? e = new wi(a, b, c, d) : e = a;\n    e.sd = this;\n    a = this.Yg();\n    null !== a && Fl(a) && C(\"Cannot add a Binding to a template that has already been copied: \" + e);\n    null === this.localBindings && (this.localBindings = new E());\n    this.localBindings.add(e);\n    return this;\n  };\n\n  t.set = function (a) {\n    Object.assign(this, a);\n    return this;\n  };\n\n  t.ku = function (a) {\n    Gl(this, a);\n    return this;\n  };\n\n  t.apply = function (a) {\n    a(this);\n    return this;\n  };\n\n  t.Vl = function (a) {\n    uj(this, a);\n    return this;\n  };\n\n  t.Yy = function () {\n    return this.Yg();\n  };\n\n  t.Yg = function () {\n    for (var a = this instanceof W ? this : this.panel; null !== a;) {\n      if (null !== a.allBindings) return a;\n      a = a.panel;\n    }\n\n    return null;\n  };\n\n  t.mv = function (a) {\n    a.sd = this;\n    null === this.animationTriggers && (this.animationTriggers = new pb());\n    this.animationTriggers.add(a.propertyName, a);\n    return this;\n  };\n\n  function Hl(a, b) {\n    for (var c = 1; c < arguments.length; ++c) {\n      ;\n    }\n\n    c = arguments;\n    var d = null,\n        e = null;\n    if (\"function\" === typeof a) e = a;else if (\"string\" === typeof a) {\n      var f = Il.I(a);\n      \"function\" === typeof f ? (c = Aa(arguments), d = f(c), ya(d) || C('GraphObject.make invoked object builder \"' + a + '\", but it did not return an Object')) : e = x.go[a];\n    }\n    null === d && (void 0 !== e && null !== e && e.constructor || C(\"GraphObject.make requires a class function or GoJS class name or name of an object builder, not: \" + a), d = new e());\n    e = 1;\n\n    if (d instanceof Q && 1 < c.length) {\n      f = d;\n      var g = c[1];\n      if (\"string\" === typeof g || g instanceof HTMLDivElement) si(f, g), e++;\n    }\n\n    for (; e < c.length; e++) {\n      f = c[e], void 0 === f ? C(\"Undefined value at argument \" + e + \" for object being constructed by GraphObject.make: \" + d) : Gl(d, f);\n    }\n\n    return d;\n  }\n\n  function Gl(a, b) {\n    if (\"string\" === typeof b) {\n      if (a instanceof Qg) a.text = b;else if (a instanceof Cf) a.figure = b;else if (a instanceof Wj) a.source = b;else if (a instanceof W) b = Jl.I(b), null !== b && (a.type = b);else if (a instanceof ml) {\n        var c = Sa(ml, b);\n        null !== c ? a.type = c : C(\"Unknown Brush type as an argument to GraphObject.make: \" + b);\n      } else a instanceof O ? (b = Sa(O, b), null !== b && (a.type = b)) : a instanceof Yd && (b = Sa(Yd, b), null !== b && (a.type = b));\n    } else if (b instanceof Y) a instanceof W || C(\"A GraphObject can only be added to a Panel, not to: \" + a), a.add(b);else if (b instanceof Oj) {\n      var d;\n      b.isRow && \"function\" === typeof a.getRowDefinition ? d = a.getRowDefinition(b.index) : b.isRow || \"function\" !== typeof a.getColumnDefinition || (d = a.getColumnDefinition(b.index));\n      d instanceof Oj ? (a = d, b.isRow ? a.height = b.height : a.width = b.width, a.minimum = b.minimum, a.maximum = b.maximum, a.alignment = b.alignment, a.stretch = b.stretch, a.sizing = b.sizing, a.Wf = null === b.separatorPadding ? null : b.separatorPadding.J(), a.separatorStroke = b.separatorStroke, a.separatorStrokeWidth = b.separatorStrokeWidth, a.oj = null, b.separatorDashArray && (a.oj = Aa(b.separatorDashArray)), a.background = b.background, a.coversSeparators = b.coversSeparators, a.Vd = b.Vd) : C(\"A RowColumnDefinition can only be added to an object that implements getRowDefinition/getColumnDefinition, not to: \" + a);\n    } else if (b instanceof D) \"function\" === typeof a.ob && a.ob(b);else if (b instanceof Kl) a.type = b;else if (b instanceof wi) a instanceof Y ? a.bind(b) : a instanceof Oj ? a.bind(b) : C(\"A Binding can only be applied to a GraphObject or RowColumnDefinition, not to: \" + a);else if (b instanceof Zh) a instanceof Y ? a.mv(b) : C(\"An AnimationTrigger can only be applied to a GraphObject, not to: \" + a);else if (b instanceof Xd) a instanceof O && a.type === O.m ? a.figures.add(b) : C(\"A PathFigure can only be added to a Path Geometry, not to: \" + a);else if (b instanceof Yd) a instanceof Xd ? a.segments.add(b) : C(\"A PathSegment can only be added to a PathFigure, not to: \" + a);else if (b instanceof qi) a instanceof Q ? a.layout = b : a instanceof qf ? a.layout = b : C(\"A Layout can only be assigned to a Diagram or a Group, not to: \" + a);else if (Array.isArray(b)) for (c = 0; c < b.length; c++) {\n      Gl(a, b[c]);\n    } else if (\"object\" === typeof b && null !== b) {\n      if (a instanceof ml) {\n        c = new Wa();\n\n        for (var e in b) {\n          d = parseFloat(e), isNaN(d) ? c[e] = b[e] : a.addColorStop(d, b[e]);\n        }\n\n        uj(a, c);\n      } else if (a instanceof Oj) {\n        void 0 !== b.row ? (e = b.row, (void 0 === e || null === e || Infinity === e || isNaN(e) || 0 > e) && C(\"Must specify non-negative integer row for RowColumnDefinition \" + b + \", not: \" + e), a.isRow = !0, a.index = e) : void 0 !== b.column && (e = b.column, (void 0 === e || null === e || Infinity === e || isNaN(e) || 0 > e) && C(\"Must specify non-negative integer column for RowColumnDefinition \" + b + \", not: \" + e), a.isRow = !1, a.index = e);\n        e = new Wa();\n\n        for (c in b) {\n          \"row\" !== c && \"column\" !== c && (e[c] = b[c]);\n        }\n\n        uj(a, e);\n      } else uj(a, b);\n    } else C('Unknown initializer \"' + b + '\" for object being constructed by GraphObject.make: ' + a);\n  }\n\n  function Ll(a, b) {\n    Il.add(a, b);\n  }\n\n  function Ml(a, b, c) {\n    void 0 === c && (c = null);\n    var d = a[1];\n    if (\"function\" === typeof c ? c(d) : \"string\" === typeof d) return a.splice(1, 1), d;\n    if (void 0 === b) throw Error(\"no \" + (\"function\" === typeof c ? \"satisfactory\" : \"string\") + \" argument for GraphObject builder \" + a[0]);\n    return b;\n  }\n\n  ma.Object.defineProperties(Y.prototype, {\n    bindingId: {\n      get: function get() {\n        return null !== this.A ? this.A.bp : -1;\n      },\n      set: function set(a) {\n        this.bindingId !== a && (null === this.A && (this.A = new bl()), this.A.bp = a);\n      }\n    },\n    localBindings: {\n      get: function get() {\n        return null !== this.A ? this.A.Ff : null;\n      },\n      set: function set(a) {\n        this.localBindings !== a && (null === this.A && (this.A = new bl()), this.A.Ff = a);\n      }\n    },\n    srcBindings: {\n      get: function get() {\n        return null !== this.A ? this.A.Wo : null;\n      },\n      set: function set(a) {\n        this.srcBindings !== a && (null === this.A && (this.A = new bl()), this.A.Wo = a);\n      }\n    },\n    shadowVisible: {\n      get: function get() {\n        return null !== this.A ? this.A.wi : null;\n      },\n      set: function set(a) {\n        var b = this.shadowVisible;\n        b !== a && (al(this), this.A.wi = a, this.N(), this.g(\"shadowVisible\", b, a));\n      }\n    },\n    enabledChanged: {\n      get: function get() {\n        return null !== this.A ? this.A.Hc : null;\n      },\n      set: function set(a) {\n        var b = this.enabledChanged;\n        b !== a && (al(this), this.A.Hc = a, this.g(\"enabledChanged\", b, a));\n      }\n    },\n    segmentOrientation: {\n      get: function get() {\n        return null !== this.Ra ? this.Ra.Oq : $f;\n      },\n      set: function set(a) {\n        var b = this.segmentOrientation;\n        b !== a && (null === this.Ra && (this.Ra = new Nl()), this.Ra.Oq = a, this.w(), this.g(\"segmentOrientation\", b, a), a === $f && (this.angle = 0));\n      }\n    },\n    segmentIndex: {\n      get: function get() {\n        return null !== this.Ra ? this.Ra.u : -Infinity;\n      },\n      set: function set(a) {\n        a = Math.round(a);\n        var b = this.segmentIndex;\n        b !== a && (null === this.Ra && (this.Ra = new Nl()), this.Ra.u = a, this.w(), this.g(\"segmentIndex\", b, a));\n      }\n    },\n    segmentFraction: {\n      get: function get() {\n        return null !== this.Ra ? this.Ra.m : 0;\n      },\n      set: function set(a) {\n        isNaN(a) ? a = 0 : 0 > a ? a = 0 : 1 < a && (a = 1);\n        var b = this.segmentFraction;\n        b !== a && (null === this.Ra && (this.Ra = new Nl()), this.Ra.m = a, this.w(), this.g(\"segmentFraction\", b, a));\n      }\n    },\n    segmentOffset: {\n      get: function get() {\n        return null !== this.Ra ? this.Ra.F : qb;\n      },\n      set: function set(a) {\n        var b = this.segmentOffset;\n        b.C(a) || (a = a.J(), null === this.Ra && (this.Ra = new Nl()), this.Ra.F = a, this.w(), this.g(\"segmentOffset\", b, a));\n      }\n    },\n    stretch: {\n      get: function get() {\n        return null !== this.A ? this.A.$f : Wk;\n      },\n      set: function set(a) {\n        var b = this.stretch;\n        b !== a && (al(this), this.A.$f = a, this.w(), this.g(\"stretch\", b, a));\n      }\n    },\n    name: {\n      get: function get() {\n        return null !== this.A ? this.A.va : \"\";\n      },\n      set: function set(a) {\n        var b = this.name;\n        b !== a && (al(this), this.A.va = a, null !== this.part && (this.part.Kh = null), this.g(\"name\", b, a));\n      }\n    },\n    opacity: {\n      get: function get() {\n        return this.tb;\n      },\n      set: function set(a) {\n        var b = this.tb;\n        b !== a && ((0 > a || 1 < a) && wa(a, \"0 <= value <= 1\", Y, \"opacity\"), this.tb = a, this.g(\"opacity\", b, a), a = this.diagram, b = this.part, null !== a && null !== b && a.N(yj(b, b.actualBounds)));\n      }\n    },\n    visible: {\n      get: function get() {\n        return 0 !== (this.o & 1);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.o & 1);\n        b !== a && (this.o ^= 1, this.g(\"visible\", b, a), b = this.panel, null !== b ? b.w() : this.li() && this.Ub(a), this.N(), El(this));\n      }\n    },\n    pickable: {\n      get: function get() {\n        return 0 !== (this.o & 2);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.o & 2);\n        b !== a && (this.o ^= 2, this.g(\"pickable\", b, a));\n      }\n    },\n    fromLinkableDuplicates: {\n      get: function get() {\n        return 0 !== (this.o & 4);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.o & 4);\n        b !== a && (this.o ^= 4, this.g(\"fromLinkableDuplicates\", b, a));\n      }\n    },\n    fromLinkableSelfNode: {\n      get: function get() {\n        return 0 !== (this.o & 8);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.o & 8);\n        b !== a && (this.o ^= 8, this.g(\"fromLinkableSelfNode\", b, a));\n      }\n    },\n    toLinkableDuplicates: {\n      get: function get() {\n        return 0 !== (this.o & 16);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.o & 16);\n        b !== a && (this.o ^= 16, this.g(\"toLinkableDuplicates\", b, a));\n      }\n    },\n    toLinkableSelfNode: {\n      get: function get() {\n        return 0 !== (this.o & 32);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.o & 32);\n        b !== a && (this.o ^= 32, this.g(\"toLinkableSelfNode\", b, a));\n      }\n    },\n    isPanelMain: {\n      get: function get() {\n        return 0 !== (this.o & 64);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.o & 64);\n        b !== a && (this.o ^= 64, this.w(), this.g(\"isPanelMain\", b, a));\n      }\n    },\n    isActionable: {\n      get: function get() {\n        return 0 !== (this.o & 128);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.o & 128);\n        b !== a && (this.o ^= 128, this.g(\"isActionable\", b, a));\n      }\n    },\n    areaBackground: {\n      get: function get() {\n        return null !== this.A ? this.A.nb : null;\n      },\n      set: function set(a) {\n        var b = this.areaBackground;\n        b !== a && (null !== a && Ol(a, \"GraphObject.areaBackground\"), a instanceof ml && a.freeze(), al(this), this.A.nb = a, this.N(), this.g(\"areaBackground\", b, a));\n      }\n    },\n    background: {\n      get: function get() {\n        return this.Yb;\n      },\n      set: function set(a) {\n        var b = this.Yb;\n        b !== a && (null !== a && Ol(a, \"GraphObject.background\"), a instanceof ml && a.freeze(), this.Yb = a, this.N(), this.g(\"background\", b, a));\n      }\n    },\n    part: {\n      get: function get() {\n        if (this.li()) return this;\n        if (null !== this.jj) return this.jj;\n        var a;\n\n        for (a = this.panel; a;) {\n          if (a instanceof U) return this.jj = a;\n          a = a.panel;\n        }\n\n        return null;\n      }\n    },\n    svg: {\n      get: function get() {\n        return this.kr;\n      },\n      set: function set(a) {\n        this.kr = a;\n      }\n    },\n    panel: {\n      get: function get() {\n        return this.Uf;\n      }\n    },\n    layer: {\n      get: function get() {\n        var a = this.part;\n        return null !== a ? a.layer : null;\n      }\n    },\n    diagram: {\n      get: function get() {\n        var a = this.part;\n        return null !== a ? a.diagram : null;\n      }\n    },\n    position: {\n      get: function get() {\n        return this.pa;\n      },\n      set: function set(a) {\n        var b = a.x,\n            c = a.y,\n            d = this.pa,\n            e = d.x;\n        d = d.y;\n        (e === b || isNaN(e) && isNaN(b)) && (d === c || isNaN(d) && isNaN(c)) ? this.ns() : (a = a.copy(), this.fv(a, e, d) && this.g(\"position\", new I(e, d), a));\n      }\n    },\n    actualBounds: {\n      get: function get() {\n        return this.Eb;\n      }\n    },\n    scale: {\n      get: function get() {\n        return this.xa;\n      },\n      set: function set(a) {\n        var b = this.xa;\n        b !== a && (0 >= a && C(\"GraphObject.scale for \" + this + \" must be greater than zero, not: \" + a), this.xa = a, this.w(), this.g(\"scale\", b, a));\n      }\n    },\n    angle: {\n      get: function get() {\n        return this.Gb;\n      },\n      set: function set(a) {\n        var b = this.Gb;\n        b !== a && (a %= 360, 0 > a && (a += 360), b !== a && (this.Gb = a, El(this), this.w(), this.g(\"angle\", b, a)));\n      }\n    },\n    desiredSize: {\n      get: function get() {\n        return this.$c;\n      },\n      set: function set(a) {\n        var b = a.width,\n            c = a.height,\n            d = this.$c,\n            e = d.width,\n            f = d.height;\n        (e === b || isNaN(e) && isNaN(b)) && (f === c || isNaN(f) && isNaN(c)) || (this.$c = a = a.J(), this.w(), this instanceof Cf && this.mc(), this.g(\"desiredSize\", d, a), dl(this) && (a = this.part, null !== a && (el(this, a, \"width\"), el(this, a, \"height\"))));\n      }\n    },\n    width: {\n      get: function get() {\n        return this.$c.width;\n      },\n      set: function set(a) {\n        var b = this.$c.width;\n        b === a || isNaN(b) && isNaN(a) || (b = this.$c, this.$c = a = new K(a, this.$c.height).freeze(), this.w(), this instanceof Cf && this.mc(), this.g(\"desiredSize\", b, a), dl(this) && (a = this.part, null !== a && el(this, a, \"width\")));\n      }\n    },\n    height: {\n      get: function get() {\n        return this.$c.height;\n      },\n      set: function set(a) {\n        var b = this.$c.height;\n        b === a || isNaN(b) && isNaN(a) || (b = this.$c, this.$c = a = new K(this.$c.width, a).freeze(), this.w(), this instanceof Cf && this.mc(), this.g(\"desiredSize\", b, a), dl(this) && (a = this.part, null !== a && el(this, a, \"height\")));\n      }\n    },\n    minSize: {\n      get: function get() {\n        return null !== this.A ? this.A.u : Db;\n      },\n      set: function set(a) {\n        var b = this.minSize;\n        b.C(a) || (a = a.copy(), isNaN(a.width) && (a.width = 0), isNaN(a.height) && (a.height = 0), a.freeze(), al(this), this.A.u = a, this.w(), this.g(\"minSize\", b, a));\n      }\n    },\n    maxSize: {\n      get: function get() {\n        return null !== this.A ? this.A.m : Lb;\n      },\n      set: function set(a) {\n        var b = this.maxSize;\n        b.C(a) || (a = a.copy(), isNaN(a.width) && (a.width = Infinity), isNaN(a.height) && (a.height = Infinity), a.freeze(), al(this), this.A.m = a, this.w(), this.g(\"maxSize\", b, a));\n      }\n    },\n    measuredBounds: {\n      get: function get() {\n        return this.qc;\n      }\n    },\n    naturalBounds: {\n      get: function get() {\n        return this.bc;\n      }\n    },\n    margin: {\n      get: function get() {\n        return this.Ag;\n      },\n      set: function set(a) {\n        \"number\" === typeof a && (a = new ec(a));\n        var b = this.Ag;\n        b.C(a) || (this.Ag = a = a.J(), this.w(), this.g(\"margin\", b, a));\n      }\n    },\n    transform: {\n      get: function get() {\n        0 !== (this.o & 2048) === !0 && ol(this);\n        return this.Bb;\n      }\n    },\n    ge: {\n      get: function get() {\n        0 !== (this.o & 4096) === !0 && ol(this);\n        return this.lh;\n      }\n    },\n    animationTriggers: {\n      get: function get() {\n        return null !== this.A ? this.A.cb : null;\n      },\n      set: function set(a) {\n        this.animationTriggers !== a && (al(this), this.A.cb = a);\n      }\n    },\n    reshapingBehavior: {\n      get: function get() {\n        return null !== this.A ? this.A.ui : lg;\n      },\n      set: function set(a) {\n        this.reshapingBehavior !== a && (al(this), this.A.ui = a);\n      }\n    },\n    alignment: {\n      get: function get() {\n        return this.Fb;\n      },\n      set: function set(a) {\n        var b = this.Fb;\n        b.C(a) || (a.Fc() && !a.Sb() && C(\"GraphObject.alignment for \" + this + \" must be a real Spot or Spot.Default, not: \" + a), this.Fb = a = a.J(), zl(this), this.g(\"alignment\", b, a));\n      }\n    },\n    column: {\n      get: function get() {\n        return this.rg;\n      },\n      set: function set(a) {\n        a = Math.round(a);\n        var b = this.rg;\n        b !== a && (0 > a && wa(a, \">= 0\", Y, \"column\"), this.rg = a, this.w(), this.g(\"column\", b, a));\n      }\n    },\n    columnSpan: {\n      get: function get() {\n        return null !== this.A ? this.A.Db : 1;\n      },\n      set: function set(a) {\n        a = Math.round(a);\n        var b = this.columnSpan;\n        b !== a && (1 > a && wa(a, \">= 1\", Y, \"columnSpan\"), al(this), this.A.Db = a, this.w(), this.g(\"columnSpan\", b, a));\n      }\n    },\n    row: {\n      get: function get() {\n        return this.Ln;\n      },\n      set: function set(a) {\n        a = Math.round(a);\n        var b = this.Ln;\n        b !== a && (0 > a && wa(a, \">= 0\", Y, \"row\"), this.Ln = a, this.w(), this.g(\"row\", b, a));\n      }\n    },\n    rowSpan: {\n      get: function get() {\n        return null !== this.A ? this.A.vi : 1;\n      },\n      set: function set(a) {\n        a = Math.round(a);\n        var b = this.rowSpan;\n        b !== a && (1 > a && wa(a, \">= 1\", Y, \"rowSpan\"), al(this), this.A.vi = a, this.w(), this.g(\"rowSpan\", b, a));\n      }\n    },\n    spanAllocation: {\n      get: function get() {\n        return null !== this.A ? this.A.xi : null;\n      },\n      set: function set(a) {\n        var b = this.spanAllocation;\n        b !== a && (al(this), this.A.xi = a, this.w(), this.g(\"spanAllocation\", b, a));\n      }\n    },\n    alignmentFocus: {\n      get: function get() {\n        return this.fk;\n      },\n      set: function set(a) {\n        var b = this.fk;\n        b.C(a) || (this.fk = a = a.J(), this.w(), this.g(\"alignmentFocus\", b, a));\n      }\n    },\n    portId: {\n      get: function get() {\n        return this.Gn;\n      },\n      set: function set(a) {\n        var b = this.Gn;\n\n        if (b !== a) {\n          var c = this.part;\n          null === c || c instanceof V || C(\"Cannot set portID on a Link: \" + a);\n          null !== b && null !== c && Pl(c, this);\n          this.Gn = a;\n          null !== a && null !== c && (c.He = !0, Ql(c, this));\n          this.g(\"portId\", b, a);\n        }\n      }\n    },\n    toSpot: {\n      get: function get() {\n        return null !== this.aa ? this.aa.tj : sc;\n      },\n      set: function set(a) {\n        var b = this.toSpot;\n        b.C(a) || (a = a.J(), this.Rc(), this.aa.tj = a, this.g(\"toSpot\", b, a), Dl(this));\n      }\n    },\n    toEndSegmentLength: {\n      get: function get() {\n        return null !== this.aa ? this.aa.rj : 10;\n      },\n      set: function set(a) {\n        var b = this.toEndSegmentLength;\n        b !== a && (0 > a && wa(a, \">= 0\", Y, \"toEndSegmentLength\"), this.Rc(), this.aa.rj = a, this.g(\"toEndSegmentLength\", b, a), Dl(this));\n      }\n    },\n    toShortLength: {\n      get: function get() {\n        return null !== this.aa ? this.aa.sj : 0;\n      },\n      set: function set(a) {\n        var b = this.toShortLength;\n        b !== a && (this.Rc(), this.aa.sj = a, this.g(\"toShortLength\", b, a), Dl(this));\n      }\n    },\n    toLinkable: {\n      get: function get() {\n        return null !== this.aa ? this.aa.sr : null;\n      },\n      set: function set(a) {\n        var b = this.toLinkable;\n        b !== a && (this.Rc(), this.aa.sr = a, this.g(\"toLinkable\", b, a));\n      }\n    },\n    toMaxLinks: {\n      get: function get() {\n        return null !== this.aa ? this.aa.tr : Infinity;\n      },\n      set: function set(a) {\n        var b = this.toMaxLinks;\n        b !== a && (0 > a && wa(a, \">= 0\", Y, \"toMaxLinks\"), this.Rc(), this.aa.tr = a, this.g(\"toMaxLinks\", b, a));\n      }\n    },\n    fromSpot: {\n      get: function get() {\n        return null !== this.aa ? this.aa.Qi : sc;\n      },\n      set: function set(a) {\n        var b = this.fromSpot;\n        b.C(a) || (a = a.J(), this.Rc(), this.aa.Qi = a, this.g(\"fromSpot\", b, a), Dl(this));\n      }\n    },\n    fromEndSegmentLength: {\n      get: function get() {\n        return null !== this.aa ? this.aa.Oi : 10;\n      },\n      set: function set(a) {\n        var b = this.fromEndSegmentLength;\n        b !== a && (0 > a && wa(a, \">= 0\", Y, \"fromEndSegmentLength\"), this.Rc(), this.aa.Oi = a, this.g(\"fromEndSegmentLength\", b, a), Dl(this));\n      }\n    },\n    fromShortLength: {\n      get: function get() {\n        return null !== this.aa ? this.aa.Pi : 0;\n      },\n      set: function set(a) {\n        var b = this.fromShortLength;\n        b !== a && (this.Rc(), this.aa.Pi = a, this.g(\"fromShortLength\", b, a), Dl(this));\n      }\n    },\n    fromLinkable: {\n      get: function get() {\n        return null !== this.aa ? this.aa.Kp : null;\n      },\n      set: function set(a) {\n        var b = this.fromLinkable;\n        b !== a && (this.Rc(), this.aa.Kp = a, this.g(\"fromLinkable\", b, a));\n      }\n    },\n    fromMaxLinks: {\n      get: function get() {\n        return null !== this.aa ? this.aa.Lp : Infinity;\n      },\n      set: function set(a) {\n        var b = this.fromMaxLinks;\n        b !== a && (0 > a && wa(a, \">= 0\", Y, \"fromMaxLinks\"), this.Rc(), this.aa.Lp = a, this.g(\"fromMaxLinks\", b, a));\n      }\n    },\n    cursor: {\n      get: function get() {\n        return null !== this.A ? this.A.j : \"\";\n      },\n      set: function set(a) {\n        var b = this.cursor;\n        b !== a && (al(this), this.A.j = a, this.g(\"cursor\", b, a));\n      }\n    },\n    click: {\n      get: function get() {\n        return null !== this.A ? this.A.oh : null;\n      },\n      set: function set(a) {\n        var b = this.click;\n        b !== a && (al(this), this.A.oh = a, this.g(\"click\", b, a));\n      }\n    },\n    doubleClick: {\n      get: function get() {\n        return null !== this.A ? this.A.uh : null;\n      },\n      set: function set(a) {\n        var b = this.doubleClick;\n        b !== a && (al(this), this.A.uh = a, this.g(\"doubleClick\", b, a));\n      }\n    },\n    contextClick: {\n      get: function get() {\n        return null !== this.A ? this.A.qh : null;\n      },\n      set: function set(a) {\n        var b = this.contextClick;\n        b !== a && (al(this), this.A.qh = a, this.g(\"contextClick\", b, a));\n      }\n    },\n    mouseEnter: {\n      get: function get() {\n        return null !== this.A ? this.A.Fh : null;\n      },\n      set: function set(a) {\n        var b = this.mouseEnter;\n        b !== a && (al(this), this.A.Fh = a, this.g(\"mouseEnter\", b, a));\n      }\n    },\n    mouseLeave: {\n      get: function get() {\n        return null !== this.A ? this.A.Ih : null;\n      },\n      set: function set(a) {\n        var b = this.mouseLeave;\n        b !== a && (al(this), this.A.Ih = a, this.g(\"mouseLeave\", b, a));\n      }\n    },\n    mouseOver: {\n      get: function get() {\n        return null !== this.A ? this.A.Jh : null;\n      },\n      set: function set(a) {\n        var b = this.mouseOver;\n        b !== a && (al(this), this.A.Jh = a, this.g(\"mouseOver\", b, a));\n      }\n    },\n    mouseHover: {\n      get: function get() {\n        return null !== this.A ? this.A.Hh : null;\n      },\n      set: function set(a) {\n        var b = this.mouseHover;\n        b !== a && (al(this), this.A.Hh = a, this.g(\"mouseHover\", b, a));\n      }\n    },\n    mouseHold: {\n      get: function get() {\n        return null !== this.A ? this.A.Gh : null;\n      },\n      set: function set(a) {\n        var b = this.mouseHold;\n        b !== a && (al(this), this.A.Gh = a, this.g(\"mouseHold\", b, a));\n      }\n    },\n    mouseDragEnter: {\n      get: function get() {\n        return null !== this.A ? this.A.Qd : null;\n      },\n      set: function set(a) {\n        var b = this.mouseDragEnter;\n        b !== a && (al(this), this.A.Qd = a, this.g(\"mouseDragEnter\", b, a));\n      }\n    },\n    mouseDragLeave: {\n      get: function get() {\n        return null !== this.A ? this.A.Gf : null;\n      },\n      set: function set(a) {\n        var b = this.mouseDragLeave;\n        b !== a && (al(this), this.A.Gf = a, this.g(\"mouseDragLeave\", b, a));\n      }\n    },\n    mouseDrop: {\n      get: function get() {\n        return null !== this.A ? this.A.Eh : null;\n      },\n      set: function set(a) {\n        var b = this.mouseDrop;\n        b !== a && (al(this), this.A.Eh = a, this.g(\"mouseDrop\", b, a));\n      }\n    },\n    actionDown: {\n      get: function get() {\n        return null !== this.A ? this.A.W : null;\n      },\n      set: function set(a) {\n        var b = this.actionDown;\n        b !== a && (al(this), this.A.W = a, this.g(\"actionDown\", b, a));\n      }\n    },\n    actionMove: {\n      get: function get() {\n        return null !== this.A ? this.A.ga : null;\n      },\n      set: function set(a) {\n        var b = this.actionMove;\n        b !== a && (al(this), this.A.ga = a, this.g(\"actionMove\", b, a));\n      }\n    },\n    actionUp: {\n      get: function get() {\n        return null !== this.A ? this.A.Ga : null;\n      },\n      set: function set(a) {\n        var b = this.actionUp;\n        b !== a && (al(this), this.A.Ga = a, this.g(\"actionUp\", b, a));\n      }\n    },\n    actionCancel: {\n      get: function get() {\n        return null !== this.A ? this.A.F : null;\n      },\n      set: function set(a) {\n        var b = this.actionCancel;\n        b !== a && (al(this), this.A.F = a, this.g(\"actionCancel\", b, a));\n      }\n    },\n    toolTip: {\n      get: function get() {\n        return null !== this.A ? this.A.Th : null;\n      },\n      set: function set(a) {\n        var b = this.toolTip;\n        b !== a && (al(this), this.A.Th = a, this.g(\"toolTip\", b, a));\n      }\n    },\n    contextMenu: {\n      get: function get() {\n        return null !== this.A ? this.A.rh : null;\n      },\n      set: function set(a) {\n        var b = this.contextMenu;\n        b !== a && (al(this), this.A.rh = a, this.g(\"contextMenu\", b, a));\n      }\n    }\n  });\n  Y.prototype.trigger = Y.prototype.mv;\n  Y.prototype.findBindingPanel = Y.prototype.Yg;\n  Y.prototype.findTemplateBinder = Y.prototype.Yy;\n  Y.prototype.setProperties = Y.prototype.Vl;\n  Y.prototype.apply = Y.prototype.apply;\n  Y.prototype.attach = Y.prototype.ku;\n  Y.prototype.set = Y.prototype.set;\n  Y.prototype.isEnabledObject = Y.prototype.yf;\n  Y.prototype.isVisibleObject = Y.prototype.zf;\n  Y.prototype.isContainedBy = Y.prototype.jg;\n  Y.prototype.getNearestIntersectionPoint = Y.prototype.Or;\n  Y.prototype.getLocalPoint = Y.prototype.Nr;\n  Y.prototype.getDocumentScale = Y.prototype.uf;\n  Y.prototype.getDocumentAngle = Y.prototype.fi;\n  Y.prototype.getDocumentBounds = Y.prototype.gi;\n  Y.prototype.getDocumentPoint = Y.prototype.ia;\n  Y.prototype.intersectsRect = Y.prototype.Sc;\n  Y.prototype.containedInRect = Y.prototype.Wg;\n  Y.prototype.containsRect = Y.prototype.Ee;\n  Y.prototype.containsPoint = Y.prototype.ba;\n  Y.prototype.raiseChanged = Y.prototype.g;\n  Y.prototype.raiseChangedEvent = Y.prototype.bb;\n  Y.prototype.addCopyProperty = Y.prototype.zw;\n  var Il = null;\n  Y.className = \"GraphObject\";\n  Il = new pb();\n  Ll(\"Button\", function () {\n    function a(a, b) {\n      return null !== a.diagram.ec(a.documentPoint, function (a) {\n        for (; null !== a.panel && !a.isActionable;) {\n          a = a.panel;\n        }\n\n        return a;\n      }, function (a) {\n        return a === b;\n      });\n    }\n\n    var b = Hl(W, W.Auto, {\n      isActionable: !0,\n      enabledChanged: function enabledChanged(a, b) {\n        if (a instanceof W) {\n          var c = a.fb(\"ButtonBorder\");\n          null !== c && (c.fill = b ? a._buttonFillNormal : a._buttonFillDisabled);\n        }\n      },\n      cursor: \"pointer\",\n      _buttonFillNormal: \"#F5F5F5\",\n      _buttonStrokeNormal: \"#BDBDBD\",\n      _buttonFillOver: \"#E0E0E0\",\n      _buttonStrokeOver: \"#9E9E9E\",\n      _buttonFillPressed: \"#BDBDBD\",\n      _buttonStrokePressed: \"#9E9E9E\",\n      _buttonFillDisabled: \"#E5E5E5\"\n    }, Hl(Cf, {\n      name: \"ButtonBorder\",\n      figure: \"RoundedRectangle\",\n      spot1: new N(0, 0, 2.76142374915397, 2.761423749153969),\n      spot2: new N(1, 1, -2.76142374915397, -2.761423749153969),\n      parameter1: 2,\n      parameter2: 2,\n      fill: \"#F5F5F5\",\n      stroke: \"#BDBDBD\"\n    }));\n\n    b.mouseEnter = function (a, b) {\n      if (b.yf() && b instanceof W && (a = b.fb(\"ButtonBorder\"), a instanceof Cf)) {\n        var c = b._buttonFillOver;\n        b._buttonFillNormal = a.fill;\n        a.fill = c;\n        c = b._buttonStrokeOver;\n        b._buttonStrokeNormal = a.stroke;\n        a.stroke = c;\n      }\n    };\n\n    b.mouseLeave = function (a, b) {\n      b.yf() && b instanceof W && (a = b.fb(\"ButtonBorder\"), a instanceof Cf && (a.fill = b._buttonFillNormal, a.stroke = b._buttonStrokeNormal));\n    };\n\n    b.actionDown = function (a, b) {\n      if (b.yf() && b instanceof W && null !== b._buttonFillPressed && 0 === a.button) {\n        var c = b.fb(\"ButtonBorder\");\n\n        if (c instanceof Cf) {\n          a = a.diagram;\n          var d = a.skipsUndoManager;\n          a.skipsUndoManager = !0;\n          var g = b._buttonFillPressed;\n          b._buttonFillOver = c.fill;\n          c.fill = g;\n          g = b._buttonStrokePressed;\n          b._buttonStrokeOver = c.stroke;\n          c.stroke = g;\n          a.skipsUndoManager = d;\n        }\n      }\n    };\n\n    b.actionUp = function (b, d) {\n      if (d.yf() && d instanceof W && null !== d._buttonFillPressed && 0 === b.button) {\n        var c = d.fb(\"ButtonBorder\");\n\n        if (c instanceof Cf) {\n          var f = b.diagram,\n              g = f.skipsUndoManager;\n          f.skipsUndoManager = !0;\n          a(b, d) ? (c.fill = d._buttonFillOver, c.stroke = d._buttonStrokeOver) : (c.fill = d._buttonFillNormal, c.stroke = d._buttonStrokeNormal);\n          f.skipsUndoManager = g;\n        }\n      }\n    };\n\n    b.actionCancel = function (b, d) {\n      if (d.yf() && d instanceof W && null !== d._buttonFillPressed) {\n        var c = d.fb(\"ButtonBorder\");\n\n        if (c instanceof Cf) {\n          var f = b.diagram,\n              g = f.skipsUndoManager;\n          f.skipsUndoManager = !0;\n          a(b, d) ? (c.fill = d._buttonFillOver, c.stroke = d._buttonStrokeOver) : (c.fill = d._buttonFillNormal, c.stroke = d._buttonStrokeNormal);\n          f.skipsUndoManager = g;\n        }\n      }\n    };\n\n    b.actionMove = function (b, d) {\n      if (d.yf() && d instanceof W && null !== d._buttonFillPressed) {\n        var c = b.diagram;\n\n        if (0 === c.firstInput.button && (c.currentTool.standardMouseOver(), a(b, d) && (b = d.fb(\"ButtonBorder\"), b instanceof Cf))) {\n          var f = c.skipsUndoManager;\n          c.skipsUndoManager = !0;\n          var g = d._buttonFillPressed;\n          b.fill !== g && (b.fill = g);\n          g = d._buttonStrokePressed;\n          b.stroke !== g && (b.stroke = g);\n          c.skipsUndoManager = f;\n        }\n      }\n    };\n\n    return b;\n  });\n  Ll(\"TreeExpanderButton\", function () {\n    var a = Hl(\"Button\", {\n      _treeExpandedFigure: \"MinusLine\",\n      _treeCollapsedFigure: \"PlusLine\"\n    }, Hl(Cf, {\n      name: \"ButtonIcon\",\n      figure: \"MinusLine\",\n      stroke: \"#424242\",\n      strokeWidth: 2,\n      desiredSize: Jb\n    }, new wi(\"figure\", \"isTreeExpanded\", function (a, c) {\n      c = c.panel;\n      return a ? c._treeExpandedFigure : c._treeCollapsedFigure;\n    }).Fo()), {\n      visible: !1\n    }, new wi(\"visible\", \"isTreeLeaf\", function (a) {\n      return !a;\n    }).Fo());\n\n    a.click = function (a, c) {\n      c = c.part;\n      c instanceof ue && (c = c.adornedPart);\n\n      if (c instanceof V) {\n        var b = c.diagram;\n\n        if (null !== b) {\n          b = b.commandHandler;\n\n          if (c.isTreeExpanded) {\n            if (!b.canCollapseTree(c)) return;\n          } else if (!b.canExpandTree(c)) return;\n\n          a.handled = !0;\n          c.isTreeExpanded ? b.collapseTree(c) : b.expandTree(c);\n        }\n      }\n    };\n\n    return a;\n  });\n  Ll(\"SubGraphExpanderButton\", function () {\n    var a = Hl(\"Button\", {\n      _subGraphExpandedFigure: \"MinusLine\",\n      _subGraphCollapsedFigure: \"PlusLine\"\n    }, Hl(Cf, {\n      name: \"ButtonIcon\",\n      figure: \"MinusLine\",\n      stroke: \"#424242\",\n      strokeWidth: 2,\n      desiredSize: Jb\n    }, new wi(\"figure\", \"isSubGraphExpanded\", function (a, c) {\n      c = c.panel;\n      return a ? c._subGraphExpandedFigure : c._subGraphCollapsedFigure;\n    }).Fo()));\n\n    a.click = function (a, c) {\n      c = c.part;\n      c instanceof ue && (c = c.adornedPart);\n\n      if (c instanceof qf) {\n        var b = c.diagram;\n\n        if (null !== b) {\n          b = b.commandHandler;\n\n          if (c.isSubGraphExpanded) {\n            if (!b.canCollapseSubGraph(c)) return;\n          } else if (!b.canExpandSubGraph(c)) return;\n\n          a.handled = !0;\n          c.isSubGraphExpanded ? b.collapseSubGraph(c) : b.expandSubGraph(c);\n        }\n      }\n    };\n\n    return a;\n  });\n  Ll(\"ToolTip\", function () {\n    return Hl(ue, W.Auto, {\n      isShadowed: !0,\n      shadowColor: \"rgba(0, 0, 0, .4)\",\n      shadowOffset: new I(0, 3),\n      shadowBlur: 5\n    }, Hl(Cf, {\n      name: \"Border\",\n      figure: \"RoundedRectangle\",\n      parameter1: 1,\n      parameter2: 1,\n      fill: \"#F5F5F5\",\n      stroke: \"#F0F0F0\",\n      spot1: new N(0, 0, 4, 6),\n      spot2: new N(1, 1, -4, -4)\n    }));\n  });\n  Ll(\"ContextMenu\", function () {\n    return Hl(ue, W.Vertical, {\n      background: \"#F5F5F5\",\n      isShadowed: !0,\n      shadowColor: \"rgba(0, 0, 0, .4)\",\n      shadowOffset: new I(0, 3),\n      shadowBlur: 5\n    }, new wi(\"background\", \"\", function (a) {\n      return null !== a.adornedPart && null !== a.placeholder ? null : \"#F5F5F5\";\n    }));\n  });\n  Ll(\"ContextMenuButton\", function () {\n    var a = Hl(\"Button\");\n    a.stretch = Uk;\n    var b = a.fb(\"ButtonBorder\");\n    b instanceof Cf && (b.figure = \"Rectangle\", b.strokeWidth = 0, b.spot1 = new N(0, 0, 2, 3), b.spot2 = new N(1, 1, -2, -2));\n    return a;\n  });\n  Ll(\"PanelExpanderButton\", function (a) {\n    var b = Ml(a, \"COLLAPSIBLE\"),\n        c = Hl(\"Button\", {\n      _buttonExpandedFigure: \"M0 0 M0 6 L4 2 8 6 M8 8\",\n      _buttonCollapsedFigure: \"M0 0 M0 2 L4 6 8 2 M8 8\",\n      _buttonFillNormal: \"rgba(0, 0, 0, 0)\",\n      _buttonStrokeNormal: null,\n      _buttonFillOver: \"rgba(0, 0, 0, .2)\",\n      _buttonStrokeOver: null,\n      _buttonFillPressed: \"rgba(0, 0, 0, .4)\",\n      _buttonStrokePressed: null\n    }, Hl(Cf, {\n      name: \"ButtonIcon\",\n      strokeWidth: 2\n    }, new wi(\"geometryString\", \"visible\", function (a) {\n      return a ? c._buttonExpandedFigure : c._buttonCollapsedFigure;\n    }).Fo(b)));\n    a = c.fb(\"ButtonBorder\");\n    a instanceof Cf && (a.stroke = null, a.fill = \"rgba(0, 0, 0, 0)\");\n\n    c.click = function (a, c) {\n      var d = c.diagram;\n\n      if (null !== d && !d.isReadOnly) {\n        var e = c.Yg();\n        null === e && (e = c.part);\n        null !== e && (c = e.fb(b), null !== c && (a.handled = !0, d.Da(\"Collapse/Expand Panel\"), c.visible = !c.visible, d.eb(\"Collapse/Expand Panel\")));\n      }\n    };\n\n    return c;\n  });\n  Ll(\"CheckBoxButton\", function (a) {\n    var b = Ml(a);\n    a = Hl(\"Button\", {\n      desiredSize: new K(14, 14)\n    }, Hl(Cf, {\n      name: \"ButtonIcon\",\n      geometryString: \"M0 0 M0 8.85 L4.9 13.75 16.2 2.45 M16.2 16.2\",\n      strokeWidth: 2,\n      stretch: td,\n      geometryStretch: ng,\n      visible: !1\n    }, \"\" !== b ? new wi(\"visible\", b).px() : []));\n\n    a.click = function (a, d) {\n      if (d instanceof W) {\n        var c = a.diagram;\n\n        if (!(null === c || c.isReadOnly || \"\" !== b && c.model.isReadOnly)) {\n          a.handled = !0;\n          var f = d.fb(\"ButtonIcon\");\n          c.Da(\"checkbox\");\n          f.visible = !f.visible;\n          \"function\" === typeof d._doClick && d._doClick(a, d);\n          c.eb(\"checkbox\");\n        }\n      }\n    };\n\n    return a;\n  });\n  Ll(\"CheckBox\", function (a) {\n    a = Ml(a);\n    a = Hl(\"CheckBoxButton\", a, {\n      name: \"Button\",\n      isActionable: !1,\n      margin: new ec(0, 1, 0, 0)\n    });\n    var b = Hl(W, \"Horizontal\", a, {\n      isActionable: !0,\n      cursor: a.cursor,\n      margin: 1,\n      _buttonFillNormal: a._buttonFillNormal,\n      _buttonStrokeNormal: a._buttonStrokeNormal,\n      _buttonFillOver: a._buttonFillOver,\n      _buttonStrokeOver: a._buttonStrokeOver,\n      _buttonFillPressed: a._buttonFillPressed,\n      _buttonStrokePressed: a._buttonStrokePressed,\n      _buttonFillDisabled: a._buttonFillDisabled,\n      mouseEnter: a.mouseEnter,\n      mouseLeave: a.mouseLeave,\n      actionDown: a.actionDown,\n      actionUp: a.actionUp,\n      actionCancel: a.actionCancel,\n      actionMove: a.actionMove,\n      click: a.click,\n      _buttonClick: a.click\n    });\n    a.mouseEnter = null;\n    a.mouseLeave = null;\n    a.actionDown = null;\n    a.actionUp = null;\n    a.actionCancel = null;\n    a.actionMove = null;\n    a.click = null;\n    return b;\n  });\n  Y.None = lg = new D(Y, \"None\", 0);\n  Y.Default = Wk = new D(Y, \"Default\", 0);\n  Y.Vertical = Vk = new D(Y, \"Vertical\", 4);\n  Y.Horizontal = Uk = new D(Y, \"Horizontal\", 5);\n  Y.Fill = td = new D(Y, \"Fill\", 3);\n  Y.Uniform = ng = new D(Y, \"Uniform\", 1);\n  Y.UniformToFill = Xk = new D(Y, \"UniformToFill\", 2);\n  Y.FlipVertical = Yk = new D(Y, \"FlipVertical\", 1);\n  Y.FlipHorizontal = Zk = new D(Y, \"FlipHorizontal\", 2);\n  Y.FlipBoth = $k = new D(Y, \"FlipBoth\", 3);\n  Y.make = Hl;\n\n  Y.getBuilders = function () {\n    var a = new pb(),\n        b;\n\n    for (b in Il) {\n      if (b !== b.toLowerCase()) {\n        var c = Il.I(b);\n        \"function\" === typeof c && a.add(b, c);\n      }\n    }\n\n    a.freeze();\n    return a;\n  };\n\n  Y.defineBuilder = Ll;\n\n  Y.build = function (a, b) {\n    var c = Il.I(a);\n    if (\"function\" === typeof c && (c = c(null), c instanceof Y)) return b && c.set(b), c;\n    C('GraphObject.build invoked object builder \"' + a + '\", but it did not return an Object');\n  };\n\n  Y.takeBuilderArgument = Ml;\n\n  function bl() {\n    this.ic = !1;\n    this.va = \"\";\n    this.bp = -1;\n    this.hb = this.Wo = this.Ff = null;\n    this.j = \"\";\n    this.cb = this.xi = this.Hc = this.rh = this.Th = this.F = this.Ga = this.ga = this.W = this.Eh = this.Gf = this.Qd = this.Gh = this.Hh = this.Jh = this.Ih = this.Fh = this.qh = this.uh = this.oh = null;\n    this.u = Db;\n    this.m = Lb;\n    this.$f = Wk;\n    this.Db = this.vi = 1;\n    this.ui = lg;\n    this.le = this.wi = this.nb = null;\n    this.Ic = \"category\";\n  }\n\n  bl.prototype.copy = function () {\n    var a = new bl();\n    a.va = this.va;\n    a.bp = this.bp;\n    a.Ff = this.Ff;\n    a.hb = this.hb;\n    a.j = this.j;\n    a.oh = this.oh;\n    a.uh = this.uh;\n    a.qh = this.qh;\n    a.Fh = this.Fh;\n    a.Ih = this.Ih;\n    a.Jh = this.Jh;\n    a.Hh = this.Hh;\n    a.Gh = this.Gh;\n    a.Qd = this.Qd;\n    a.Gf = this.Gf;\n    a.Eh = this.Eh;\n    a.W = this.W;\n    a.ga = this.ga;\n    a.Ga = this.Ga;\n    a.F = this.F;\n    a.Th = this.Th;\n    a.rh = this.rh;\n    a.Hc = this.Hc;\n    a.xi = this.xi;\n    a.cb = this.cb;\n    a.u = this.u.J();\n    a.m = this.m.J();\n    a.$f = this.$f;\n    a.vi = this.vi;\n    a.Db = this.Db;\n    a.ui = this.ui;\n    a.nb = this.nb;\n    a.wi = this.wi;\n    a.le = this.le;\n    a.Ic = this.Ic;\n    return a;\n  };\n\n  function Nl() {\n    this.u = -Infinity;\n    this.m = 0;\n    this.F = qb;\n    this.Oq = $f;\n    this.j = this.W = \"None\";\n  }\n\n  Nl.prototype.copy = function () {\n    var a = new Nl();\n    a.u = this.u;\n    a.m = this.m;\n    a.F = this.F.J();\n    a.Oq = this.Oq;\n    a.W = this.W;\n    a.j = this.j;\n    return a;\n  };\n\n  Nl.className = \"LinkElementSettings\";\n\n  function cl() {\n    this.tj = this.Qi = Wc;\n    this.sj = this.Pi = this.rj = this.Oi = NaN;\n    this.sr = this.Kp = null;\n    this.tr = this.Lp = Infinity;\n  }\n\n  cl.prototype.copy = function () {\n    var a = new cl();\n    a.Qi = this.Qi.J();\n    a.tj = this.tj.J();\n    a.Oi = this.Oi;\n    a.rj = this.rj;\n    a.Pi = this.Pi;\n    a.sj = this.sj;\n    a.Kp = this.Kp;\n    a.sr = this.sr;\n    a.Lp = this.Lp;\n    a.tr = this.tr;\n    return a;\n  };\n\n  cl.className = \"LinkSettings\";\n\n  function Rl() {\n    this.Ta = [1, 0, 0, 1, 0, 0];\n  }\n\n  Rl.prototype.copy = function () {\n    var a = new Rl();\n    a.Ta[0] = this.Ta[0];\n    a.Ta[1] = this.Ta[1];\n    a.Ta[2] = this.Ta[2];\n    a.Ta[3] = this.Ta[3];\n    a.Ta[4] = this.Ta[4];\n    a.Ta[5] = this.Ta[5];\n    return a;\n  };\n\n  Rl.prototype.translate = function (a, b) {\n    this.Ta[4] += this.Ta[0] * a + this.Ta[2] * b;\n    this.Ta[5] += this.Ta[1] * a + this.Ta[3] * b;\n  };\n\n  Rl.prototype.scale = function (a, b) {\n    this.Ta[0] *= a;\n    this.Ta[1] *= a;\n    this.Ta[2] *= b;\n    this.Ta[3] *= b;\n  };\n\n  Rl.className = \"STransform\";\n\n  function Sl(a) {\n    this.type = a;\n    this.r2 = this.y2 = this.x2 = this.r1 = this.y1 = this.x1 = 0;\n    this.Jw = [];\n    this.pattern = null;\n  }\n\n  Sl.prototype.addColorStop = function (a, b) {\n    this.Jw.push({\n      offset: a,\n      color: b\n    });\n  };\n\n  Sl.className = \"SGradient\";\n\n  function xj(a, b) {\n    this.ownerDocument = a = void 0 === b ? x.document : b;\n    this.Jz = \"http://www.w3.org/2000/svg\";\n    void 0 !== a && (this.Sa = this.Vb(\"svg\", {\n      width: \"1px\",\n      height: \"1px\",\n      viewBox: \"0 0 1 1\"\n    }), this.Sa.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns\", \"http://www.w3.org/2000/svg\"), this.Sa.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\"));\n    this.po = null;\n    this.context = new Tl(this);\n  }\n\n  xj.prototype.resize = function (a, b, c, d) {\n    return this.width !== a || this.height !== b ? (this.style.width = c + \"px\", this.style.height = d + \"px\", this.Sa.setAttributeNS(null, \"width\", c + \"px\"), this.Sa.setAttributeNS(null, \"height\", d + \"px\"), this.Sa.setAttributeNS(null, \"viewBox\", \"0 0 \" + c + \" \" + d), this.context.bw.firstElementChild.setAttributeNS(null, \"width\", c + \"px\"), this.context.bw.firstElementChild.setAttributeNS(null, \"height\", d + \"px\"), !0) : !1;\n  };\n\n  xj.prototype.Vb = function (a, b, c) {\n    a = this.ownerDocument.createElementNS(this.Jz, a);\n    if (ya(b)) for (var d in b) {\n      a.setAttributeNS(\"href\" === d ? \"http://www.w3.org/1999/xlink\" : \"\", d, b[d]);\n    }\n    void 0 !== c && (a.textContent = c);\n    return a;\n  };\n\n  xj.prototype.getBoundingClientRect = function () {\n    return this.Sa.getBoundingClientRect();\n  };\n\n  xj.prototype.focus = function () {\n    this.Sa.focus();\n  };\n\n  xj.prototype.Pw = function () {\n    this.ownerDocument = null;\n  };\n\n  ma.Object.defineProperties(xj.prototype, {\n    width: {\n      get: function get() {\n        return this.Sa.width.baseVal.value;\n      },\n      set: function set(a) {\n        this.Sa.width = a;\n      }\n    },\n    height: {\n      get: function get() {\n        return this.Sa.height.baseVal.value;\n      },\n      set: function set(a) {\n        this.Sa.height = a;\n      }\n    },\n    style: {\n      get: function get() {\n        return this.Sa.style;\n      }\n    }\n  });\n  xj.className = \"SVGSurface\";\n\n  function Tl(a) {\n    this.qs = a;\n    this.svg = a.Sa;\n    this.stack = [];\n    this.md = [];\n    this.fillStyle = \"#000000\";\n    this.font = \"10px sans-serif\";\n    this.globalAlpha = 1;\n    this.lineCap = \"butt\";\n    this.lineDashOffset = 0;\n    this.lineJoin = \"miter\";\n    this.lineWidth = 1;\n    this.miterLimit = 10;\n    this.shadowBlur = 0;\n    this.shadowColor = \"rgba(0, 0, 0, 0)\";\n    this.shadowOffsetY = this.shadowOffsetX = 0;\n    this.strokeStyle = \"#000000\";\n    this.textAlign = \"start\";\n    this.clipInsteadOfFill = !1;\n    this.Lg = this.Yq = this.Xq = 0;\n    this.Xr = null;\n    this.path = [];\n    this.et = !1;\n    this.Og = null;\n    this.pj = 0;\n    this.Fe = new Rl();\n    Ul(this, 1, 0, 0, 1, 0, 0);\n    var b = kb++,\n        c = this.Vb(\"clipPath\", {\n      id: \"mainClip\" + b\n    });\n    c.appendChild(this.Vb(\"rect\", {\n      x: 0,\n      y: 0,\n      width: a.width,\n      height: a.height\n    }));\n    this.bw = c;\n    this.qs.Sa.appendChild(c);\n    this.md[0].setAttributeNS(null, \"clip-path\", \"url(#mainClip\" + b + \")\");\n    this.Lz = {};\n  }\n\n  t = Tl.prototype;\n\n  t.arc = function (a, b, c, d, e, f, g, h) {\n    var k = 2 * Math.PI,\n        l = k - 1E-6,\n        m = c * Math.cos(d),\n        n = c * Math.sin(d),\n        p = a + m,\n        r = b + n,\n        q = f ? 0 : 1;\n    d = f ? d - e : e - d;\n    (1E-6 < Math.abs(g - p) || 1E-6 < Math.abs(h - r)) && this.path.push([\"L\", p, +r]);\n    0 > d && (d = d % k + k);\n    d > l ? (this.path.push([\"A\", c, c, 0, 1, q, a - m, b - n]), this.path.push([\"A\", c, c, 0, 1, q, p, r])) : 1E-6 < d && this.path.push([\"A\", c, c, 0, +(d >= Math.PI), q, a + c * Math.cos(e), b + c * Math.sin(e)]);\n  };\n\n  t.beginPath = function () {\n    this.path = [];\n  };\n\n  t.bezierCurveTo = function (a, b, c, d, e, f) {\n    this.path.push([\"C\", a, b, c, d, e, f]);\n  };\n\n  t.clearRect = function () {};\n\n  t.clip = function () {\n    this.addPath(\"clipPath\", this.path, this.Fe);\n  };\n\n  t.closePath = function () {\n    this.path.push([\"z\"]);\n  };\n\n  t.createLinearGradient = function (a, b, c, d) {\n    var e = new Sl(\"linear\");\n    e.x1 = a;\n    e.y1 = b;\n    e.x2 = c;\n    e.y2 = d;\n    return e;\n  };\n\n  t.createPattern = function (a) {\n    var b = \"\";\n    a instanceof HTMLCanvasElement && (b = a.toDataURL());\n    a instanceof HTMLImageElement && (b = a.getAttribute(\"src\"));\n    var c = this.Lz;\n    if (c[b]) return \"url(#\" + c[b] + \")\";\n    var d = \"PATTERN\" + kb++,\n        e = {\n      x: 0,\n      y: 0,\n      width: a.width,\n      height: a.height,\n      href: b\n    };\n    a = this.Vb(\"pattern\", {\n      width: a.width,\n      height: a.height,\n      id: d,\n      patternUnits: \"userSpaceOnUse\"\n    });\n    a.appendChild(this.Vb(zk, e));\n    this.svg.appendChild(a);\n    c[b] = d;\n    return \"url(#\" + d + \")\";\n  };\n\n  t.createRadialGradient = function (a, b, c, d, e, f) {\n    var g = new Sl(\"radial\");\n    g.x1 = a;\n    g.y1 = b;\n    g.r1 = c;\n    g.x2 = d;\n    g.y2 = e;\n    g.r2 = f;\n    return g;\n  };\n\n  t.drawImage = function (a, b, c, d, e, f, g, h, k) {\n    var l = \"\";\n    a instanceof HTMLCanvasElement && (l = a.toDataURL());\n    a instanceof HTMLImageElement && (l = a.getAttribute(\"src\"));\n    var m = a instanceof HTMLImageElement ? a.naturalWidth : a.width,\n        n = a instanceof HTMLImageElement ? a.naturalHeight : a.height;\n    void 0 === d && (f = b, g = c, h = d = m, k = e = n);\n    d = d || 0;\n    e = e || 0;\n    f = f || 0;\n    g = g || 0;\n    h = h || 0;\n    k = k || 0;\n    a = {\n      x: 0,\n      y: 0,\n      width: m || d,\n      height: n || e,\n      href: l\n    };\n    J.ca(d, h) && J.ca(e, k) ? -1 === l.toLowerCase().indexOf(\".svg\") && -1 === l.toLowerCase().indexOf(\"data:image/svg\") && (a.preserveAspectRatio = \"xMidYMid slice\") : a.preserveAspectRatio = \"none\";\n    l = \"\";\n    h /= d;\n    k /= e;\n    if (0 !== f || 0 !== g) l += \" translate(\" + f + \", \" + g + \")\";\n    if (1 !== h || 1 !== k) l += \" scale(\" + h + \", \" + k + \")\";\n    if (0 !== b || 0 !== c) l += \" translate(\" + -b + \", \" + -c + \")\";\n    if (0 !== b || 0 !== c || d !== m || e !== n) f = \"CLIP\" + kb++, g = this.Vb(\"clipPath\", {\n      id: f\n    }), g.appendChild(this.Vb(\"rect\", {\n      x: b,\n      y: c,\n      width: d,\n      height: e\n    })), this.svg.appendChild(g), a[\"clip-path\"] = \"url(#\" + f + \")\";\n    Vl(this, zk, a, this.Fe, l);\n    this.addElement(zk, a);\n  };\n\n  t.fill = function () {\n    this.addPath(\"fill\", this.path, this.Fe);\n  };\n\n  t.sf = function () {\n    this.clipInsteadOfFill ? this.clip() : this.fill();\n  };\n\n  t.fillRect = function (a, b, c, d) {\n    a = [a, b, c, d];\n    a = {\n      x: a[0],\n      y: a[1],\n      width: a[2],\n      height: a[3]\n    };\n    Vl(this, \"fill\", a, this.Fe);\n    this.addElement(\"rect\", a);\n  };\n\n  t.fillText = function (a, b, c) {\n    a = [a, b, c];\n    b = this.textAlign;\n    \"left\" === b ? b = \"start\" : \"right\" === b ? b = \"end\" : \"center\" === b && (b = \"middle\");\n    b = {\n      x: a[1],\n      y: a[2],\n      style: \"font: \" + this.font,\n      \"text-anchor\": b\n    };\n    Vl(this, \"fill\", b, this.Fe);\n    this.addElement(\"text\", b, a[0]);\n  };\n\n  t.lineTo = function (a, b) {\n    this.path.push([\"L\", a, b]);\n  };\n\n  t.moveTo = function (a, b) {\n    this.path.push([\"M\", a, b]);\n  };\n\n  t.quadraticCurveTo = function (a, b, c, d) {\n    this.path.push([\"Q\", a, b, c, d]);\n  };\n\n  t.rect = function (a, b, c, d) {\n    this.path.push([\"M\", a, b], [\"L\", a + c, b], [\"L\", a + c, b + d], [\"L\", a, b + d], [\"z\"]);\n  };\n\n  t.restore = function () {\n    this.Fe = this.stack.pop();\n    this.path = this.stack.pop();\n    var a = this.stack.pop();\n    this.fillStyle = a.fillStyle;\n    this.font = a.font;\n    this.globalAlpha = a.globalAlpha;\n    this.lineCap = a.lineCap;\n    this.lineDashOffset = a.lineDashOffset;\n    this.lineJoin = a.lineJoin;\n    this.lineWidth = a.lineWidth;\n    this.miterLimit = a.miterLimit;\n    this.shadowBlur = a.shadowBlur;\n    this.shadowColor = a.shadowColor;\n    this.shadowOffsetX = a.shadowOffsetX;\n    this.shadowOffsetY = a.shadowOffsetY;\n    this.strokeStyle = a.strokeStyle;\n    this.textAlign = a.textAlign;\n  };\n\n  t.save = function () {\n    this.stack.push({\n      fillStyle: this.fillStyle,\n      font: this.font,\n      globalAlpha: this.globalAlpha,\n      lineCap: this.lineCap,\n      lineDashOffset: this.lineDashOffset,\n      lineJoin: this.lineJoin,\n      lineWidth: this.lineWidth,\n      miterLimit: this.miterLimit,\n      shadowBlur: this.shadowBlur,\n      shadowColor: this.shadowColor,\n      shadowOffsetX: this.shadowOffsetX,\n      shadowOffsetY: this.shadowOffsetY,\n      strokeStyle: this.strokeStyle,\n      textAlign: this.textAlign\n    });\n\n    for (var a = [], b = 0; b < this.path.length; b++) {\n      a.push(this.path[b]);\n    }\n\n    this.stack.push(a);\n    this.stack.push(this.Fe.copy());\n  };\n\n  t.setTransform = function (a, b, c, d, e, f) {\n    1 === a && 0 === b && 0 === c && 1 === d && 0 === e && 0 === f || Ul(this, a, b, c, d, e, f);\n  };\n\n  t.scale = function (a, b) {\n    this.Fe.scale(a, b);\n  };\n\n  t.translate = function (a, b) {\n    this.Fe.translate(a, b);\n  };\n\n  t.transform = function () {};\n\n  t.Pc = function () {};\n\n  t.stroke = function () {\n    this.addPath(\"stroke\", this.path, this.Fe);\n  };\n\n  t.si = function () {\n    this.clipInsteadOfFill || this.stroke();\n  };\n\n  t.Vb = function (a, b, c) {\n    return this.qs.Vb(a, b, c);\n  };\n\n  t.addElement = function (a, b, c) {\n    a = this.Vb(a, b, c);\n    0 < this.md.length ? this.md[this.md.length - 1].appendChild(a) : this.svg.appendChild(a);\n    return this.Xr = a;\n  };\n\n  function Vl(a, b, c, d, e) {\n    1 !== a.globalAlpha && (c.opacity = a.globalAlpha);\n    \"fill\" === b ? (a.fillStyle instanceof Sl ? c.fill = Wl(a, a.fillStyle) : /^rgba\\(/.test(a.fillStyle) ? (a = /^\\s*rgba\\s*\\(([^,\\s]+)\\s*,\\s*([^,\\s]+)\\s*,\\s*([^,\\s]+)\\s*,\\s*([^,\\s]+)\\)\\s*$/i.exec(a.fillStyle), c.fill = \"rgb(\" + a[1] + \",\" + a[2] + \",\" + a[3] + \")\", c[\"fill-opacity\"] = a[4]) : c.fill = a.fillStyle, c.stroke = \"none\") : \"stroke\" === b && (c.fill = \"none\", a.strokeStyle instanceof Sl ? c.stroke = Wl(a, a.strokeStyle) : /^rgba\\(/.test(a.strokeStyle) ? (b = /^\\s*rgba\\s*\\(([^,\\s]+)\\s*,\\s*([^,\\s]+)\\s*,\\s*([^,\\s]+)\\s*,\\s*([^,\\s]+)\\)\\s*$/i.exec(a.strokeStyle), c.stroke = \"rgb(\" + b[1] + \",\" + b[2] + \",\" + b[3] + \")\", c[\"stroke-opacity\"] = b[4]) : c.stroke = a.strokeStyle, c[\"stroke-width\"] = a.lineWidth, c[\"stroke-linecap\"] = a.lineCap, c[\"stroke-linejoin\"] = a.lineJoin, c[\"stroke-miterlimit\"] = a.miterLimit);\n    d = d.Ta;\n    d = \"matrix(\" + d[0] + \", \" + d[1] + \", \" + d[2] + \", \" + d[3] + \", \" + d[4] + \", \" + d[5] + \")\";\n    void 0 !== e && (d += e);\n    c.transform = d;\n  }\n\n  function Wl(a, b) {\n    var c = \"GRAD\" + kb++;\n    if (\"linear\" === b.type) var d = a.Vb(\"linearGradient\", {\n      x1: b.x1,\n      x2: b.x2,\n      y1: b.y1,\n      y2: b.y2,\n      id: c,\n      gradientUnits: \"userSpaceOnUse\"\n    });else if (\"radial\" === b.type) d = a.Vb(\"radialGradient\", {\n      x1: b.x1,\n      x2: b.x2,\n      y1: b.y1,\n      y2: b.y2,\n      r1: b.r1,\n      r2: b.r2,\n      id: c\n    });else throw Error(\"invalid gradient\");\n    var e = b.Jw;\n    b = e.length;\n\n    for (var f = [], g = 0; g < b; g++) {\n      var h = e[g],\n          k = h.color;\n      h = {\n        offset: h.offset,\n        \"stop-color\": k\n      };\n      /^rgba\\(/.test(k) && (k = /^\\s*rgba\\s*\\(([^,\\s]+)\\s*,\\s*([^,\\s]+)\\s*,\\s*([^,\\s]+)\\s*,\\s*([^,\\s]+)\\)\\s*$/i.exec(k), h[\"stop-color\"] = \"rgb(\" + k[1] + \",\" + k[2] + \",\" + k[3] + \")\", h[\"stop-opacity\"] = k[4]);\n      f.push(h);\n    }\n\n    f.sort(function (a, b) {\n      return a.offset > b.offset ? 1 : -1;\n    });\n\n    for (e = 0; e < b; e++) {\n      d.appendChild(a.Vb(\"stop\", f[e]));\n    }\n\n    a.svg.appendChild(d);\n    return \"url(#\" + c + \")\";\n  }\n\n  t.addPath = function (a, b, c) {\n    for (var d = [], e = 0; e < b.length; e++) {\n      var f = Aa(b[e]),\n          g = [f.shift()];\n      if (\"A\" === g[0]) g.push(f.shift() + \",\" + f.shift(), f.shift(), f.shift() + \",\" + f.shift(), f.shift() + \",\" + f.shift());else for (; f.length;) {\n        g.push(f.shift() + \",\" + f.shift());\n      }\n      d.push(g.join(\" \"));\n    }\n\n    b = {\n      d: d.join(\" \")\n    };\n    \"stroke\" === a && this.et && (b[\"stroke-dasharray\"] = this.Og.toString(), b[\"stroke-dashoffset\"] = this.pj);\n    Vl(this, a, b, c);\n    \"clipPath\" === a ? (a = \"CLIP\" + kb++, c = this.Vb(\"clipPath\", {\n      id: a\n    }), c.appendChild(this.Vb(\"path\", b)), this.svg.appendChild(c), 0 < this.md.length && this.md[this.md.length - 1].setAttributeNS(null, \"clip-path\", \"url(#\" + a + \")\")) : this.addElement(\"path\", b);\n  };\n\n  function Ul(a, b, c, d, e, f, g) {\n    var h = new Rl();\n    h.Ta = [b, c, d, e, f, g];\n    b = {};\n    Vl(a, \"g\", b, h);\n    h = a.addElement(\"g\", b);\n    a.md.push(h);\n  }\n\n  t.Xl = function (a) {\n    if (0 !== this.shadowOffsetX || 0 !== this.shadowOffsetY || 0 !== this.shadowBlur) {\n      var b = \"SHADOW\" + kb++,\n          c = this.addElement(\"filter\", {\n        id: b,\n        x: \"-100%\",\n        y: \"-100%\",\n        width: \"300%\",\n        height: \"300%\"\n      }, null),\n          d = a.computePixelRatio();\n      a = this.Vb(\"feGaussianBlur\", {\n        \"in\": \"SourceAlpha\",\n        result: \"blur\",\n        stdDeviation: this.shadowBlur / 2 / d\n      });\n      var e = this.Vb(\"feFlood\", {\n        \"in\": \"blur\",\n        result: \"flood\",\n        \"flood-color\": this.shadowColor\n      }),\n          f = this.Vb(\"feComposite\", {\n        \"in\": \"flood\",\n        in2: \"blur\",\n        operator: \"in\",\n        result: \"comp\"\n      });\n      d = this.Vb(\"feOffset\", {\n        \"in\": \"comp\",\n        result: \"offsetBlur\",\n        dx: this.shadowOffsetX / d,\n        dy: this.shadowOffsetY / d\n      });\n      var g = this.Vb(\"feMerge\", {});\n      g.appendChild(this.Vb(\"feMergeNode\", {\n        \"in\": \"offsetBlur\"\n      }));\n      g.appendChild(this.Vb(\"feMergeNode\", {\n        \"in\": \"SourceGraphic\"\n      }));\n      c.appendChild(a);\n      c.appendChild(e);\n      c.appendChild(f);\n      c.appendChild(d);\n      c.appendChild(g);\n      0 < this.md.length && this.md[this.md.length - 1].setAttributeNS(null, \"filter\", \"url(#\" + b + \")\");\n    }\n  };\n\n  t.iv = function (a, b, c) {\n    this.Xq = a;\n    this.Yq = b;\n    this.Lg = c;\n  };\n\n  function ql(a) {\n    a.shadowOffsetX = 0;\n    a.shadowOffsetY = 0;\n    a.shadowBlur = 0;\n  }\n\n  function pl(a) {\n    a.shadowOffsetX = a.Xq;\n    a.shadowOffsetY = a.Yq;\n    a.shadowBlur = a.Lg;\n  }\n\n  t.Gr = function (a, b) {\n    this.et = !0;\n    this.Og = a;\n    this.pj = b;\n  };\n\n  t.Er = function () {\n    this.et = !1;\n  };\n\n  t.Oc = function () {};\n\n  t.Ex = function () {};\n\n  Tl.prototype.rotate = function () {};\n\n  Tl.prototype.getImageData = function () {\n    return null;\n  };\n\n  Tl.prototype.measureText = function () {\n    return null;\n  };\n\n  Tl.className = \"SVGContext\";\n\n  Q.prototype.bs = function (a) {\n    var b = new xj(this, x.document);\n    void 0 === a && (a = new Wa());\n    var c = this;\n    return uk(this, function (a, e) {\n      a = yk(c, a, \"SVG\", b);\n      a = null !== a ? a.svg : null;\n      return \"function\" === typeof e ? (e(a), null) : a;\n    }, a);\n  };\n\n  Q.prototype.makeSvg = Q.prototype.bs;\n\n  Q.prototype.Nu = function (a) {\n    return this.bs(a);\n  };\n\n  Q.prototype.makeSVG = Q.prototype.Nu;\n\n  Y.prototype.Qw = function (a, b) {\n    if (!(a instanceof Tl)) return !1;\n    var c = null,\n        d = a.Xr,\n        e = this.transform,\n        f = this.panel;\n    0 !== (this.o & 4096) === !0 && ol(this);\n    var g = this.Eb,\n        h = 0 !== (this.o & 256);\n    a.clipInsteadOfFill && (h = !1);\n    var k = !1;\n    this instanceof Qg && (a.font = this.font);\n\n    if (h) {\n      k = f.ke() ? f.naturalBounds : f.actualBounds;\n\n      if (null !== this.ib) {\n        var l = this.ib;\n        var m = l.x;\n        var n = l.y;\n        var p = l.width;\n        l = l.height;\n      } else m = Math.max(g.x, k.x), n = Math.max(g.y, k.y), p = Math.min(g.right, k.right) - m, l = Math.min(g.bottom, k.bottom) - n;\n\n      if (m > g.width + g.x || g.x > k.width + k.x || n > g.height + g.y || g.y > k.height + k.y) return !0;\n      k = !0;\n      Ul(a, 1, 0, 0, 1, 0, 0);\n      a.save();\n      a.beginPath();\n      a.rect(m, n, p, l);\n      a.clip();\n    }\n\n    if (this.li() && !this.isVisible()) return !0;\n    a.Fe.Ta = [1, 0, 0, 1, 0, 0];\n    (this instanceof Qg && 1 < this.lineCount || this instanceof Cf && 1 < this.geometry.figures.length) && Ul(a, 1, 0, 0, 1, 0, 0);\n    m = !1;\n    this.li() && this.isShadowed && b.Ge(\"drawShadows\") && (n = this.shadowOffset, a.iv(n.x * b.scale * b.kc, n.y * b.scale * b.kc, this.shadowBlur), pl(a), a.shadowColor = this.shadowColor);\n    n = !1;\n    this.part && b.Ge(\"drawShadows\") && (n = this.part.isShadowed);\n    a.clipInsteadOfFill && (n = !1);\n    !0 === this.shadowVisible ? (pl(a), !1 === m && n && (Ul(a, 1, 0, 0, 1, 0, 0), a.Xl(b), m = !0)) : !1 === this.shadowVisible && ql(a);\n    p = this.naturalBounds;\n    null !== this.areaBackground && (gi(this, a, this.areaBackground, !0, !0, p, g), !1 === m && n && (Ul(a, 1, 0, 0, 1, 0, 0), a.Xl(b), m = !0), this.areaBackground instanceof ml && this.areaBackground.type === nl ? (a.beginPath(), a.rect(g.x, g.y, g.width, g.height), a.sf(this.areaBackground)) : a.fillRect(g.x, g.y, g.width, g.height));\n    l = !1;\n    this instanceof W ? Ul(a, e.m11, e.m12, e.m21, e.m22, e.dx, e.dy) : (a.Fe.Ta = [e.m11, e.m12, e.m21, e.m22, e.dx, e.dy], !1 === m && n && (l = !0));\n    null !== this.background && (!1 === m && n && (Ul(a, 1, 0, 0, 1, 0, 0), a.Xl(b), m = !0), rl(this, a, p, g));\n    n && (null !== this.background || null !== this.areaBackground || null !== f && 0 !== (f.o & 512) || null !== f && (f.type === W.Auto || f.type === W.Spot) && f.vb() !== this) ? (sl(this, !0), null === this.shadowVisible && ql(a), l = !1) : sl(this, !1);\n    l && !1 === m && (Ul(a, 1, 0, 0, 1, 0, 0), a.Xl(b), m = !0);\n    this.ai(a, b);\n    n && 0 !== (this.o & 512) === !0 && pl(a);\n    this.li() && n && ql(a);\n    h && (a.restore(), k && a.md.pop());\n    this instanceof W && (c = a.md.pop());\n    !0 === m && a.md.pop();\n    if (this instanceof Qg && 1 < this.lineCount || this instanceof Cf && 1 < this.geometry.figures.length) c = a.md.pop();\n    null !== a.qs.po && (null === c && (d === a.Xr ? (Ul(a, 1, 0, 0, 1, 0, 0), c = a.md.pop()) : c = a.Xr), a.qs.po(this, c));\n    this.svg = c;\n    return !0;\n  };\n\n  function Ak(a, b) {\n    this.ownerDocument = b = void 0 === b ? x.document : b;\n    this.po = null;\n    b = b.createElement(\"canvas\");\n    b.tabIndex = 0;\n    this.Sa = b;\n    this.Sa.innerHTML = \"This text is displayed if your browser does not support the Canvas HTML element.\";\n    this.context = new ul(b);\n    b.H = a;\n  }\n\n  Ak.prototype.resize = function (a, b, c, d) {\n    return this.width !== a || this.height !== b ? (this.width = a, this.height = b, this.style.width = c + \"px\", this.style.height = d + \"px\", !0) : !1;\n  };\n\n  Ak.prototype.toDataURL = function (a, b) {\n    return this.Sa.toDataURL(a, b);\n  };\n\n  Ak.prototype.getBoundingClientRect = function () {\n    return this.Sa.getBoundingClientRect();\n  };\n\n  Ak.prototype.focus = function () {\n    this.Sa.focus();\n  };\n\n  Ak.prototype.Pw = function () {\n    this.ownerDocument = this.Sa.H = null;\n  };\n\n  ma.Object.defineProperties(Ak.prototype, {\n    width: {\n      get: function get() {\n        return this.Sa.width;\n      },\n      set: function set(a) {\n        this.Sa.width = a;\n      }\n    },\n    height: {\n      get: function get() {\n        return this.Sa.height;\n      },\n      set: function set(a) {\n        this.Sa.height = a;\n      }\n    },\n    style: {\n      get: function get() {\n        return this.Sa.style;\n      }\n    }\n  });\n  Ak.className = \"CanvasSurface\";\n\n  function ul(a) {\n    a.getContext && a.getContext(\"2d\") || C(\"Browser does not support HTML Canvas Element\");\n    this.Z = a.getContext(\"2d\");\n    this.Es = this.Gs = this.Fs = \"\";\n    this.pm = !1;\n    this.Lg = this.Yq = this.Xq = 0;\n    this.rl = new md();\n  }\n\n  t = ul.prototype;\n\n  t.Ex = function (a) {\n    this.Z.imageSmoothingEnabled = a;\n  };\n\n  t.arc = function (a, b, c, d, e, f) {\n    this.Z.arc(a, b, c, d, e, f);\n  };\n\n  t.beginPath = function () {\n    this.Z.beginPath();\n  };\n\n  t.bezierCurveTo = function (a, b, c, d, e, f) {\n    this.Z.bezierCurveTo(a, b, c, d, e, f);\n  };\n\n  t.clearRect = function (a, b, c, d) {\n    this.Pc();\n    this.Z.clearRect(a, b, c, d);\n  };\n\n  t.clip = function () {\n    this.Z.clip();\n  };\n\n  t.closePath = function () {\n    this.Z.closePath();\n  };\n\n  t.createLinearGradient = function (a, b, c, d) {\n    return this.Z.createLinearGradient(a, b, c, d);\n  };\n\n  t.createPattern = function (a, b) {\n    return this.Z.createPattern(a, b);\n  };\n\n  t.createRadialGradient = function (a, b, c, d, e, f) {\n    return this.Z.createRadialGradient(a, b, c, d, e, f);\n  };\n\n  t.drawImage = function (a, b, c, d, e, f, g, h, k) {\n    void 0 === d ? this.Z.drawImage(a, b, c) : this.Z.drawImage(a, b, c, d, e, f, g, h, k);\n  };\n\n  t.fill = function () {\n    this.Z.fill();\n  };\n\n  t.fillRect = function (a, b, c, d) {\n    this.Z.fillRect(a, b, c, d);\n  };\n\n  t.fillText = function (a, b, c) {\n    this.Z.fillText(a, b, c);\n  };\n\n  t.getImageData = function (a, b, c, d) {\n    return this.Z.getImageData(a, b, c, d);\n  };\n\n  t.lineTo = function (a, b) {\n    this.Z.lineTo(a, b);\n  };\n\n  t.measureText = function (a) {\n    return this.Z.measureText(a);\n  };\n\n  t.moveTo = function (a, b) {\n    this.Z.moveTo(a, b);\n  };\n\n  t.quadraticCurveTo = function (a, b, c, d) {\n    this.Z.quadraticCurveTo(a, b, c, d);\n  };\n\n  t.rect = function (a, b, c, d) {\n    this.Z.rect(a, b, c, d);\n  };\n\n  t.restore = function () {\n    this.Z.restore();\n  };\n\n  t.save = function () {\n    this.Pc();\n    this.Z.save();\n  };\n\n  ul.prototype.rotate = function (a) {\n    this.rl.rotate(57.2958 * a, 0, 0);\n  };\n\n  t = ul.prototype;\n\n  t.setTransform = function (a, b, c, d, e, f) {\n    this.rl.setTransform(a, b, c, d, e, f);\n  };\n\n  t.scale = function (a, b) {\n    this.rl.scale(a, b);\n  };\n\n  t.translate = function (a, b) {\n    this.rl.translate(a, b);\n  };\n\n  t.stroke = function () {\n    this.Z.stroke();\n  };\n\n  t.transform = function (a, b, c, d, e, f) {\n    if (1 !== a || 0 !== b || 0 !== c || 1 !== d || 0 !== e || 0 !== f) {\n      var g = this.rl,\n          h = g.m11 * a + g.m21 * b;\n      a = g.m12 * a + g.m22 * b;\n      b = g.m11 * c + g.m21 * d;\n      c = g.m12 * c + g.m22 * d;\n      g.dx = g.m11 * e + g.m21 * f + g.dx;\n      g.dy = g.m12 * e + g.m22 * f + g.dy;\n      g.m11 = h;\n      g.m12 = a;\n      g.m21 = b;\n      g.m22 = c;\n    }\n  };\n\n  t.Pc = function () {\n    var a = this.rl;\n    this.Z.setTransform(a.m11, a.m12, a.m21, a.m22, a.dx, a.dy);\n  };\n\n  t.sf = function (a) {\n    if (a instanceof ml && a.type === nl) {\n      var b = a.lk;\n      a = a.Hs;\n      a > b ? (this.scale(b / a, 1), this.translate((a - b) / 2, 0)) : b > a && (this.scale(1, a / b), this.translate(0, (b - a) / 2));\n      this.pm ? this.clip() : this.fill();\n      a > b ? (this.translate(-(a - b) / 2, 0), this.scale(1 / (b / a), 1)) : b > a && (this.translate(0, -(b - a) / 2), this.scale(1, 1 / (a / b)));\n    } else this.pm ? this.clip() : this.fill();\n  };\n\n  t.si = function () {\n    this.pm || this.stroke();\n  };\n\n  t.iv = function (a, b, c) {\n    this.Xq = a;\n    this.Yq = b;\n    this.Lg = c;\n  };\n\n  t.Gr = function (a, b) {\n    var c = this.Z;\n    void 0 !== c.setLineDash && (c.setLineDash(a), c.lineDashOffset = b);\n  };\n\n  t.Er = function () {\n    var a = this.Z;\n    void 0 !== a.setLineDash && (a.setLineDash(Xl), a.lineDashOffset = 0);\n  };\n\n  t.Oc = function (a) {\n    a && (this.Fs = \"\");\n    this.Es = this.Gs = \"\";\n  };\n\n  ma.Object.defineProperties(ul.prototype, {\n    fillStyle: {\n      get: function get() {\n        return this.Z.fillStyle;\n      },\n      set: function set(a) {\n        this.Es !== a && (this.Es = this.Z.fillStyle = a);\n      }\n    },\n    font: {\n      get: function get() {\n        return this.Z.font;\n      },\n      set: function set(a) {\n        this.Fs !== a && (this.Fs = this.Z.font = a);\n      }\n    },\n    globalAlpha: {\n      get: function get() {\n        return this.Z.globalAlpha;\n      },\n      set: function set(a) {\n        this.Z.globalAlpha = a;\n      }\n    },\n    lineCap: {\n      get: function get() {\n        return this.Z.lineCap;\n      },\n      set: function set(a) {\n        this.Z.lineCap = a;\n      }\n    },\n    lineDashOffset: {\n      get: function get() {\n        return this.Z.lineDashOffset;\n      },\n      set: function set(a) {\n        this.Z.lineDashOffset = a;\n      }\n    },\n    lineJoin: {\n      get: function get() {\n        return this.Z.lineJoin;\n      },\n      set: function set(a) {\n        this.Z.lineJoin = a;\n      }\n    },\n    lineWidth: {\n      get: function get() {\n        return this.Z.lineWidth;\n      },\n      set: function set(a) {\n        this.Z.lineWidth = a;\n      }\n    },\n    miterLimit: {\n      get: function get() {\n        return this.Z.miterLimit;\n      },\n      set: function set(a) {\n        this.Z.miterLimit = a;\n      }\n    },\n    shadowBlur: {\n      get: function get() {\n        return this.Z.shadowBlur;\n      },\n      set: function set(a) {\n        this.Z.shadowBlur = a;\n      }\n    },\n    shadowColor: {\n      get: function get() {\n        return this.Z.shadowColor;\n      },\n      set: function set(a) {\n        this.Z.shadowColor = a;\n      }\n    },\n    shadowOffsetX: {\n      get: function get() {\n        return this.Z.shadowOffsetX;\n      },\n      set: function set(a) {\n        this.Z.shadowOffsetX = a;\n      }\n    },\n    shadowOffsetY: {\n      get: function get() {\n        return this.Z.shadowOffsetY;\n      },\n      set: function set(a) {\n        this.Z.shadowOffsetY = a;\n      }\n    },\n    strokeStyle: {\n      get: function get() {\n        return this.Z.strokeStyle;\n      },\n      set: function set(a) {\n        this.Gs !== a && (this.Gs = this.Z.strokeStyle = a);\n      }\n    },\n    textAlign: {\n      get: function get() {\n        return this.Z.textAlign;\n      },\n      set: function set(a) {\n        this.Z.textAlign = a;\n      }\n    },\n    imageSmoothingEnabled: {\n      get: function get() {\n        return this.Z.imageSmoothingEnabled;\n      },\n      set: function set(a) {\n        this.Z.imageSmoothingEnabled = a;\n      }\n    },\n    clipInsteadOfFill: {\n      get: function get() {\n        return this.pm;\n      },\n      set: function set(a) {\n        this.pm = a;\n      }\n    }\n  });\n  var Xl = Object.freeze([]);\n  ul.className = \"CanvasSurfaceContext\";\n\n  function Yl() {\n    this.F = this.m = this.u = this.j = 0;\n  }\n\n  Yl.className = \"ColorNumbers\";\n\n  function ml(a, b) {\n    Zl || ($l(), Zl = !0);\n    Ra(this);\n    this._isFrozen = !1;\n    void 0 === a ? (this.qa = tl, this.kk = \"black\") : \"string\" === typeof a ? (this.qa = tl, this.kk = a) : (this.qa = a, this.kk = \"black\");\n    a = this.qa;\n    a === wl ? (this.Gd = uc, this.zk = Bc) : this.zk = a === nl ? this.Gd = yc : this.Gd = sc;\n    this.cr = 0;\n    this.Ap = NaN;\n    this.oe = this.Bq = this.ne = null;\n    this.Hs = this.lk = 0;\n    b && Object.assign(this, b);\n  }\n\n  ml.prototype.copy = function () {\n    var a = new ml();\n    a.qa = this.qa;\n    a.kk = this.kk;\n    a.Gd = this.Gd.J();\n    a.zk = this.zk.J();\n    a.cr = this.cr;\n    a.Ap = this.Ap;\n    null !== this.ne && (a.ne = this.ne.copy());\n    a.Bq = this.Bq;\n    return a;\n  };\n\n  t = ml.prototype;\n\n  t.freeze = function () {\n    this._isFrozen = !0;\n    null !== this.ne && this.ne.freeze();\n    return this;\n  };\n\n  t.ja = function () {\n    Object.isFrozen(this) && C(\"cannot thaw constant: \" + this);\n    this._isFrozen = !1;\n    null !== this.ne && this.ne.ja();\n    return this;\n  };\n\n  t.ob = function (a) {\n    a.classType === ml && (this.type = a);\n  };\n\n  t.toString = function () {\n    var a = \"Brush(\";\n    if (this.type === tl) a += this.color;else if (a = this.type === wl ? a + \"Linear \" : this.type === nl ? a + \"Radial \" : this.type === vl ? a + \"Pattern \" : a + \"(unknown) \", a += this.start + \" \" + this.end, null !== this.colorStops) for (var b = this.colorStops.iterator; b.next();) {\n      a += \" \" + b.key + \":\" + b.value;\n    }\n    return a + \")\";\n  };\n\n  t.addColorStop = function (a, b) {\n    this._isFrozen && va(this);\n    (\"number\" !== typeof a || !isFinite(a) || 1 < a || 0 > a) && wa(a, \"0 <= loc <= 1\", ml, \"addColorStop:loc\");\n    null === this.ne && (this.ne = new pb());\n    this.ne.add(a, b);\n    this.qa === tl && (this.type = wl);\n    this.oe = null;\n    return this;\n  };\n\n  t.Cz = function (a, b) {\n    this._isFrozen && va(this);\n    a = void 0 === a || \"number\" !== typeof a ? .2 : a;\n    b = void 0 === b ? am : b;\n    if (this.type === tl) Uh(this.color), this.color = bm(a, b);else if ((this.type === wl || this.type === nl) && null !== this.colorStops) for (var c = this.colorStops.iterator; c.next();) {\n      Uh(c.value), this.addColorStop(c.key, bm(a, b));\n    }\n    return this;\n  };\n\n  function cm(a, b, c) {\n    b = void 0 === b || \"number\" !== typeof b ? .2 : b;\n    c = void 0 === c ? am : c;\n    Uh(a);\n    return bm(b, c);\n  }\n\n  t.Dy = function (a, b) {\n    this._isFrozen && va(this);\n    a = void 0 === a || \"number\" !== typeof a ? .2 : a;\n    b = void 0 === b ? am : b;\n    if (this.type === tl) Uh(this.color), this.color = bm(-a, b);else if ((this.type === wl || this.type === nl) && null !== this.colorStops) for (var c = this.colorStops.iterator; c.next();) {\n      Uh(c.value), this.addColorStop(c.key, bm(-a, b));\n    }\n    return this;\n  };\n\n  function dm(a, b, c) {\n    b = void 0 === b || \"number\" !== typeof b ? .2 : b;\n    c = void 0 === c ? am : c;\n    Uh(a);\n    return bm(-b, c);\n  }\n\n  function em(a, b, c) {\n    Uh(a);\n    a = fm.j;\n    var d = fm.u,\n        e = fm.m,\n        f = fm.F;\n    Uh(b);\n    void 0 === c && (c = .5);\n    return \"rgba(\" + Math.round((fm.j - a) * c + a) + \", \" + Math.round((fm.u - d) * c + d) + \", \" + Math.round((fm.m - e) * c + e) + \", \" + Math.round((fm.F - f) * c + f) + \")\";\n  }\n\n  t.kx = function () {\n    if (this.type === tl) return gm(this.color);\n\n    if ((this.type === wl || this.type === nl) && null !== this.colorStops) {\n      var a = this.colorStops;\n      if (this.type === nl) return gm(a.first().value);\n      if (null !== a.get(.5)) return gm(a.get(.5));\n      if (2 === a.count) return a = a.Ea(), gm(em(a[0].value, a[1].value));\n\n      for (var b = a.iterator, c = -1, d = -1, e = 1, f = 1; b.next();) {\n        var g = b.key,\n            h = Math.abs(.5 - b.key);\n        e > f && h < e ? (c = g, e = h) : f >= e && h < f && (d = g, f = h);\n      }\n\n      c > d && (f = c, c = d, d = f, f = e);\n      e = d - c;\n      return gm(em(a.get(c), a.get(d), 1 - f / e));\n    }\n\n    return !1;\n  };\n\n  function gm(a) {\n    if (!a) return !1;\n    if (a instanceof ml) return a.kx();\n    Uh(a);\n    return 128 > (299 * fm.j + 587 * fm.u + 114 * fm.m) / 1E3;\n  }\n\n  function bm(a, b) {\n    switch (b) {\n      case am:\n        b = 100 * hm(fm.j);\n        var c = 100 * hm(fm.u),\n            d = 100 * hm(fm.m);\n        im.j = .4124564 * b + .3575761 * c + .1804375 * d;\n        im.u = .2126729 * b + .7151522 * c + .072175 * d;\n        im.m = .0193339 * b + .119192 * c + .9503041 * d;\n        im.F = fm.F;\n        b = jm(im.j / km[0]);\n        c = jm(im.u / km[1]);\n        d = jm(im.m / km[2]);\n        lm.j = 116 * c - 16;\n        lm.u = 500 * (b - c);\n        lm.m = 200 * (c - d);\n        lm.F = im.F;\n        lm.j = Math.min(100, Math.max(0, lm.j + 100 * a));\n        a = (lm.j + 16) / 116;\n        b = a - lm.m / 200;\n        im.j = km[0] * mm(lm.u / 500 + a);\n        im.u = km[1] * (lm.j > nm * om ? Math.pow(a, 3) : lm.j / nm);\n        im.m = km[2] * mm(b);\n        im.F = lm.F;\n        a = -.969266 * im.j + 1.8760108 * im.u + .041556 * im.m;\n        b = .0556434 * im.j + -.2040259 * im.u + 1.0572252 * im.m;\n        fm.j = 255 * pm((3.2404542 * im.j + -1.5371385 * im.u + -.4985314 * im.m) / 100);\n        fm.u = 255 * pm(a / 100);\n        fm.m = 255 * pm(b / 100);\n        fm.F = im.F;\n        fm.j = Math.round(fm.j);\n        255 < fm.j ? fm.j = 255 : 0 > fm.j && (fm.j = 0);\n        fm.u = Math.round(fm.u);\n        255 < fm.u ? fm.u = 255 : 0 > fm.u && (fm.u = 0);\n        fm.m = Math.round(fm.m);\n        255 < fm.m ? fm.m = 255 : 0 > fm.m && (fm.m = 0);\n        return \"rgba(\" + fm.j + \", \" + fm.u + \", \" + fm.m + \", \" + fm.F + \")\";\n\n      case qm:\n        return Vh(), Wh.m = Math.min(100, Math.max(0, Wh.m + 100 * a)), \"hsla(\" + Wh.j + \", \" + Wh.u + \"%, \" + Wh.m + \"%, \" + Wh.F + \")\";\n\n      default:\n        C(\"Unknown color space: \" + b);\n    }\n  }\n\n  function Uh(a) {\n    Zl || ($l(), Zl = !0);\n    var b = rm;\n\n    if (null !== b) {\n      b.clearRect(0, 0, 1, 1);\n      b.fillStyle = \"#000000\";\n      var c = b.fillStyle;\n      b.fillStyle = a;\n      b.fillStyle !== c ? (b.fillRect(0, 0, 1, 1), a = b.getImageData(0, 0, 1, 1).data, fm.j = a[0], fm.u = a[1], fm.m = a[2], fm.F = a[3] / 255) : (b.fillStyle = \"#FFFFFF\", b.fillStyle = a, fm.j = 0, fm.u = 0, fm.m = 0, fm.F = 1);\n    }\n  }\n\n  function Vh() {\n    var a = fm.j / 255,\n        b = fm.u / 255,\n        c = fm.m / 255,\n        d = Math.max(a, b, c),\n        e = Math.min(a, b, c),\n        f = d - e;\n    e = (d + e) / 2;\n    if (0 === f) var g = a = 0;else {\n      switch (d) {\n        case a:\n          g = (b - c) / f % 6;\n          break;\n\n        case b:\n          g = (c - a) / f + 2;\n          break;\n\n        case c:\n          g = (a - b) / f + 4;\n      }\n\n      g *= 60;\n      0 > g && (g += 360);\n      a = f / (1 - Math.abs(2 * e - 1));\n    }\n    Wh.j = Math.round(g);\n    Wh.u = Math.round(100 * a);\n    Wh.m = Math.round(100 * e);\n    Wh.F = fm.F;\n  }\n\n  function hm(a) {\n    a /= 255;\n    return .04045 >= a ? a / 12.92 : Math.pow((a + .055) / 1.055, 2.4);\n  }\n\n  function pm(a) {\n    return .0031308 >= a ? 12.92 * a : 1.055 * Math.pow(a, 1 / 2.4) - .055;\n  }\n\n  function jm(a) {\n    return a > om ? Math.pow(a, 1 / 3) : (nm * a + 16) / 116;\n  }\n\n  function mm(a) {\n    var b = a * a * a;\n    return b > om ? b : (116 * a - 16) / nm;\n  }\n\n  function Ol(a, b) {\n    \"string\" !== typeof a && (a instanceof ml || C(\"Value for \" + b + \" must be a color string or a Brush, not \" + a));\n  }\n\n  function $l() {\n    rm = Og ? new Ak(null).context : null;\n  }\n\n  ma.Object.defineProperties(ml.prototype, {\n    type: {\n      get: function get() {\n        return this.qa;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.qa = a;\n        this.start.Fc() && (a === wl ? this.start = uc : a === nl && (this.start = yc));\n        this.end.Fc() && (a === wl ? this.end = Bc : a === nl && (this.end = yc));\n        this.oe = null;\n      }\n    },\n    color: {\n      get: function get() {\n        return this.kk;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.kk = a;\n        this.oe = null;\n      }\n    },\n    start: {\n      get: function get() {\n        return this.Gd;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.Gd = a.J();\n        this.oe = null;\n      }\n    },\n    end: {\n      get: function get() {\n        return this.zk;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.zk = a.J();\n        this.oe = null;\n      }\n    },\n    startRadius: {\n      get: function get() {\n        return this.cr;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        0 > a && wa(a, \">= zero\", ml, \"startRadius\");\n        this.cr = a;\n        this.oe = null;\n      }\n    },\n    endRadius: {\n      get: function get() {\n        return this.Ap;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        0 > a && wa(a, \">= zero\", ml, \"endRadius\");\n        this.Ap = a;\n        this.oe = null;\n      }\n    },\n    colorStops: {\n      get: function get() {\n        return this.ne;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.ne = a;\n        this.oe = null;\n      }\n    },\n    pattern: {\n      get: function get() {\n        return this.Bq;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this, a);\n        this.Bq = a;\n        this.oe = null;\n      }\n    }\n  });\n  ml.prototype.isDark = ml.prototype.kx;\n  ml.prototype.darkenBy = ml.prototype.Dy;\n  ml.prototype.lightenBy = ml.prototype.Cz;\n  ml.prototype.addColorStop = ml.prototype.addColorStop;\n  var om = 216 / 24389,\n      nm = 24389 / 27,\n      km = [95.047, 100, 108.883],\n      rm = null,\n      fm = new Yl(),\n      Wh = new Yl(),\n      im = new Yl(),\n      lm = new Yl(),\n      Zl = !1;\n  ml.className = \"Brush\";\n  var tl;\n  ml.Solid = tl = new D(ml, \"Solid\", 0);\n  var wl;\n  ml.Linear = wl = new D(ml, \"Linear\", 1);\n  var nl;\n  ml.Radial = nl = new D(ml, \"Radial\", 2);\n  var vl;\n  ml.Pattern = vl = new D(ml, \"Pattern\", 4);\n  var am;\n  ml.Lab = am = new D(ml, \"Lab\", 5);\n  var qm;\n  ml.HSL = qm = new D(ml, \"HSL\", 6);\n\n  ml.randomColor = function (a, b) {\n    void 0 === a && (a = 128);\n    void 0 === b && (b = Math.max(a, 255));\n    var c = Math.abs(b - a);\n    b = Math.floor(a + Math.random() * c).toString(16);\n    var d = Math.floor(a + Math.random() * c).toString(16);\n    a = Math.floor(a + Math.random() * c).toString(16);\n    2 > b.length && (b = \"0\" + b);\n    2 > d.length && (d = \"0\" + d);\n    2 > a.length && (a = \"0\" + a);\n    return \"#\" + b + d + a;\n  };\n\n  ml.isValidColor = function (a) {\n    if (\"black\" === a) return !0;\n    if (\"\" === a) return !1;\n    Zl || ($l(), Zl = !0);\n    var b = rm;\n    if (null === b) return !0;\n    b.fillStyle = \"#000000\";\n    var c = b.fillStyle;\n    b.fillStyle = a;\n    if (b.fillStyle !== c) return !0;\n    b.fillStyle = \"#FFFFFF\";\n    c = b.fillStyle;\n    b.fillStyle = a;\n    return b.fillStyle !== c;\n  };\n\n  ml.lighten = function (a) {\n    return cm(a);\n  };\n\n  ml.lightenBy = cm;\n\n  ml.darken = function (a) {\n    return dm(a);\n  };\n\n  ml.darkenBy = dm;\n  ml.mix = em;\n  ml.isDark = gm;\n\n  function Kl() {\n    this.va = \"Base\";\n  }\n\n  Kl.prototype.measure = function () {};\n\n  Kl.prototype.Fz = function (a, b, c, d, e) {\n    a.measure(b, c, d, e);\n  };\n\n  Kl.prototype.arrange = function () {};\n\n  Kl.prototype.sy = function (a, b, c, d, e, f) {\n    a.arrange(b, c, d, e, f);\n  };\n\n  Kl.prototype.Pz = function (a) {\n    a.Mj();\n  };\n\n  Kl.prototype.tc = function () {};\n\n  ma.Object.defineProperties(Kl.prototype, {\n    name: {\n      get: function get() {\n        return this.va;\n      },\n      set: function set(a) {\n        this.va = a;\n      }\n    },\n    classType: {\n      get: function get() {\n        return W;\n      }\n    }\n  });\n  Kl.prototype.remeasureObject = Kl.prototype.Pz;\n  Kl.prototype.arrangeElement = Kl.prototype.sy;\n  Kl.prototype.measureElement = Kl.prototype.Fz;\n  Kl.className = \"PanelLayout\";\n\n  function sm() {\n    this.va = \"Base\";\n  }\n\n  la(sm, Kl);\n\n  sm.prototype.measure = function (a, b, c, d, e, f, g) {\n    var h = d.length;\n    a = tm(a);\n\n    for (var k = 0; k < h; k++) {\n      var l = d[k];\n\n      if (l.visible || l === a) {\n        var m = l.margin,\n            n = m.right + m.left;\n        m = m.top + m.bottom;\n        l.measure(b, c, f, g);\n        var p = l.measuredBounds;\n        n = Math.max(p.width + n, 0);\n        m = Math.max(p.height + m, 0);\n        p = l.position.x;\n        var r = l.position.y;\n        isFinite(p) || (p = 0);\n        isFinite(r) || (r = 0);\n        l instanceof Cf && l.isGeometryPositioned && (l = l.strokeWidth / 2, p -= l, r -= l);\n        Zb(e, p, r, n, m);\n      }\n    }\n  };\n\n  sm.prototype.arrange = function (a, b, c) {\n    var d = b.length,\n        e = a.padding;\n    a = c.x - e.left;\n    c = c.y - e.top;\n\n    for (e = 0; e < d; e++) {\n      var f = b[e],\n          g = f.measuredBounds,\n          h = f.margin,\n          k = f.position.x,\n          l = f.position.y;\n      k = isNaN(k) ? -a : k - a;\n      l = isNaN(l) ? -c : l - c;\n\n      if (f instanceof Cf && f.isGeometryPositioned) {\n        var m = f.strokeWidth / 2;\n        k -= m;\n        l -= m;\n      }\n\n      f.visible && f.arrange(k + h.left, l + h.top, g.width, g.height);\n    }\n  };\n\n  function um() {\n    this.va = \"Base\";\n  }\n\n  la(um, Kl);\n\n  um.prototype.measure = function (a, b, c, d, e, f, g) {\n    var h = d.length;\n    b = Ea();\n    f = tm(a);\n\n    for (var k = 0; k < h; k++) {\n      var l = d[k];\n\n      if (l.visible || l === f) {\n        var m = hl(l, !1);\n        if (m !== lg && m !== Uk) b.push(l);else {\n          l.measure(Infinity, c, 0, g);\n          m = l.margin;\n          l = l.measuredBounds;\n          var n = Math.max(l.height + m.top + m.bottom, 0);\n          e.width += Math.max(l.width + m.right + m.left, 0);\n          e.height = Math.max(e.height, n);\n        }\n      }\n    }\n\n    d = b.length;\n    a.desiredSize.height ? c = Math.min(a.desiredSize.height, a.maxSize.height) : 0 !== e.height && (c = Math.min(e.height, a.maxSize.height));\n\n    for (a = 0; a < d; a++) {\n      if (k = b[a], k.visible || k === f) m = k.margin, h = m.right + m.left, m = m.top + m.bottom, k.measure(Infinity, c, 0, g), k = k.measuredBounds, m = Math.max(k.height + m, 0), e.width += Math.max(k.width + h, 0), e.height = Math.max(e.height, m);\n    }\n\n    Ga(b);\n  };\n\n  um.prototype.arrange = function (a, b, c) {\n    for (var d = b.length, e = a.padding, f = e.top, g = a.isOpposite, h = g ? c.width : e.left, k = 0; k < d; k++) {\n      var l = f,\n          m = b[k];\n\n      if (m.visible) {\n        var n = m.measuredBounds,\n            p = m.margin,\n            r = p.top + p.bottom,\n            q = f + e.bottom,\n            u = n.height,\n            w = hl(m, !1);\n        if (isNaN(m.desiredSize.height) && w === td || w === Vk) u = Math.max(c.height - r - q, 0);\n        r = u + r + q;\n        q = m.alignment;\n        q.Sb() && (q = a.defaultAlignment);\n        q.pb() || (q = yc);\n        g && (h -= n.width + p.left + p.right);\n        m.arrange(h + q.offsetX + p.left, l + q.offsetY + p.top + (c.height * q.y - r * q.y), n.width, u);\n        g || (h += n.width + p.left + p.right);\n      }\n    }\n  };\n\n  function vm() {\n    this.va = \"Base\";\n  }\n\n  la(vm, Kl);\n\n  vm.prototype.measure = function (a, b, c, d, e, f) {\n    var g = d.length;\n    c = Ea();\n\n    for (var h = tm(a), k = 0; k < g; k++) {\n      var l = d[k];\n\n      if (l.visible || l === h) {\n        var m = hl(l, !1);\n        if (m !== lg && m !== Vk) c.push(l);else {\n          var n = l.margin;\n          m = n.right + n.left;\n          n = n.top + n.bottom;\n          l.measure(b, Infinity, f, 0);\n          l = l.measuredBounds;\n          Qb(e, Math.max(e.width, Math.max(l.width + m, 0)), e.height + Math.max(l.height + n, 0));\n        }\n      }\n    }\n\n    d = c.length;\n\n    if (0 !== d) {\n      a.desiredSize.width ? b = Math.min(a.desiredSize.width, a.maxSize.width) : 0 !== e.width && (b = Math.min(e.width, a.maxSize.width));\n\n      for (a = 0; a < d; a++) {\n        if (k = c[a], k.visible || k === h) l = k.margin, g = l.right + l.left, l = l.top + l.bottom, k.measure(b, Infinity, f, 0), k = k.measuredBounds, l = Math.max(k.height + l, 0), e.width = Math.max(e.width, Math.max(k.width + g, 0)), e.height += l;\n      }\n\n      Ga(c);\n    }\n  };\n\n  vm.prototype.arrange = function (a, b, c) {\n    for (var d = b.length, e = a.padding, f = e.left, g = a.isOpposite, h = g ? c.height : e.top, k = 0; k < d; k++) {\n      var l = f,\n          m = b[k];\n\n      if (m.visible) {\n        var n = m.measuredBounds,\n            p = m.margin,\n            r = p.left + p.right,\n            q = f + e.right,\n            u = n.width,\n            w = hl(m, !1);\n        if (isNaN(m.desiredSize.width) && w === td || w === Uk) u = Math.max(c.width - r - q, 0);\n        r = u + r + q;\n        q = m.alignment;\n        q.Sb() && (q = a.defaultAlignment);\n        q.pb() || (q = yc);\n        g && (h -= n.height + p.bottom + p.top);\n        m.arrange(l + q.offsetX + p.left + (c.width * q.x - r * q.x), h + q.offsetY + p.top, u, n.height);\n        g || (h += n.height + p.bottom + p.top);\n      }\n    }\n  };\n\n  function wm() {\n    this.va = \"Base\";\n  }\n\n  la(wm, Kl);\n\n  wm.prototype.measure = function (a, b, c, d, e, f, g) {\n    var h = d.length,\n        k = a.vb(),\n        l = k.margin,\n        m = l.right + l.left,\n        n = l.top + l.bottom;\n    k.measure(b, c, f, g);\n    var p = k.measuredBounds;\n    f = p.width;\n    g = p.height;\n    var r = Math.max(f + m, 0);\n    var q = Math.max(g + n, 0);\n    var u = a.isClipping,\n        w = M.allocAt(-l.left, -l.top, r, q),\n        v = M.allocAt(0, 0, f, g);\n    xm(k, v, !0);\n    f = v.width;\n    g = v.height;\n\n    for (var z = !0, y = tm(a), A = 0; A < h; A++) {\n      var B = d[A],\n          F = b,\n          L = c;\n\n      if (B !== k && (B.visible || B === y)) {\n        l = B.margin;\n        r = l.right + l.left;\n        q = l.top + l.bottom;\n        p = hl(B, !1);\n\n        switch (p) {\n          case td:\n            F = f;\n            L = g;\n            break;\n\n          case Uk:\n            F = f;\n            break;\n\n          case Vk:\n            L = g;\n        }\n\n        B.measure(F, L, 0, 0);\n        p = B.measuredBounds;\n        r = Math.max(p.width + r, 0);\n        q = Math.max(p.height + q, 0);\n        F = B.alignment;\n        F.Sb() && (F = a.defaultAlignment);\n        F.pb() || (F = yc);\n        var S = B.alignmentFocus;\n        S.Sb() && (S = yc);\n        L = null;\n        B instanceof W && \"\" !== B.Pe && (L = B.fb(B.Pe), L === B && (L = null));\n        var R = v.x,\n            P = v.y;\n\n        if (null !== L) {\n          B.arrange(0, 0, p.width, p.height);\n          l = L.actualBounds;\n          l = I.allocAt(l.x + (S.x * l.width - S.offsetX), l.y + (S.y * l.height - S.offsetY));\n\n          for (L = L.panel; L !== B;) {\n            L.transform.Fa(l), L = L.panel;\n          }\n\n          R += F.x * f + F.offsetX - l.x;\n          P += F.y * g + F.offsetY - l.y;\n          I.free(l);\n        } else R += F.x * f + F.offsetX - (S.x * p.width + S.offsetX) - l.left, P += F.y * g + F.offsetY - (S.y * p.height + S.offsetY) - l.top;\n\n        z ? (z = !1, e.h(R, P, r, q)) : Zb(e, R, P, r, q);\n      }\n    }\n\n    z ? e.assign(w) : u ? e.Gu(v.x, v.y, v.width, v.height) : Zb(e, w.x, w.y, w.width, w.height);\n    M.free(w);\n    M.free(v);\n    p = k.stretch;\n    p === Wk && (p = hl(k, !1));\n\n    switch (p) {\n      case lg:\n        return;\n\n      case td:\n        if (!isFinite(b) && !isFinite(c)) return;\n        break;\n\n      case Uk:\n        if (!isFinite(b)) return;\n        break;\n\n      case Vk:\n        if (!isFinite(c)) return;\n    }\n\n    p = k.measuredBounds;\n    f = p.width;\n    g = p.height;\n    r = Math.max(f + m, 0);\n    q = Math.max(g + n, 0);\n    l = k.margin;\n    v = M.allocAt(-l.left, -l.top, r, q);\n    xm(k, v, !0);\n    f = v.width;\n    g = v.height;\n\n    for (b = 0; b < h; b++) {\n      c = d[b], c === k || !c.visible && c !== y || (l = c.margin, r = l.right + l.left, q = l.top + l.bottom, p = c.measuredBounds, r = Math.max(p.width + r, 0), q = Math.max(p.height + q, 0), m = c.alignment, m.Sb() && (m = a.defaultAlignment), m.pb() || (m = yc), c = c.alignmentFocus, c.Sb() && (c = yc), z ? (z = !1, e.h(m.x * f + m.offsetX - (c.x * p.width + c.offsetX) - l.left, m.y * g + m.offsetY - (c.y * p.height + c.offsetY) - l.top, r, q)) : Zb(e, m.x * f + m.offsetX - (c.x * p.width + c.offsetX) - l.left, m.y * g + m.offsetY - (c.y * p.height + c.offsetY) - l.top, r, q));\n    }\n\n    z ? e.assign(w) : u ? e.Gu(v.x, v.y, v.width, v.height) : Zb(e, w.x, w.y, w.width, w.height);\n    M.free(v);\n  };\n\n  wm.prototype.arrange = function (a, b, c) {\n    var d = b.length,\n        e = a.vb(),\n        f = e.measuredBounds,\n        g = f.width,\n        h = f.height,\n        k = a.padding;\n    f = k.left;\n    k = k.top;\n    var l = f - c.x,\n        m = k - c.y;\n    e.arrange(l, m, g, h);\n    g = M.allocAt(0, 0, g, h);\n    xm(e, g, !1);\n\n    for (h = 0; h < d; h++) {\n      var n = b[h];\n\n      if (n !== e) {\n        l = n.measuredBounds;\n        var p = l.width,\n            r = l.height;\n        m = n.alignment;\n        m.Sb() && (m = a.defaultAlignment);\n        m.pb() || (m = yc);\n        var q = n.alignmentFocus;\n        q.Sb() && (q = yc);\n        l = null;\n        n instanceof W && \"\" !== n.Pe && (l = n.fb(n.Pe), l === n && (l = null));\n\n        if (null !== l) {\n          var u = l.actualBounds;\n          q = I.allocAt(u.x + (q.x * u.width - q.offsetX), u.y + (q.y * u.height - q.offsetY));\n\n          for (l = l.panel; l !== n;) {\n            l.transform.Fa(q), l = l.panel;\n          }\n\n          l = m.x * g.width + m.offsetX - q.x;\n          m = m.y * g.height + m.offsetY - q.y;\n          I.free(q);\n        } else l = m.x * g.width + m.offsetX - (q.x * p + q.offsetX), m = m.y * g.height + m.offsetY - (q.y * r + q.offsetY);\n\n        l += g.x - c.x;\n        m += g.y - c.y;\n        n.visible && n.arrange(f + l, k + m, p, r);\n      }\n    }\n\n    M.free(g);\n  };\n\n  function xm(a, b, c) {\n    var d = null;\n    a instanceof W && \"\" !== a.Pe && (d = a.fb(a.Pe), d === a && (d = null));\n    if (null !== d) for (c && a.arrange(0, 0, b.width, b.height), b.assign(d.actualBounds), d = d.panel; d !== a;) {\n      d.transform.So(b), d = d.panel;\n    }\n  }\n\n  function ym() {\n    this.va = \"Base\";\n  }\n\n  la(ym, Kl);\n\n  ym.prototype.measure = function (a, b, c, d, e, f, g) {\n    var h = d.length,\n        k = a.vb(),\n        l = k.margin,\n        m = b,\n        n = c,\n        p = l.right + l.left,\n        r = l.top + l.bottom;\n    k.measure(b, c, f, g);\n    l = k.measuredBounds;\n    var q = 0,\n        u = null;\n    k instanceof Cf && (u = k, q = u.strokeWidth * u.scale);\n    var w = Math.max(l.width + p, 0);\n    l = Math.max(l.height + r, 0);\n    var v = zm(k),\n        z = v.x * w + v.offsetX;\n    v = v.y * l + v.offsetY;\n    var y = Am(k),\n        A = y.x * w + y.offsetX;\n    y = y.y * l + y.offsetY;\n    isFinite(b) && (m = Math.max(Math.abs(z - A) - q, 0));\n    isFinite(c) && (n = Math.max(Math.abs(v - y) - q, 0));\n    q = K.alloc();\n    q.h(0, 0);\n    a = tm(a);\n\n    for (y = 0; y < h; y++) {\n      v = d[y], v === k || !v.visible && v !== a || (l = v.margin, w = l.right + l.left, z = l.top + l.bottom, v.measure(m, n, 0, 0), l = v.measuredBounds, w = Math.max(l.width + w, 0), l = Math.max(l.height + z, 0), q.h(Math.max(w, q.width), Math.max(l, q.height)));\n    }\n\n    if (1 === h) e.width = w, e.height = l, K.free(q);else {\n      v = zm(k);\n      y = Am(k);\n      h = d = 0;\n      y.x !== v.x && y.y !== v.y && (d = q.width / Math.abs(y.x - v.x), h = q.height / Math.abs(y.y - v.y));\n      K.free(q);\n      q = 0;\n      null !== u && (q = u.strokeWidth * u.scale, mg(u) === ng && (d = h = Math.max(d, h)));\n      d += Math.abs(v.offsetX) + Math.abs(y.offsetX) + q;\n      h += Math.abs(v.offsetY) + Math.abs(y.offsetY) + q;\n      u = k.stretch;\n      u === Wk && (u = hl(k, !1));\n\n      switch (u) {\n        case lg:\n          g = f = 0;\n          break;\n\n        case td:\n          isFinite(b) && (d = b);\n          isFinite(c) && (h = c);\n          break;\n\n        case Uk:\n          isFinite(b) && (d = b);\n          g = 0;\n          break;\n\n        case Vk:\n          f = 0, isFinite(c) && (h = c);\n      }\n\n      k.Mj();\n      k.measure(d, h, f, g);\n      e.width = k.measuredBounds.width + p;\n      e.height = k.measuredBounds.height + r;\n    }\n  };\n\n  ym.prototype.arrange = function (a, b) {\n    var c = b.length,\n        d = a.vb(),\n        e = d.measuredBounds,\n        f = M.alloc();\n    f.h(0, 0, 1, 1);\n    var g = d.margin,\n        h = g.left;\n    g = g.top;\n    var k = a.padding,\n        l = k.left;\n    k = k.top;\n    d.arrange(l + h, k + g, e.width, e.height);\n    var m = zm(d),\n        n = Am(d),\n        p = m.y * e.height + m.offsetY,\n        r = n.x * e.width + n.offsetX;\n    n = n.y * e.height + n.offsetY;\n    f.x = m.x * e.width + m.offsetX;\n    f.y = p;\n    Zb(f, r, n, 0, 0);\n    f.x += h + l;\n    f.y += g + k;\n\n    for (e = 0; e < c; e++) {\n      h = b[e], h !== d && (l = h.measuredBounds, g = h.margin, k = Math.max(l.width + g.right + g.left, 0), m = Math.max(l.height + g.top + g.bottom, 0), p = h.alignment, p.Sb() && (p = a.defaultAlignment), p.pb() || (p = yc), k = f.width * p.x + p.offsetX - k * p.x + g.left + f.x, g = f.height * p.y + p.offsetY - m * p.y + g.top + f.y, h.visible && ($b(f.x, f.y, f.width, f.height, k, g, l.width, l.height) ? h.arrange(k, g, l.width, l.height) : h.arrange(k, g, l.width, l.height, new M(f.x, f.y, f.width, f.height))));\n    }\n\n    M.free(f);\n  };\n\n  function Bm() {\n    this.va = \"Base\";\n    this.name = \"Table\";\n  }\n\n  la(Bm, Kl);\n\n  Bm.prototype.measure = function (a, b, c, d, e) {\n    for (var f = d.length, g = Ea(), h = Ea(), k = 0; k < f; k++) {\n      var l = d[k],\n          m = l instanceof W ? l : null;\n      if (null === m || m.type !== W.TableRow && m.type !== W.TableColumn || !l.visible) g.push(l);else {\n        h.push(m);\n\n        for (var n = m.R.s, p = n.length, r = 0; r < p; r++) {\n          var q = n[r];\n          m.type === W.TableRow ? q.row = l.row : m.type === W.TableColumn && (q.column = l.column);\n          g.push(q);\n        }\n      }\n    }\n\n    f = g.length;\n    0 === f && (a.getRowDefinition(0), a.getColumnDefinition(0));\n\n    for (var u = [], w = 0; w < f; w++) {\n      var v = g[w];\n      v.visible && (ij(v, !0), il(v, !0), u[v.row] || (u[v.row] = []), u[v.row][v.column] || (u[v.row][v.column] = []), u[v.row][v.column].push(v));\n    }\n\n    Ga(g);\n    var z = Ea(),\n        y = Ea(),\n        A = Ea(),\n        B = {\n      count: 0\n    },\n        F = {\n      count: 0\n    },\n        L = b,\n        S = c,\n        R = a.rowDefs,\n        P = a.colDefs,\n        H = null;\n    f = R.length;\n\n    for (var da = 0; da < f; da++) {\n      H = R[da], void 0 !== H && (H.actual = 0);\n    }\n\n    f = P.length;\n\n    for (var X = 0; X < f; X++) {\n      H = P[X], void 0 !== H && (H.actual = 0);\n    }\n\n    for (var oa = u.length, Ba = 0, db = 0; db < oa; db++) {\n      u[db] && (Ba = Math.max(Ba, u[db].length));\n    }\n\n    var hb = Math.min(a.topIndex, oa - 1),\n        Fb = Math.min(a.leftIndex, Ba - 1),\n        eb = 0;\n    oa = u.length;\n\n    for (var Je = tm(a), Ua = 0; Ua < oa; Ua++) {\n      if (u[Ua]) {\n        Ba = u[Ua].length;\n        var od = a.getRowDefinition(Ua);\n        od.actual = 0;\n\n        for (var Gb = od.jc = 0; Gb < Ba; Gb++) {\n          if (u[Ua][Gb]) {\n            var Ke = a.getColumnDefinition(Gb);\n            void 0 === z[Gb] && (Ke.actual = 0, Ke.jc = 0, z[Gb] = !0);\n\n            for (var wc = u[Ua][Gb], Rc = wc.length, lc = 0; lc < Rc; lc++) {\n              var fc = wc[lc];\n\n              if (fc.visible || fc === Je) {\n                var gf = 1 < fc.rowSpan || 1 < fc.columnSpan;\n                gf && (Ua < hb || Gb < Fb || y.push(fc));\n                var pd = fc.margin,\n                    Dh = pd.right + pd.left,\n                    mc = pd.top + pd.bottom;\n                var Hb = Al(fc, od, Ke, !1);\n                var Hi = fc.desiredSize,\n                    sg = !isNaN(Hi.height),\n                    Bd = !isNaN(Hi.width) && sg;\n                gf || Hb === lg || Bd || Ua < hb || Gb < Fb || (void 0 !== B[Gb] || Hb !== td && Hb !== Uk || (B[Gb] = -1, B.count++), void 0 !== F[Ua] || Hb !== td && Hb !== Vk || (F[Ua] = -1, F.count++), A.push(fc));\n                fc.measure(Infinity, Infinity, 0, 0);\n\n                if (!(Ua < hb || Gb < Fb)) {\n                  var gc = fc.measuredBounds,\n                      Mf = Math.max(gc.width + Dh, 0),\n                      nc = Math.max(gc.height + mc, 0);\n\n                  if (1 === fc.rowSpan && (Hb === lg || Hb === Uk)) {\n                    H = a.getRowDefinition(Ua);\n                    var hf = H.Qc();\n                    eb = Math.max(nc - H.actual, 0);\n                    eb + hf > S && (eb = Math.max(S - hf, 0));\n                    var mk = 0 === H.ma;\n                    H.jc = H.jc + eb;\n                    H.actual = H.ma + eb;\n                    S = Math.max(S - (eb + (mk ? hf : 0)), 0);\n                  }\n\n                  if (1 === fc.columnSpan && (Hb === lg || Hb === Vk)) {\n                    H = a.getColumnDefinition(Gb);\n                    var Ii = H.Qc();\n                    eb = Math.max(Mf - H.actual, 0);\n                    eb + Ii > L && (eb = Math.max(L - Ii, 0));\n                    var Kn = 0 === H.ma;\n                    H.jc = H.jc + eb;\n                    H.actual = H.ma + eb;\n                    L = Math.max(L - (eb + (Kn ? Ii : 0)), 0);\n                  }\n\n                  gf && fc.Mj();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    Ga(z);\n    var Nd = 0,\n        me = 0;\n    f = a.columnCount;\n\n    for (var tg = 0; tg < f; tg++) {\n      var jf = P[tg];\n      void 0 !== jf && (Nd += isNaN(jf.Ac) ? jf.jc : jf.Ac, 0 !== jf.jc && (Nd += jf.Qc()));\n    }\n\n    f = a.rowCount;\n\n    for (var Eh = 0; Eh < f; Eh++) {\n      var kf = R[Eh];\n      void 0 !== kf && (me += isNaN(kf.Ac) ? kf.jc : kf.Ac, 0 !== kf.jc && (me += kf.Qc()));\n    }\n\n    L = Math.max(b - Nd, 0);\n    var Od = S = Math.max(c - me, 0),\n        Le = L;\n    f = A.length;\n\n    for (var hc = 0; hc < f; hc++) {\n      var Cd = A[hc],\n          nk = a.getRowDefinition(Cd.row),\n          ne = a.getColumnDefinition(Cd.column),\n          Fh = Cd.measuredBounds,\n          qd = Cd.margin,\n          Nf = qd.right + qd.left,\n          Dd = qd.top + qd.bottom;\n      B[Cd.column] = 0 === ne.jc && void 0 !== B[Cd.column] ? Math.max(Fh.width + Nf, B[Cd.column]) : null;\n      F[Cd.row] = 0 === nk.jc && void 0 !== F[Cd.row] ? Math.max(Fh.height + Dd, F[Cd.row]) : null;\n    }\n\n    var ug = 0,\n        Gh = 0,\n        bd;\n\n    for (bd in F) {\n      \"count\" !== bd && (ug += F[bd]);\n    }\n\n    for (bd in B) {\n      \"count\" !== bd && (Gh += B[bd]);\n    }\n\n    for (var ib = K.alloc(), Ji = 0; Ji < f; Ji++) {\n      var Vb = A[Ji];\n\n      if (Vb.visible || Vb === Je) {\n        var Va = a.getRowDefinition(Vb.row),\n            Wb = a.getColumnDefinition(Vb.column),\n            oe = 0;\n        isFinite(Wb.width) ? oe = Wb.width : (isFinite(L) && null !== B[Vb.column] ? 0 === Gh ? oe = Wb.actual + L : oe = B[Vb.column] / Gh * Le : null !== B[Vb.column] ? oe = L : oe = Wb.actual || L, oe = Math.max(0, oe - Wb.Qc()));\n        var Me = 0;\n        isFinite(Va.height) ? Me = Va.height : (isFinite(S) && null !== F[Vb.row] ? 0 === ug ? Me = Va.actual + S : Me = F[Vb.row] / ug * Od : null !== F[Vb.row] ? Me = S : Me = Va.actual || S, Me = Math.max(0, Me - Va.Qc()));\n        ib.h(Math.max(Wb.minimum, Math.min(oe, Wb.maximum)), Math.max(Va.minimum, Math.min(Me, Va.maximum)));\n        Hb = Al(Vb, Va, Wb, !1);\n\n        switch (Hb) {\n          case Uk:\n            ib.height = Math.max(ib.height, Va.actual + S);\n            break;\n\n          case Vk:\n            ib.width = Math.max(ib.width, Wb.actual + L);\n        }\n\n        var Of = Vb.margin,\n            Ln = Of.right + Of.left,\n            ok = Of.top + Of.bottom;\n        Vb.Mj();\n        Vb.measure(ib.width, ib.height, Wb.minimum, Va.minimum);\n        var Hh = Vb.measuredBounds,\n            Pf = Math.max(Hh.width + Ln, 0),\n            vg = Math.max(Hh.height + ok, 0);\n        isFinite(L) && (Pf = Math.min(Pf, ib.width));\n        isFinite(S) && (vg = Math.min(vg, ib.height));\n        var ic = 0;\n        ic = Va.actual;\n        Va.actual = Math.max(Va.actual, vg);\n        Va.jc = Math.max(Va.jc, vg);\n        eb = Va.actual - ic;\n        S = Math.max(S - eb, 0);\n        null === F[Vb.row] && (Od = Math.max(Od - eb, 0));\n        ic = Wb.actual;\n        Wb.actual = Math.max(Wb.actual, Pf);\n        Wb.jc = Math.max(Wb.jc, Pf);\n        eb = Wb.actual - ic;\n        L = Math.max(L - eb, 0);\n        null === B[Vb.column] && (Le = Math.max(Le - eb, 0));\n      }\n    }\n\n    Ga(A);\n    var Ed = K.alloc(),\n        rd = Ea(),\n        Fc = Ea();\n    f = y.length;\n    if (0 !== f) for (var lf = 0; lf < oa; lf++) {\n      if (u[lf]) {\n        Ba = u[lf].length;\n        var Ih = a.getRowDefinition(lf);\n        rd[lf] = Ih.actual;\n\n        for (var mf = 0; mf < Ba; mf++) {\n          if (u[lf][mf]) {\n            var pk = a.getColumnDefinition(mf);\n            Fc[mf] = pk.actual;\n          }\n        }\n      }\n    }\n\n    for (var Jh = 0; Jh < f; Jh++) {\n      var Oa = y[Jh];\n\n      if (Oa.visible || Oa === Je) {\n        var cd = a.getRowDefinition(Oa.row),\n            Sc = a.getColumnDefinition(Oa.column);\n        ib.h(Math.max(Sc.minimum, Math.min(b, Sc.maximum)), Math.max(cd.minimum, Math.min(c, cd.maximum)));\n        Hb = Al(Oa, cd, Sc, !1);\n\n        switch (Hb) {\n          case td:\n            0 !== Fc[Sc.index] && (ib.width = Math.min(ib.width, Fc[Sc.index]));\n            0 !== rd[cd.index] && (ib.height = Math.min(ib.height, rd[cd.index]));\n            break;\n\n          case Uk:\n            0 !== Fc[Sc.index] && (ib.width = Math.min(ib.width, Fc[Sc.index]));\n            break;\n\n          case Vk:\n            0 !== rd[cd.index] && (ib.height = Math.min(ib.height, rd[cd.index]));\n        }\n\n        isFinite(Sc.width) && (ib.width = Sc.width);\n        isFinite(cd.height) && (ib.height = cd.height);\n        Ed.h(0, 0);\n\n        for (var qk = Sc.minimum, oc = cd.minimum, Ne = 1; Ne < Oa.rowSpan && !(Oa.row + Ne >= a.rowCount); Ne++) {\n          H = a.getRowDefinition(Oa.row + Ne), eb = 0, eb = Hb === td || Hb === Vk ? Math.max(H.minimum, 0 === rd[Oa.row + Ne] ? H.maximum : Math.min(rd[Oa.row + Ne], H.maximum)) : Math.max(H.minimum, isNaN(H.Ac) ? H.maximum : Math.min(H.Ac, H.maximum)), Ed.height += eb, oc += H.minimum;\n        }\n\n        for (var Tc = 1; Tc < Oa.columnSpan && !(Oa.column + Tc >= a.columnCount); Tc++) {\n          H = a.getColumnDefinition(Oa.column + Tc), eb = 0, eb = Hb === td || Hb === Uk ? Math.max(H.minimum, 0 === Fc[Oa.column + Tc] ? H.maximum : Math.min(Fc[Oa.column + Tc], H.maximum)) : Math.max(H.minimum, isNaN(H.Ac) ? H.maximum : Math.min(H.Ac, H.maximum)), Ed.width += eb, qk += H.minimum;\n        }\n\n        ib.width += Ed.width;\n        ib.height += Ed.height;\n        var Kh = Oa.margin,\n            nf = Kh.right + Kh.left,\n            Ki = Kh.top + Kh.bottom;\n        Oa.measure(ib.width, ib.height, qk, oc);\n\n        for (var Lh = Oa.measuredBounds, Fd = Math.max(Lh.width + nf, 0), Qf = Math.max(Lh.height + Ki, 0), of = 0, Mh = 0; Mh < Oa.rowSpan && !(Oa.row + Mh >= a.rowCount); Mh++) {\n          H = a.getRowDefinition(Oa.row + Mh), of += H.total || 0;\n        }\n\n        if (of < Qf) {\n          var Oe = Qf - of,\n              Pd = Qf - of;\n          if (null !== Oa.spanAllocation) for (var Pe = Oa.spanAllocation, pe = 0; pe < Oa.rowSpan && !(0 >= Oe) && !(Oa.row + pe >= a.rowCount); pe++) {\n            H = a.getRowDefinition(Oa.row + pe);\n            var Qe = H.ma || 0,\n                Rf = Pe(Oa, H, Pd);\n            H.actual = Math.min(H.maximum, Qe + Rf);\n            H.ma !== Qe && (Oe -= H.ma - Qe);\n          }\n\n          for (; 0 < Oe;) {\n            var sd = H.ma || 0;\n            isNaN(H.height) && H.maximum > sd && (H.actual = Math.min(H.maximum, sd + Oe), H.ma !== sd && (Oe -= H.ma - sd));\n            if (0 === H.index) break;\n            H = a.getRowDefinition(H.index - 1);\n          }\n        }\n\n        for (var wg = 0, Re = 0; Re < Oa.columnSpan && !(Oa.column + Re >= a.columnCount); Re++) {\n          H = a.getColumnDefinition(Oa.column + Re), wg += H.total || 0;\n        }\n\n        if (wg < Fd) {\n          var xg = Fd - wg,\n              Mn = Fd - wg;\n          if (null !== Oa.spanAllocation) for (var qe = Oa.spanAllocation, Sf = 0; Sf < Oa.columnSpan && !(0 >= xg) && !(Oa.column + Sf >= a.columnCount); Sf++) {\n            H = a.getColumnDefinition(Oa.column + Sf);\n            var Li = H.ma || 0,\n                Nn = qe(Oa, H, Mn);\n            H.actual = Math.min(H.maximum, Li + Nn);\n            H.ma !== Li && (xg -= H.ma - Li);\n          }\n\n          for (; 0 < xg;) {\n            var rk = H.ma || 0;\n            isNaN(H.width) && H.maximum > rk && (H.actual = Math.min(H.maximum, rk + xg), H.ma !== rk && (xg -= H.ma - rk));\n            if (0 === H.index) break;\n            H = a.getColumnDefinition(H.index - 1);\n          }\n        }\n      }\n    }\n\n    Ga(y);\n    K.free(Ed);\n    K.free(ib);\n    void 0 !== rd && Ga(rd);\n    void 0 !== Fc && Ga(Fc);\n    var yg = 0,\n        zg = 0,\n        sk = a.desiredSize,\n        ur = a.maxSize;\n    Hb = hl(a, !0);\n    var Mi = me = Nd = 0,\n        Ni = 0;\n    f = a.columnCount;\n\n    for (var tk = 0; tk < f; tk++) {\n      void 0 !== P[tk] && (H = a.getColumnDefinition(tk), isFinite(H.width) ? (Mi += H.width, Mi += H.Qc()) : Cm(H) === Dm ? (Mi += H.ma, Mi += H.Qc()) : 0 !== H.ma && (Nd += H.ma, Nd += H.Qc()));\n    }\n\n    isFinite(sk.width) ? yg = Math.min(sk.width, ur.width) : yg = Hb !== lg && isFinite(b) ? b : Nd;\n    yg = Math.max(yg, a.minSize.width);\n    yg = Math.max(yg - Mi, 0);\n\n    for (var hu = 0 === Nd ? 1 : Math.max(yg / Nd, 1), vk = 0; vk < f; vk++) {\n      void 0 !== P[vk] && (H = a.getColumnDefinition(vk), isFinite(H.width) || Cm(H) === Dm || (H.actual = H.ma * hu), H.position = e.width, 0 !== H.ma && (e.width += H.ma, e.width += H.Qc()));\n    }\n\n    f = a.rowCount;\n\n    for (var wk = 0; wk < f; wk++) {\n      void 0 !== R[wk] && (H = a.getRowDefinition(wk), isFinite(H.height) ? (Ni += H.height, Ni += H.Qc()) : Cm(H) === Dm ? (Ni += H.ma, Ni += H.Qc()) : 0 !== H.ma && (me += H.ma, me += H.Qc()));\n    }\n\n    isFinite(sk.height) ? zg = Math.min(sk.height, ur.height) : zg = Hb !== lg && isFinite(c) ? c : me;\n    zg = Math.max(zg, a.minSize.height);\n    zg = Math.max(zg - Ni, 0);\n\n    for (var iu = 0 === me ? 1 : Math.max(zg / me, 1), xk = 0; xk < f; xk++) {\n      void 0 !== R[xk] && (H = a.getRowDefinition(xk), isFinite(H.height) || Cm(H) === Dm || (H.actual = H.ma * iu), H.position = e.height, 0 !== H.ma && (e.height += H.ma, e.height += H.Qc()));\n    }\n\n    f = h.length;\n\n    for (var On = 0; On < f; On++) {\n      var Pi = h[On],\n          Pn = 0,\n          Qn = 0;\n      Pi.type === W.TableRow ? (Pn = e.width, H = a.getRowDefinition(Pi.row), Qn = H.actual) : (H = a.getColumnDefinition(Pi.column), Pn = H.actual, Qn = e.height);\n      Pi.measuredBounds.h(0, 0, Pn, Qn);\n      ij(Pi, !1);\n    }\n\n    Ga(h);\n    a.inRowsCols = u;\n  };\n\n  Bm.prototype.arrange = function (a, b, c) {\n    var d = b.length,\n        e = a.padding,\n        f = e.left;\n    e = e.top;\n    var g = a.inRowsCols;\n\n    if (null !== g) {\n      for (var h, k, l = g.length, m = 0, n = 0; n < l; n++) {\n        g[n] && (m = Math.max(m, g[n].length));\n      }\n\n      k = a.rowDefs;\n      h = a.colDefs;\n      var p = n = 0,\n          r = Math.min(a.topIndex, l - 1);\n\n      if (0 < k.length) {\n        for (; r !== l && (void 0 === k[r] || 0 === k[r].ma);) {\n          r++;\n        }\n\n        r = Math.max(Math.min(r, l - 1), 0);\n        n = -k[r].position;\n      }\n\n      var q = Math.min(a.leftIndex, m - 1);\n\n      if (0 < h.length) {\n        for (; q !== m && (void 0 === h[q] || 0 === h[q].ma);) {\n          q++;\n        }\n\n        q = Math.max(Math.min(q, m - 1), 0);\n        p = -h[q].position;\n      }\n\n      for (var u = 0, w = 0; u !== l && void 0 === k[u];) {\n        u++;\n      }\n\n      for (; w !== l && void 0 === h[w];) {\n        w++;\n      }\n\n      m = a.part;\n      a.getRowDefinition(u);\n      a.getColumnDefinition(w);\n\n      for (var v = 0; v < b.length; v++) {\n        var z = b[v];\n\n        if (z instanceof W && z.visible && (z.type === W.TableRow || z.type === W.TableColumn)) {\n          if (z.type === W.TableRow) {\n            h = a.getRowDefinition(z.row);\n            var y = a.getColumnDefinition(w);\n          } else h = a.getRowDefinition(u), y = a.getColumnDefinition(z.column);\n\n          k = h.position + n + e;\n          0 !== h.ma && (k += h.mo(Math.max(u, r)));\n          h = y.position + p + f;\n          0 !== y.ma && (h += y.mo(Math.max(w, q)));\n          y = z.measuredBounds;\n          z.Jk();\n          z.actualBounds.ja();\n          var A = z.actualBounds,\n              B = M.allocAt(A.x, A.y, A.width, A.height);\n          A.x = z.type === W.TableRow ? f : h;\n          A.y = z.type === W.TableColumn ? e : k;\n          A.width = y.width;\n          A.height = y.height;\n          z.actualBounds.freeze();\n          il(z, !1);\n          Tb(B, A) || null === m || (m.dh(), z.wn(m));\n          M.free(B);\n        }\n      }\n\n      v = K.alloc();\n\n      for (z = 0; z < l; z++) {\n        if (g[z]) for (m = g[z].length, y = a.getRowDefinition(z), k = y.position + n + e, 0 !== y.ma && (k += y.mo(Math.max(u, r))), A = 0; A < m; A++) {\n          if (g[z][A]) {\n            B = a.getColumnDefinition(A);\n            h = B.position + p + f;\n            0 !== B.ma && (h += B.mo(Math.max(w, q)));\n\n            for (var F = g[z][A], L = F.length, S = 0; S < L; S++) {\n              var R = F[S],\n                  P = R.measuredBounds;\n              v.h(0, 0);\n\n              for (var H = 1; H < R.rowSpan && !(z + H >= a.rowCount); H++) {\n                var da = a.getRowDefinition(z + H);\n                0 !== da.ma && (v.height += da.total);\n              }\n\n              for (H = 1; H < R.columnSpan && !(A + H >= a.columnCount); H++) {\n                da = a.getColumnDefinition(A + H), 0 !== da.ma && (v.width += da.total);\n              }\n\n              var X = B.ma + v.width,\n                  oa = y.ma + v.height;\n              H = h;\n              da = k;\n              var Ba = X,\n                  db = oa,\n                  hb = h,\n                  Fb = k,\n                  eb = X,\n                  Je = oa;\n              h + X > c.width && (eb = Math.max(c.width - h, 0));\n              k + oa > c.height && (Je = Math.max(c.height - k, 0));\n              var Ua = R.alignment;\n\n              if (Ua.Sb()) {\n                Ua = a.defaultAlignment;\n                Ua.pb() || (Ua = yc);\n                var od = Ua.x;\n                var Gb = Ua.y;\n                var Ke = Ua.offsetX;\n                Ua = Ua.offsetY;\n                var wc = B.alignment,\n                    Rc = y.alignment;\n                wc.pb() && (od = wc.x, Ke = wc.offsetX);\n                Rc.pb() && (Gb = Rc.y, Ua = Rc.offsetY);\n              } else od = Ua.x, Gb = Ua.y, Ke = Ua.offsetX, Ua = Ua.offsetY;\n\n              if (isNaN(od) || isNaN(Gb)) Gb = od = .5, Ua = Ke = 0;\n              wc = P.width;\n              Rc = P.height;\n              var lc = R.margin,\n                  fc = lc.left + lc.right,\n                  gf = lc.top + lc.bottom,\n                  pd = Al(R, y, B, !1);\n              !isNaN(R.desiredSize.width) || pd !== td && pd !== Uk || (wc = Math.max(X - fc, 0));\n              !isNaN(R.desiredSize.height) || pd !== td && pd !== Vk || (Rc = Math.max(oa - gf, 0));\n              X = R.maxSize;\n              oa = R.minSize;\n              wc = Math.min(X.width, wc);\n              Rc = Math.min(X.height, Rc);\n              wc = Math.max(oa.width, wc);\n              Rc = Math.max(oa.height, Rc);\n              X = Rc + gf;\n              H += Ba * od - (wc + fc) * od + Ke + lc.left;\n              da += db * Gb - X * Gb + Ua + lc.top;\n              R.visible && ($b(hb, Fb, eb, Je, H, da, P.width, P.height) ? R.arrange(H, da, wc, Rc) : R.arrange(H, da, wc, Rc, new M(hb, Fb, eb, Je)));\n            }\n          }\n        }\n      }\n\n      K.free(v);\n\n      for (a = 0; a < d; a++) {\n        c = b[a], f = c instanceof W ? c : null, null === f || f.type !== W.TableRow && f.type !== W.TableColumn || (f = c.actualBounds, c.naturalBounds.ja(), c.naturalBounds.h(0, 0, f.width, f.height), c.naturalBounds.freeze());\n      }\n    }\n  };\n\n  function Em() {\n    this.va = \"Base\";\n  }\n\n  la(Em, Kl);\n\n  Em.prototype.measure = function () {};\n\n  Em.prototype.arrange = function () {};\n\n  function Fm() {\n    this.va = \"Base\";\n  }\n\n  la(Fm, Kl);\n\n  Fm.prototype.measure = function () {};\n\n  Fm.prototype.arrange = function () {};\n\n  function Gm() {\n    this.va = \"Base\";\n  }\n\n  la(Gm, Kl);\n\n  Gm.prototype.measure = function (a, b, c, d, e, f, g) {\n    1 < d.length && C(\"Viewbox Panel cannot contain more than one GraphObject.\");\n    d = d[0];\n    d.xa = 1;\n    d.Mj();\n    d.measure(Infinity, Infinity, f, g);\n    var h = d.measuredBounds,\n        k = d.margin,\n        l = k.right + k.left;\n    k = k.top + k.bottom;\n\n    if (isFinite(b) || isFinite(c)) {\n      var m = d.scale,\n          n = h.width;\n      h = h.height;\n      var p = Math.max(b - l, 0),\n          r = Math.max(c - k, 0),\n          q = 1;\n      a.viewboxStretch === ng ? 0 !== n && 0 !== h && (q = Math.min(p / n, r / h)) : 0 !== n && 0 !== h && (q = Math.max(p / n, r / h));\n      0 === q && (q = 1E-4);\n      d.xa *= q;\n      m !== d.scale && (ij(d, !0), d.measure(Infinity, Infinity, f, g));\n    }\n\n    h = d.measuredBounds;\n    e.width = isFinite(b) ? b : Math.max(h.width + l, 0);\n    e.height = isFinite(c) ? c : Math.max(h.height + k, 0);\n  };\n\n  Gm.prototype.arrange = function (a, b, c) {\n    b = b[0];\n    var d = b.measuredBounds,\n        e = b.margin,\n        f = Math.max(d.width + (e.right + e.left), 0);\n    e = Math.max(d.height + (e.top + e.bottom), 0);\n    var g = b.alignment;\n    g.Sb() && (g = a.defaultAlignment);\n    g.pb() || (g = yc);\n    b.arrange(c.width * g.x - f * g.x + g.offsetX, c.height * g.y - e * g.y + g.offsetY, d.width, d.height);\n  };\n\n  function Hm() {\n    this.va = \"Base\";\n  }\n\n  la(Hm, Kl);\n\n  Hm.prototype.measure = function () {};\n\n  Hm.prototype.arrange = function () {};\n\n  Hm.prototype.tc = function (a, b, c) {\n    c = a.uf() * c.scale;\n    0 >= c && (c = 1);\n    var d = a.gridCellSize,\n        e = d.width;\n    d = d.height;\n    var f = a.naturalBounds,\n        g = a.actualBounds,\n        h = f.width,\n        k = f.height,\n        l = Math.ceil(h / e),\n        m = Math.ceil(k / d),\n        n = a.gridOrigin,\n        p = n.x;\n    n = n.y;\n    b.save();\n    b.beginPath();\n    b.rect(0, 0, h, k);\n    b.clip();\n\n    for (var r = [], q = a.R.s, u = q.length, w = 0; w < u; w++) {\n      var v = q[w],\n          z = [];\n      r.push(z);\n\n      if (v.visible) {\n        var y = v.interval;\n\n        if (!(0 > y)) {\n          v = Sj(v.figure);\n\n          for (var A = 0; A < u; A++) {\n            if (A !== w) {\n              var B = q[A];\n              B.visible && Sj(B.figure) === v && (B = B.interval, B > y && z.push(B));\n            }\n          }\n        }\n      }\n    }\n\n    q = a.R.s;\n    u = q.length;\n\n    for (w = 0; w < u; w++) {\n      var F = q[w];\n\n      if (F.visible && (z = F.interval || 1, v = Math.abs(z), !(2 > e * v * c))) {\n        y = F.segmentIndex;\n        if (!isFinite(y) || isNaN(y)) y = 0;\n        0 > y && (y = v - Math.min(-y, v));\n        y = Math.round(y % v);\n        v = F.opacity;\n        A = 1;\n\n        if (1 !== v) {\n          if (0 === v) continue;\n          A = b.globalAlpha;\n          b.globalAlpha = A * v;\n        }\n\n        B = r[w];\n        var L = !1,\n            S = F.strokeDashArray;\n        null !== S && (L = !0, b.Gr(S, F.strokeDashOffset));\n\n        if (\"LineV\" === F.figure && null !== F.stroke && 0 < F.strokeWidth) {\n          b.lineWidth = F.strokeWidth;\n          gi(a, b, F.stroke, !1, !1, f, g);\n          b.beginPath();\n\n          for (S = F = Math.floor((p - e) / e); S <= F + l; S++) {\n            var R = S * e + p;\n            0 <= R && R <= h && Im(S, z, y, B) && (b.moveTo(R, 0), b.lineTo(R, k));\n          }\n\n          b.stroke();\n        } else if (\"LineH\" === F.figure && null !== F.stroke && 0 < F.strokeWidth) {\n          b.lineWidth = F.strokeWidth;\n          gi(a, b, F.stroke, !1, !1, f, g);\n          b.beginPath();\n\n          for (S = F = Math.floor((n - d) / d); S <= F + m; S++) {\n            R = S * d + n, 0 <= R && R <= k && Im(S, z, y, B) && (b.moveTo(0, R), b.lineTo(h, R));\n          }\n\n          b.stroke();\n        } else if (\"BarV\" === F.figure && null !== F.fill) for (gi(a, b, F.fill, !0, !1, f, g), F = F.width, isNaN(F) && (F = e), R = S = Math.floor((p - e) / e); R <= S + l; R++) {\n          var P = R * e + p;\n          0 <= P + F && P <= h && Im(R, z, y, B) && b.fillRect(P, 0, F, k);\n        } else if (\"BarH\" === F.figure && null !== F.fill) for (gi(a, b, F.fill, !0, !1, f, g), F = F.height, isNaN(F) && (F = d), R = S = Math.floor((n - d) / d); R <= S + m; R++) {\n          P = R * d + n, 0 <= P + F && P <= k && Im(R, z, y, B) && b.fillRect(0, P, h, F);\n        }\n\n        L && b.Er();\n        1 !== v && (b.globalAlpha = A);\n      }\n    }\n\n    b.restore();\n    b.Oc(!1);\n  };\n\n  function Im(a, b, c, d) {\n    if (0 > b) return a % b === c;\n    if (a % b !== c) return !1;\n    b = d.length;\n\n    for (var e = 0; e < b; e++) {\n      if (a % d[e] === c) return !1;\n    }\n\n    return !0;\n  }\n\n  function Jm() {\n    this.va = \"Base\";\n  }\n\n  la(Jm, Kl);\n\n  Jm.prototype.measure = function (a, b, c, d, e) {\n    var f = d.length;\n\n    if (a instanceof ue || a instanceof T) {\n      var g = null,\n          h = null;\n      a instanceof T && (g = a);\n      a instanceof ue && (h = a, g = h.adornedPart, null === a.j && (a.j = []));\n\n      if (g instanceof T) {\n        var k = g;\n        if (0 === f) Qb(a.naturalBounds, 0, 0), a.measuredBounds.h(0, 0, 0, 0);else {\n          var l = a instanceof ue ? null : g.path;\n          b = g.routeBounds;\n          c = a.bg;\n          c.h(0, 0, b.width, b.height);\n          var m = k.points,\n              n = g.pointsCount;\n          null !== h ? h.Rj(!1) : null !== g && g.Rj(!1);\n          h = b.width;\n          var p = b.height,\n              r = a.j;\n          r.length = 0;\n\n          if (null !== l) {\n            Km(a, h, p, l);\n            var q = l.measuredBounds;\n            c.Xc(q);\n            r.push(q);\n          }\n\n          q = md.alloc();\n\n          for (var u = I.alloc(), w = I.alloc(), v = 0; v < f; v++) {\n            var z = d[v];\n            if (z !== l) if (z.isPanelMain && z instanceof Cf) {\n              Km(a, h, p, z);\n              var y = z.measuredBounds;\n              c.Xc(y);\n              r.push(y);\n            } else if (2 > n) z.measure(Infinity, Infinity, 0, 0), y = z.measuredBounds, c.Xc(y), r.push(y);else {\n              var A = z.segmentIndex,\n                  B = z.segmentFraction,\n                  F = z.alignmentFocus;\n              F.Fc() && (F = yc);\n              var L = z.segmentOrientation,\n                  S = z.segmentOffset;\n\n              if (isNaN(A)) {\n                var R = k.sa;\n                y = Ea();\n                R.Cu(B, y);\n                var P = I.allocAt(y[0], y[1]);\n                P.add(k.i(0));\n                R.type === O.j ? P.offset(-R.startX, -R.startY) : (R = R.figures.first(), null !== R && P.offset(-R.startX, -R.startY));\n                R = y[2];\n\n                if (L !== $f) {\n                  var H = k.computeAngle(z, L, R);\n                  z.Gb = H;\n                }\n\n                H = P.x - b.x;\n                var da = P.y - b.y;\n                I.free(P);\n                Ga(y);\n              } else if (A < -n || A >= n) y = I.alloc(), k.mg(), k.computeMidPoint(y), R = k.midAngle, L !== $f && (H = k.computeAngle(z, L, R), z.Gb = H), H = y.x - b.x, da = y.y - b.y, I.free(y);else {\n                H = 0;\n                0 <= A ? (da = m.K(A), y = A < n - 1 ? m.K(A + 1) : da) : (H = n + A, da = m.K(H), y = 0 < H ? m.K(H - 1) : da);\n\n                if (da.$a(y)) {\n                  0 <= A ? (R = 0 < A ? m.K(A - 1) : da, H = A < n - 2 ? m.K(A + 2) : y) : (R = H < n - 1 ? m.K(H + 1) : da, H = 1 < H ? m.K(H - 2) : y);\n                  P = R.rf(da);\n                  var X = y.rf(H);\n                  R = P > X + 10 ? 0 <= A ? R.Ya(da) : da.Ya(R) : X > P + 10 ? 0 <= A ? y.Ya(H) : H.Ya(y) : 0 <= A ? R.Ya(H) : H.Ya(R);\n                } else R = 0 <= A ? da.Ya(y) : y.Ya(da);\n\n                L !== $f && (H = k.computeAngle(z, L, R), z.Gb = H);\n                H = da.x + (y.x - da.x) * B - b.x;\n                da = da.y + (y.y - da.y) * B - b.y;\n              }\n\n              z.measure(Infinity, Infinity, 0, 0);\n              y = z.measuredBounds;\n              P = z.naturalBounds;\n              var oa = 0;\n              z instanceof Cf && (oa = z.strokeWidth);\n              X = P.width + oa;\n              var Ba = P.height + oa;\n              q.reset();\n              q.translate(-y.x, -y.y);\n              q.scale(z.scale, z.scale);\n              q.rotate(L === $f ? z.angle : R, X / 2, Ba / 2);\n              L !== Lm && L !== Mm || q.rotate(90, X / 2, Ba / 2);\n              L !== Nm && L !== Om || q.rotate(-90, X / 2, Ba / 2);\n              L === Pm && (45 < R && 135 > R || 225 < R && 315 > R) && q.rotate(-R, X / 2, Ba / 2);\n              P = new M(0, 0, X, Ba);\n              u.oi(P, F);\n              q.Fa(u);\n              F = -u.x + oa / 2 * z.scale;\n              z = -u.y + oa / 2 * z.scale;\n              w.assign(S);\n              oa = isNaN(S.x);\n              var db = isNaN(S.y);\n\n              if (oa || db) {\n                X = X / 2 + 3;\n                Ba = Ba / 2 + 3;\n                var hb = 45 <= R && 135 >= R,\n                    Fb = 225 <= R && 315 >= R;\n                L === $f && (hb || Fb) ? (w.x = db ? X : S.y, w.y = oa ? Ba : S.x, hb ? 0 <= A || isNaN(A) && .5 > B || !oa || (w.y = -Ba) : Fb && ((0 <= A || isNaN(A) && .5 > B) && oa && (w.y = -Ba), db && (w.x = -X))) : (oa && (w.x = 0 <= A || isNaN(A) && .5 > B ? X : -X), db && (w.y = -Ba), w.rotate(R));\n              } else w.rotate(R);\n\n              H += w.x;\n              da += w.y;\n              P.set(y);\n              P.h(H + F, da + z, y.width, y.height);\n              r.push(P);\n              c.Xc(P);\n            }\n          }\n\n          if (null !== g) for (d = g.labelNodes; d.next();) {\n            d.value.measure(Infinity, Infinity);\n          }\n          a.bg = c;\n          a.position.h(b.x + c.x, b.y + c.y);\n          a.location.h(NaN, NaN);\n          Qb(e, c.width || 0, c.height || 0);\n          md.free(q);\n          I.free(u);\n          I.free(w);\n        }\n      }\n    }\n  };\n\n  Jm.prototype.arrange = function (a, b) {\n    var c = b.length;\n\n    if (a instanceof ue || a instanceof T) {\n      var d = a,\n          e = null;\n      a instanceof ue && (e = a, d = e.adornedPart);\n      var f = a instanceof ue ? null : d.path,\n          g = a.j;\n\n      if (0 !== g.length) {\n        var h = 0;\n\n        if (null !== f && h < g.length) {\n          var k = g[h];\n          h++;\n          f.arrange(k.x - a.bg.x, k.y - a.bg.y, k.width, k.height);\n        }\n\n        for (k = 0; k < c; k++) {\n          var l = b[k];\n\n          if (l !== f && h < g.length) {\n            var m = g[h];\n            h++;\n            l.arrange(m.x - a.bg.x, m.y - a.bg.y, m.width, m.height);\n          }\n        }\n      }\n\n      b = d.points;\n      c = b.count;\n      if (2 <= c && a instanceof T) for (f = a.labelNodes; f.next();) {\n        var n = a;\n        g = f.value;\n        h = g.segmentIndex;\n        k = g.segmentFraction;\n        var p = g.alignmentFocus;\n        l = g.segmentOrientation;\n        m = g.segmentOffset;\n\n        if (isNaN(h)) {\n          var r = n.sa;\n          var q = Ea();\n          r.Cu(k, q);\n          var u = I.allocAt(q[0], q[1]);\n          u.add(n.i(0));\n          r.type === O.j ? u.offset(-r.startX, -r.startY) : (r = r.figures.first(), u.offset(-r.startX, -r.startY));\n          r = q[2];\n          l !== $f && (n = n.computeAngle(g, l, r), g.angle = n);\n          n = u.x;\n          var w = u.y;\n          I.free(u);\n          Ga(q);\n        } else if (h < -c || h >= c) q = I.alloc(), r = n, w = q, r.mg(), r.computeMidPoint(w), r = n.midAngle, l !== $f && (n = n.computeAngle(g, l, r), g.angle = n), n = q.x, w = q.y, I.free(q);else {\n          u = 0;\n          0 <= h ? (q = b.s[h], w = h < c - 1 ? b.s[h + 1] : q) : (u = c + h, q = b.s[u], w = 0 < u ? b.s[u - 1] : q);\n\n          if (q.$a(w)) {\n            0 <= h ? (r = 0 < h ? b.s[h - 1] : q, u = h < c - 2 ? b.s[h + 2] : w) : (r = u < c - 1 ? b.s[u + 1] : q, u = 1 < u ? b.s[u - 2] : w);\n            var v = r.rf(q),\n                z = w.rf(u);\n            r = v > z + 10 ? 0 <= h ? r.Ya(q) : q.Ya(r) : z > v + 10 ? 0 <= h ? w.Ya(u) : u.Ya(w) : 0 <= h ? r.Ya(u) : u.Ya(r);\n          } else r = 0 <= h ? q.Ya(w) : w.Ya(q);\n\n          l !== $f && (n = n.computeAngle(g, l, r), g.angle = n);\n          n = q.x + (w.x - q.x) * k;\n          w = q.y + (w.y - q.y) * k;\n        }\n\n        if (p.Wr()) g.location = new I(n, w);else {\n          p.Fc() && (p = yc);\n          q = md.alloc();\n          q.reset();\n          q.scale(g.scale, g.scale);\n          q.rotate(g.angle, 0, 0);\n          var y = g.naturalBounds;\n          u = M.allocAt(0, 0, y.width, y.height);\n          v = I.alloc();\n          v.oi(u, p);\n          q.Fa(v);\n          p = -v.x;\n          z = -v.y;\n          var A = y.width,\n              B = y.height;\n          y = I.alloc();\n          y.assign(m);\n          var F = isNaN(m.x),\n              L = isNaN(m.y);\n\n          if (F || L) {\n            A = A / 2 + 3;\n            B = B / 2 + 3;\n            var S = 45 <= r && 135 >= r,\n                R = 225 <= r && 315 >= r;\n            l === $f && (S || R) ? (y.x = L ? A : m.y, y.y = F ? B : m.x, S ? 0 <= h || isNaN(h) && .5 > k || !F || (y.y = -B) : R && ((0 <= h || isNaN(h) && .5 > k) && F && (y.y = -B), L && (y.x = -A))) : (F && (y.x = 0 <= h || isNaN(h) && .5 > k ? A : -A), L && (y.y = -B), y.rotate(r));\n          } else y.rotate(r);\n\n          n += y.x;\n          w += y.y;\n          q.So(u);\n          p += u.x;\n          z += u.y;\n          h = I.allocAt(n + p, w + z);\n          g.move(h);\n          I.free(h);\n          I.free(y);\n          I.free(v);\n          M.free(u);\n          md.free(q);\n        }\n      }\n      null !== e ? e.Rj(!1) : d.Rj(!1);\n    }\n  };\n\n  function Km(a, b, c, d) {\n    if (!1 !== nj(d)) {\n      var e = d.strokeWidth;\n      0 === e && a instanceof ue && a.type === W.Link && a.adornedObject instanceof Cf && (e = a.adornedObject.strokeWidth);\n      e *= d.xa;\n      a instanceof T && null !== a.sa ? (a = a.sa.bounds, d.ve(a.x - e / 2, a.y - e / 2, a.width + e, a.height + e)) : a instanceof ue && null !== a.adornedPart.sa ? (a = a.adornedPart.sa.bounds, d.ve(a.x - e / 2, a.y - e / 2, a.width + e, a.height + e)) : d.ve(-(e / 2), -(e / 2), b + e, c + e);\n      e = d.desiredSize;\n      e.v() || null === d.sa ? d.bc.h(0, 0, e.width, e.height) : d.bc.assign(d.sa.bounds);\n      ij(d, !1);\n    }\n  }\n\n  function Qm() {\n    this.va = \"Base\";\n  }\n\n  la(Qm, Kl);\n\n  Qm.prototype.measure = function (a, b, c, d, e, f, g) {\n    var h = a.vb();\n    a.graduatedBounds = [];\n    var k = h.margin,\n        l = k.right + k.left,\n        m = k.top + k.bottom;\n    h.measure(b, c, f, g);\n    var n = h.measuredBounds,\n        p = new M(-k.left, -k.top, Math.max(n.width + l, 0), Math.max(n.height + m, 0));\n    a.graduatedBounds.push(p);\n    e.assign(p);\n\n    for (var r = h.geometry, q = h.strokeWidth, u = r.flattenedSegments, w = r.flattenedLengths, v = r.flattenedTotalLength, z = u.length, y = 0, A = 0, B = Ea(), F = 0; F < z; F++) {\n      var L = u[F],\n          S = [];\n      A = y = 0;\n\n      for (var R = L.length, P = 0; P < R; P += 2) {\n        var H = L[P],\n            da = L[P + 1];\n\n        if (0 !== P) {\n          var X = 180 * Math.atan2(da - A, H - y) / Math.PI;\n          0 > X && (X += 360);\n          S.push(X);\n        }\n\n        y = H;\n        A = da;\n      }\n\n      B.push(S);\n    }\n\n    if (null === a.graduatedIntervals) {\n      for (var oa = [], Ba = a.R.s, db = Ba.length, hb = 0; hb < db; hb++) {\n        var Fb = Ba[hb],\n            eb = [];\n        oa.push(eb);\n\n        if (Fb.visible) {\n          var Je = Fb.interval;\n          if (!(0 > Je)) for (var Ua = 0; Ua < db; Ua++) {\n            if (Ua !== hb) {\n              var od = Ba[Ua];\n\n              if (od.visible && Fb.constructor === od.constructor) {\n                var Gb = od.interval;\n                Gb > Je && eb.push(Gb);\n              }\n            }\n          }\n        }\n      }\n\n      a.graduatedIntervals = oa;\n    }\n\n    var Ke = a.graduatedIntervals;\n    var wc = a.R.s,\n        Rc = wc.length,\n        lc = 0,\n        fc = 0,\n        gf = v;\n    a.graduatedMarks = [];\n\n    for (var pd, Dh = 0; Dh < Rc; Dh++) {\n      var mc = wc[Dh];\n      pd = [];\n\n      if (mc.visible && mc !== h) {\n        var Hb = Math.abs(mc.interval),\n            Hi = a.graduatedTickUnit;\n\n        if (!(2 > Hi * Hb * v / a.graduatedRange && null === mc.graduatedSkip)) {\n          var sg = w[0][0],\n              Bd = 0,\n              gc = 0;\n          fc = v * mc.graduatedStart - 1E-4;\n          gf = v * mc.graduatedEnd + 1E-4;\n          var Mf = Hi * Hb,\n              nc = a.graduatedTickBase;\n\n          if (nc < a.graduatedMin) {\n            var hf = (a.graduatedMin - nc) / Mf;\n            hf = 0 === hf % 1 ? hf : Math.floor(hf + 1);\n            nc += hf * Mf;\n          } else nc > a.graduatedMin + Mf && (nc -= Math.floor((nc - a.graduatedMin) / Mf) * Mf);\n\n          for (var mk = Ke[Dh], Ii = nc, Kn = 1E-6 * a.graduatedMax, Nd = 1; nc <= a.graduatedMax + Kn; Nd++) {\n            a: {\n              for (var me = mk.length, tg = 0; tg < me; tg++) {\n                var jf = (nc - a.graduatedTickBase) % (mk[tg] * a.graduatedTickUnit),\n                    Eh = 1E-6 * a.graduatedTickUnit;\n\n                if (jf < Eh && jf > -Eh) {\n                  var kf = !1;\n                  break a;\n                }\n              }\n\n              kf = !0;\n            }\n\n            if (kf && (nc > a.graduatedMax && (nc = a.graduatedMax), null === mc.graduatedSkip || mc instanceof Qg && !mc.graduatedSkip(nc, mc) || mc instanceof Cf && !mc.graduatedSkip(nc, mc)) && (lc = (nc - a.graduatedMin) * v / a.graduatedRange, lc > v && (lc = v), fc <= lc && lc <= gf)) {\n              for (var Od = B[Bd][gc], Le = w[Bd][gc]; Bd < w.length;) {\n                for (; lc > sg && gc < w[Bd].length - 1;) {\n                  gc++, Od = B[Bd][gc], Le = w[Bd][gc], sg += Le;\n                }\n\n                if (lc <= sg) break;\n                Bd++;\n                gc = 0;\n                Od = B[Bd][gc];\n                Le = w[Bd][gc];\n                sg += Le;\n              }\n\n              var hc = u[Bd],\n                  Cd = hc[2 * gc],\n                  nk = hc[2 * gc + 1],\n                  ne = (lc - (sg - Le)) / Le,\n                  Fh = new I(Cd + (hc[2 * gc + 2] - Cd) * ne + q / 2 - r.bounds.x, nk + (hc[2 * gc + 3] - nk) * ne + q / 2 - r.bounds.y);\n              Fh.scale(h.scale, h.scale);\n\n              a: {\n                var qd = Od,\n                    Nf = B[Bd];\n\n                if (!(.5005 > ne && .4995 < ne)) {\n                  var Dd = qd;\n                  .5 > ne ? 0 < gc ? Dd = Nf[gc - 1] : J.ca(hc[0], hc[hc.length - 2]) && J.ca(hc[1], hc[hc.length - 1]) && (Dd = Nf[Nf.length - 1]) : .5 < ne && (gc + 1 < Nf.length ? Dd = Nf[gc + 1] : J.ca(hc[0], hc[hc.length - 2]) && J.ca(hc[1], hc[hc.length - 1]) && (Dd = Nf[0]));\n\n                  if (qd !== Dd) {\n                    var ug = Math.abs(qd - Dd);\n                    180 < ug && (qd < Dd ? qd += 360 : Dd += 360, ug = Math.abs(qd - Dd));\n\n                    if (5E-4 > ne || .9995 < ne) {\n                      Od = (qd + Dd) / 2 % 360;\n                      break a;\n                    }\n\n                    if (10 > ug) {\n                      var Gh = 1 - Math.abs(.5 - ne);\n                      Od = (qd * Gh + Dd * (1 - Gh)) % 360;\n                      break a;\n                    }\n                  }\n                }\n\n                Od = qd;\n              }\n\n              if (mc instanceof Qg) {\n                var bd = \"\";\n                null !== mc.graduatedFunction ? (bd = mc.graduatedFunction(nc, mc), bd = null !== bd && void 0 !== bd ? bd.toString() : \"\") : bd = (+nc.toFixed(2)).toString();\n                \"\" !== bd && pd.push({\n                  Hl: Fh,\n                  angle: Od,\n                  text: bd\n                });\n              } else pd.push({\n                Hl: Fh,\n                angle: Od\n              });\n            }\n\n            nc = Ii + Nd * Mf;\n          }\n        }\n      }\n\n      a.graduatedMarks.push(pd);\n    }\n\n    Ga(B);\n    var ib = a.graduatedMarks;\n    if (null !== ib) for (var Ji = d.length, Vb = 0; Vb < Ji; Vb++) {\n      var Va = d[Vb],\n          Wb = ib[Vb];\n\n      if (Va.visible && Va !== h && 0 !== Wb.length) {\n        if (Va instanceof Cf) {\n          var oe = a,\n              Me = e,\n              Of = Va.alignmentFocus;\n          Of.Fc() && (Of = uc);\n          var Ln = Va.angle;\n          Va.Gb = 0;\n          Va.measure(Infinity, Infinity, 0, 0);\n          Va.Gb = Ln;\n          var ok = Va.measuredBounds,\n              Hh = ok.width,\n              Pf = ok.height,\n              vg = M.allocAt(0, 0, Hh, Pf),\n              ic = I.alloc();\n          ic.oi(vg, Of);\n          M.free(vg);\n\n          for (var Ed = -ic.x, rd = -ic.y, Fc = new M(), lf = Wb.length, Ih = 0; Ih < lf; Ih++) {\n            for (var mf = Wb[Ih], pk = mf.Hl.x, Jh = mf.Hl.y, Oa = mf.angle, cd = 0; 4 > cd; cd++) {\n              switch (cd) {\n                case 0:\n                  ic.h(Ed, rd);\n                  break;\n\n                case 1:\n                  ic.h(Ed + Hh, rd);\n                  break;\n\n                case 2:\n                  ic.h(Ed, rd + Pf);\n                  break;\n\n                case 3:\n                  ic.h(Ed + Hh, rd + Pf);\n              }\n\n              ic.rotate(Oa + Va.angle);\n              ic.offset(pk, Jh);\n              0 === Ih && 0 === cd ? Fc.h(ic.x, ic.y, 0, 0) : Fc.Me(ic);\n              ic.offset(-pk, -Jh);\n              ic.rotate(-Oa - Va.angle);\n            }\n          }\n\n          I.free(ic);\n          null !== oe.graduatedBounds && oe.graduatedBounds.push(Fc);\n          Zb(Me, Fc.x, Fc.y, Fc.width, Fc.height);\n        } else if (Va instanceof Qg) {\n          var Sc = a,\n              qk = e;\n          null === Sc.temporaryTextBlock && (Sc.temporaryTextBlock = new Qg());\n          var oc = Sc.temporaryTextBlock;\n          Rm(oc, Va);\n          var Ne = Va.alignmentFocus;\n          Ne.Fc() && (Ne = uc);\n\n          for (var Tc = Va.segmentOrientation, Kh = Va.segmentOffset, nf = new M(), Ki = 0, Lh = 0, Fd = 0, Qf = 0, of = 0, Mh = Wb.length, Oe = 0; Oe < Mh; Oe++) {\n            var Pd = Wb[Oe];\n            Ki = Pd.Hl.x;\n            Lh = Pd.Hl.y;\n            Fd = Pd.angle;\n            of = Qf = Va.angle;\n            Tc !== $f && (of = Tc === Sm || Tc === Tm ? Fd + Va.angle : Fd, Qf = T.computeAngle(Tc, of));\n            oc.Gb = Qf;\n            oc.text = Pd.text || \"\";\n            oc.measure(Infinity, Infinity, 0, 0);\n            var Pe = oc.measuredBounds,\n                pe = oc.naturalBounds,\n                Qe = pe.width,\n                Rf = pe.height,\n                sd = md.alloc();\n            sd.reset();\n            sd.translate(-Pe.x, -Pe.y);\n            sd.scale(oc.scale, oc.scale);\n            sd.rotate(of, Qe / 2, Rf / 2);\n            Tc !== Lm && Tc !== Mm || sd.rotate(90, Qe / 2, Rf / 2);\n            Tc !== Nm && Tc !== Om || sd.rotate(-90, Qe / 2, Rf / 2);\n            Tc === Pm && (45 < Fd && 135 > Fd || 225 < Fd && 315 > Fd) && sd.rotate(-Fd, Qe / 2, Rf / 2);\n            var wg = M.allocAt(0, 0, Qe, Rf),\n                Re = I.alloc();\n            Re.oi(wg, Ne);\n            sd.Fa(Re);\n            var xg = -Re.x,\n                Mn = -Re.y,\n                qe = I.alloc();\n            qe.assign(Kh);\n            isNaN(qe.x) && (qe.x = Qe / 2 + 3);\n            isNaN(qe.y) && (qe.y = -(Rf / 2 + 3));\n            qe.rotate(Fd);\n            Ki += qe.x + xg;\n            Lh += qe.y + Mn;\n            var Sf = new M(Ki, Lh, Pe.width, Pe.height),\n                Li = new M(Pe.x, Pe.y, Pe.width, Pe.height),\n                Nn = new M(pe.x, pe.y, pe.width, pe.height);\n            Pd.Az = Qf;\n            Pd.lineCount = oc.lineCount;\n            Pd.lines = [oc.yb, oc.zh, oc.Te, oc.Ae, oc.Jc, oc.Wb, oc.qe];\n            Pd.actualBounds = Sf;\n            Pd.measuredBounds = Li;\n            Pd.naturalBounds = Nn;\n            0 === Oe ? nf.assign(Sf) : nf.Xc(Sf);\n            I.free(qe);\n            I.free(Re);\n            M.free(wg);\n            md.free(sd);\n          }\n\n          null !== Sc.graduatedBounds && Sc.graduatedBounds.push(nf);\n          Zb(qk, nf.x, nf.y, nf.width, nf.height);\n        }\n\n        ij(Va, !1);\n      }\n    }\n  };\n\n  Qm.prototype.arrange = function (a, b, c) {\n    if (null !== a.graduatedBounds) {\n      var d = a.vb(),\n          e = a.graduatedMarks;\n\n      if (null !== e) {\n        var f = a.graduatedBounds,\n            g = 0,\n            h = f[g];\n        g++;\n        null !== d && d.arrange(h.x - c.x, h.y - c.y, h.width, h.height);\n\n        for (var k = b.length, l = 0; l < k; l++) {\n          var m = b[l];\n          h = e[l];\n          m.visible && m !== d && 0 !== h.length && (h = f[g], g++, m.arrange(h.x - c.x, h.y - c.y, h.width, h.height));\n        }\n\n        a.graduatedBounds = null;\n      }\n    }\n  };\n\n  Qm.prototype.tc = function (a, b, c) {\n    var d = c.Vi;\n    c.Vi = !0;\n    var e = a.naturalBounds,\n        f = e.width;\n    e = e.height;\n    b.save();\n    b.beginPath();\n    b.rect(-1, -1, f + 1, e + 1);\n    b.clip();\n    f = a.vb();\n    f.tc(b, c);\n    e = a.uf() * c.scale;\n    0 >= e && (e = 1);\n\n    for (var g = f.actualBounds, h = a.R.s, k = a.graduatedMarks, l = h.length, m = 0; m < l; m++) {\n      var n = h[m],\n          p = k[m],\n          r = p.length;\n      if (n.visible && n !== f && 0 !== p.length) if (n instanceof Cf) {\n        if (!(2 > a.graduatedTickUnit * n.interval * f.geometry.flattenedTotalLength / a.graduatedRange * e && null === n.graduatedSkip)) {\n          var q = n.measuredBounds,\n              u = n.strokeWidth * n.scale,\n              w = n.alignmentFocus;\n          w.Fc() && (w = uc);\n\n          for (var v = 0; v < r; v++) {\n            var z = p[v].Hl,\n                y = p[v].angle,\n                A = w,\n                B = n.Bb;\n            B.reset();\n            B.translate(z.x + g.x, z.y + g.y);\n            B.rotate(y + n.angle, 0, 0);\n            B.translate(-q.width * A.x + A.offsetX + u / 2, -q.height * A.y + A.offsetY + u / 2);\n            B.scale(n.scale, n.scale);\n            xl(n, !1);\n            n.lh.set(n.Bb);\n            n.yk = n.scale;\n            yl(n, !1);\n            n.tc(b, c);\n            n.Bb.reset();\n          }\n        }\n      } else if (n instanceof Qg) for (null === a.temporaryTextBlock && (a.temporaryTextBlock = new Qg()), q = a.temporaryTextBlock, Rm(q, n), n = 0; n < r; n++) {\n        u = p[n], u.actualBounds && u.measuredBounds && u.naturalBounds && (q.cc = u.text || \"\", q.Gb = u.Az || 0, q.dd = u.lineCount || 0, w = u.lines, void 0 !== w && (q.yb = w[0], q.zh = w[1], q.Te = w[2], q.Ae = w[3], q.Jc = w[4], q.Wb = w[5], q.qe = w[6]), u.naturalBounds && (q.bc = u.naturalBounds), u.actualBounds && (w = u.actualBounds, q.arrange(w.x, w.y, w.width, w.height)), w = u.actualBounds, q.arrange(w.x, w.y, w.width, w.height), v = u.measuredBounds, u = u.naturalBounds, z = q.Bb, z.reset(), z.translate(w.x + g.x, w.y + g.y), z.translate(-v.x, -v.y), q.Qn(z, u.x, u.y, u.width, u.height), xl(q, !1), q.lh.set(q.Bb), q.yk = q.scale, yl(q, !1), q.tc(b, c));\n      }\n    }\n\n    c.Vi = d;\n    b.restore();\n    b.Oc(!0);\n  };\n\n  function W(a, b) {\n    Y.call(this);\n    this.qa = null;\n    if (void 0 === a) this.qa = W.Position;else if (\"string\" === typeof a) {\n      var c = Jl.I(a);\n      null !== c && (this.qa = c);\n    } else a instanceof Kl ? this.qa = a : a && (this.qa = W.Position, b = a);\n    null === this.qa && C(\"Panel type not specified or PanelLayout not loaded: \" + a);\n    this.o = this.o | 4194304 | (this.qa === W.Grid ? 1048576 : 0);\n    this.R = new E();\n    this.ub = qc;\n    this.Bm = Wc;\n    this.Kf = Wk;\n    this.Qg = null;\n    this.Pe = \"\";\n    this.bg = new M(NaN, NaN, NaN, NaN);\n    this.T = this.F = null;\n    this.$n = ng;\n    this.Qm = Kb;\n    this.Rm = qb;\n    this.qb = this.oa = null;\n    this.fn = NaN;\n    this.$d = this.xh = null;\n    b && Object.assign(this, b);\n  }\n\n  la(W, Y);\n\n  W.prototype.cloneProtected = function (a) {\n    Y.prototype.cloneProtected.call(this, a);\n    a.qa = this.qa;\n    a.ub = this.ub.J();\n    a.Bm = this.Bm.J();\n    a.Kf = this.Kf;\n    a.Pe = this.Pe;\n    a.bg.assign(this.bg);\n    null !== this.T && (a.T = this.T.copy(a));\n    a.$n = this.$n;\n    a.Qm = this.Qm.J();\n    a.Rm = this.Rm.J();\n    null !== this.oa && (a.oa = this.oa.copy());\n    a.qb = this.qb;\n    a.fn = this.fn;\n    a.xh = this.xh;\n  };\n\n  W.prototype.qf = function (a) {\n    Y.prototype.qf.call(this, a);\n    a.R = this.R;\n\n    for (var b = a.R.s, c = b.length, d = 0; d < c; d++) {\n      b[d].Uf = a;\n    }\n\n    a.Qg = null;\n  };\n\n  W.prototype.copy = function () {\n    var a = Y.prototype.copy.call(this);\n\n    if (null !== a) {\n      for (var b = this.R.s, c = b.length, d = 0; d < c; d++) {\n        var e = b[d].copy();\n        e.ni(a);\n        e.jj = null;\n        var f = a.R,\n            g = f.count;\n        f.Cb(g, e);\n        f = a.part;\n\n        if (null !== f) {\n          f.Kh = null;\n          null !== e.portId && f instanceof V && (f.He = !0);\n          var h = a.diagram;\n          null !== h && h.undoManager.isUndoingRedoing || f.bb(fe, \"elements\", a, null, e, null, g);\n        }\n      }\n\n      return a;\n    }\n\n    return null;\n  };\n\n  t = W.prototype;\n\n  t.toString = function () {\n    return \"Panel(\" + this.type.name + \")#\" + cb(this);\n  };\n\n  t.wn = function (a) {\n    Y.prototype.wn.call(this, a);\n\n    for (var b = this.R.s, c = b.length, d = 0; d < c; d++) {\n      b[d].wn(a);\n    }\n  };\n\n  t.ai = function (a, b) {\n    if (this.qa === W.Grid) a.Pc(), this.qa.tc(this, a, b);else if (this.qa === W.Graduated) a.Pc(), this.qa.tc(this, a, b);else {\n      if (this.qa === W.Table) {\n        a.Pc();\n        a.lineCap = \"butt\";\n        var c = 0 < this.rowCount ? this.rowDefs : null,\n            d = 0 < this.columnCount ? this.colDefs : null;\n        null !== c && Um(this, a, !0, c, !0);\n        null !== d && Um(this, a, !1, d, !0);\n        null !== c && Vm(this, a, !0, c);\n        null !== d && Vm(this, a, !1, d);\n        null !== c && Um(this, a, !0, c, !1);\n        null !== d && Um(this, a, !1, d, !1);\n      }\n\n      (c = this.isClipping && this.qa === W.Spot) && a.save();\n      d = this.vb();\n\n      for (var e = this.R.s, f = e.length, g = 0; g < f; g++) {\n        var h = e[g];\n        c && h === d && (a.clipInsteadOfFill = !0);\n        h.tc(a, b);\n        c && h === d && (a.clipInsteadOfFill = !1);\n      }\n\n      c && (a.restore(), a.Oc(!0));\n    }\n  };\n\n  function Vm(a, b, c, d) {\n    for (var e = d.length, f = a.actualBounds, g = a.naturalBounds, h = !0, k = 0; k < e; k++) {\n      var l = d[k];\n      if (void 0 !== l && 0 !== l.actual) if (h) h = !1;else {\n        if (c) {\n          if (l.position > f.height) continue;\n        } else if (l.position > f.width) continue;\n\n        var m = l.separatorStrokeWidth;\n        isNaN(m) && (m = c ? a.defaultRowSeparatorStrokeWidth : a.defaultColumnSeparatorStrokeWidth);\n        var n = l.separatorStroke;\n        null === n && (n = c ? a.defaultRowSeparatorStroke : a.defaultColumnSeparatorStroke);\n\n        if (0 !== m && null !== n) {\n          gi(a, b, n, !1, !1, g, f);\n          n = !1;\n          var p = l.separatorDashArray;\n          null === p && (p = c ? a.defaultRowSeparatorDashArray : a.defaultColumnSeparatorDashArray);\n          null !== p && (n = !0, b.Gr(p, 0));\n          b.beginPath();\n          p = l.position + m;\n          c ? p > f.height && (m -= p - f.height) : p > f.width && (m -= p - f.width);\n          l = l.position + m / 2;\n          b.lineWidth = m;\n          m = a.ub;\n          c ? (l += m.top, p = f.width - m.right, b.moveTo(m.left, l), b.lineTo(p, l)) : (l += m.left, p = f.height - m.bottom, b.moveTo(l, m.top), b.lineTo(l, p));\n          b.stroke();\n          n && b.Er();\n        }\n      }\n    }\n  }\n\n  function Um(a, b, c, d, e) {\n    for (var f = d.length, g = a.actualBounds, h = a.naturalBounds, k = Wm(a, !0), l = Wm(a, !1), m = 0; m < f; m++) {\n      var n = d[m];\n\n      if (void 0 !== n && null !== n.background && n.coversSeparators !== e && 0 !== n.actual) {\n        var p = c ? g.height : g.width;\n\n        if (!(n.position > p)) {\n          var r = n.Qc(),\n              q = n.separatorStrokeWidth;\n          isNaN(q) && (q = c ? a.defaultRowSeparatorStrokeWidth : a.defaultColumnSeparatorStrokeWidth);\n          var u = n.separatorStroke;\n          null === u && (u = c ? a.defaultRowSeparatorStroke : a.defaultColumnSeparatorStroke);\n          if (null === u || n.index === (c ? k : l)) q = 0;\n          r -= q;\n          q = n.position + q;\n          r += n.actual;\n          q + r > p && (r = p - q);\n          0 >= r || (p = a.ub, gi(a, b, n.background, !0, !1, h, g), c ? b.fillRect(p.left, q + p.top, g.width - (p.left + p.right), r) : b.fillRect(q + p.left, p.top, r, g.height - (p.top + p.bottom)));\n        }\n      }\n    }\n  }\n\n  function Wm(a, b) {\n    for (var c = b ? a.rowCount : a.columnCount, d = 0; d < c; d++) {\n      var e = b ? a.rowDefs[d] : a.colDefs[d];\n      if (void 0 !== e) return e.index;\n    }\n\n    return 0;\n  }\n\n  function Sj(a) {\n    return \"LineV\" === a || \"BarV\" === a;\n  }\n\n  t.Kj = function (a, b, c, d, e) {\n    var f = this.ke(),\n        g = this.transform,\n        h = 1 / (g.m11 * g.m22 - g.m12 * g.m21),\n        k = g.m22 * h,\n        l = -g.m12 * h,\n        m = -g.m21 * h,\n        n = g.m11 * h,\n        p = h * (g.m21 * g.dy - g.m22 * g.dx),\n        r = h * (g.m12 * g.dx - g.m11 * g.dy);\n    if (null !== this.areaBackground) return g = this.actualBounds, J.wf(g.left, g.top, g.right, g.bottom, a, b, c, d, e);\n    if (null !== this.background) return f = a * k + b * m + p, h = a * l + b * n + r, a = c * k + d * m + p, k = c * l + d * n + r, e.h(0, 0), c = this.naturalBounds, f = J.wf(0, 0, c.width, c.height, f, h, a, k, e), e.transform(g), f;\n    f || (k = 1, m = l = 0, n = 1, r = p = 0);\n    h = a * k + b * m + p;\n    a = a * l + b * n + r;\n    k = c * k + d * m + p;\n    c = c * l + d * n + r;\n    e.h(k, c);\n    d = (k - h) * (k - h) + (c - a) * (c - a);\n    l = !1;\n    n = this.R.s;\n    r = n.length;\n    m = I.alloc();\n    p = null;\n    b = Infinity;\n    var q = null,\n        u = this.isClipping && this.qa === W.Spot;\n    u && (q = I.alloc(), p = this.vb(), (l = p.Kj(h, a, k, c, q)) && (b = (h - q.x) * (h - q.x) + (a - q.y) * (a - q.y)));\n\n    for (var w = 0; w < r; w++) {\n      var v = n[w];\n      v.visible && v !== p && v.Kj(h, a, k, c, m) && (l = !0, v = (h - m.x) * (h - m.x) + (a - m.y) * (a - m.y), v < d && (d = v, e.set(m)));\n    }\n\n    u && (b > d && e.set(q), I.free(q));\n    I.free(m);\n    f && e.transform(g);\n    return l;\n  };\n\n  t.w = function (a) {\n    if (!nj(this)) {\n      Y.prototype.w.call(this, a);\n      a = null;\n      if (this.qa === W.Auto || this.qa === W.Link) a = this.vb();\n\n      for (var b = this.R.s, c = b.length, d = 0; d < c; d++) {\n        var e = b[d];\n        (e === a || e.isPanelMain) && e.w(!0);\n\n        if (!e.desiredSize.v()) {\n          var f = hl(e, !1);\n          (e instanceof jg || e instanceof W || e instanceof Qg || f !== lg) && e.w(!0);\n        }\n      }\n    }\n  };\n\n  t.Mj = function () {\n    if (!nj(this)) {\n      ij(this, !0);\n      il(this, !0);\n\n      for (var a = this.R.s, b = a.length, c = 0; c < b; c++) {\n        a[c].Mj();\n      }\n    }\n  };\n\n  t.Jk = function () {\n    if (0 !== (this.o & 2048) === !1) {\n      xl(this, !0);\n      yl(this, !0);\n\n      for (var a = this.R.s, b = a.length, c = 0; c < b; c++) {\n        a[c].Iu();\n      }\n    }\n  };\n\n  t.Iu = function () {\n    yl(this, !0);\n\n    for (var a = this.R.s, b = a.length, c = 0; c < b; c++) {\n      a[c].Iu();\n    }\n  };\n\n  t.El = function (a, b, c, d) {\n    var e = this.bg;\n    e.h(0, 0, 0, 0);\n    var f = this.desiredSize,\n        g = this.minSize;\n    void 0 === c && (c = g.width, d = g.height);\n    c = Math.max(c, g.width);\n    d = Math.max(d, g.height);\n    var h = this.maxSize;\n    isNaN(f.width) || (a = Math.min(f.width, h.width));\n    isNaN(f.height) || (b = Math.min(f.height, h.height));\n    a = Math.max(c, a);\n    b = Math.max(d, b);\n    var k = this.ub;\n    a = Math.max(a - k.left - k.right, 0);\n    b = Math.max(b - k.top - k.bottom, 0);\n    var l = this.R.s;\n    0 !== l.length && this.qa.measure(this, a, b, l, e, c, d);\n    a = e.width + k.left + k.right;\n    k = e.height + k.top + k.bottom;\n    isFinite(f.width) && (a = f.width);\n    isFinite(f.height) && (k = f.height);\n    a = Math.min(h.width, a);\n    k = Math.min(h.height, k);\n    a = Math.max(g.width, a);\n    k = Math.max(g.height, k);\n    a = Math.max(c, a);\n    k = Math.max(d, k);\n    Qb(e, a, k);\n    Qb(this.naturalBounds, a, k);\n    this.ve(0, 0, a, k);\n  };\n\n  t.vb = function () {\n    if (null === this.Qg) {\n      var a = this.R.s,\n          b = a.length;\n      if (0 === b) return null;\n\n      for (var c = 0; c < b; c++) {\n        var d = a[c];\n        if (!0 === d.isPanelMain) return this.Qg = d;\n      }\n\n      this.Qg = a[0];\n    }\n\n    return this.Qg;\n  };\n\n  function tm(a) {\n    return null !== a.part ? a.part.locationObject : null;\n  }\n\n  t.Vg = function (a, b, c, d) {\n    var e = this.R.s;\n    this.actualBounds.h(a, b, c, d);\n\n    if (0 !== e.length) {\n      if (!this.desiredSize.v()) {\n        a = hl(this, !0);\n        var f = this.measuredBounds;\n        b = f.width;\n        f = f.height;\n        var g = this.Ag,\n            h = g.left + g.right;\n        g = g.top + g.bottom;\n        b === c && f === d && (a = lg);\n\n        switch (a) {\n          case lg:\n            if (b > c || f > d) this.w(), this.measure(b > c ? c : b, f > d ? d : f, 0, 0);\n            break;\n\n          case td:\n            this.w(!0);\n            this.measure(c + h, d + g, 0, 0);\n            break;\n\n          case Uk:\n            this.w(!0);\n            this.measure(c + h, f + g, 0, 0);\n            break;\n\n          case Vk:\n            this.w(!0), this.measure(b + h, d + g, 0, 0);\n        }\n      }\n\n      this.qa.arrange(this, e, this.bg);\n    }\n  };\n\n  t.Xg = function (a) {\n    var b = this.naturalBounds,\n        c = tm(this);\n\n    if ($b(0, 0, b.width, b.height, a.x, a.y)) {\n      b = this.R.s;\n\n      for (var d = b.length, e = I.allocAt(0, 0); d--;) {\n        var f = b[d];\n        if (f.visible || f === c) if (yb(e.set(a), f.transform), f.ba(e)) return I.free(e), !0;\n      }\n\n      I.free(e);\n      return null === this.Yb && null === this.areaBackground ? !1 : !0;\n    }\n\n    return !1;\n  };\n\n  t.Hr = function (a) {\n    if (this.bindingId === a) return this;\n\n    for (var b = this.R.s, c = b.length, d = 0; d < c; d++) {\n      var e = b[d].Hr(a);\n      if (null !== e) return e;\n    }\n\n    return null;\n  };\n\n  t.$l = function (a, b) {\n    b(this, a);\n\n    if (a instanceof W) {\n      a = a.R.s;\n\n      for (var c = a.length, d = 0; d < c; d++) {\n        this.$l(a[d], b);\n      }\n    }\n  };\n\n  function Aj(a, b) {\n    Xm(a, a, b);\n  }\n\n  function Xm(a, b, c) {\n    c(b);\n    b = b.R.s;\n\n    for (var d = b.length, e = 0; e < d; e++) {\n      var f = b[e];\n      f instanceof W && Xm(a, f, c);\n    }\n  }\n\n  function Ym(a, b) {\n    Zm(a, a, b);\n  }\n\n  function Zm(a, b, c) {\n    c(b);\n\n    if (b instanceof W) {\n      b = b.R.s;\n\n      for (var d = b.length, e = 0; e < d; e++) {\n        Zm(a, b[e], c);\n      }\n    }\n  }\n\n  t.vl = function (a) {\n    return $m(this, this, a);\n  };\n\n  function $m(a, b, c) {\n    if (c(b)) return b;\n\n    if (b instanceof W) {\n      b = b.R.s;\n\n      for (var d = b.length, e = 0; e < d; e++) {\n        var f = $m(a, b[e], c);\n        if (null !== f) return f;\n      }\n    }\n\n    return null;\n  }\n\n  t.fb = function (a) {\n    if (this.name === a) return this;\n    var b = this.R.s,\n        c = b.length;\n    null === this.xh && null === this.itemTemplateMap || (c = an(this));\n\n    for (var d = 0; d < c; d++) {\n      var e = b[d];\n\n      if (e instanceof W) {\n        var f = e.fb(a);\n        if (null !== f) return f;\n      }\n\n      if (e.name === a) return e;\n    }\n\n    return null;\n  };\n\n  function bn(a) {\n    a = a.R.s;\n\n    for (var b = a.length, c = 0, d = 0; d < b; d++) {\n      var e = a[d];\n      e instanceof W ? c = Math.max(c, bn(e)) : e instanceof Cf && (c = Math.max(c, e.ag / 2 * e.strokeMiterLimit * e.uf()));\n    }\n\n    return c;\n  }\n\n  t.ke = function () {\n    return !(this.type === W.TableRow || this.type === W.TableColumn);\n  };\n\n  t.ec = function (a, b, c) {\n    if (!1 === this.pickable) return null;\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    if (oj(this)) return null;\n    var d = this.naturalBounds,\n        e = 1 / this.uf(),\n        f = this.ke(),\n        g = f ? a : yb(I.allocAt(a.x, a.y), this.transform),\n        h = this.diagram,\n        k = 10,\n        l = 5;\n    null !== h && (k = h.yl(\"extraTouchArea\"), l = k / 2);\n\n    if ($b(-(l * e), -(l * e), d.width + k * e, d.height + k * e, g.x, g.y)) {\n      if (!this.isAtomic) {\n        e = this.R.s;\n        var m = e.length;\n        h = I.alloc();\n        l = (k = this.isClipping && this.qa === W.Spot) ? this.vb() : null;\n        if (k && (l.ke() ? yb(h.set(a), l.transform) : h.set(a), !l.ba(h))) return I.free(h), f || I.free(g), null;\n\n        for (var n = tm(this); m--;) {\n          var p = e[m];\n          if (p.visible || p === n) if (p.ke() ? yb(h.set(a), p.transform) : h.set(a), !k || p !== l) {\n            var r = null;\n            p instanceof W ? r = p.ec(h, b, c) : !0 === p.pickable && p.ba(h) && (r = p);\n            if (null !== r && (null !== b && (r = b(r)), null !== r && (null === c || c(r)))) return I.free(h), f || I.free(g), r;\n          }\n        }\n\n        I.free(h);\n      }\n\n      if (null === this.background && null === this.areaBackground) return f || I.free(g), null;\n      a = $b(0, 0, d.width, d.height, g.x, g.y) ? this : null;\n      f || I.free(g);\n      return a;\n    }\n\n    f || I.free(g);\n    return null;\n  };\n\n  t.di = function (a, b, c, d) {\n    if (!1 === this.pickable) return !1;\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    var e = this.naturalBounds,\n        f = this.ke(),\n        g = f ? a : yb(I.allocAt(a.x, a.y), this.transform);\n    e = $b(0, 0, e.width, e.height, g.x, g.y);\n\n    if (this.type === W.TableRow || this.type === W.TableColumn || e) {\n      if (!this.isAtomic) {\n        for (var h = this.R.s, k = h.length, l = I.alloc(), m = tm(this); k--;) {\n          var n = h[k];\n\n          if (n.visible || n === m) {\n            n.ke() ? yb(l.set(a), n.transform) : l.set(a);\n            var p = n;\n            n = n instanceof W ? n : null;\n            (null !== n ? n.di(l, b, c, d) : p.ba(l)) && !1 !== p.pickable && (null !== b && (p = b(p)), null === p || null !== c && !c(p) || d.add(p));\n          }\n        }\n\n        I.free(l);\n      }\n\n      f || I.free(g);\n      return e && (null !== this.background || null !== this.areaBackground);\n    }\n\n    f || I.free(g);\n    return !1;\n  };\n\n  t.tf = function (a, b, c, d, e, f) {\n    if (!1 === this.pickable) return !1;\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    var g = f;\n    void 0 === f && (g = md.alloc(), g.reset());\n    g.multiply(this.transform);\n    if (this.Wg(a, g)) return cn(this, b, c, e), void 0 === f && md.free(g), !0;\n\n    if (this.Sc(a, g)) {\n      if (!this.isAtomic) for (var h = tm(this), k = this.R.s, l = k.length; l--;) {\n        var m = k[l];\n\n        if (m.visible || m === h) {\n          var n = m.actualBounds,\n              p = this.naturalBounds;\n\n          if (!(n.x > p.width || n.y > p.height || 0 > n.x + n.width || 0 > n.y + n.height)) {\n            n = m;\n            m = m instanceof W ? m : null;\n            p = md.alloc();\n            p.set(g);\n            if (null !== m ? m.tf(a, b, c, d, e, p) : gl(n, a, d, p)) null !== b && (n = b(n)), null === n || null !== c && !c(n) || e.add(n);\n            md.free(p);\n          }\n        }\n      }\n      void 0 === f && md.free(g);\n      return d;\n    }\n\n    void 0 === f && md.free(g);\n    return !1;\n  };\n\n  function cn(a, b, c, d) {\n    for (var e = a.R.s, f = e.length; f--;) {\n      var g = e[f];\n\n      if (g.visible) {\n        var h = g.actualBounds,\n            k = a.naturalBounds;\n        h.x > k.width || h.y > k.height || 0 > h.x + h.width || 0 > h.y + h.height || (g instanceof W && cn(g, b, c, d), null !== b && (g = b(g)), null === g || null !== c && !c(g) || d.add(g));\n      }\n    }\n  }\n\n  t.hg = function (a, b, c, d, e, f) {\n    if (!1 === this.pickable) return !1;\n    void 0 === c && (c = null);\n    void 0 === d && (d = null);\n    var g = this.naturalBounds,\n        h = this.ke(),\n        k = h ? a : yb(I.allocAt(a.x, a.y), this.transform),\n        l = h ? b : yb(I.allocAt(b.x, b.y), this.transform),\n        m = k.rf(l),\n        n = 0 < k.x && k.x < g.width && 0 < k.y && k.y < g.height || zb(k.x, k.y, 0, 0, 0, g.height) <= m || zb(k.x, k.y, 0, g.height, g.width, g.height) <= m || zb(k.x, k.y, g.width, g.height, g.width, 0) <= m || zb(k.x, k.y, g.width, 0, 0, 0) <= m;\n    g = k.td(0, 0) <= m && k.td(0, g.height) <= m && k.td(g.width, 0) <= m && k.td(g.width, g.height) <= m;\n    h || (I.free(k), I.free(l));\n\n    if (n) {\n      if (!this.isAtomic) {\n        k = I.alloc();\n        l = I.alloc();\n        m = tm(this);\n\n        for (var p = this.R.s, r = p.length; r--;) {\n          var q = p[r];\n\n          if (q.visible || q === m) {\n            var u = q.actualBounds,\n                w = this.naturalBounds;\n            if (!h || !(u.x > w.width || u.y > w.height || 0 > u.x + u.width || 0 > u.y + u.height)) if (q.ke() ? (u = q.transform, yb(k.set(a), u), yb(l.set(b), u)) : (k.set(a), l.set(b)), u = q, q = q instanceof W ? q : null, null !== q ? q.hg(k, l, c, d, e, f) : u.Vw(k, l, e)) null !== c && (u = c(u)), null === u || null !== d && !d(u) || f.add(u);\n          }\n        }\n\n        I.free(k);\n        I.free(l);\n      }\n\n      return e ? n : g;\n    }\n\n    return !1;\n  };\n\n  function zm(a) {\n    var b = null;\n    a instanceof Cf && (b = a.spot1, b === Wc && (b = null), a = a.geometry, null !== a && null === b && (b = a.spot1));\n    null === b && (b = tc);\n    return b;\n  }\n\n  function Am(a) {\n    var b = null;\n    a instanceof Cf && (b = a.spot2, b === Wc && (b = null), a = a.geometry, null !== a && null === b && (b = a.spot2));\n    null === b && (b = Cc);\n    return b;\n  }\n\n  t.add = function (a) {\n    for (var b = [], c = 0; c < arguments.length; ++c) {\n      b[c] = arguments[c];\n    }\n\n    for (c = 0; c < b.length; c++) {\n      this.Cb(this.R.count, b[c]);\n    }\n\n    return this;\n  };\n\n  t.K = function (a) {\n    return this.R.K(a);\n  };\n\n  t.Cb = function (a, b) {\n    b instanceof U && C(\"Cannot add a Part to a Panel: \" + b + \"; use a Panel instead\");\n    if (this === b || this.jg(b)) this === b && C(\"Cannot make a Panel contain itself: \" + this.toString()), C(\"Cannot make a Panel indirectly contain itself: \" + this.toString() + \" already contains \" + b.toString());\n    var c = b.panel;\n    null !== c && c !== this && C(\"Cannot add a GraphObject that already belongs to another Panel to this Panel: \" + b.toString() + \", already contained by \" + c.toString() + \", cannot be shared by this Panel: \" + this.toString());\n    this.qa !== W.Grid || b instanceof Cf || C(\"Can only add Shapes to a Grid Panel, not: \" + b);\n    this.qa !== W.Graduated || b instanceof Cf || b instanceof Qg || C(\"Can only add Shapes or TextBlocks to a Graduated Panel, not: \" + b);\n    b.ni(this);\n    b.jj = null;\n\n    if (null !== this.itemArray) {\n      var d = b.data;\n      null !== d && \"object\" === typeof d && (null === this.$d && (this.$d = new pb()), this.$d.add(d, b));\n    }\n\n    var e = this.R;\n    d = -1;\n\n    if (c === this) {\n      for (var f = -1, g = this.R.s, h = g.length, k = 0; k < h; k++) {\n        if (g[k] === b) {\n          f = k;\n          break;\n        }\n      }\n\n      if (-1 !== f) {\n        if (f === a || f + 1 >= e.count && a >= e.count) return;\n        e.mb(f);\n        d = f;\n      } else C(\"element \" + b.toString() + \" has panel \" + c.toString() + \" but is not contained by it.\");\n    }\n\n    if (0 > a || a > e.count) a = e.count;\n    e.Cb(a, b);\n    if (0 === a || b.isPanelMain) this.Qg = null;\n    nj(this) || this.w();\n    b.w(!1);\n    null !== b.portId ? this.He = !0 : b instanceof W && !0 === b.He && (this.He = !0);\n    this.graduatedIntervals = null;\n    this.yf() || dn(this, b, !1);\n    c = this.part;\n    null !== c && (c.Kh = null, c.Sf = NaN, this.He && c instanceof V && (c.He = !0), c.He && c instanceof V && (c.sc = null), e = this.diagram, null !== e && e.undoManager.isUndoingRedoing || (-1 !== d && c.bb(ge, \"elements\", this, b, null, d, null), c.bb(fe, \"elements\", this, null, b, null, a)));\n  };\n\n  function en(a, b) {\n    a.o = b ? a.o | 16777216 : a.o & -16777217;\n  }\n\n  t.remove = function (a) {\n    for (var b = this.R.s, c = b.length, d = -1, e = 0; e < c; e++) {\n      if (b[e] === a) {\n        d = e;\n        break;\n      }\n    }\n\n    -1 !== d && this.lc(d, !0);\n  };\n\n  t.mb = function (a) {\n    0 <= a && this.lc(a, !0);\n  };\n\n  t.lc = function (a, b) {\n    var c = this.R,\n        d = c.K(a);\n    d.jj = null;\n    d.ni(null);\n\n    if (null !== this.$d) {\n      var e = d.data;\n      \"object\" === typeof e && this.$d.remove(e);\n    }\n\n    c.mb(a);\n    ij(this, !1);\n    this.w();\n    this.Qg === d && (this.Qg = null);\n    this.graduatedIntervals = null;\n    var f = this.part;\n    null !== f && (f.Kh = null, f.Sf = NaN, f.Rb(), f instanceof V && (d instanceof W ? d.$l(d, function (a, c) {\n      Pl(f, c, b);\n    }) : Pl(f, d, b)), c = this.diagram, null !== c && c.undoManager.isUndoingRedoing || f.bb(ge, \"elements\", this, d, null, a, null));\n  };\n\n  W.prototype.getRowDefinition = function (a) {\n    0 > a && wa(a, \">= 0\", W, \"getRowDefinition:idx\");\n    a = Math.round(a);\n    var b = this.rowDefs;\n\n    if (void 0 === b[a]) {\n      var c = new Oj();\n      c.ni(this);\n      c.isRow = !0;\n      c.index = a;\n      b[a] = c;\n      this.bb(fe, \"rowdefs\", this, null, c, null, a);\n    }\n\n    return b[a];\n  };\n\n  W.prototype.Vz = function (a) {\n    0 > a && wa(a, \">= 0\", W, \"removeRowDefinition:idx\");\n\n    if (0 !== this.rowCount) {\n      a = Math.round(a);\n      var b = this.rowDefs,\n          c = b[a];\n\n      if (c) {\n        b[a] = void 0;\n\n        for (var d = b.length - 1; 0 <= d && void 0 === b[d--];) {\n          b.length--;\n        }\n\n        this.bb(ge, \"rowdefs\", this, c, null, a, null);\n        this.w();\n      }\n    }\n  };\n\n  function Pj(a, b, c) {\n    var d = a.rowDefs;\n\n    if (!(0 > b)) {\n      d[b] = c instanceof Oj ? c : void 0;\n      if (!c) for (b = d.length - 1; 0 <= b && void 0 === d[b--];) {\n        d.length--;\n      }\n      a.w();\n    }\n  }\n\n  W.prototype.getColumnDefinition = function (a) {\n    0 > a && wa(a, \">= 0\", W, \"getColumnDefinition:idx\");\n    a = Math.round(a);\n    var b = this.colDefs;\n\n    if (void 0 === b[a]) {\n      var c = new Oj();\n      c.ni(this);\n      c.isRow = !1;\n      c.index = a;\n      b[a] = c;\n      this.bb(fe, \"coldefs\", this, null, c, null, a);\n    }\n\n    return b[a];\n  };\n\n  t = W.prototype;\n\n  t.Qz = function (a) {\n    0 > a && wa(a, \">= 0\", W, \"removeColumnDefinition:idx\");\n\n    if (0 !== this.columnCount) {\n      a = Math.round(a);\n      var b = this.colDefs,\n          c = b[a];\n\n      if (c) {\n        b[a] = void 0;\n\n        for (var d = b.length - 1; 0 <= d && void 0 === b[d--];) {\n          b.length--;\n        }\n\n        this.bb(ge, \"coldefs\", this, c, null, a, null);\n        this.w();\n      }\n    }\n  };\n\n  function Qj(a, b, c) {\n    var d = a.colDefs;\n\n    if (!(0 > b)) {\n      d[b] = c instanceof Oj ? c : void 0;\n      if (!c) for (b = d.length - 1; 0 <= b && void 0 === d[b--];) {\n        d.length--;\n      }\n      a.w();\n    }\n  }\n\n  t.Wy = function (a) {\n    if (0 > a || this.type !== W.Table || 0 === this.rowCount) return -1;\n\n    for (var b = 0, c = this.rowDefs, d = c.length, e = this.topIndex; e < d; e++) {\n      var f = c[e];\n      if (void 0 !== f && (b += f.total, a < b)) break;\n    }\n\n    return e;\n  };\n\n  t.Oy = function (a) {\n    if (0 > a || this.type !== W.Table || 0 === this.columnCount) return -1;\n\n    for (var b = 0, c = this.colDefs, d = c.length, e = this.leftIndex; e < d; e++) {\n      var f = c[e];\n      if (void 0 !== f && (b += f.total, a < b)) break;\n    }\n\n    return e;\n  };\n\n  t.mz = function (a, b) {\n    void 0 === b && (b = new I(NaN, NaN));\n    if (this.type !== W.Graduated) return b.h(NaN, NaN), b;\n    a = Math.min(Math.max(a, this.graduatedMin), this.graduatedMax);\n    var c = this.vb();\n    c.geometry.Bu((a - this.graduatedMin) / this.graduatedRange, b);\n    return c.transform.Fa(b);\n  };\n\n  t.nz = function (a) {\n    if (this.type !== W.Graduated) return NaN;\n    var b = this.vb();\n    b.transform.Ld(a);\n    return b.geometry.Zw(a) * this.graduatedRange + this.graduatedMin;\n  };\n\n  function Fl(a) {\n    a = a.allBindings;\n    return null !== a && a._isFrozen;\n  }\n\n  function kg(a) {\n    var b = a.allBindings;\n    if (null === b) null !== a.data && C(\"Template cannot have .data be non-null: \" + a), a.allBindings = b = new E();else if (b._isFrozen) return;\n    var c = new E();\n    en(a, !1);\n    a.$l(a, function (a, d) {\n      d.ih();\n      var e = d.localBindings;\n      if (null !== e) for (Cl(d, !1), e = e.iterator; e.next();) {\n        var f = e.value;\n        f.mode === fn && Cl(d, !0);\n        var g = f.sourceName;\n        null !== g && (\"/\" === g && en(a, !0), g = fl(f, a, d), null !== g && (c.add(g), null === g.srcBindings && (g.srcBindings = new E()), g.srcBindings.add(f)));\n        b.add(f);\n      }\n\n      if (d instanceof W && d.type === W.Table) {\n        if (0 < d.rowCount) for (a = d.rowDefs, e = a.length, f = 0; f < e; f++) {\n          if (g = a[f], void 0 !== g && null !== g.Vd) for (var h = g.Vd.iterator; h.next();) {\n            var k = h.value;\n            k.sd = g;\n            k.Wn = 2;\n            k.ll = g.index;\n            b.add(k);\n          }\n        }\n        if (0 < d.columnCount) for (d = d.colDefs, a = d.length, e = 0; e < a; e++) {\n          if (f = d[e], void 0 !== f && null !== f.Vd) for (g = f.Vd.iterator; g.next();) {\n            h = g.value, h.sd = f, h.Wn = 1, h.ll = f.index, b.add(h);\n          }\n        }\n      }\n    });\n\n    for (var d = c.iterator; d.next();) {\n      var e = d.value;\n\n      if (null !== e.srcBindings) {\n        Cl(e, !0);\n\n        for (var f = e.srcBindings.iterator; f.next();) {\n          var g = f.value;\n          null === e.localBindings && (e.localBindings = new E());\n          e.localBindings.add(g);\n        }\n      }\n\n      e.srcBindings = null;\n    }\n\n    for (d = b.iterator; d.next();) {\n      if (e = d.value, f = e.sd, null !== f) {\n        e.sd = null;\n        var h = e.targetProperty,\n            k = h.indexOf(\".\");\n        0 < k && f instanceof W && (g = h.substring(0, k), h = h.substr(k + 1), k = f.fb(g), null !== k ? (f = k, e.targetProperty = h) : xa('Warning: unable to find GraphObject named \"' + g + '\" for Binding: ' + e.toString()));\n        f instanceof Oj ? (g = cb(f.panel), e.ti = void 0 === g ? -1 : g, f.panel.bindingId = e.ti) : f instanceof Y ? (g = cb(f), e.ti = void 0 === g ? -1 : g, f.bindingId = e.ti) : C(\"Unknown type of binding target: \" + f);\n      }\n    }\n\n    b.freeze();\n    a instanceof U && a.Tc() && a.Za();\n  }\n\n  t.By = function (a) {\n    void 0 === a && (a = !1);\n    var b = this.copy();\n    Ym(b, function (a) {\n      a instanceof W && (a.allBindings = null, a.qb = null);\n      var b = a.localBindings;\n      null !== b && (a.localBindings = null, b.each(function (b) {\n        a.bind(b.copy());\n      }));\n      b = a.animationTriggers;\n      null !== b && (a.animationTriggers = null, b.each(function (b) {\n        a.mv(b.value.copy());\n      }));\n    });\n    a && kg(b);\n    return b;\n  };\n\n  t.Ka = function (a) {\n    var b = this.allBindings;\n    if (null !== b) for (void 0 === a && (a = \"\"), b = b.iterator; b.next();) {\n      var c = b.value,\n          d = c.sourceProperty;\n      if (\"\" === a || \"\" === d || d === a) if (d = c.targetProperty, null !== c.converter || \"\" !== d) {\n        d = this.data;\n        var e = c.sourceName;\n        if (null !== e) {\n          if (\"\" === e) d = this;else if (\"/\" === e) d = this;else if (\".\" === e) d = this;else if (\"..\" === e) d = this;else {\n            if (d = this.fb(e), null === d) continue;\n          }\n        } else if (c.isToModel) if (d = this.diagram, null !== d) d = d.model.modelData;else continue;\n        var f = this,\n            g = c.ti;\n\n        if (-1 !== g) {\n          if (f = this.Hr(g), null === f) continue;\n        } else null !== c.sd && (f = c.sd);\n\n        \"/\" === e ? d = f.part : \".\" === e ? d = f : \"..\" === e && (d = f.panel);\n        e = c.Wn;\n\n        if (0 !== e) {\n          if (!(f instanceof W)) continue;\n          1 === e ? f = f.getColumnDefinition(c.ll) : 2 === e && (f = f.getRowDefinition(c.ll));\n        }\n\n        void 0 !== f && c.pv(f, d);\n      }\n    }\n  };\n\n  t.Uw = function (a) {\n    return void 0 === a || null === a || null === this.$d ? null : this.$d.I(a);\n  };\n\n  function gn(a, b) {\n    a = a.R.s;\n\n    for (var c = a.length, d = b.length, e = 0, f = null; e < c && !(f = a[e], f instanceof W && null !== f.data);) {\n      e++, f = a[e];\n    }\n\n    if (c - e !== d) return !0;\n    if (null === f) return 0 < d;\n\n    for (var g = 0; e < c && g < d;) {\n      f = a[e];\n      if (!(f instanceof W) || f.data !== b[g]) return !0;\n      e++;\n      g++;\n    }\n\n    return !1;\n  }\n\n  function an(a) {\n    if (a.type === W.Spot || a.type === W.Auto) return Math.min(a.R.length, 1);\n\n    if (a.type === W.Link) {\n      a = a.R;\n\n      for (var b = a.length, c = 0; c < b; c++) {\n        var d = a.K(c);\n        if (!(d instanceof Cf && d.isPanelMain)) break;\n      }\n\n      return c;\n    }\n\n    return a.type === W.Table && 0 < a.R.length && (a = a.R.K(0), a.isPanelMain && a instanceof W && (a.type === W.TableRow || a.type === W.TableColumn)) ? 1 : 0;\n  }\n\n  t.Vu = function () {\n    for (var a = an(this); this.R.length > a;) {\n      this.lc(this.R.length - 1, !1);\n    }\n\n    hn(this, this.itemArray);\n  };\n\n  function hn(a, b) {\n    var c = an(a);\n    if (null === b || 0 === b.length) for (; a.R.length > c;) {\n      a.lc(a.R.length - 1, !1);\n    } else if (a.R.length <= c) {\n      c = b.length;\n\n      for (var d = 0; d < c; d++) {\n        jn(a, b[d], d, !0);\n      }\n    } else {\n      d = c;\n\n      for (var e = 0; e < b.length; e++, d++) {\n        var f = b[e],\n            g = d < a.R.length ? a.R.K(d) : null;\n\n        if (g instanceof W) {\n          if (g.data !== f) {\n            var h = kn(a, g.data),\n                k = kn(a, f),\n                l = k !== h;\n            l || (h = ln(a, h), l = ln(a, k) !== h);\n            l ? (a.lc(d, !1), jn(a, f, e, !1)) : g.data = f;\n          }\n        } else jn(a, f, e, !1);\n      }\n\n      for (; d < a.R.length;) {\n        a.lc(d, !1);\n      }\n\n      a.Qg = null;\n      mn(a, c, 0);\n      nj(a) || a.w();\n      a.graduatedIntervals = null;\n      a.yf() || dn(a, a, !1);\n      b = a.part;\n      null !== b && (b.Kh = null, b.Sf = NaN, a.He && b instanceof V && (b.He = !0), b.He && b instanceof V && (b.sc = null));\n    }\n  }\n\n  function jn(a, b, c, d) {\n    if (!(void 0 === b || null === b || 0 > c)) {\n      var e = kn(a, b);\n      e = ln(a, e);\n\n      if (null !== e) {\n        kg(e);\n        e = e.copy();\n\n        if (0 !== (e.o & 16777216)) {\n          var f = a.Yg();\n          null !== f && en(f, !0);\n        }\n\n        \"object\" === typeof b && (null === a.$d && (a.$d = new pb()), a.$d.add(b, e));\n        f = c + an(a);\n        a.Cb(f, e);\n        d && (e.qb = b, mn(a, f, c), e.qb = null);\n        e.data = b;\n      }\n    }\n  }\n\n  function mn(a, b, c) {\n    for (a = a.R; b < a.length;) {\n      var d = a.K(b);\n\n      if (d instanceof W) {\n        var e = b,\n            f = c;\n        d.type === W.TableRow ? d.row = e : d.type === W.TableColumn && (d.column = e);\n        d.itemIndex = f;\n      }\n\n      b++;\n      c++;\n    }\n  }\n\n  function kn(a, b) {\n    if (null === b) return \"\";\n    a = a.itemCategoryProperty;\n    if (\"function\" === typeof a) a = a(b);else if (\"string\" === typeof a && \"object\" === typeof b) {\n      if (\"\" === a) return \"\";\n      a = nn(b, a);\n    } else return \"\";\n    if (void 0 === a) return \"\";\n    if (\"string\" === typeof a) return a;\n    C(\"Panel.getCategoryForItemData found a non-string category for \" + b + \": \" + a);\n  }\n\n  function ln(a, b) {\n    var c = a.itemTemplateMap,\n        d = null;\n    null !== c && (d = c.I(b));\n    null === d && (null !== c && (d = c.I(\"\")), null === d && (on || (on = !0, xa('No item template Panel found for category \"' + b + '\" on ' + a), xa(\"  Using default item template.\"), a = new W(), b = new Qg(), b.bind(new wi(\"text\", \"\", Ia)), a.add(b), pn = a), d = pn));\n    return d;\n  }\n\n  function dn(a, b, c) {\n    var d = b.enabledChanged;\n    null !== d && d(b, c);\n\n    if (b instanceof W) {\n      b = b.R.s;\n      d = b.length;\n\n      for (var e = 0; e < d; e++) {\n        var f = b[e];\n        c && f instanceof W && !f.isEnabled || dn(a, f, c);\n      }\n    }\n  }\n\n  function qn(a, b) {\n    b.name = a;\n    Jl.add(a, b);\n  }\n\n  ma.Object.defineProperties(W.prototype, {\n    type: {\n      get: function get() {\n        return this.qa;\n      },\n      set: function set(a) {\n        var b = this.qa;\n        b !== a && (this.qa = a, this.isAtomic = this.qa === W.Grid, this.w(), this.g(\"type\", b, a));\n      }\n    },\n    elements: {\n      get: function get() {\n        return this.R.iterator;\n      }\n    },\n    naturalBounds: {\n      get: function get() {\n        return this.bc;\n      }\n    },\n    padding: {\n      get: function get() {\n        return this.ub;\n      },\n      set: function set(a) {\n        \"number\" === typeof a ? (0 > a && wa(a, \">= 0\", W, \"padding\"), a = new ec(a)) : (0 > a.left && wa(a.left, \">= 0\", W, \"padding:value.left\"), 0 > a.right && wa(a.right, \">= 0\", W, \"padding:value.right\"), 0 > a.top && wa(a.top, \">= 0\", W, \"padding:value.top\"), 0 > a.bottom && wa(a.bottom, \">= 0\", W, \"padding:value.bottom\"));\n        var b = this.ub;\n        b.C(a) || (this.ub = a = a.J(), this.w(), this.g(\"padding\", b, a));\n      }\n    },\n    defaultAlignment: {\n      get: function get() {\n        return this.Bm;\n      },\n      set: function set(a) {\n        var b = this.Bm;\n        b.C(a) || (this.Bm = a = a.J(), this.w(), this.g(\"defaultAlignment\", b, a));\n      }\n    },\n    defaultStretch: {\n      get: function get() {\n        return this.Kf;\n      },\n      set: function set(a) {\n        var b = this.Kf;\n        b !== a && (this.Kf = a, this.w(), this.g(\"defaultStretch\", b, a));\n      }\n    },\n    defaultSeparatorPadding: {\n      get: function get() {\n        return null !== this.T ? this.T.tp : qc;\n      },\n      set: function set(a) {\n        \"number\" === typeof a && (a = new ec(a));\n        var b = this.defaultSeparatorPadding;\n        b.C(a) || (a = a.J(), null === this.T && (this.T = new rn()), this.T.tp = a, this.w(), this.g(\"defaultSeparatorPadding\", b, a));\n      }\n    },\n    defaultRowSeparatorStroke: {\n      get: function get() {\n        return null !== this.T ? this.T.ga : null;\n      },\n      set: function set(a) {\n        var b = this.defaultRowSeparatorStroke;\n        b !== a && (null === a || \"string\" === typeof a || a instanceof ml) && (a instanceof ml && a.freeze(), null === this.T && (this.T = new rn()), this.T.ga = a, this.N(), this.g(\"defaultRowSeparatorStroke\", b, a));\n      }\n    },\n    defaultRowSeparatorStrokeWidth: {\n      get: function get() {\n        return null !== this.T ? this.T.Ga : 1;\n      },\n      set: function set(a) {\n        var b = this.defaultRowSeparatorStrokeWidth;\n        b !== a && isFinite(a) && 0 <= a && (null === this.T && (this.T = new rn()), this.T.Ga = a, this.w(), this.g(\"defaultRowSeparatorStrokeWidth\", b, a));\n      }\n    },\n    defaultRowSeparatorDashArray: {\n      get: function get() {\n        return null !== this.T ? this.T.W : null;\n      },\n      set: function set(a) {\n        var b = this.defaultRowSeparatorDashArray;\n\n        if (b !== a) {\n          if (null !== a) {\n            for (var c = a.length, d = 0, e = 0; e < c; e++) {\n              var f = a[e];\n              \"number\" === typeof f && 0 <= f && isFinite(f) || C(\"defaultRowSeparatorDashArray value \" + f + \" at index \" + e + \" must be a positive number or zero.\");\n              d += f;\n            }\n\n            if (0 === d) {\n              if (null === b) return;\n              a = null;\n            }\n          }\n\n          null === this.T && (this.T = new rn());\n          this.T.W = a;\n          this.N();\n          this.g(\"defaultRowSeparatorDashArray\", b, a);\n        }\n      }\n    },\n    defaultColumnSeparatorStroke: {\n      get: function get() {\n        return null !== this.T ? this.T.u : null;\n      },\n      set: function set(a) {\n        var b = this.defaultColumnSeparatorStroke;\n        b !== a && (null === a || \"string\" === typeof a || a instanceof ml) && (a instanceof ml && a.freeze(), null === this.T && (this.T = new rn()), this.T.u = a, this.N(), this.g(\"defaultColumnSeparatorStroke\", b, a));\n      }\n    },\n    defaultColumnSeparatorStrokeWidth: {\n      get: function get() {\n        return null !== this.T ? this.T.F : 1;\n      },\n      set: function set(a) {\n        var b = this.defaultColumnSeparatorStrokeWidth;\n        b !== a && isFinite(a) && 0 <= a && (null === this.T && (this.T = new rn()), this.T.F = a, this.w(), this.g(\"defaultColumnSeparatorStrokeWidth\", b, a));\n      }\n    },\n    defaultColumnSeparatorDashArray: {\n      get: function get() {\n        return null !== this.T ? this.T.m : null;\n      },\n      set: function set(a) {\n        var b = this.defaultColumnSeparatorDashArray;\n\n        if (b !== a) {\n          if (null !== a) {\n            for (var c = a.length, d = 0, e = 0; e < c; e++) {\n              var f = a[e];\n              \"number\" === typeof f && 0 <= f && isFinite(f) || C(\"defaultColumnSeparatorDashArray value \" + f + \" at index \" + e + \" must be a positive number or zero.\");\n              d += f;\n            }\n\n            if (0 === d) {\n              if (null === b) return;\n              a = null;\n            }\n          }\n\n          null === this.T && (this.T = new rn());\n          this.T.m = a;\n          this.N();\n          this.g(\"defaultColumnSeparatorDashArray\", b, a);\n        }\n      }\n    },\n    inRowsCols: {\n      get: function get() {\n        return null !== this.T ? this.T.hb : null;\n      },\n      set: function set(a) {\n        null === this.T && (this.T = new rn());\n        this.T.hb = a;\n      }\n    },\n    viewboxStretch: {\n      get: function get() {\n        return this.$n;\n      },\n      set: function set(a) {\n        var b = this.$n;\n        b !== a && (this.$n = a, this.w(), this.g(\"viewboxStretch\", b, a));\n      }\n    },\n    gridCellSize: {\n      get: function get() {\n        return this.Qm;\n      },\n      set: function set(a) {\n        var b = this.Qm;\n\n        if (!b.C(a)) {\n          a.v() && 0 !== a.width && 0 !== a.height || C(\"Invalid Panel.gridCellSize: \" + a);\n          this.Qm = a.J();\n          var c = this.diagram;\n          null !== c && this === c.grid && jj(c);\n          this.N();\n          this.g(\"gridCellSize\", b, a);\n        }\n      }\n    },\n    gridOrigin: {\n      get: function get() {\n        return this.Rm;\n      },\n      set: function set(a) {\n        var b = this.Rm;\n\n        if (!b.C(a)) {\n          a.v() || C(\"Invalid Panel.gridOrigin: \" + a);\n          this.Rm = a.J();\n          var c = this.diagram;\n          null !== c && this === c.grid && jj(c);\n          this.N();\n          this.g(\"gridOrigin\", b, a);\n        }\n      }\n    },\n    graduatedMin: {\n      get: function get() {\n        return null !== this.oa ? this.oa.Np : 0;\n      },\n      set: function set(a) {\n        var b = this.graduatedMin;\n        b !== a && (null === this.oa && (this.oa = new sn()), this.oa.Np = a, this.w(), this.g(\"graduatedMin\", b, a), dl(this) && (a = this.part, null !== a && el(this, a, \"graduatedRange\")));\n      }\n    },\n    graduatedMax: {\n      get: function get() {\n        return null !== this.oa ? this.oa.F : 100;\n      },\n      set: function set(a) {\n        var b = this.graduatedMax;\n        b !== a && (null === this.oa && (this.oa = new sn()), this.oa.F = a, this.w(), this.g(\"graduatedMax\", b, a), dl(this) && (a = this.part, null !== a && el(this, a, \"graduatedRange\")));\n      }\n    },\n    graduatedRange: {\n      get: function get() {\n        return this.graduatedMax - this.graduatedMin;\n      }\n    },\n    graduatedTickUnit: {\n      get: function get() {\n        return null !== this.oa ? this.oa.ga : 10;\n      },\n      set: function set(a) {\n        var b = this.graduatedTickUnit;\n        b !== a && 0 < a && (null === this.oa && (this.oa = new sn()), this.oa.ga = a, this.w(), this.g(\"graduatedTickUnit\", b, a));\n      }\n    },\n    graduatedTickBase: {\n      get: function get() {\n        return null !== this.oa ? this.oa.W : 0;\n      },\n      set: function set(a) {\n        var b = this.graduatedTickBase;\n        b !== a && (null === this.oa && (this.oa = new sn()), this.oa.W = a, this.w(), this.g(\"graduatedTickBase\", b, a));\n      }\n    },\n    graduatedMarks: {\n      get: function get() {\n        return null !== this.oa ? this.oa.u : null;\n      },\n      set: function set(a) {\n        null !== this.oa ? this.oa.u = a : null !== a && (this.oa = new sn(), this.oa.u = a);\n      }\n    },\n    graduatedBounds: {\n      get: function get() {\n        return null !== this.oa ? this.oa.j : null;\n      },\n      set: function set(a) {\n        null !== this.oa ? this.oa.j = a : null !== a && (this.oa = new sn(), this.oa.j = a);\n      }\n    },\n    graduatedIntervals: {\n      get: function get() {\n        return null !== this.oa ? this.oa.m : null;\n      },\n      set: function set(a) {\n        null !== this.oa ? this.oa.m = a : null !== a && (this.oa = new sn(), this.oa.m = a);\n      }\n    },\n    temporaryTextBlock: {\n      get: function get() {\n        return null !== this.oa ? this.oa.Sh : null;\n      },\n      set: function set(a) {\n        null !== this.oa ? this.oa.Sh = a : null !== a && (this.oa = new sn(), this.oa.Sh = a);\n      }\n    },\n    panelLayoutState: {\n      get: function get() {\n        return this.F;\n      },\n      set: function set(a) {\n        this.F = a;\n      }\n    },\n    He: {\n      get: function get() {\n        return 0 !== (this.o & 8388608);\n      },\n      set: function set(a) {\n        0 !== (this.o & 8388608) !== a && (this.o ^= 8388608);\n      }\n    },\n    rowDefs: {\n      get: function get() {\n        null === this.T && (this.T = new rn());\n        return this.T.Ic;\n      }\n    },\n    rowCount: {\n      get: function get() {\n        return null === this.T ? 0 : this.rowDefs.length;\n      }\n    },\n    colDefs: {\n      get: function get() {\n        null === this.T && (this.T = new rn());\n        return this.T.Hc;\n      }\n    },\n    columnCount: {\n      get: function get() {\n        return null === this.T ? 0 : this.colDefs.length;\n      }\n    },\n    rowSizing: {\n      get: function get() {\n        return null !== this.T ? this.T.nb : tn;\n      },\n      set: function set(a) {\n        var b = this.rowSizing;\n        b !== a && (null === this.T && (this.T = new rn()), this.T.nb = a, this.w(), this.g(\"rowSizing\", b, a));\n      }\n    },\n    columnSizing: {\n      get: function get() {\n        return null !== this.T ? this.T.j : tn;\n      },\n      set: function set(a) {\n        var b = this.columnSizing;\n        b !== a && (null === this.T && (this.T = new rn()), this.T.j = a, this.w(), this.g(\"columnSizing\", b, a));\n      }\n    },\n    topIndex: {\n      get: function get() {\n        return null !== this.T ? this.T.Db : 0;\n      },\n      set: function set(a) {\n        var b = this.topIndex;\n        b !== a && ((!isFinite(a) || 0 > a) && C(\"Panel.topIndex must be greater than zero and a real number, not: \" + a), null === this.T && (this.T = new rn()), this.T.Db = a, this.w(), this.g(\"topIndex\", b, a));\n      }\n    },\n    leftIndex: {\n      get: function get() {\n        return null !== this.T ? this.T.cb : 0;\n      },\n      set: function set(a) {\n        var b = this.leftIndex;\n        b !== a && ((!isFinite(a) || 0 > a) && C(\"Panel.leftIndex must be greater than zero and a real number, not: \" + a), null === this.T && (this.T = new rn()), this.T.cb = a, this.w(), this.g(\"leftIndex\", b, a));\n      }\n    },\n    data: {\n      get: function get() {\n        return this.qb;\n      },\n      set: function set(a) {\n        var b = this.qb;\n\n        if (b !== a) {\n          var c = this instanceof U && !(this instanceof ue);\n          kg(this);\n          this.qb = a;\n          var d = this.diagram;\n          null !== d && (c ? (c = d.partManager, this instanceof T ? (null !== b && c.Re.remove(b), null !== a && c.Re.add(a, this)) : this instanceof U && (null !== b && c.Se.remove(b), null !== a && c.Se.add(a, this))) : (c = this.panel, null !== c && null !== c.$d && (null !== b && c.$d.remove(b), null !== a && c.$d.add(a, this))));\n          this.g(\"data\", b, a);\n          null !== d && d.undoManager.isUndoingRedoing || null !== a && this.Ka();\n        }\n      }\n    },\n    itemIndex: {\n      get: function get() {\n        return this.fn;\n      },\n      set: function set(a) {\n        var b = this.fn;\n        b !== a && (this.fn = a, this.g(\"itemIndex\", b, a));\n      }\n    },\n    allBindings: {\n      get: function get() {\n        return null !== this.A ? this.A.hb : null;\n      },\n      set: function set(a) {\n        this.localBindings !== a && (null === this.A && (this.A = new bl()), this.A.hb = a);\n      }\n    },\n    itemArray: {\n      get: function get() {\n        return this.xh;\n      },\n      set: function set(a) {\n        var b = this.xh;\n\n        if (b !== a || null !== a && gn(this, a)) {\n          var c = this.diagram;\n          b !== a && (null !== c && null !== b && Fj(c.partManager, this, c), this.xh = a, null !== c && null !== a && Cj(c.partManager, this));\n          this.g(\"itemArray\", b, a);\n          null !== c && c.undoManager.isUndoingRedoing || hn(this, a);\n        }\n      }\n    },\n    itemTemplate: {\n      get: function get() {\n        return null === this.itemTemplateMap ? null : this.itemTemplateMap.I(\"\");\n      },\n      set: function set(a) {\n        if (null === this.itemTemplateMap) {\n          if (null === a) return;\n          this.itemTemplateMap = new pb();\n        }\n\n        var b = this.itemTemplateMap.I(\"\");\n        b !== a && ((a instanceof U || a.isPanelMain) && C(\"Panel.itemTemplate must not be a Part or be Panel.isPanelMain: \" + a), this.itemTemplateMap.add(\"\", a), this.g(\"itemTemplate\", b, a), a = this.diagram, null !== a && a.undoManager.isUndoingRedoing || this.Vu());\n      }\n    },\n    itemTemplateMap: {\n      get: function get() {\n        return null !== this.A ? this.A.le : null;\n      },\n      set: function set(a) {\n        var b = this.itemTemplateMap;\n\n        if (b !== a) {\n          for (var c = a.iterator; c.next();) {\n            ;\n          }\n\n          al(this);\n          this.A.le = a;\n          this.g(\"itemTemplateMap\", b, a);\n          a = this.diagram;\n          null !== a && a.undoManager.isUndoingRedoing || this.Vu();\n        }\n      }\n    },\n    itemCategoryProperty: {\n      get: function get() {\n        return null !== this.A ? this.A.Ic : \"category\";\n      },\n      set: function set(a) {\n        var b = this.itemCategoryProperty;\n        b !== a && (al(this), this.A.Ic = a, this.g(\"itemCategoryProperty\", b, a));\n      }\n    },\n    isAtomic: {\n      get: function get() {\n        return 0 !== (this.o & 1048576);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.o & 1048576);\n        b !== a && (this.o ^= 1048576, this.g(\"isAtomic\", b, a));\n      }\n    },\n    isClipping: {\n      get: function get() {\n        return 0 !== (this.o & 2097152);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.o & 2097152);\n        b !== a && (this.o ^= 2097152, this instanceof qf && (this.ib = null), this.w(), this.g(\"isClipping\", b, a));\n      }\n    },\n    isOpposite: {\n      get: function get() {\n        return 0 !== (this.o & 33554432);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.o & 33554432);\n        b !== a && (this.o ^= 33554432, this.w(), this.g(\"isOpposite\", b, a));\n      }\n    },\n    isEnabled: {\n      get: function get() {\n        return 0 !== (this.o & 4194304);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.o & 4194304);\n\n        if (b !== a) {\n          var c = null === this.panel || this.panel.yf();\n          this.o ^= 4194304;\n          this.g(\"isEnabled\", b, a);\n          b = this.diagram;\n          null !== b && b.undoManager.isUndoingRedoing || c && dn(this, this, a);\n        }\n      }\n    },\n    alignmentFocusName: {\n      get: function get() {\n        return this.Pe;\n      },\n      set: function set(a) {\n        var b = this.Pe;\n        b !== a && (this.Pe = a, this.w(), this.g(\"alignmentFocusName\", b, a));\n      }\n    }\n  });\n  ma.Object.defineProperties(W, {\n    Position: {\n      get: function get() {\n        return Jl.I(\"Position\");\n      }\n    },\n    Horizontal: {\n      get: function get() {\n        return Jl.I(\"Horizontal\");\n      }\n    },\n    Vertical: {\n      get: function get() {\n        return Jl.I(\"Vertical\");\n      }\n    },\n    Spot: {\n      get: function get() {\n        return Jl.I(\"Spot\");\n      }\n    },\n    Auto: {\n      get: function get() {\n        return Jl.I(\"Auto\");\n      }\n    },\n    Table: {\n      get: function get() {\n        return Jl.I(\"Table\");\n      }\n    },\n    Viewbox: {\n      get: function get() {\n        return Jl.I(\"Viewbox\");\n      }\n    },\n    TableRow: {\n      get: function get() {\n        return Jl.I(\"TableRow\");\n      }\n    },\n    TableColumn: {\n      get: function get() {\n        return Jl.I(\"TableColumn\");\n      }\n    },\n    Link: {\n      get: function get() {\n        return Jl.I(\"Link\");\n      }\n    },\n    Grid: {\n      get: function get() {\n        return Jl.I(\"Grid\");\n      }\n    },\n    Graduated: {\n      get: function get() {\n        return Jl.I(\"Graduated\");\n      }\n    }\n  });\n  W.prototype.rebuildItemElements = W.prototype.Vu;\n  W.prototype.findItemPanelForData = W.prototype.Uw;\n  W.prototype.updateTargetBindings = W.prototype.Ka;\n  W.prototype.copyTemplate = W.prototype.By;\n  W.prototype.graduatedValueForPoint = W.prototype.nz;\n  W.prototype.graduatedPointForValue = W.prototype.mz;\n  W.prototype.findColumnForLocalX = W.prototype.Oy;\n  W.prototype.findRowForLocalY = W.prototype.Wy;\n  W.prototype.removeColumnDefinition = W.prototype.Qz;\n  W.prototype.removeRowDefinition = W.prototype.Vz;\n  W.prototype.removeAt = W.prototype.mb;\n  W.prototype.remove = W.prototype.remove;\n  W.prototype.insertAt = W.prototype.Cb;\n  W.prototype.elt = W.prototype.K;\n  W.prototype.add = W.prototype.add;\n  W.prototype.findObject = W.prototype.fb;\n  W.prototype.findInVisualTree = W.prototype.vl;\n  W.prototype.walkVisualTreeFrom = W.prototype.$l;\n  W.prototype.findMainElement = W.prototype.vb;\n  var on = !1,\n      pn = null,\n      Jl = new pb();\n  W.className = \"Panel\";\n  W.definePanelLayout = qn;\n  qn(\"Position\", new sm());\n  qn(\"Vertical\", new vm());\n  qn(\"Auto\", new ym());\n  qn(\"Link\", new Jm());\n\n  function sn() {\n    this.Np = 0;\n    this.F = 100;\n    this.ga = 10;\n    this.W = 0;\n    this.Sh = this.m = this.j = this.u = null;\n  }\n\n  sn.prototype.copy = function () {\n    var a = new sn();\n    a.Np = this.Np;\n    a.F = this.F;\n    a.ga = this.ga;\n    a.W = this.W;\n    a.u = this.u;\n    a.j = this.j;\n    a.m = this.m;\n    a.Sh = this.Sh;\n    return a;\n  };\n\n  sn.className = \"GradPanelSettings\";\n\n  function rn() {\n    this.Ic = [];\n    this.Hc = [];\n    this.j = this.nb = tn;\n    this.cb = this.Db = 0;\n    this.tp = qc;\n    this.Ga = 1;\n    this.W = this.ga = null;\n    this.F = 1;\n    this.hb = this.m = this.u = null;\n  }\n\n  rn.prototype.copy = function (a) {\n    for (var b = new rn(), c = this.Ic, d = c.length, e = b.Ic, f = 0; f < d; f++) {\n      if (void 0 !== c[f]) {\n        var g = c[f].copy();\n        g.ni(a);\n        e[f] = g;\n      }\n    }\n\n    c = this.Hc;\n    d = c.length;\n    e = b.Hc;\n\n    for (f = 0; f < d; f++) {\n      void 0 !== c[f] && (g = c[f].copy(), g.ni(a), e[f] = g);\n    }\n\n    b.nb = this.nb;\n    b.j = this.j;\n    b.Db = this.Db;\n    b.cb = this.cb;\n    b.tp = this.tp.J();\n    b.Ga = this.Ga;\n    b.ga = this.ga;\n    b.W = this.W;\n    b.F = this.F;\n    b.u = this.u;\n    b.m = this.m;\n    b.hb = this.hb;\n    return b;\n  };\n\n  rn.className = \"TablePanelSettings\";\n\n  function Oj() {\n    Ra(this);\n    this.Uf = null;\n    this.Wp = !0;\n    this.Wa = 0;\n    this.Ac = NaN;\n    this.ej = 0;\n    this.cj = Infinity;\n    this.Fb = Wc;\n    this.pa = this.jc = this.ma = 0;\n    this.Vd = null;\n    this.Rn = un;\n    this.$f = Wk;\n    this.On = this.Wf = null;\n    this.Pn = NaN;\n    this.Yb = this.oj = null;\n    this.xm = !1;\n  }\n\n  Oj.prototype.copy = function () {\n    var a = new Oj();\n    a.Wp = this.Wp;\n    a.Wa = this.Wa;\n    a.Ac = this.Ac;\n    a.ej = this.ej;\n    a.cj = this.cj;\n    a.Fb = this.Fb;\n    a.ma = this.ma;\n    a.jc = this.jc;\n    a.pa = this.pa;\n    a.$f = this.$f;\n    a.Rn = this.Rn;\n    null === this.Wf ? a.Wf = null : a.Wf = this.Wf.J();\n    a.On = this.On;\n    a.Pn = this.Pn;\n    a.oj = null;\n    null !== this.oj && (a.separatorDashArray = Aa(this.separatorDashArray));\n    a.Yb = this.Yb;\n    a.xm = this.xm;\n    a.Vd = this.Vd;\n    return a;\n  };\n\n  t = Oj.prototype;\n\n  t.ob = function (a) {\n    a.classType === Oj && (this.sizing = a);\n  };\n\n  t.toString = function () {\n    return \"RowColumnDefinition \" + (this.isRow ? \"(Row \" : \"(Column \") + this.index + \") #\" + cb(this);\n  };\n\n  t.ni = function (a) {\n    this.Uf = a;\n  };\n\n  t.mo = function (a) {\n    var b = 0,\n        c = this.Uf;\n    this.index !== a && (a = this.separatorStroke, null === a && null !== c && (a = this.isRow ? c.defaultRowSeparatorStroke : c.defaultColumnSeparatorStroke), null !== a && (b = this.separatorStrokeWidth, isNaN(b) && (null !== c ? b = this.isRow ? c.defaultRowSeparatorStrokeWidth : c.defaultColumnSeparatorStrokeWidth : b = 0)));\n    a = this.Wf;\n    if (null === a) if (null !== c) a = c.defaultSeparatorPadding;else return b;\n    return b + (this.isRow ? a.top : a.left);\n  };\n\n  t.Qc = function () {\n    var a = 0,\n        b = this.Uf,\n        c = 0,\n        d = this.isRow;\n    if (null !== b && b.type === W.Table) for (var e = d ? b.rowDefs.length : b.colDefs.length, f = 0; f < e; f++) {\n      var g = d ? b.rowDefs[f] : b.colDefs[f];\n\n      if (void 0 !== g && 0 !== g.ma) {\n        c = g.index;\n        break;\n      }\n    }\n    this.index !== c && (c = this.separatorStroke, null === c && null !== b && (c = d ? b.defaultRowSeparatorStroke : b.defaultColumnSeparatorStroke), null !== c && (a = this.separatorStrokeWidth, isNaN(a) && (null !== b ? a = d ? b.defaultRowSeparatorStrokeWidth : b.defaultColumnSeparatorStrokeWidth : a = 0)));\n    d = this.Wf;\n    if (null === d) if (null !== b) d = b.defaultSeparatorPadding;else return a;\n    return a + (this.isRow ? d.top + d.bottom : d.left + d.right);\n  };\n\n  t.Kb = function (a, b, c) {\n    var d = this.Uf;\n    if (null !== d && (d.bb(de, a, this, b, c, void 0, void 0), null !== this.Vd && (b = d.diagram, null !== b && !b.skipsModelSourceBindings && (d = d.Yg(), null !== d && (b = d.data, null !== b))))) for (c = this.Vd.iterator; c.next();) {\n      c.value.Vo(this, b, a, d);\n    }\n  };\n\n  function Cm(a) {\n    if (a.sizing === un) {\n      var b = a.Uf;\n      return a.isRow ? b.rowSizing : b.columnSizing;\n    }\n\n    return a.sizing;\n  }\n\n  t.bind = function (a, b, c, d) {\n    var e = null;\n    \"string\" === typeof a ? e = new wi(a, b, c, d) : e = a;\n    e.sd = this;\n    a = this.panel;\n    null !== a && (b = a.Yg(), null !== b && Fl(b) && C(\"Cannot add a Binding to a RowColumnDefinition that is already frozen: \" + e + \" on \" + a));\n    null === this.Vd && (this.Vd = new E());\n    this.Vd.add(e);\n    return this;\n  };\n\n  ma.Object.defineProperties(Oj.prototype, {\n    panel: {\n      get: function get() {\n        return this.Uf;\n      }\n    },\n    isRow: {\n      get: function get() {\n        return this.Wp;\n      },\n      set: function set(a) {\n        this.Wp = a;\n      }\n    },\n    index: {\n      get: function get() {\n        return this.Wa;\n      },\n      set: function set(a) {\n        this.Wa = a;\n      }\n    },\n    height: {\n      get: function get() {\n        return this.Ac;\n      },\n      set: function set(a) {\n        var b = this.Ac;\n        b !== a && (0 > a && wa(a, \">= 0\", Oj, \"height\"), this.Ac = a, this.actual = this.ma, null !== this.panel && this.panel.w(), this.Kb(\"height\", b, a));\n      }\n    },\n    width: {\n      get: function get() {\n        return this.Ac;\n      },\n      set: function set(a) {\n        var b = this.Ac;\n        b !== a && (0 > a && wa(a, \">= 0\", Oj, \"width\"), this.Ac = a, this.actual = this.ma, null !== this.panel && this.panel.w(), this.Kb(\"width\", b, a));\n      }\n    },\n    minimum: {\n      get: function get() {\n        return this.ej;\n      },\n      set: function set(a) {\n        var b = this.ej;\n        b !== a && ((0 > a || !isFinite(a)) && wa(a, \">= 0\", Oj, \"minimum\"), this.ej = a, this.actual = this.ma, null !== this.panel && this.panel.w(), this.Kb(\"minimum\", b, a));\n      }\n    },\n    maximum: {\n      get: function get() {\n        return this.cj;\n      },\n      set: function set(a) {\n        var b = this.cj;\n        b !== a && (0 > a && wa(a, \">= 0\", Oj, \"maximum\"), this.cj = a, this.actual = this.ma, null !== this.panel && this.panel.w(), this.Kb(\"maximum\", b, a));\n      }\n    },\n    alignment: {\n      get: function get() {\n        return this.Fb;\n      },\n      set: function set(a) {\n        var b = this.Fb;\n        b.C(a) || (this.Fb = a.J(), null !== this.panel && this.panel.w(), this.Kb(\"alignment\", b, a));\n      }\n    },\n    stretch: {\n      get: function get() {\n        return this.$f;\n      },\n      set: function set(a) {\n        var b = this.$f;\n        b !== a && (this.$f = a, null !== this.panel && this.panel.w(), this.Kb(\"stretch\", b, a));\n      }\n    },\n    separatorPadding: {\n      get: function get() {\n        return this.Wf;\n      },\n      set: function set(a) {\n        \"number\" === typeof a && (a = new ec(a));\n        var b = this.Wf;\n        null !== a && null !== b && b.C(a) || (null !== a && (a = a.J()), this.Wf = a, null !== this.panel && this.panel.w(), this.Kb(\"separatorPadding\", b, a));\n      }\n    },\n    separatorStroke: {\n      get: function get() {\n        return this.On;\n      },\n      set: function set(a) {\n        var b = this.On;\n        b !== a && (null !== a && Ol(a, \"RowColumnDefinition.separatorStroke\"), a instanceof ml && a.freeze(), this.On = a, null !== this.panel && this.panel.w(), this.Kb(\"separatorStroke\", b, a));\n      }\n    },\n    separatorStrokeWidth: {\n      get: function get() {\n        return this.Pn;\n      },\n      set: function set(a) {\n        var b = this.Pn;\n        b !== a && (this.Pn = a, null !== this.panel && this.panel.w(), this.Kb(\"separatorStrokeWidth\", b, a));\n      }\n    },\n    separatorDashArray: {\n      get: function get() {\n        return this.oj;\n      },\n      set: function set(a) {\n        var b = this.oj;\n\n        if (b !== a) {\n          if (null !== a) {\n            for (var c = a.length, d = 0, e = 0; e < c; e++) {\n              var f = a[e];\n              \"number\" === typeof f && 0 <= f && isFinite(f) || C(\"separatorDashArray value \" + f + \" at index \" + e + \" must be a positive number or zero.\");\n              d += f;\n            }\n\n            if (0 === d) {\n              if (null === b) return;\n              a = null;\n            }\n          }\n\n          this.oj = a;\n          null !== this.panel && this.panel.N();\n          this.Kb(\"separatorDashArray\", b, a);\n        }\n      }\n    },\n    background: {\n      get: function get() {\n        return this.Yb;\n      },\n      set: function set(a) {\n        var b = this.Yb;\n        b !== a && (null !== a && Ol(a, \"RowColumnDefinition.background\"), a instanceof ml && a.freeze(), this.Yb = a, null !== this.panel && this.panel.N(), this.Kb(\"background\", b, a));\n      }\n    },\n    coversSeparators: {\n      get: function get() {\n        return this.xm;\n      },\n      set: function set(a) {\n        var b = this.xm;\n        b !== a && (this.xm = a, null !== this.panel && this.panel.N(), this.Kb(\"coversSeparators\", b, a));\n      }\n    },\n    sizing: {\n      get: function get() {\n        return this.Rn;\n      },\n      set: function set(a) {\n        var b = this.Rn;\n        b !== a && (this.Rn = a, null !== this.panel && this.panel.w(), this.Kb(\"sizing\", b, a));\n      }\n    },\n    actual: {\n      get: function get() {\n        return this.ma;\n      },\n      set: function set(a) {\n        this.ma = isNaN(this.Ac) ? Math.max(Math.min(this.cj, a), this.ej) : Math.max(Math.min(this.cj, this.Ac), this.ej);\n      }\n    },\n    measured: {\n      get: function get() {\n        return this.jc;\n      },\n      set: function set(a) {\n        this.jc = a;\n      }\n    },\n    total: {\n      get: function get() {\n        return this.ma + this.Qc();\n      }\n    },\n    position: {\n      get: function get() {\n        return this.pa;\n      },\n      set: function set(a) {\n        this.pa = a;\n      }\n    }\n  });\n  Oj.prototype.computeEffectiveSpacing = Oj.prototype.Qc;\n  Oj.prototype.computeEffectiveSpacingTop = Oj.prototype.mo;\n  var un = new D(Oj, \"Default\", 0),\n      Dm = new D(Oj, \"None\", 1),\n      tn = new D(Oj, \"ProportionalExtra\", 2);\n  Oj.className = \"RowColumnDefinition\";\n  Oj.Default = un;\n  Oj.None = Dm;\n  Oj.ProportionalExtra = tn;\n\n  function Cf(a, b) {\n    Y.call(this);\n    this.Hd = this.sa = null;\n    this.Jm = \"None\";\n    this.Nc = this.Ak = \"black\";\n    this.ag = 1;\n    this.Na = this.Og = null;\n    this.Dn = this.Cn = NaN;\n    this.fa = null;\n    \"string\" === typeof a ? this.figure = a : a && Object.assign(this, a);\n    b && Object.assign(this, b);\n  }\n\n  la(Cf, Y);\n\n  Cf.prototype.cloneProtected = function (a) {\n    Y.prototype.cloneProtected.call(this, a);\n    a.sa = this.sa;\n    a.Hd = this.Hd;\n    a.Jm = this.Jm;\n    a.Ak = this.Ak;\n    a.Nc = this.Nc;\n    a.ag = this.ag;\n    null !== this.Og && (a.Og = Aa(this.Og));\n    null !== this.Na && (a.Na = this.Na.ic ? this.Na : this.Na.copy());\n    a.Cn = this.Cn;\n    a.Dn = this.Dn;\n    null !== this.fa && (a.fa = this.fa.copy());\n  };\n\n  function vn(a) {\n    null === a.Na ? a.Na = new wn() : a.Na.ic && (a.Na = a.Na.copy());\n  }\n\n  t = Cf.prototype;\n\n  t.ih = function () {\n    Y.prototype.ih.call(this);\n    null !== this.Na && (this.Na.ic = !0);\n  };\n\n  t.ob = function (a) {\n    a === lg || a === ng || a === Xk || a === Wk ? this.geometryStretch = a : Y.prototype.ob.call(this, a);\n  };\n\n  t.toString = function () {\n    return \"Shape(\" + (\"None\" !== this.figure ? this.figure : \"None\" !== this.toArrow ? this.toArrow : this.fromArrow) + \")#\" + cb(this);\n  };\n\n  function xn(a, b, c, d) {\n    var e = c.length;\n\n    if (!(4 > e)) {\n      var f = d.measuredBounds,\n          g = Math.max(1, f.width);\n      f = f.height;\n\n      for (var h = c[0], k = c[1], l, m, n, p, r, q, u = 0, w = Ea(), v = 2; v < e; v += 2) {\n        l = c[v], m = c[v + 1], n = l - h, h = m - k, 0 === n && (n = .001), p = h / n, r = Math.atan2(h, n), q = Math.sqrt(n * n + h * h), w.push([n, r, p, q]), u += q, h = l, k = m;\n      }\n\n      h = c[0];\n      k = c[1];\n      n = d.measuredBounds.width;\n      d instanceof Cf && (n -= d.strokeWidth);\n      1 > n && (n = 1);\n      e = c = n;\n      l = g / 2;\n      m = 0 === l ? !1 : !0;\n      v = 0;\n      q = w[v];\n      n = q[0];\n      r = q[1];\n      p = q[2];\n      q = q[3];\n\n      for (var z = 0; .1 <= u;) {\n        0 === z && (m ? (e = c, e -= l, u -= l, m = !1) : e = c, 0 === e && (e = 1));\n\n        if (e > u) {\n          Ga(w);\n          return;\n        }\n\n        e > q ? (z = e - q, e = q) : z = 0;\n        var y = Math.sqrt(e * e / (1 + p * p));\n        0 > n && (y = -y);\n        h += y;\n        k += p * y;\n        a.translate(h, k);\n        a.rotate(r);\n        a.translate(-(g / 2), -(f / 2));\n        0 === z && d.ai(a, b);\n        a.translate(g / 2, f / 2);\n        a.rotate(-r);\n        a.translate(-h, -k);\n        u -= e;\n        q -= e;\n\n        if (0 !== z) {\n          v++;\n\n          if (v === w.length) {\n            Ga(w);\n            return;\n          }\n\n          q = w[v];\n          n = q[0];\n          r = q[1];\n          p = q[2];\n          q = q[3];\n          e = z;\n        }\n      }\n\n      Ga(w);\n    }\n  }\n\n  t.ai = function (a, b) {\n    var c = this.Nc,\n        d = this.Ak;\n\n    if (null !== c || null !== d) {\n      var e = this.sa;\n\n      if (null !== e) {\n        a.Pc();\n        var f = this.actualBounds,\n            g = this.naturalBounds;\n        null !== d && gi(this, a, d, !0, !1, g, f);\n        var h = this.part,\n            k = this.ag;\n        null === c || 0 !== k || null === h || !this.isPanelMain && h.vb() !== this || (k = h.type === W.Link && h instanceof ue && \"Selection\" === h.category && h.adornedObject instanceof Cf && h.adornedPart.vb() === h.adornedObject ? h.adornedObject.strokeWidth : 0);\n        0 === k && (c = null);\n        null !== c && 0 !== k && (gi(this, a, c, !1, !1, g, f), a.lineWidth = k, a.lineJoin = this.strokeJoin, a.lineCap = this.strokeCap, a.miterLimit = this.strokeMiterLimit);\n        f = !1;\n        h && b.Ge(\"drawShadows\") && (f = h.isShadowed);\n        h = !0;\n        null === c || null !== d && \"transparent\" !== d || (h = !1);\n        g = !1;\n        k = this.strokeDashArray;\n        null !== k && (g = !0, a.Gr(k, this.strokeDashOffset));\n        if (e.type === O.j) a.beginPath(), a.moveTo(e.startX, e.startY), a.lineTo(e.endX, e.endY), null !== c && a.si();else if (e.type === O.u) {\n          var l = e.startX;\n          k = e.startY;\n          var m = e.endX,\n              n = e.endY;\n          e = Math.min(l, m);\n          var p = Math.min(k, n);\n          l = Math.abs(m - l);\n          k = Math.abs(n - k);\n          a.beginPath();\n          a.rect(e, p, l, k);\n          null !== d && a.sf(d);\n\n          if (null !== c) {\n            h && f && ql(a);\n            if (0 === l || 0 === k) a.beginPath(), a.rect(e, p, Math.max(l, .1), Math.max(k, .1));\n            a.si();\n            h && f && pl(a);\n          }\n        } else if (e.type === O.F) l = e.startX, k = e.startY, m = e.endX, n = e.endY, e = Math.abs(m - l) / 2, p = Math.abs(n - k) / 2, l = Math.min(l, m) + e, k = Math.min(k, n) + p, a.beginPath(), a.moveTo(l, k - p), a.bezierCurveTo(l + J.ng * e, k - p, l + e, k - J.ng * p, l + e, k), a.bezierCurveTo(l + e, k + J.ng * p, l + J.ng * e, k + p, l, k + p), a.bezierCurveTo(l - J.ng * e, k + p, l - e, k + J.ng * p, l - e, k), a.bezierCurveTo(l - e, k - J.ng * p, l - J.ng * e, k - p, l, k - p), a.closePath(), null !== d && a.sf(d), null !== c && (h && f ? (ql(a), a.si(), pl(a)) : a.si());else if (e.type === O.m) for (e = e.figures, k = e.length, p = 0; p < k; p++) {\n          l = e.s[p];\n          a.beginPath();\n          a.moveTo(l.startX, l.startY);\n          m = l.segments.s;\n          n = m.length;\n\n          for (var r = null, q = 0; q < n; q++) {\n            var u = m[q];\n\n            switch (u.type) {\n              case Jd:\n                a.moveTo(u.endX, u.endY);\n                break;\n\n              case vd:\n                a.lineTo(u.endX, u.endY);\n                break;\n\n              case Kd:\n                a.bezierCurveTo(u.point1X, u.point1Y, u.point2X, u.point2Y, u.endX, u.endY);\n                break;\n\n              case Ld:\n                a.quadraticCurveTo(u.point1X, u.point1Y, u.endX, u.endY);\n                break;\n\n              case Md:\n                if (u.radiusX === u.radiusY) {\n                  var w = Math.PI / 180;\n                  a.arc(u.point1X, u.point1Y, u.radiusX, u.startAngle * w, (u.startAngle + u.sweepAngle) * w, 0 > u.sweepAngle, null !== r ? r.endX : l.startX, null !== r ? r.endY : l.startY);\n                } else if (r = Rd(u, l), w = r.length, 0 === w) a.lineTo(u.centerX, u.centerY);else for (var v = 0; v < w; v++) {\n                  var z = r[v];\n                  0 === v && a.lineTo(z[0], z[1]);\n                  a.bezierCurveTo(z[2], z[3], z[4], z[5], z[6], z[7]);\n                }\n\n                break;\n\n              case Qd:\n                v = w = 0;\n\n                if (null !== r && r.type === Md) {\n                  r = Rd(r, l);\n                  z = r.length;\n\n                  if (0 === z) {\n                    a.lineTo(u.endX, u.endY);\n                    break;\n                  }\n\n                  r = r[z - 1] || null;\n                  null !== r && (w = r[6], v = r[7]);\n                } else w = null !== r ? r.endX : l.startX, v = null !== r ? r.endY : l.startY;\n\n                r = Sd(u, l, w, v);\n                w = r.length;\n\n                if (0 === w) {\n                  a.lineTo(u.endX, u.endY);\n                  break;\n                }\n\n                for (v = 0; v < w; v++) {\n                  z = r[v], a.bezierCurveTo(z[2], z[3], z[4], z[5], z[6], z[7]);\n                }\n\n                break;\n\n              default:\n                C(\"Segment not of valid type: \" + u.type);\n            }\n\n            u.isClosed && a.closePath();\n            r = u;\n          }\n\n          m = l.isFilled;\n          f ? l.isShadowed ? (!0 === m && \"transparent\" !== d && null !== d && a.sf(d), null !== c && (m && h && ql(a), a.si(), m && h && pl(a))) : (ql(a), m && \"transparent\" !== d && null !== d && a.sf(d), null !== c && a.si(), pl(a)) : (m && null !== d && a.sf(d), null !== c && a.si());\n        }\n        g && a.Er();\n\n        if (null !== this.pathPattern) {\n          c = this.pathPattern;\n          c.measure(Infinity, Infinity);\n          d = c.measuredBounds;\n          c.arrange(0, 0, d.width, d.height);\n          f = this.geometry;\n          a.save();\n          a.beginPath();\n          d = Ea();\n          if (f.type === O.j) d.push(f.startX), d.push(f.startY), d.push(f.endX), d.push(f.endY), xn(a, b, d, c);else if (f.type === O.m) for (f = f.figures.iterator; f.next();) {\n            h = f.value;\n            d.length = 0;\n            d.push(h.startX);\n            d.push(h.startY);\n            g = h.startX;\n            e = h.startY;\n            k = g;\n            p = e;\n            l = h.segments.s;\n            m = l.length;\n\n            for (n = 0; n < m; n++) {\n              q = l[n];\n\n              switch (q.type) {\n                case Jd:\n                  xn(a, b, d, c);\n                  d.length = 0;\n                  d.push(q.endX);\n                  d.push(q.endY);\n                  g = q.endX;\n                  e = q.endY;\n                  k = g;\n                  p = e;\n                  break;\n\n                case vd:\n                  d.push(q.endX);\n                  d.push(q.endY);\n                  g = q.endX;\n                  e = q.endY;\n                  break;\n\n                case Kd:\n                  J.De(g, e, q.point1X, q.point1Y, q.point2X, q.point2Y, q.endX, q.endY, .5, d);\n                  g = q.endX;\n                  e = q.endY;\n                  break;\n\n                case Ld:\n                  J.Go(g, e, q.point1X, q.point1Y, q.endX, q.endY, .5, d);\n                  g = q.endX;\n                  e = q.endY;\n                  break;\n\n                case Md:\n                  u = Rd(q, h);\n                  r = u.length;\n\n                  if (0 === r) {\n                    d.push(q.centerX);\n                    d.push(q.centerY);\n                    g = q.centerX;\n                    e = q.centerY;\n                    break;\n                  }\n\n                  for (w = 0; w < r; w++) {\n                    v = u[w], J.De(g, e, v[2], v[3], v[4], v[5], v[6], v[7], .5, d), g = v[6], e = v[7];\n                  }\n\n                  break;\n\n                case Qd:\n                  u = Sd(q, h, g, e);\n                  r = u.length;\n\n                  if (0 === r) {\n                    d.push(q.endX);\n                    d.push(q.endY);\n                    g = q.endX;\n                    e = q.endY;\n                    break;\n                  }\n\n                  for (w = 0; w < r; w++) {\n                    v = u[w], J.De(g, e, v[2], v[3], v[4], v[5], v[6], v[7], .5, d), g = v[6], e = v[7];\n                  }\n\n                  break;\n\n                default:\n                  C(\"Segment not of valid type: \" + q.type);\n              }\n\n              q.isClosed && (d.push(k), d.push(p), xn(a, b, d, c));\n            }\n\n            xn(a, b, d, c);\n          } else if (f.type === O.u) d.push(f.startX), d.push(f.startY), d.push(f.endX), d.push(f.startY), d.push(f.endX), d.push(f.endY), d.push(f.startX), d.push(f.endY), d.push(f.startX), d.push(f.startY), xn(a, b, d, c);else if (f.type === O.F) {\n            e = new Xd();\n            e.startX = f.endX;\n            e.startY = (f.startY + f.endY) / 2;\n            g = new Yd(Md);\n            g.startAngle = 0;\n            g.sweepAngle = 360;\n            g.centerX = (f.startX + f.endX) / 2;\n            g.centerY = (f.startY + f.endY) / 2;\n            g.radiusX = Math.abs(f.startX - f.endX) / 2;\n            g.radiusY = Math.abs(f.startY - f.endY) / 2;\n            e.add(g);\n            f = Rd(g, e);\n            h = f.length;\n            if (0 === h) d.push(g.centerX), d.push(g.centerY);else for (g = e.startX, e = e.startY, k = 0; k < h; k++) {\n              p = f[k], J.De(g, e, p[2], p[3], p[4], p[5], p[6], p[7], .5, d), g = p[6], e = p[7];\n            }\n            xn(a, b, d, c);\n          }\n          Ga(d);\n          a.restore();\n          a.Oc(!1);\n        }\n      }\n    }\n  };\n\n  t.ia = function (a, b) {\n    void 0 === b && (b = new I());\n\n    if (a instanceof N) {\n      a.Fc() && C(\"getDocumentPoint Spot must be a real, specific Spot, not: \" + a.toString());\n      var c = this.naturalBounds,\n          d = this.strokeWidth;\n      b.h(a.x * (c.width + d) - d / 2 + c.x + a.offsetX, a.y * (c.height + d) - d / 2 + c.y + a.offsetY);\n    } else b.set(a);\n\n    this.ge.Fa(b);\n    return b;\n  };\n\n  t.gi = function (a) {\n    void 0 === a && (a = new M());\n    var b = this.naturalBounds,\n        c = this.ge;\n    b = M.allocAt(b.x, b.y, b.width, b.height);\n    var d = this.strokeWidth;\n    b.vc(d / 2, d / 2);\n    d = I.allocAt(b.x, b.y).transform(c);\n    a.h(d.x, d.y, 0, 0);\n    d.h(b.right, b.y).transform(c);\n    Zb(a, d.x, d.y, 0, 0);\n    d.h(b.right, b.bottom).transform(c);\n    Zb(a, d.x, d.y, 0, 0);\n    d.h(b.x, b.bottom).transform(c);\n    Zb(a, d.x, d.y, 0, 0);\n    M.free(b);\n    I.free(d);\n    return a;\n  };\n\n  t.Xg = function (a, b) {\n    var c = this.geometry;\n    if (null === c || null === this.fill && null === this.stroke) return !1;\n    var d = c.bounds,\n        e = this.strokeWidth / 2;\n    c.type !== O.j || b || (e += 2);\n    var f = M.alloc();\n    f.assign(d);\n    f.vc(e + 2, e + 2);\n    if (!f.ba(a)) return M.free(f), !1;\n    d = e + 1E-4;\n\n    if (c.type === O.j) {\n      if (null === this.stroke) return !1;\n      d = (c.endX - c.startX) * (a.x - c.startX) + (c.endY - c.startY) * (a.y - c.startY);\n      if (0 > (c.startX - c.endX) * (a.x - c.endX) + (c.startY - c.endY) * (a.y - c.endY) || 0 > d) return !1;\n      M.free(f);\n      return J.Tb(c.startX, c.startY, c.endX, c.endY, e, a.x, a.y);\n    }\n\n    if (c.type === O.u) {\n      b = c.startX;\n      var g = c.startY,\n          h = c.endX;\n      c = c.endY;\n      f.x = Math.min(b, h);\n      f.y = Math.min(g, c);\n      f.width = Math.abs(h - b);\n      f.height = Math.abs(c - g);\n\n      if (null === this.fill) {\n        f.vc(-d, -d);\n        if (f.ba(a)) return M.free(f), !1;\n        f.vc(d, d);\n      }\n\n      null !== this.stroke && f.vc(e, e);\n      a = f.ba(a);\n      M.free(f);\n      return a;\n    }\n\n    if (c.type === O.F) {\n      g = c.startX;\n      e = c.startY;\n      h = c.endX;\n      var k = c.endY;\n      c = Math.min(g, h);\n      b = Math.min(e, k);\n      g = Math.abs(h - g) / 2;\n      e = Math.abs(k - e) / 2;\n      c = a.x - (c + g);\n      b = a.y - (b + e);\n\n      if (null === this.fill) {\n        g -= d;\n        e -= d;\n        if (0 >= g || 0 >= e || 1 >= c * c / (g * g) + b * b / (e * e)) return M.free(f), !1;\n        g += d;\n        e += d;\n      }\n\n      null !== this.stroke && (g += d, e += d);\n      M.free(f);\n      return 0 >= g || 0 >= e ? !1 : 1 >= c * c / (g * g) + b * b / (e * e);\n    }\n\n    if (c.type === O.m) return M.free(f), null === this.fill ? Vd(c, a.x, a.y, e) : Td(c, a, e, 1 < this.strokeWidth, b);\n    C(\"Unknown Geometry type: \" + c.type);\n  };\n\n  t.El = function (a, b, c, d) {\n    var e = this.desiredSize,\n        f = this.ag;\n    a = Math.max(a, 0);\n    b = Math.max(b, 0);\n    if (null !== this.Hd) var g = this.geometry.bounds;else {\n      var h = this.figure,\n          k = yn[h];\n\n      if (void 0 === k) {\n        var l = J.Oe[h];\n        \"string\" === typeof l && (l = J.Oe[l]);\n        \"function\" === typeof l ? (k = l(null, 100, 100), yn[h] = k) : C(\"Unsupported Figure: \" + h);\n      }\n\n      g = k.bounds;\n    }\n    h = g.width;\n    k = g.height;\n    l = g.width;\n    var m = g.height;\n\n    switch (hl(this, !0)) {\n      case lg:\n        d = c = 0;\n        break;\n\n      case td:\n        l = Math.max(a - f, 0);\n        m = Math.max(b - f, 0);\n        break;\n\n      case Uk:\n        l = Math.max(a - f, 0);\n        d = 0;\n        break;\n\n      case Vk:\n        c = 0, m = Math.max(b - f, 0);\n    }\n\n    isFinite(e.width) && (l = e.width);\n    isFinite(e.height) && (m = e.height);\n    g = this.maxSize;\n    var n = this.minSize;\n    c = Math.max(c - f, n.width);\n    d = Math.max(d - f, n.height);\n    l = Math.min(g.width, l);\n    m = Math.min(g.height, m);\n    l = isFinite(l) ? Math.max(c, l) : Math.max(h, c);\n    m = isFinite(m) ? Math.max(d, m) : Math.max(k, d);\n    c = mg(this);\n\n    switch (c) {\n      case lg:\n        break;\n\n      case td:\n        h = l;\n        k = m;\n        break;\n\n      case ng:\n        c = Math.min(l / h, m / k);\n        isFinite(c) || (c = 1);\n        h *= c;\n        k *= c;\n        break;\n\n      default:\n        C(c + \" is not a valid geometryStretch.\");\n    }\n\n    null !== this.Hd ? (0 === h && (h = .001), 0 === k && (k = .001), c = null !== this.Hd ? this.Hd : this.sa, g = c.bounds, d = h / g.width, g = k / g.height, isFinite(d) || (d = 1), isFinite(g) || (g = 1), this.sa = 1 === d && 1 === g ? c : c.copy().scale(d, g)) : null !== this.sa && J.ca(this.sa.Hk, a - f) && J.ca(this.sa.Gk, b - f) || (this.sa = Cf.makeGeometry(this, h, k));\n    g = this.sa.bounds;\n    Infinity === a || Infinity === b ? this.ve(g.x - f / 2, g.y - f / 2, 0 === a && 0 === h ? 0 : g.width + f, 0 === b && 0 === k ? 0 : g.height + f) : this.ve(-(f / 2), -(f / 2), l + f, m + f);\n    e.v() ? this.bc.h(0, 0, e.width, e.height) : this.bc.assign(g);\n  };\n\n  function mg(a) {\n    var b = a.geometryStretch;\n    return null !== a.Hd ? b === Wk ? td : b : b === Wk ? yn[a.figure].defaultStretch : b;\n  }\n\n  t.Vg = function (a, b, c, d) {\n    jl(this, a, b, c, d);\n  };\n\n  t.Or = function (a, b, c) {\n    return this.Kj(a.x, a.y, b.x, b.y, c);\n  };\n\n  t.Kj = function (a, b, c, d, e) {\n    var f = this.transform,\n        g = 1 / (f.m11 * f.m22 - f.m12 * f.m21),\n        h = f.m22 * g,\n        k = -f.m12 * g,\n        l = -f.m21 * g,\n        m = f.m11 * g,\n        n = g * (f.m21 * f.dy - f.m22 * f.dx),\n        p = g * (f.m12 * f.dx - f.m11 * f.dy);\n    f = a * h + b * l + n;\n    g = a * k + b * m + p;\n    h = c * h + d * l + n;\n    k = c * k + d * m + p;\n    n = this.ag / 2;\n    l = this.sa;\n    null === l && (this.measure(Infinity, Infinity), l = this.sa);\n    var r = l.bounds;\n    m = !1;\n    if (l.type === O.j) {\n      if (1.5 >= this.strokeWidth) m = J.Je(l.startX, l.startY, l.endX, l.endY, f, g, h, k, e);else {\n        l.startX === l.endX ? (d = n, m = 0) : (b = (l.endY - l.startY) / (l.endX - l.startX), m = n / Math.sqrt(1 + b * b), d = m * b);\n        b = Ea();\n        a = new I();\n        J.Je(l.startX + d, l.startY + m, l.endX + d, l.endY + m, f, g, h, k, a) && b.push(a);\n        a = new I();\n        J.Je(l.startX - d, l.startY - m, l.endX - d, l.endY - m, f, g, h, k, a) && b.push(a);\n        a = new I();\n        J.Je(l.startX + d, l.startY + m, l.startX - d, l.startY - m, f, g, h, k, a) && b.push(a);\n        a = new I();\n        J.Je(l.endX + d, l.endY + m, l.endX - d, l.endY - m, f, g, h, k, a) && b.push(a);\n        h = b.length;\n        if (0 === h) return Ga(b), !1;\n        m = !0;\n        k = Infinity;\n\n        for (d = 0; d < h; d++) {\n          a = b[d], c = (a.x - f) * (a.x - f) + (a.y - g) * (a.y - g), c < k && (k = c, e.x = a.x, e.y = a.y);\n        }\n\n        Ga(b);\n      }\n    } else if (l.type === O.u) m = J.wf(r.x - n, r.y - n, r.x + r.width + n, r.y + r.height + n, f, g, h, k, e);else if (l.type === O.F) {\n      b = M.allocAt(r.x, r.y, r.width, r.height).vc(n, n);\n\n      a: if (0 === b.width) m = J.Je(b.x, b.y, b.x, b.y + b.height, f, g, h, k, e);else if (0 === b.height) m = J.Je(b.x, b.y, b.x + b.width, b.y, f, g, h, k, e);else {\n        a = b.width / 2;\n        l = b.height / 2;\n        d = b.x + a;\n        m = b.y + l;\n        c = 9999;\n        f !== h && (c = (g - k) / (f - h));\n\n        if (9999 > Math.abs(c)) {\n          k = g - m - c * (f - d);\n\n          if (0 > a * a * c * c + l * l - k * k) {\n            e.x = NaN;\n            e.y = NaN;\n            m = !1;\n            break a;\n          }\n\n          n = Math.sqrt(a * a * c * c + l * l - k * k);\n          h = (-(a * a * c * k) + a * l * n) / (l * l + a * a * c * c) + d;\n          a = (-(a * a * c * k) - a * l * n) / (l * l + a * a * c * c) + d;\n          l = c * (h - d) + k + m;\n          k = c * (a - d) + k + m;\n          Math.abs((f - h) * (f - h)) + Math.abs((g - l) * (g - l)) < Math.abs((f - a) * (f - a)) + Math.abs((g - k) * (g - k)) ? (e.x = h, e.y = l) : (e.x = a, e.y = k);\n        } else {\n          h = l * l;\n          k = f - d;\n          h -= h / (a * a) * k * k;\n\n          if (0 > h) {\n            e.x = NaN;\n            e.y = NaN;\n            m = !1;\n            break a;\n          }\n\n          k = Math.sqrt(h);\n          h = m + k;\n          k = m - k;\n          Math.abs(h - g) < Math.abs(k - g) ? (e.x = f, e.y = h) : (e.x = f, e.y = k);\n        }\n\n        m = !0;\n      }\n\n      M.free(b);\n    } else if (l.type === O.m) {\n      p = I.alloc();\n      var q = h - f;\n      var u = k - g,\n          w = q * q + u * u,\n          v = f,\n          z = g;\n      if (0 < w && r.contains(v, z) && (p.x = v, p.y = z, this.ba(p))) for (0 !== q && .5 > Math.abs(q) ? (u *= .5 / q, q = .5) : 0 !== u && .5 > Math.abs(u) && (q *= .5 / u, u = .5), v -= q, z -= u; r.contains(v, z);) {\n        v -= q, z -= u;\n      }\n      e.x = h;\n      e.y = k;\n\n      for (u = 0; u < l.figures.count; u++) {\n        var y = l.figures.s[u],\n            A = y.isFilled ? v : f,\n            B = y.isFilled ? z : g,\n            F = y.segments;\n        r = y.startX;\n        q = y.startY;\n\n        for (var L = r, S = q, R = 0; R < F.count; R++) {\n          var P = F.s[R],\n              H = P.type;\n          var da = P.endX;\n          var X = P.endY;\n          var oa = !1;\n\n          switch (H) {\n            case Jd:\n              L = da;\n              S = X;\n              break;\n\n            case vd:\n              oa = zn(r, q, da, X, A, B, h, k, p);\n              break;\n\n            case Kd:\n              oa = J.io(r, q, P.point1X, P.point1Y, P.point2X, P.point2Y, da, X, A, B, h, k, .6, p);\n              break;\n\n            case Ld:\n              oa = J.io(r, q, r + 2 / 3 * (P.point1X - r), q + 2 / 3 * (P.point1Y - q), da + 2 / 3 * (P.point1X - da), X + 2 / 3 * (P.point1Y - X), da, X, A, B, h, k, .6, p);\n              break;\n\n            case Md:\n            case Qd:\n              H = P.type === Md ? Rd(P, y) : Sd(P, y, r, q);\n              var Ba = H.length;\n\n              if (0 === Ba) {\n                oa = zn(r, q, P.type === Md ? P.centerX : P.endX, P.type === Md ? P.centerY : P.endY, A, B, h, k, p);\n                break;\n              }\n\n              X = null;\n\n              for (da = 0; da < Ba; da++) {\n                X = H[da];\n\n                if (0 === da && zn(r, q, X[0], X[1], A, B, h, k, p)) {\n                  var db = An(A, B, p, w, e);\n                  db < w && (w = db, m = !0);\n                }\n\n                J.io(X[0], X[1], X[2], X[3], X[4], X[5], X[6], X[7], A, B, h, k, .6, p) && (db = An(A, B, p, w, e), db < w && (w = db, m = !0));\n              }\n\n              da = X[6];\n              X = X[7];\n              break;\n\n            default:\n              C(\"Unknown Segment type: \" + H);\n          }\n\n          r = da;\n          q = X;\n          oa && (oa = An(A, B, p, w, e), oa < w && (w = oa, m = !0));\n          P.isClosed && (da = L, X = S, zn(r, q, da, X, A, B, h, k, p) && (P = An(A, B, p, w, e), P < w && (w = P, m = !0)));\n        }\n      }\n\n      f = c - a;\n      g = d - b;\n      h = Math.sqrt(f * f + g * g);\n      0 !== h && (f /= h, g /= h);\n      e.x -= f * n;\n      e.y -= g * n;\n      I.free(p);\n    } else C(\"Unknown Geometry type: \" + l.type);\n    if (!m) return !1;\n    this.transform.Fa(e);\n    return !0;\n  };\n\n  function An(a, b, c, d, e) {\n    a = c.x - a;\n    b = c.y - b;\n    b = a * a + b * b;\n    return b < d ? (e.x = c.x, e.y = c.y, b) : d;\n  }\n\n  function zn(a, b, c, d, e, f, g, h, k) {\n    var l = !1,\n        m = (e - g) * (b - d) - (f - h) * (a - c);\n    if (0 === m) return !1;\n    k.x = ((e * h - f * g) * (a - c) - (e - g) * (a * d - b * c)) / m;\n    k.y = ((e * h - f * g) * (b - d) - (f - h) * (a * d - b * c)) / m;\n    (a > c ? a - c : c - a) < (b > d ? b - d : d - b) ? (a = b < d ? b : d, b = b < d ? d : b, (k.y > a || J.ca(k.y, a)) && (k.y < b || J.ca(k.y, b)) && (l = !0)) : (b = a < c ? a : c, a = a < c ? c : a, (k.x > b || J.ca(k.x, b)) && (k.x < a || J.ca(k.x, a)) && (l = !0));\n    return l;\n  }\n\n  t.Wg = function (a, b) {\n    if (void 0 === b) return a.Ee(this.actualBounds);\n    var c = this.sa;\n    null === c && (this.measure(Infinity, Infinity), c = this.sa);\n    c = c.bounds;\n    var d = this.strokeWidth / 2,\n        e = !1,\n        f = I.alloc();\n    f.h(c.x - d, c.y - d);\n    a.ba(b.Fa(f)) && (f.h(c.x - d, c.bottom + d), a.ba(b.Fa(f)) && (f.h(c.right + d, c.bottom + d), a.ba(b.Fa(f)) && (f.h(c.right + d, c.y - d), a.ba(b.Fa(f)) && (e = !0))));\n    I.free(f);\n    return e;\n  };\n\n  t.Sc = function (a, b) {\n    if (this.Wg(a, b) || void 0 === b && (b = this.transform, a.Ee(this.actualBounds))) return !0;\n    var c = md.alloc();\n    c.set(b);\n    c.Tr();\n    var d = a.left,\n        e = a.right,\n        f = a.top;\n    a = a.bottom;\n    var g = I.alloc();\n    g.h(d, f);\n    c.Fa(g);\n    if (this.Xg(g, !0)) return I.free(g), !0;\n    g.h(e, f);\n    c.Fa(g);\n    if (this.Xg(g, !0)) return I.free(g), !0;\n    g.h(d, a);\n    c.Fa(g);\n    if (this.Xg(g, !0)) return I.free(g), !0;\n    g.h(e, a);\n    c.Fa(g);\n    if (this.Xg(g, !0)) return I.free(g), !0;\n    var h = I.alloc(),\n        k = I.alloc();\n    c.set(b);\n    c.Ou(this.transform);\n    c.Tr();\n    h.x = e;\n    h.y = f;\n    h.transform(c);\n    g.x = d;\n    g.y = f;\n    g.transform(c);\n    b = !1;\n    Bn(this, g, h, k) ? b = !0 : (g.x = e, g.y = a, g.transform(c), Bn(this, g, h, k) ? b = !0 : (h.x = d, h.y = a, h.transform(c), Bn(this, g, h, k) ? b = !0 : (g.x = d, g.y = f, g.transform(c), Bn(this, g, h, k) && (b = !0))));\n    I.free(g);\n    md.free(c);\n    I.free(h);\n    I.free(k);\n    return b;\n  };\n\n  function Bn(a, b, c, d) {\n    if (!a.Or(b, c, d)) return !1;\n    a = b.x;\n    b = b.y;\n    var e = c.x,\n        f = c.y;\n    c = d.x;\n    d = d.y;\n    if (a === e) return b < f ? (a = b, b = f) : a = f, d >= a && d <= b;\n    a < e ? (d = a, a = e) : d = e;\n    return c >= d && c <= a;\n  }\n\n  t.Vw = function (a, b, c) {\n    function d(a, b) {\n      for (var c = a.length, d = 0; d < c; d += 2) {\n        if (b.td(a[d], a[d + 1]) > e) return !0;\n      }\n\n      return !1;\n    }\n\n    if (c && null !== this.fill && this.Xg(a, !0)) return !0;\n    var e = a.rf(b),\n        f = e;\n    1.5 < this.strokeWidth && (e = this.strokeWidth / 2 + Math.sqrt(e), e *= e);\n    b = this.sa;\n    if (null === b && (this.measure(Infinity, Infinity), b = this.sa, null === b)) return !1;\n\n    if (!c) {\n      var g = b.bounds,\n          h = g.x,\n          k = g.y,\n          l = g.x + g.width;\n      g = g.y + g.height;\n      if (Ab(a.x, a.y, h, k) <= e && Ab(a.x, a.y, l, k) <= e && Ab(a.x, a.y, h, g) <= e && Ab(a.x, a.y, l, g) <= e) return !0;\n    }\n\n    h = b.startX;\n    k = b.startY;\n    l = b.endX;\n    g = b.endY;\n\n    if (b.type === O.j) {\n      if (c = (h - l) * (a.x - l) + (k - g) * (a.y - g), zb(a.x, a.y, h, k, l, g) <= (0 <= (l - h) * (a.x - h) + (g - k) * (a.y - k) && 0 <= c ? e : f)) return !0;\n    } else {\n      if (b.type === O.u) return b = !1, c && (b = zb(a.x, a.y, h, k, h, g) <= e || zb(a.x, a.y, h, k, l, k) <= e || zb(a.x, a.y, l, k, l, g) <= e || zb(a.x, a.y, h, g, l, g) <= e), b;\n\n      if (b.type === O.F) {\n        b = a.x - (h + l) / 2;\n        f = a.y - (k + g) / 2;\n        var m = Math.abs(l - h) / 2,\n            n = Math.abs(g - k) / 2;\n        if (0 === m || 0 === n) return zb(a.x, a.y, h, k, l, g) <= e ? !0 : !1;\n\n        if (c) {\n          if (a = J.Hy(m, n, b, f), a * a <= e) return !0;\n        } else return Ab(b, f, -m, 0) >= e || Ab(b, f, 0, -n) >= e || Ab(b, f, 0, n) >= e || Ab(b, f, m, 0) >= e ? !1 : !0;\n      } else if (b.type === O.m) {\n        l = b.bounds;\n        f = l.x;\n        h = l.y;\n        k = l.x + l.width;\n        l = l.y + l.height;\n        if (a.x > k && a.x < f && a.y > l && a.y < h && zb(a.x, a.y, f, h, f, l) > e && zb(a.x, a.y, f, h, k, h) > e && zb(a.x, a.y, k, l, f, l) > e && zb(a.x, a.y, k, l, k, h) > e) return !1;\n        f = Math.sqrt(e);\n\n        if (c) {\n          if (null === this.fill ? Vd(b, a.x, a.y, f) : Td(b, a, f, !0, !1)) return !0;\n        } else {\n          c = b.figures;\n\n          for (b = 0; b < c.count; b++) {\n            f = c.s[b];\n            g = f.startX;\n            m = f.startY;\n            if (a.td(g, m) > e) return !1;\n            h = f.segments.s;\n            k = h.length;\n\n            for (l = 0; l < k; l++) {\n              switch (n = h[l], n.type) {\n                case Jd:\n                case vd:\n                  g = n.endX;\n                  m = n.endY;\n                  if (a.td(g, m) > e) return !1;\n                  break;\n\n                case Kd:\n                  var p = Ea();\n                  J.De(g, m, n.point1X, n.point1Y, n.point2X, n.point2Y, n.endX, n.endY, .8, p);\n                  g = d(p, a);\n                  Ga(p);\n                  if (g) return !1;\n                  g = n.endX;\n                  m = n.endY;\n                  if (a.td(g, m) > e) return !1;\n                  break;\n\n                case Ld:\n                  p = Ea();\n                  J.Go(g, m, n.point1X, n.point1Y, n.endX, n.endY, .8, p);\n                  g = d(p, a);\n                  Ga(p);\n                  if (g) return !1;\n                  g = n.endX;\n                  m = n.endY;\n                  if (a.td(g, m) > e) return !1;\n                  break;\n\n                case Md:\n                case Qd:\n                  p = n.type === Md ? Rd(n, f) : Sd(n, f, g, m);\n                  var r = p.length;\n\n                  if (0 === r) {\n                    g = n.type === Md ? n.centerX : n.endX;\n                    m = n.type === Md ? n.centerY : n.endY;\n                    if (a.td(g, m) > e) return !1;\n                    break;\n                  }\n\n                  n = null;\n\n                  for (var q = Ea(), u = 0; u < r; u++) {\n                    if (n = p[u], q.length = 0, J.De(n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], .8, q), d(q, a)) return Ga(q), !1;\n                  }\n\n                  Ga(q);\n                  null !== n && (g = n[6], m = n[7]);\n                  break;\n\n                default:\n                  C(\"Unknown Segment type: \" + n.type);\n              }\n            }\n          }\n\n          return !0;\n        }\n      }\n    }\n\n    return !1;\n  };\n\n  t.mc = function () {\n    this.sa = null;\n  };\n\n  t.Sv = function () {\n    return this.ag;\n  };\n\n  function Cn(a) {\n    var b = a.diagram;\n    null !== b && b.undoManager.isUndoingRedoing || (a.segmentOrientation = Sm, \"None\" !== a.toArrow ? (a.segmentIndex = -1, a.alignmentFocus = ed) : \"None\" !== a.fromArrow && (a.segmentIndex = 0, a.alignmentFocus = new N(1 - ed.x, ed.y)));\n  }\n\n  Cf.makeGeometry = function (a, b, c) {\n    if (\"None\" !== a.toArrow) var d = Dn[a.toArrow];else \"None\" !== a.fromArrow ? d = Dn[a.fromArrow] : (d = J.Oe[a.figure], \"string\" === typeof d && (d = J.Oe[d]), void 0 === d && C(\"Unknown Shape.figure: \" + a.figure), d = d(a, b, c), d.Hk = b, d.Gk = c);\n\n    if (null === d) {\n      var e = J.Oe.Rectangle;\n      \"function\" === typeof e && (d = e(a, b, c));\n    }\n\n    return d;\n  };\n\n  function En(a) {\n    var b = Dn[a];\n\n    if (void 0 === b) {\n      var c = a.toLowerCase();\n      if (\"none\" === c) return \"None\";\n      b = Dn[c];\n\n      if (void 0 === b) {\n        var d = null,\n            e;\n\n        for (e in J.dm) {\n          if (e.toLowerCase() === c) {\n            d = e;\n            break;\n          }\n        }\n\n        if (null !== d) return a = O.parse(J.dm[d], !1), Dn[d] = a, c !== d && (Dn[c] = d), d;\n      }\n    }\n\n    return \"string\" === typeof b ? b : b instanceof O ? a : null;\n  }\n\n  ma.Object.defineProperties(Cf.prototype, {\n    geometry: {\n      get: function get() {\n        return null !== this.sa ? this.sa : this.Hd;\n      },\n      set: function set(a) {\n        var b = this.sa,\n            c = this.Hd;\n\n        if (b !== a) {\n          null !== a ? this.Hd = this.sa = a.freeze() : this.Hd = this.sa = null;\n          var d = this.part;\n          null !== d && (d.Sf = NaN);\n          this.w();\n          this.g(\"geometry\", b || c, a);\n          dl(this) && (a = this.part, null !== a && el(this, a, \"geometryString\"));\n        }\n      }\n    },\n    geometryString: {\n      get: function get() {\n        return null === this.geometry ? \"\" : this.geometry.toString();\n      },\n      set: function set(a) {\n        a = O.parse(a);\n        var b = a.normalize();\n        this.geometry = a;\n        this.position = a = I.allocAt(-b.x, -b.y);\n        I.free(a);\n      }\n    },\n    isGeometryPositioned: {\n      get: function get() {\n        return 0 !== (this.o & 1048576);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.o & 1048576);\n        b !== a && (this.o ^= 1048576, this.w(), this.g(\"isGeometryPositioned\", b, a));\n      }\n    },\n    fill: {\n      get: function get() {\n        return this.Ak;\n      },\n      set: function set(a) {\n        var b = this.Ak;\n        b !== a && (null !== a && Ol(a, \"Shape.fill\"), a instanceof ml && a.freeze(), this.Ak = a, this.N(), this.g(\"fill\", b, a));\n      }\n    },\n    stroke: {\n      get: function get() {\n        return this.Nc;\n      },\n      set: function set(a) {\n        var b = this.Nc;\n        b !== a && (null !== a && Ol(a, \"Shape.stroke\"), a instanceof ml && a.freeze(), this.Nc = a, this.N(), this.g(\"stroke\", b, a));\n      }\n    },\n    strokeWidth: {\n      get: function get() {\n        return this.ag;\n      },\n      set: function set(a) {\n        var b = this.ag;\n        if (b !== a) if (0 <= a) {\n          this.ag = a;\n          this.w();\n          var c = this.part;\n          null !== c && (c.Sf = NaN);\n          this.g(\"strokeWidth\", b, a);\n        } else wa(a, \"value >= 0\", Cf, \"strokeWidth:value\");\n      }\n    },\n    strokeCap: {\n      get: function get() {\n        return null !== this.Na ? this.Na.dr : \"butt\";\n      },\n      set: function set(a) {\n        var b = this.strokeCap;\n        b !== a && (\"string\" !== typeof a || \"butt\" !== a && \"round\" !== a && \"square\" !== a ? wa(a, '\"butt\", \"round\", or \"square\"', Cf, \"strokeCap\") : (vn(this), this.Na.dr = a, this.N(), this.g(\"strokeCap\", b, a)));\n      }\n    },\n    strokeJoin: {\n      get: function get() {\n        return null !== this.Na ? this.Na.er : \"miter\";\n      },\n      set: function set(a) {\n        var b = this.strokeJoin;\n        b !== a && (\"string\" !== typeof a || \"miter\" !== a && \"bevel\" !== a && \"round\" !== a ? wa(a, '\"miter\", \"bevel\", or \"round\"', Cf, \"strokeJoin\") : (vn(this), this.Na.er = a, this.N(), this.g(\"strokeJoin\", b, a)));\n      }\n    },\n    strokeMiterLimit: {\n      get: function get() {\n        return null !== this.Na ? this.Na.fr : 10;\n      },\n      set: function set(a) {\n        var b = this.strokeMiterLimit;\n\n        if (b !== a && 1 <= a) {\n          vn(this);\n          this.Na.fr = a;\n          this.N();\n          var c = this.part;\n          null !== c && (c.Sf = NaN);\n          this.g(\"strokeMiterLimit\", b, a);\n        }\n      }\n    },\n    strokeDashArray: {\n      get: function get() {\n        return this.Og;\n      },\n      set: function set(a) {\n        var b = this.Og;\n\n        if (b !== a) {\n          if (null !== a) {\n            for (var c = a.length, d = 0, e = 0; e < c; e++) {\n              var f = a[e];\n              0 <= f && isFinite(f) || C(\"strokeDashArray:value \" + f + \" at index \" + e + \" must be a positive number or zero.\");\n              d += f;\n            }\n\n            if (0 === d) {\n              if (null === b) return;\n              a = null;\n            }\n          }\n\n          this.Og = a;\n          this.N();\n          this.g(\"strokeDashArray\", b, a);\n        }\n      }\n    },\n    strokeDashOffset: {\n      get: function get() {\n        return null !== this.Na ? this.Na.pj : 0;\n      },\n      set: function set(a) {\n        var b = this.strokeDashOffset;\n        b !== a && 0 <= a && (vn(this), this.Na.pj = a, this.N(), this.g(\"strokeDashOffset\", b, a));\n      }\n    },\n    figure: {\n      get: function get() {\n        return this.Jm;\n      },\n      set: function set(a) {\n        var b = this.Jm;\n\n        if (b !== a) {\n          var c = J.Oe[a];\n          \"function\" === typeof c ? c = a : (c = J.Oe[a.toLowerCase()]) || C(\"Unknown Shape.figure: \" + a);\n          b !== c && (a = this.part, null !== a && (a.Sf = NaN), this.Jm = c, this.Hd = null, this.mc(), this.w(), this.g(\"figure\", b, c));\n        }\n      }\n    },\n    toArrow: {\n      get: function get() {\n        return null !== this.Ra ? this.Ra.W : \"None\";\n      },\n      set: function set(a) {\n        var b = this.toArrow;\n        !0 === a ? a = \"Standard\" : !1 === a && (a = \"\");\n\n        if (b !== a) {\n          var c = En(a);\n          null === c ? C(\"Unknown Shape.toArrow: \" + a) : b !== c && (null === this.Ra && (this.Ra = new Nl()), this.Ra.W = c, this.Hd = null, this.mc(), this.w(), Cn(this), this.g(\"toArrow\", b, c));\n        }\n      }\n    },\n    fromArrow: {\n      get: function get() {\n        return null !== this.Ra ? this.Ra.j : \"None\";\n      },\n      set: function set(a) {\n        var b = this.fromArrow;\n        !0 === a ? a = \"Standard\" : !1 === a && (a = \"\");\n\n        if (b !== a) {\n          var c = En(a);\n          null === c ? C(\"Unknown Shape.fromArrow: \" + a) : b !== c && (null === this.Ra && (this.Ra = new Nl()), this.Ra.j = c, this.Hd = null, this.mc(), this.w(), Cn(this), this.g(\"fromArrow\", b, c));\n        }\n      }\n    },\n    spot1: {\n      get: function get() {\n        return null !== this.Na ? this.Na.Yf : Wc;\n      },\n      set: function set(a) {\n        var b = this.spot1;\n        b.C(a) || (a = a.J(), vn(this), this.Na.Yf = a, this.w(), this.g(\"spot1\", b, a));\n      }\n    },\n    spot2: {\n      get: function get() {\n        return null !== this.Na ? this.Na.Zf : Wc;\n      },\n      set: function set(a) {\n        var b = this.spot2;\n        b.C(a) || (a = a.J(), vn(this), this.Na.Zf = a, this.w(), this.g(\"spot2\", b, a));\n      }\n    },\n    parameter1: {\n      get: function get() {\n        return this.Cn;\n      },\n      set: function set(a) {\n        var b = this.Cn;\n        b !== a && (this.Cn = a, this.mc(), this.w(), this.g(\"parameter1\", b, a));\n      }\n    },\n    parameter2: {\n      get: function get() {\n        return this.Dn;\n      },\n      set: function set(a) {\n        var b = this.Dn;\n        b !== a && (this.Dn = a, this.mc(), this.w(), this.g(\"parameter2\", b, a));\n      }\n    },\n    naturalBounds: {\n      get: function get() {\n        return this.bc;\n      }\n    },\n    pathPattern: {\n      get: function get() {\n        return null !== this.Na ? this.Na.Aq : null;\n      },\n      set: function set(a) {\n        var b = this.pathPattern;\n        b !== a && (vn(this), this.Na.Aq = a, this.N(), this.g(\"pathPattern\", b, a));\n      }\n    },\n    geometryStretch: {\n      get: function get() {\n        return null !== this.Na ? this.Na.Mp : Wk;\n      },\n      set: function set(a) {\n        var b = this.geometryStretch;\n        b !== a && (vn(this), this.Na.Mp = a, this.w(), this.g(\"geometryStretch\", b, a));\n      }\n    },\n    interval: {\n      get: function get() {\n        return null !== this.fa ? this.fa.Ik : 1;\n      },\n      set: function set(a) {\n        var b = this.interval;\n        a = Math.round(a);\n\n        if (b !== a && 0 !== a && isFinite(a)) {\n          null === this.fa && (this.fa = new Fn());\n          this.fa.Ik = a;\n          var c = this.diagram;\n          null !== c && this.panel === c.grid && jj(c);\n          this.w();\n          c = this.panel;\n          null !== c && (c.graduatedIntervals = null);\n          this.g(\"interval\", b, a);\n        }\n      }\n    },\n    graduatedStart: {\n      get: function get() {\n        return null !== this.fa ? this.fa.u : 0;\n      },\n      set: function set(a) {\n        var b = this.graduatedStart;\n        b !== a && (0 > a ? a = 0 : 1 < a && (a = 1), null === this.fa && (this.fa = new Fn()), this.fa.u = a, this.w(), this.g(\"graduatedStart\", b, a));\n      }\n    },\n    graduatedEnd: {\n      get: function get() {\n        return null !== this.fa ? this.fa.j : 1;\n      },\n      set: function set(a) {\n        var b = this.graduatedEnd;\n        b !== a && (0 > a ? a = 0 : 1 < a && (a = 1), null === this.fa && (this.fa = new Fn()), this.fa.j = a, this.w(), this.g(\"graduatedEnd\", b, a));\n      }\n    },\n    graduatedSkip: {\n      get: function get() {\n        return null !== this.fa ? this.fa.m : null;\n      },\n      set: function set(a) {\n        var b = this.graduatedSkip;\n        b !== a && (null === this.fa && (this.fa = new Fn()), this.fa.m = a, this.w(), this.g(\"graduatedSkip\", b, a));\n      }\n    }\n  });\n  Cf.prototype.intersectsRect = Cf.prototype.Sc;\n  Cf.prototype.containedInRect = Cf.prototype.Wg;\n  Cf.prototype.getNearestIntersectionPoint = Cf.prototype.Or;\n  Cf.prototype.getDocumentBounds = Cf.prototype.gi;\n  Cf.prototype.getDocumentPoint = Cf.prototype.ia;\n  var Dn = new Wa(),\n      yn = new Wa();\n  Cf.className = \"Shape\";\n\n  Cf.getFigureGenerators = function () {\n    var a = new pb(),\n        b;\n\n    for (b in J.Oe) {\n      b !== b.toLowerCase() && a.add(b, J.Oe[b]);\n    }\n\n    a.freeze();\n    return a;\n  };\n\n  Cf.defineFigureGenerator = function (a, b) {\n    var c = a.toLowerCase(),\n        d = J.Oe;\n    d[a] = b;\n    d[c] = a;\n  };\n\n  Cf.getArrowheadGeometries = function () {\n    var a = new pb();\n\n    for (d in J.dm) {\n      if (void 0 === Dn[d]) {\n        var b = O.parse(J.dm[d], !1);\n        Dn[d] = b;\n        b = d.toLowerCase();\n        b !== d && (Dn[b] = d);\n      }\n    }\n\n    for (var c in Dn) {\n      if (c !== c.toLowerCase()) {\n        var d = Dn[c];\n        d instanceof O && a.add(c, d);\n      }\n    }\n\n    a.freeze();\n    return a;\n  };\n\n  Cf.defineArrowheadGeometry = function (a, b) {\n    var c = null;\n    \"string\" === typeof b ? c = O.parse(b, !1) : c = b;\n    b = a.toLowerCase();\n    \"none\" !== b && a !== b || C(\"Shape.defineArrowheadGeometry name must not be empty or None or all-lower-case: \" + a);\n    var d = Dn;\n    d[a] = c;\n    d[b] = a;\n  };\n\n  function wn() {\n    this.ic = !1;\n    this.dr = \"butt\";\n    this.er = \"miter\";\n    this.fr = 10;\n    this.pj = 0;\n    this.Aq = null;\n    this.Mp = Wk;\n    this.Zf = this.Yf = Wc;\n  }\n\n  wn.prototype.copy = function () {\n    var a = new wn();\n    a.dr = this.dr;\n    a.er = this.er;\n    a.fr = this.fr;\n    a.pj = this.pj;\n    a.Aq = this.Aq;\n    a.Mp = this.Mp;\n    a.Yf = this.Yf.J();\n    a.Zf = this.Zf.J();\n    return a;\n  };\n\n  function Qg(a, b) {\n    Y.call(this);\n    Gn || (Hn = Og ? new Ak(null).context : null, Gn = !0);\n    this.o |= 2097152;\n    this.cc = \"\";\n    this.Nc = \"black\";\n    this.re = \"13px sans-serif\";\n    this.kq = this.yb = this.dd = 0;\n    this.da = this.fa = this.om = this.rt = this.st = null;\n    this.zh = 0;\n    this.Te = null;\n    this.Ae = 0;\n    this.qe = this.Wb = this.Jc = null;\n    \"string\" === typeof a ? this.text = a : a && Object.assign(this, a);\n    b && Object.assign(this, b);\n    return this;\n  }\n\n  la(Qg, Y);\n\n  Qg.prototype.cloneProtected = function (a) {\n    Y.prototype.cloneProtected.call(this, a);\n    a.cc = this.cc;\n    a.Nc = this.Nc;\n    a.re = this.re;\n    a.dd = this.dd;\n    a.yb = this.yb;\n    a.kq = this.kq;\n    a.st = this.st;\n    a.rt = this.rt;\n    a.om = this.om;\n    null !== this.fa && (a.fa = this.fa.copy());\n    null !== this.da && (a.da = this.da.ic ? this.da : this.da.copy());\n    a.zh = this.zh;\n    a.Te = this.Te;\n    a.Ae = this.Ae;\n    a.Jc = this.Jc;\n    a.Wb = this.Wb;\n    a.qe = this.qe;\n  };\n\n  function In(a) {\n    null === a.da ? a.da = new Jn() : a.da.ic && (a.da = a.da.copy());\n  }\n\n  t = Qg.prototype;\n\n  t.ih = function () {\n    Y.prototype.ih.call(this);\n    null !== this.da && (this.da.ic = !0);\n  };\n\n  function Rm(a, b) {\n    a.o = b.o | 6144;\n    a.tb = b.opacity;\n    a.Yb = b.background;\n    a.areaBackground = b.areaBackground;\n    a.$c = b.desiredSize.J();\n    a.minSize = b.minSize.J();\n    a.maxSize = b.maxSize.J();\n    null !== b.Ib ? a.Ib = b.Ib.copy() : a.Ib = null;\n    a.xa = b.scale;\n    a.Gb = b.angle;\n    a.stretch = b.stretch;\n    a.Ag = b.margin.J();\n    a.Fb = b.alignment.J();\n    a.fk = b.alignmentFocus.J();\n    a.segmentFraction = b.segmentFraction;\n    a.segmentOffset = b.segmentOffset.J();\n    a.segmentOrientation = b.segmentOrientation;\n    null !== b.ib && (a.ib = b.ib.copy());\n    a.shadowVisible = b.shadowVisible;\n    a.cc = b.cc;\n    a.Nc = b.Nc;\n    a.re = b.re;\n    null !== a.fa && (a.fa = b.fa.copy());\n    null !== b.da && (a.da = b.da.ic ? b.da : b.da.copy());\n    a.zh = b.zh;\n  }\n\n  t.ob = function (a) {\n    a.classType === Qg ? this.wrap = a : Y.prototype.ob.call(this, a);\n  };\n\n  t.toString = function () {\n    return 22 < this.cc.length ? 'TextBlock(\"' + this.cc.substring(0, 20) + '\"...)' : 'TextBlock(\"' + this.cc + '\")';\n  };\n\n  t.w = function () {\n    Y.prototype.w.call(this);\n    this.rt = this.st = null;\n  };\n\n  t.ai = function (a, b) {\n    if (null !== this.Nc && 0 !== this.cc.length && null !== this.re) {\n      var c = this.naturalBounds,\n          d = this.actualBounds,\n          e = c.width,\n          f = c.height,\n          g = Rn(this),\n          h = a.textAlign = this.textAlign,\n          k = b.$m;\n      \"start\" === h ? h = k ? \"right\" : \"left\" : \"end\" === h && (h = k ? \"left\" : \"right\");\n      k = this.isUnderline;\n      var l = this.isStrikethrough;\n      gi(this, a, this.Nc, !0, !1, c, d);\n      (k || l) && gi(this, a, this.Nc, !1, !1, c, d);\n      d = 0;\n      c = !1;\n      var m = this.ge,\n          n = m.dx - (g * m.m21 + m.dx);\n      m = m.dy - (g * m.m22 + m.dy);\n      var p = b.scale;\n      8 > (n * n + m * m) * p * p && (c = !0);\n      b.Zb !== a && (c = !1);\n      !1 === b.Ge(\"textGreeking\") && (c = !1);\n      b = this.spacingAbove;\n      n = this.spacingBelow;\n\n      switch (this.flip) {\n        case Zk:\n          a.translate(e, 0);\n          a.scale(-1, 1);\n          break;\n\n        case Yk:\n          a.translate(0, f);\n          a.scale(1, -1);\n          break;\n\n        case $k:\n          a.translate(e, f), a.scale(-1, -1);\n      }\n\n      a.Pc();\n      m = this.dd;\n      p = (b + g + n) * m;\n      f > p && (d = this.verticalAlignment, d = d.y * f - d.y * p + d.offsetY);\n      if (1 === m && null !== this.qe) n = this.yb, n > e && (n = e), this.$h(this.qe, a, 0, d + b, e, g, n, c, h, k, l);else if (null !== this.Jc && null !== this.Wb) for (p = 0; p < m; p++) {\n        var r = this.Jc[p];\n        r > e && (r = e);\n        d += b;\n        this.$h(this.Wb[p], a, 0, d, e, g, r, c, h, k, l);\n        d += g + n;\n      }\n\n      switch (this.flip) {\n        case Zk:\n          a.scale(-1, 1);\n          a.translate(-e, 0);\n          break;\n\n        case Yk:\n          a.scale(1, -1);\n          a.translate(0, -f);\n          break;\n\n        case $k:\n          a.scale(-1, -1), a.translate(-e, -f);\n      }\n    }\n  };\n\n  t.$h = function (a, b, c, d, e, f, g, h, k, l, m) {\n    var n = 0;\n    h ? (\"left\" === k ? n = 0 : \"right\" === k ? n = e - g : \"center\" === k && (n = (e - g) / 2), b.fillRect(c + n, d + .25 * f, g, 1)) : (\"left\" === k ? n = 0 : \"right\" === k ? n = e : \"center\" === k && (n = e / 2), e = null !== Sn ? Sn(this, f) : .75 * f, b.fillText(a, c + n, d + e), a = f / 20 | 0, 0 === a && (a = 1), \"right\" === k ? n -= g : \"center\" === k && (n -= g / 2), l && (k = null !== Tn ? Tn(this, f) : .8 * f, b.beginPath(), b.lineWidth = a, b.moveTo(c + n, d + k), b.lineTo(c + n + g, d + k), b.stroke()), m && (b.beginPath(), b.lineWidth = a, d = d + f - f / 2.2 | 0, 0 !== a % 2 && (d += .5), b.moveTo(c + n, d), b.lineTo(c + n + g, d), b.stroke()));\n  };\n\n  t.El = function (a, b, c, d) {\n    this.zh = a;\n    var e = this.re;\n    null !== Hn && Un !== e && (Un = Hn.font = e);\n    this.yb = this.Ae = 0;\n    this.qe = this.Wb = this.Jc = this.Te = null;\n    var f;\n\n    if (isNaN(this.desiredSize.width)) {\n      e = this.cc.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\");\n      if (0 === e.length) e = 0;else if (this.isMultiline) {\n        for (var g = f = 0, h = !1; !h;) {\n          var k = e.indexOf(\"\\n\", g);\n          -1 === k && (k = e.length, h = !0);\n          g = e.substr(g, k - g);\n          this.formatting === Vn && (g = g.trim());\n          f = Math.max(f, Wn(g));\n          g = k + 1;\n        }\n\n        e = f;\n      } else f = e.indexOf(\"\\n\", 0), 0 <= f && (e = e.substr(0, f)), e = Wn(e);\n      e = Math.min(e, a / this.scale);\n      e = Math.max(8, e);\n    } else e = this.desiredSize.width;\n\n    null !== this.panel && (e = Math.min(e, this.panel.maxSize.width));\n    f = Xn(this, e);\n    isNaN(this.desiredSize.height) ? f = Math.min(f, b / this.scale) : f = this.desiredSize.height;\n    h = f;\n\n    if (0 !== this.yb && null !== this.Jc && null !== this.Wb && this.overflow === Yn && (b = this.re, b = this.overflow === Yn ? Zn(b) : 0, k = this.spacingAbove + this.spacingBelow, k = Math.max(0, Rn(this) + k), h = Math.min(this.maxLines - 1, Math.max(Math.floor(h / k + .01) - 1, 0)), !(h + 1 >= this.Wb.length))) {\n      k = this.Wb[h];\n\n      for (b = Math.max(1, a - b); Wn(k) > b && 1 < k.length;) {\n        k = k.substr(0, k.length - 1);\n      }\n\n      k += $n;\n      b = Wn(k);\n      this.Wb[h] = k;\n      this.Wb = this.Wb.slice(0, h + 1);\n      this.Jc[h] = b;\n      this.Jc = this.Jc.slice(0, h + 1);\n      this.Ae = this.Wb.length;\n      this.yb = Math.max(this.yb, b);\n      this.dd = this.Ae;\n      1 === this.dd && (this.qe = this.Wb[0]);\n    }\n\n    if (this.wrap === ao || isNaN(this.desiredSize.width)) e = isNaN(a) ? this.yb : Math.min(a, this.yb), isNaN(this.desiredSize.width) && (e = Math.max(8, e));\n    e = Math.max(c, e);\n    f = Math.max(d, f);\n    Qb(this.bc, e, f);\n    this.ve(0, 0, e, f);\n  };\n\n  t.Vg = function (a, b, c, d) {\n    jl(this, a, b, c, d);\n  };\n\n  function bo(a, b, c) {\n    if (null === a.qe) a.qe = b, a.yb = c;else {\n      if (null === a.Wb || null === a.Jc) a.Wb = [], a.Jc = [], a.Wb.push(a.qe), a.Jc.push(a.yb);\n      a.Wb.push(b);\n      a.Jc.push(c);\n    }\n  }\n\n  function co(a, b, c, d) {\n    var e = a.formatting === Vn;\n    e && (b = b.trim());\n    var f = 0,\n        g = a.re,\n        h = a.spacingAbove + a.spacingBelow;\n    h = Math.max(0, Rn(a) + h);\n    var k = a.overflow === Yn ? Zn(g) : 0;\n    if (a.dd >= a.maxLines) null !== d && d.h(0, h);else if (g = b, a.wrap === eo) {\n      a.Ae = 1;\n      var l = Wn(b);\n      if (0 === k || l <= c) a.yb = Math.max(a.yb, l), bo(a, b, a.yb), null !== d && d.h(l, h);else {\n        f = fo(a, g);\n        g = g.substr(f.length);\n        b = fo(a, g);\n\n        for (l = Wn(f + b); 0 < b.length && l <= c;) {\n          f += b, g = g.substr(b.length), b = fo(a, g), l = f + b, e && (l = l.trim()), l = Wn(l);\n        }\n\n        e && (b = b.trim());\n        f += b;\n\n        for (c = Math.max(1, c - k); Wn(f) > c && 1 < f.length;) {\n          f = f.substr(0, f.length - 1);\n        }\n\n        f += $n;\n        var m = Wn(f);\n        a.yb = m;\n        bo(a, f, m);\n        null !== d && d.h(m, h);\n      }\n    } else {\n      k = 0;\n      0 === g.length && (k = 1, bo(a, g, 0));\n\n      for (; 0 < g.length;) {\n        b = fo(a, g);\n\n        for (g = g.substr(b.length); Wn(b) > c;) {\n          var n = 1;\n          l = Wn(b.substr(0, n));\n\n          for (m = 0; l <= c;) {\n            n++, m = l, l = Wn(b.substr(0, n));\n          }\n\n          if (1 === n) {\n            var p = l;\n            f = Math.max(f, l);\n          } else p = m, f = Math.max(f, m);\n\n          n--;\n          1 > n && (n = 1);\n          bo(a, b.substr(0, n), p);\n          k++;\n          b = b.substr(n);\n          if (a.dd + k > a.maxLines) break;\n        }\n\n        m = fo(a, g);\n\n        for (l = Wn(b + m); 0 < m.length && l <= c;) {\n          b += m, g = g.substr(m.length), m = fo(a, g), l = b + m, e && (l = l.trim()), l = Wn(l);\n        }\n\n        e && (b = b.trim());\n        if (\"\" !== b && (\"\\xAD\" === b[b.length - 1] && (b = b.substring(0, b.length - 1) + \"\\u2010\"), 0 === m.length ? (n = l, f = Math.max(f, l)) : (n = m = Wn(b), f = Math.max(f, m)), bo(a, b, n), k++, a.dd + k > a.maxLines)) break;\n      }\n\n      a.Ae = Math.min(a.maxLines, k);\n      a.yb = Math.max(a.yb, f);\n      null !== d && d.h(a.yb, h * a.Ae);\n    }\n  }\n\n  function fo(a, b) {\n    if (a.wrap === go) return b.substr(0, 1);\n\n    for (var c = b.length, d = 0, e = ho; d < c && !e.test(b.charAt(d));) {\n      d++;\n    }\n\n    for (a.formatting === io && (c = Math.min(c, d + 1)); d < c && e.test(b.charAt(d));) {\n      d++;\n    }\n\n    return d >= b.length ? b : b.substr(0, d);\n  }\n\n  function Wn(a) {\n    return null === Hn ? 8 * a.length : Hn.measureText(a).width;\n  }\n\n  function Rn(a) {\n    if (null !== a.Te) return a.Te;\n    var b = a.re;\n\n    if (null === Hn) {\n      var c = 16;\n      return a.Te = c;\n    }\n\n    void 0 !== jo[b] && 5E3 > ko ? c = jo[b] : (c = 1.3 * Hn.measureText(\"M\").width, jo[b] = c, ko++);\n    return a.Te = c;\n  }\n\n  function Zn(a) {\n    if (null === Hn) return 6;\n    if (void 0 !== lo[a] && 5E3 > mo) var b = lo[a];else b = Hn.measureText($n).width, lo[a] = b, mo++;\n    return b;\n  }\n\n  function Xn(a, b) {\n    var c = a.cc.replace(/\\r\\n/g, \"\\n\").replace(/\\r/g, \"\\n\"),\n        d = a.spacingAbove + a.spacingBelow;\n    d = Math.max(0, Rn(a) + d);\n    if (0 === c.length) return a.yb = 0, a.dd = 1, d;\n\n    if (!a.isMultiline) {\n      var e = c.indexOf(\"\\n\", 0);\n      0 <= e && (c = c.substr(0, e));\n    }\n\n    e = 0;\n\n    for (var f = a.dd = 0, g, h = !1; !h;) {\n      g = c.indexOf(\"\\n\", f);\n      -1 === g && (g = c.length, h = !0);\n\n      if (f <= g) {\n        f = c.substr(f, g - f);\n\n        if (a.wrap !== eo) {\n          a.Ae = 0;\n          var k = K.alloc();\n          co(a, f, b, k);\n          e += k.height;\n          K.free(k);\n          a.dd += a.Ae;\n        } else co(a, f, b, null), e += d, a.dd++;\n\n        a.dd === a.maxLines && (h = !0);\n      }\n\n      f = g + 1;\n    }\n\n    return a.kq = e;\n  }\n\n  ma.Object.defineProperties(Qg.prototype, {\n    font: {\n      get: function get() {\n        return this.re;\n      },\n      set: function set(a) {\n        var b = this.re;\n        b !== a && (this.re = a, this.Te = null, this.w(), this.g(\"font\", b, a));\n      }\n    },\n    text: {\n      get: function get() {\n        return this.cc;\n      },\n      set: function set(a) {\n        var b = this.cc;\n        null !== a && void 0 !== a ? a = a.toString() : a = \"\";\n        b !== a && (this.cc = a, this.w(), this.g(\"text\", b, a));\n      }\n    },\n    textAlign: {\n      get: function get() {\n        return null !== this.da ? this.da.mr : \"start\";\n      },\n      set: function set(a) {\n        var b = this.textAlign;\n        b === a || \"start\" !== a && \"end\" !== a && \"left\" !== a && \"right\" !== a && \"center\" !== a || (In(this), this.da.mr = a, this.N(), this.g(\"textAlign\", b, a));\n      }\n    },\n    flip: {\n      get: function get() {\n        return null !== this.da ? this.da.Nf : lg;\n      },\n      set: function set(a) {\n        var b = this.flip;\n        b !== a && (In(this), this.da.Nf = a, this.N(), this.g(\"flip\", b, a));\n      }\n    },\n    verticalAlignment: {\n      get: function get() {\n        return null !== this.da ? this.da.xr : Zc;\n      },\n      set: function set(a) {\n        var b = this.verticalAlignment;\n        b.C(a) || (a = a.J(), In(this), this.da.xr = a, zl(this), this.g(\"verticalAlignment\", b, a));\n      }\n    },\n    naturalBounds: {\n      get: function get() {\n        if (!this.bc.v()) {\n          var a = K.alloc();\n          co(this, this.cc, 999999, a);\n          var b = a.width;\n          K.free(a);\n          a = Xn(this, b);\n          var c = this.desiredSize;\n          isNaN(c.width) || (b = c.width);\n          isNaN(c.height) || (a = c.height);\n          Qb(this.bc, b, a);\n        }\n\n        return this.bc;\n      }\n    },\n    isMultiline: {\n      get: function get() {\n        return 0 !== (this.o & 2097152);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.o & 2097152);\n        b !== a && (this.o ^= 2097152, this.w(), this.g(\"isMultiline\", b, a));\n      }\n    },\n    isUnderline: {\n      get: function get() {\n        return 0 !== (this.o & 4194304);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.o & 4194304);\n        b !== a && (this.o ^= 4194304, this.N(), this.g(\"isUnderline\", b, a));\n      }\n    },\n    isStrikethrough: {\n      get: function get() {\n        return 0 !== (this.o & 8388608);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.o & 8388608);\n        b !== a && (this.o ^= 8388608, this.N(), this.g(\"isStrikethrough\", b, a));\n      }\n    },\n    wrap: {\n      get: function get() {\n        return null !== this.da ? this.da.Ar : no;\n      },\n      set: function set(a) {\n        var b = this.wrap;\n        b !== a && (In(this), this.da.Ar = a, this.w(), this.g(\"wrap\", b, a));\n      }\n    },\n    overflow: {\n      get: function get() {\n        return null !== this.da ? this.da.yq : oo;\n      },\n      set: function set(a) {\n        var b = this.overflow;\n        b !== a && (In(this), this.da.yq = a, this.w(), this.g(\"overflow\", b, a));\n      }\n    },\n    stroke: {\n      get: function get() {\n        return this.Nc;\n      },\n      set: function set(a) {\n        var b = this.Nc;\n        b !== a && (null !== a && Ol(a, \"TextBlock.stroke\"), a instanceof ml && a.freeze(), this.Nc = a, this.N(), this.g(\"stroke\", b, a));\n      }\n    },\n    lineCount: {\n      get: function get() {\n        return this.dd;\n      }\n    },\n    lineHeight: {\n      get: function get() {\n        return Rn(this);\n      }\n    },\n    editable: {\n      get: function get() {\n        return 0 !== (this.o & 1048576);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.o & 1048576);\n        b !== a && (this.o ^= 1048576, this.g(\"editable\", b, a));\n      }\n    },\n    textEditor: {\n      get: function get() {\n        return null !== this.da ? this.da.pr : null;\n      },\n      set: function set(a) {\n        var b = this.textEditor;\n        b !== a && (In(this), this.da.pr = a, this.g(\"textEditor\", b, a));\n      }\n    },\n    errorFunction: {\n      get: function get() {\n        return null !== this.da ? this.da.zd : null;\n      },\n      set: function set(a) {\n        var b = this.errorFunction;\n        b !== a && (In(this), this.da.zd = a, this.g(\"errorFunction\", b, a));\n      }\n    },\n    interval: {\n      get: function get() {\n        return null !== this.fa ? this.fa.Ik : 1;\n      },\n      set: function set(a) {\n        var b = this.interval;\n        a = Math.round(a);\n\n        if (b !== a && 0 !== a && isFinite(a)) {\n          null === this.fa && (this.fa = new Fn());\n          this.fa.Ik = a;\n          this.w();\n          var c = this.panel;\n          null !== c && (c.graduatedIntervals = null);\n          this.g(\"interval\", b, a);\n        }\n      }\n    },\n    graduatedStart: {\n      get: function get() {\n        return null !== this.fa ? this.fa.u : 0;\n      },\n      set: function set(a) {\n        var b = this.graduatedStart;\n        b !== a && (0 > a ? a = 0 : 1 < a && (a = 1), null === this.fa && (this.fa = new Fn()), this.fa.u = a, this.w(), this.g(\"graduatedStart\", b, a));\n      }\n    },\n    graduatedEnd: {\n      get: function get() {\n        return null !== this.fa ? this.fa.j : 1;\n      },\n      set: function set(a) {\n        var b = this.graduatedEnd;\n        b !== a && (0 > a ? a = 0 : 1 < a && (a = 1), null === this.fa && (this.fa = new Fn()), this.fa.j = a, this.w(), this.g(\"graduatedEnd\", b, a));\n      }\n    },\n    graduatedFunction: {\n      get: function get() {\n        return null !== this.fa ? this.fa.F : null;\n      },\n      set: function set(a) {\n        var b = this.graduatedFunction;\n        b !== a && (null === this.fa && (this.fa = new Fn()), this.fa.F = a, this.w(), this.g(\"graduatedFunction\", b, a));\n      }\n    },\n    graduatedSkip: {\n      get: function get() {\n        return null !== this.fa ? this.fa.m : null;\n      },\n      set: function set(a) {\n        var b = this.graduatedSkip;\n        b !== a && (null === this.fa && (this.fa = new Fn()), this.fa.m = a, this.w(), this.g(\"graduatedSkip\", b, a));\n      }\n    },\n    textValidation: {\n      get: function get() {\n        return null !== this.da ? this.da.qj : null;\n      },\n      set: function set(a) {\n        var b = this.textValidation;\n        b !== a && (In(this), this.da.qj = a, this.g(\"textValidation\", b, a));\n      }\n    },\n    textEdited: {\n      get: function get() {\n        return null !== this.da ? this.da.nr : null;\n      },\n      set: function set(a) {\n        var b = this.textEdited;\n        b !== a && (In(this), this.da.nr = a, this.g(\"textEdited\", b, a));\n      }\n    },\n    spacingAbove: {\n      get: function get() {\n        return null !== this.da ? this.da.$q : 0;\n      },\n      set: function set(a) {\n        var b = this.spacingAbove;\n        b !== a && (In(this), this.da.$q = a, this.w(), this.g(\"spacingAbove\", b, a));\n      }\n    },\n    spacingBelow: {\n      get: function get() {\n        return null !== this.da ? this.da.ar : 0;\n      },\n      set: function set(a) {\n        var b = this.spacingBelow;\n        b !== a && (In(this), this.da.ar = a, this.w(), this.g(\"spacingBelow\", b, a));\n      }\n    },\n    formatting: {\n      get: function get() {\n        return null !== this.da ? this.da.Jp : Vn;\n      },\n      set: function set(a) {\n        var b = this.formatting;\n        b !== a && (In(this), this.da.Jp = a, this.w(), this.g(\"formatting\", b, a));\n      }\n    },\n    maxLines: {\n      get: function get() {\n        return null !== this.da ? this.da.iq : Infinity;\n      },\n      set: function set(a) {\n        var b = this.maxLines;\n        b !== a && (a = Math.floor(a), 0 >= a && wa(a, \"> 0\", Qg, \"maxLines\"), In(this), this.da.iq = a, this.w(), this.g(\"maxLines\", b, a));\n      }\n    },\n    metrics: {\n      get: function get() {\n        return {\n          arrSize: null !== this.Jc ? this.Jc : [this.yb],\n          arrText: null !== this.Wb ? this.Wb : [this.qe],\n          maxLineWidth: this.yb,\n          fontHeight: this.Te\n        };\n      }\n    },\n    choices: {\n      get: function get() {\n        return this.om;\n      },\n      set: function set(a) {\n        var b = this.om;\n        b !== a && (this.om = a, this.g(\"choices\", b, a));\n      }\n    }\n  });\n  var Sn = null,\n      Tn = null,\n      eo = new D(Qg, \"None\", 0),\n      ao = new D(Qg, \"WrapFit\", 1),\n      no = new D(Qg, \"WrapDesiredSize\", 2),\n      go = new D(Qg, \"WrapBreakAll\", 3),\n      oo = new D(Qg, \"OverflowClip\", 0),\n      Yn = new D(Qg, \"OverflowEllipsis\", 1),\n      Vn = new D(Qg, \"FormatTrim\", 0),\n      io = new D(Qg, \"FormatNone\", 0),\n      ho = /[ \\u200b\\u00ad]/,\n      jo = new Wa(),\n      ko = 0,\n      lo = new Wa(),\n      mo = 0,\n      $n = \"...\",\n      Un = \"\",\n      Hn = null,\n      Gn = !1;\n  Qg.className = \"TextBlock\";\n\n  function Jn() {\n    this.ic = !1;\n    this.zd = null;\n    this.Nf = lg;\n    this.Jp = Vn;\n    this.iq = Infinity;\n    this.yq = oo;\n    this.ar = this.$q = 0;\n    this.mr = \"start\";\n    this.qj = this.pr = this.nr = null;\n    this.xr = Zc;\n    this.Ar = no;\n  }\n\n  Jn.prototype.copy = function () {\n    var a = new Jn();\n    a.zd = this.zd;\n    a.Nf = this.Nf;\n    a.Jp = this.Jp;\n    a.iq = this.iq;\n    a.yq = this.yq;\n    a.$q = this.$q;\n    a.ar = this.ar;\n    a.mr = this.mr;\n    a.nr = this.nr;\n    a.pr = this.pr;\n    a.qj = this.qj;\n    a.xr = this.xr;\n    a.Ar = this.Ar;\n    return a;\n  };\n\n  Qg.getEllipsis = function () {\n    return $n;\n  };\n\n  Qg.setEllipsis = function (a) {\n    $n = a;\n    lo = new Wa();\n    mo = 0;\n  };\n\n  Qg.getBaseline = function () {\n    return Sn;\n  };\n\n  Qg.setBaseline = function (a) {\n    Sn = a;\n  };\n\n  Qg.getUnderline = function () {\n    return Tn;\n  };\n\n  Qg.setUnderline = function (a) {\n    Tn = a;\n  };\n\n  Qg.isValidFont = function (a) {\n    Gn || (Hn = Og ? new Ak(null).context : null, Gn = !0);\n    if (null === Hn) return !0;\n    var b = Hn.font;\n    if (a === b || \"10px sans-serif\" === a) return !0;\n    Hn.font = \"10px sans-serif\";\n    Hn.font = a;\n    var c = Hn.font;\n    if (\"10px sans-serif\" !== c) return Hn.font = b, !0;\n    Hn.font = \"19px serif\";\n    var d = Hn.font;\n    Hn.font = a;\n    c = Hn.font;\n    Hn.font = b;\n    return c !== d;\n  };\n\n  Qg.FormatNone = io;\n  Qg.FormatTrim = Vn;\n  Qg.None = eo;\n  Qg.OverflowClip = oo;\n  Qg.OverflowEllipsis = Yn;\n  Qg.WrapBreakAll = go;\n  Qg.WrapDesiredSize = no;\n  Qg.WrapFit = ao;\n\n  function Fn() {\n    this.Ik = 1;\n    this.u = 0;\n    this.j = 1;\n    this.m = this.F = null;\n  }\n\n  Fn.prototype.copy = function () {\n    var a = new Fn();\n    a.Ik = this.Ik;\n    a.u = this.u;\n    a.j = this.j;\n    a.F = this.F;\n    a.m = this.m;\n    return a;\n  };\n\n  Fn.className = \"GradElementSettings\";\n\n  function Wj(a, b) {\n    Y.call(this);\n    this.vg = null;\n    this.Tn = \"\";\n    this.Ng = dc;\n    this.Ck = td;\n    this.Pg = this.zd = null;\n    this.Bk = yc;\n    this.Nf = lg;\n    this.kl = null;\n    this.Xm = !1;\n    this.Mm = !0;\n    this.Qk = !1;\n    this.gl = null;\n    \"string\" === typeof a ? this.source = a : a && Object.assign(this, a);\n    b && Object.assign(this, b);\n  }\n\n  var po;\n  la(Wj, Y);\n\n  Wj.prototype.cloneProtected = function (a) {\n    Y.prototype.cloneProtected.call(this, a);\n    a.Tn = this.Tn;\n    a.element = this.vg;\n    a.Ng = this.Ng.J();\n    a.Ck = this.Ck;\n    a.Nf = this.Nf;\n    a.zd = this.zd;\n    a.Pg = this.Pg;\n    a.Bk = this.Bk.J();\n    a.Mm = this.Mm;\n    a.gl = this.gl;\n  };\n\n  Wj.prototype.ob = function (a) {\n    a === lg || a === ng || a === Xk ? this.imageStretch = a : Y.prototype.ob.call(this, a);\n  };\n\n  Wj.prototype.toString = function () {\n    return \"Picture(\" + this.source + \")#\" + cb(this);\n  };\n\n  function Bi(a) {\n    void 0 === a && (a = \"\");\n    \"\" !== a ? po[a] && (delete po[a], qo--) : (po = new Wa(), qo = 0);\n  }\n\n  function ro(a, b) {\n    b.Wx || (b.fq = function (c) {\n      b.Up = !0;\n      b.Sm = !1;\n      var d = b.sg.copy();\n\n      if (null !== d && void 0 !== d) {\n        for (d = d.iterator; d.next();) {\n          var e = d.value;\n          var f = b.getAttribute(\"src\") || \"\";\n          var g = e.Fg.I(f);\n          if (null !== g) for (var h = g.length, k = 0; k < h; k++) {\n            f = g[k], e.Fn.add(f), e.Mb(), b.Pm && (void 0 === b.Kt && (b.Kt = c), null !== f.Pg && f.Pg(f, c));\n          }\n        }\n\n        b.sg.clear();\n      }\n\n      a.desiredSize.v() || (ij(a, !1), a.w());\n    }, b.Bp = function (a) {\n      b.Sm = a;\n      var c = b.sg.copy();\n\n      if (null !== c && void 0 !== c) {\n        for (c = c.iterator; c.next();) {\n          var e = c.value,\n              f = b.getAttribute(\"src\") || \"\";\n          var g = e.Fg.I(f);\n\n          if (null !== g) {\n            e = g.length;\n            f = Ea();\n\n            for (var h = 0; h < e; h++) {\n              f.push(g[h]);\n            }\n\n            if (b.Pm) for (h = 0; h < e; h++) {\n              g = f[h], null !== g.zd && g.zd(g, a);\n            }\n            Ga(f);\n          }\n        }\n\n        b.sg.clear();\n      }\n    }, b.addEventListener(\"load\", b.fq), b.addEventListener(\"error\", b.Bp), b.Wx = !0);\n  }\n\n  Wj.prototype.Oz = function () {\n    if (\"\" !== this.source) {\n      Bi(this.source);\n      var a = this.source;\n      this.source = \"\";\n      this.source = a;\n    }\n  };\n\n  Wj.prototype.redraw = function () {\n    this.N();\n  };\n\n  Wj.prototype.ai = function (a, b) {\n    var c = this.vg;\n\n    if (null !== c) {\n      var d = c.getAttribute(\"src\");\n\n      if (!(c instanceof HTMLImageElement && (null === d || \"\" === d) || c.Sm instanceof Event && a instanceof ul)) {\n        d = this.naturalBounds;\n        var e = 0,\n            f = 0,\n            g = this.Xm,\n            h = g ? +c.width : c.naturalWidth;\n        g = g ? +c.height : c.naturalHeight;\n        void 0 === h && c.videoWidth && (h = c.videoWidth);\n        void 0 === g && c.videoHeight && (g = c.videoHeight);\n        h = h || d.width;\n        g = g || d.height;\n\n        if (0 !== h && 0 !== g) {\n          var k = h,\n              l = g;\n          this.sourceRect.v() && (e = this.Ng.x, f = this.Ng.y, h = this.Ng.width, g = this.Ng.height);\n          var m = h,\n              n = g,\n              p = this.Ck,\n              r = this.Bk;\n\n          switch (p) {\n            case lg:\n              if (this.sourceRect.v()) break;\n              m >= d.width && (e = e + r.offsetX + (m * r.x - d.width * r.x));\n              n >= d.height && (f = f + r.offsetY + (n * r.y - d.height * r.y));\n              h = Math.min(d.width, m);\n              g = Math.min(d.height, n);\n              break;\n\n            case td:\n              m = d.width;\n              n = d.height;\n              break;\n\n            case ng:\n            case Xk:\n              p === ng ? (p = Math.min(d.height / n, d.width / m), m *= p, n *= p) : p === Xk && (p = Math.max(d.height / n, d.width / m), m *= p, n *= p, m >= d.width && (e = (e + r.offsetX + (m * r.x - d.width * r.x) / m) * h), n >= d.height && (f = (f + r.offsetY + (n * r.y - d.height * r.y) / n) * g), h *= 1 / (m / d.width), g *= 1 / (n / d.height), m = d.width, n = d.height);\n          }\n\n          p = this.uf() * b.scale;\n          var q = m * p * n * p,\n              u = h * g / q,\n              w = c.__goCache;\n          p = null;\n          var v = so;\n          if (c.Up && void 0 !== w && 4 < q && u > v * v) for (null === w.Zh && (to(w, 4, k, l, c), to(w, 16, k, l, c)), k = w.Zh, l = k.length, q = 0; q < l; q++) {\n            if (k[q].ratio * k[q].ratio < u) p = k[q];else break;\n          }\n\n          if (!b.Fm) {\n            if (null === this.kl) if (null === this.vg) this.kl = !1;else {\n              k = new Ak(null).context;\n\n              try {\n                k.drawImage(this.vg, 0, 0);\n              } catch (z) {\n                this.Mm = !1;\n              }\n\n              try {\n                k.getImageData(0, 0, 1, 1).data[3] && (this.kl = !1), this.kl = !1;\n              } catch (z) {\n                this.kl = !0;\n              }\n            }\n            if (this.kl) return;\n          }\n\n          k = 0;\n          m < d.width && (k = r.offsetX + (d.width * r.x - m * r.x));\n          l = 0;\n          n < d.height && (l = r.offsetY + (d.height * r.y - n * r.y));\n\n          switch (this.flip) {\n            case Zk:\n              a.translate(Math.min(d.width, m), 0);\n              a.scale(-1, 1);\n              break;\n\n            case Yk:\n              a.translate(0, Math.min(d.height, n));\n              a.scale(1, -1);\n              break;\n\n            case $k:\n              a.translate(Math.min(d.width, m), Math.min(d.height, n)), a.scale(-1, -1);\n          }\n\n          a.Pc();\n\n          if (b.Ge(\"pictureRatioOptimization\") && !b.Vi && void 0 !== w && null !== p && 1 !== p.ratio) {\n            a.save();\n            b = p.ratio;\n\n            try {\n              a.drawImage(p.source, e / b, f / b, Math.min(p.source.width, h / b), Math.min(p.source.height, g / b), k, l, Math.min(d.width, m), Math.min(d.height, n));\n            } catch (z) {\n              this.Mm = !1;\n            }\n\n            a.restore();\n          } else try {\n            a.drawImage(c, e, f, h, g, k, l, Math.min(d.width, m), Math.min(d.height, n));\n          } catch (z) {\n            this.Mm = !1;\n          }\n\n          switch (this.flip) {\n            case Zk:\n              a.scale(-1, 1);\n              a.translate(-Math.min(d.width, m), 0);\n              break;\n\n            case Yk:\n              a.scale(1, -1);\n              a.translate(0, -Math.min(d.height, n));\n              break;\n\n            case $k:\n              a.scale(-1, -1), a.translate(-Math.min(d.width, m), -Math.min(d.height, n));\n          }\n        }\n      }\n    }\n  };\n\n  Wj.prototype.El = function (a, b, c, d) {\n    var e = this.desiredSize,\n        f = hl(this, !0),\n        g = this.vg,\n        h = this.Xm;\n    if (h || !this.Qk && g && g.complete) this.Qk = !0;\n    null === g && (isFinite(e.width) || (a = 0), isFinite(e.height) || (b = 0));\n    isFinite(e.width) || f === td || f === Uk ? (isFinite(a) || (this.sourceRect.v() ? a = this.sourceRect.width : null !== g && (a = h ? +g.width : g.naturalWidth)), c = 0) : null !== g && !1 !== this.Qk && (a = this.sourceRect.v() ? this.sourceRect.width : h ? +g.width : g.naturalWidth);\n    isFinite(e.height) || f === td || f === Vk ? (isFinite(b) || (this.sourceRect.v() ? b = this.sourceRect.height : null !== g && (b = h ? +g.height : g.naturalHeight)), d = 0) : null !== g && !1 !== this.Qk && (b = this.sourceRect.v() ? this.sourceRect.height : h ? +g.height : g.naturalHeight);\n    isFinite(e.width) && (a = e.width);\n    isFinite(e.height) && (b = e.height);\n    e = this.maxSize;\n    f = this.minSize;\n    c = Math.max(c || 0, f.width);\n    d = Math.max(d || 0, f.height);\n    a = Math.min(e.width, a);\n    b = Math.min(e.height, b);\n    a = Math.max(c, a);\n    b = Math.max(d, b);\n    null === g || g.complete || (isFinite(a) || (a = 0), isFinite(b) || (b = 0));\n    Qb(this.bc, a, b);\n    this.ve(0, 0, a, b);\n  };\n\n  Wj.prototype.Vg = function (a, b, c, d) {\n    jl(this, a, b, c, d);\n  };\n\n  ma.Object.defineProperties(Wj.prototype, {\n    element: {\n      get: function get() {\n        return this.vg;\n      },\n      set: function set(a) {\n        var b = this.vg;\n\n        if (b !== a) {\n          this.Xm = a instanceof HTMLCanvasElement;\n          var c = a instanceof HTMLImageElement;\n          null === a || c || a instanceof HTMLVideoElement || this.Xm || C(\"Picture.element must be an instance of Image, Canvas, or Video, not: \" + a);\n          var d = this.diagram;\n          null !== d && Xj(d, this);\n          this.vg = a;\n          null !== a && c && void 0 === a.sg && (a.sg = new G());\n          null !== d && c && Vj(d, this);\n          null !== a && (this.Xm || !0 === a.complete ? (a.Pm && (a.Sm instanceof Event && null !== this.zd ? this.zd(this, a.Sm) : !0 === a.Up && !a.Sm && null !== this.Pg && a.Kt && this.Pg(this, a.Kt)), a.Up = !0, this.desiredSize.v() || (ij(this, !1), this.w())) : c && ro(this, a));\n          this.g(\"element\", b, a);\n          this.N();\n        }\n      }\n    },\n    source: {\n      get: function get() {\n        return this.Tn;\n      },\n      set: function set(a) {\n        var b = this.Tn;\n\n        if (b !== a) {\n          this.Tn = a;\n          var c = po;\n\n          if (Og) {\n            if (void 0 !== c[a]) var d = c[a];else if (\"\" !== a) {\n              30 < qo && (Bi(), c = po);\n              d = ua(\"img\");\n              d.Pm = !0;\n              ro(this, d);\n              var e = this.gl;\n              null !== e && (d.crossOrigin = e(this));\n              d.src = a;\n              c[a] = d;\n              qo++;\n            }\n            this.element = d;\n            null !== d && void 0 === d.__goCache && (d.__goCache = new uo());\n            this.w();\n            this.N();\n          }\n\n          this.g(\"source\", b, a);\n        }\n      }\n    },\n    sourceCrossOrigin: {\n      get: function get() {\n        return this.gl;\n      },\n      set: function set(a) {\n        if (this.gl !== a && (this.gl = a, null !== this.element)) {\n          var b = this.element.getAttribute(\"src\");\n          null === a && \"string\" === typeof b ? this.element.crossOrigin = null : null !== a && (this.element.crossOrigin = a(this));\n          this.element.src = b;\n        }\n      }\n    },\n    sourceRect: {\n      get: function get() {\n        return this.Ng;\n      },\n      set: function set(a) {\n        var b = this.Ng;\n        b.C(a) || (this.Ng = a = a.J(), this.N(), this.g(\"sourceRect\", b, a));\n      }\n    },\n    imageStretch: {\n      get: function get() {\n        return this.Ck;\n      },\n      set: function set(a) {\n        var b = this.Ck;\n        b !== a && (this.Ck = a, this.N(), this.g(\"imageStretch\", b, a));\n      }\n    },\n    flip: {\n      get: function get() {\n        return this.Nf;\n      },\n      set: function set(a) {\n        var b = this.Nf;\n        b !== a && (this.Nf = a, this.N(), this.g(\"flip\", b, a));\n      }\n    },\n    imageAlignment: {\n      get: function get() {\n        return this.Bk;\n      },\n      set: function set(a) {\n        var b = this.Bk;\n        b.C(a) || (this.Bk = a = a.J(), this.N(), this.g(\"imageAlignment\", b, a));\n      }\n    },\n    errorFunction: {\n      get: function get() {\n        return this.zd;\n      },\n      set: function set(a) {\n        var b = this.zd;\n        b !== a && (this.zd = a, this.g(\"errorFunction\", b, a));\n      }\n    },\n    successFunction: {\n      get: function get() {\n        return this.Pg;\n      },\n      set: function set(a) {\n        var b = this.Pg;\n        b !== a && (this.Pg = a, this.g(\"successFunction\", b, a));\n      }\n    },\n    naturalBounds: {\n      get: function get() {\n        return this.bc;\n      }\n    }\n  });\n  Wj.prototype.redraw = Wj.prototype.redraw;\n  Wj.prototype.reloadSource = Wj.prototype.Oz;\n  var qo = 0,\n      so = 4;\n  Wj.className = \"Picture\";\n  po = new Wa();\n  Wj.clearCache = Bi;\n\n  function uo() {\n    this.Zh = null;\n  }\n\n  function to(a, b, c, d, e) {\n    null === a.Zh && (a.Zh = []);\n    var f = new Ak(null),\n        g = f.context,\n        h = 1 / b;\n    f.width = c / b;\n    f.height = d / b;\n    0 !== f.width && 0 !== f.height && (b = new vo(f.Sa, b), c = 1, 0 < a.Zh.length && (c = a.Zh[a.Zh.length - 1], e = c.source, c = c.ratio), g.setTransform(h * c, 0, 0, h * c, 0, 0), g.Pc(), g.drawImage(e, 0, 0), a.Zh.push(b));\n  }\n\n  uo.className = \"PictureCacheArray\";\n\n  function vo(a, b) {\n    this.source = a;\n    this.ratio = b;\n  }\n\n  vo.className = \"PictureCacheInstance\";\n\n  function wo() {\n    this.Lr = new O();\n    this.pc = null;\n  }\n\n  wo.prototype.reset = function (a) {\n    null !== a ? (a.ja(), this.Lr = a, a.figures.clear()) : this.Lr = new O();\n    this.pc = null;\n  };\n\n  function xd(a, b, c, d, e) {\n    a.pc = new Xd();\n    a.pc.startX = b;\n    a.pc.startY = c;\n    a.pc.isFilled = d;\n    a.Lr.figures.add(a.pc);\n    void 0 !== e && (a.pc.isShadowed = e);\n  }\n\n  function Gd(a) {\n    var b = a.pc.segments.length;\n    0 < b && a.pc.segments.K(b - 1).close();\n  }\n\n  wo.prototype.Xl = function (a) {\n    this.pc.isShadowed = a;\n  };\n\n  wo.prototype.moveTo = function (a, b, c) {\n    void 0 === c && (c = !1);\n    var d = new Yd(Jd);\n    d.endX = a;\n    d.endY = b;\n    c && d.close();\n    this.pc.segments.add(d);\n  };\n\n  wo.prototype.lineTo = function (a, b, c) {\n    void 0 === c && (c = !1);\n    var d = new Yd(vd);\n    d.endX = a;\n    d.endY = b;\n    c && d.close();\n    this.pc.segments.add(d);\n  };\n\n  function yd(a, b, c, d, e, f, g) {\n    var h;\n    void 0 === h && (h = !1);\n    var k = new Yd(Kd);\n    k.point1X = b;\n    k.point1Y = c;\n    k.point2X = d;\n    k.point2Y = e;\n    k.endX = f;\n    k.endY = g;\n    h && k.close();\n    a.pc.segments.add(k);\n  }\n\n  function zd(a, b, c, d, e) {\n    var f;\n    void 0 === f && (f = !1);\n    var g = new Yd(Ld);\n    g.point1X = b;\n    g.point1Y = c;\n    g.endX = d;\n    g.endY = e;\n    f && g.close();\n    a.pc.segments.add(g);\n  }\n\n  wo.prototype.arcTo = function (a, b, c, d, e, f, g) {\n    void 0 === f && (f = 0);\n    void 0 === g && (g = !1);\n    var h = new Yd(Md);\n    h.startAngle = a;\n    h.sweepAngle = b;\n    h.centerX = c;\n    h.centerY = d;\n    h.radiusX = e;\n    h.radiusY = 0 !== f ? f : e;\n    g && h.close();\n    this.pc.segments.add(h);\n  };\n\n  function Ad(a, b, c, d, e, f, g, h) {\n    var k;\n    void 0 === k && (k = !1);\n    b = new Yd(Qd, g, h, b, c, d, e, f);\n    k && b.close();\n    a.pc.segments.add(b);\n  }\n\n  function wd(a) {\n    var b = Hd;\n    if (null !== b) return Hd = null, b.reset(a), b;\n    b = new wo();\n    b.reset(a);\n    return b;\n  }\n\n  var Hd = null;\n  wo.className = \"StreamGeometryContext\";\n\n  function xo(a, b) {\n    var c = a.toLowerCase(),\n        d = J.Oe;\n    d[a] = b;\n    d[c] = a;\n  }\n\n  xo(\"Rectangle\", function (a, b, c) {\n    a = \"r\" + b + \",\" + c;\n    var d = J.Df[a];\n    if (void 0 !== d) return d;\n    d = new O(O.u);\n    d.endX = b;\n    d.endY = c;\n    J.Ef < J.em && (J.Df[a] = d, J.Ef++);\n    return d;\n  });\n  xo(\"Square\", function (a, b, c) {\n    a = \"s\" + b + \",\" + c;\n    var d = J.Df[a];\n    if (void 0 !== d) return d;\n    d = new O(O.u);\n    d.endX = b;\n    d.endY = c;\n    d.defaultStretch = ng;\n    J.Ef < J.em && (J.Df[a] = d, J.Ef++);\n    return d;\n  });\n  xo(\"RoundedRectangle\", function (a, b, c) {\n    a = a ? a.parameter1 : NaN;\n    if (isNaN(a) || 0 > a) a = 5;\n    a = Math.min(a, b / 3);\n    a = Math.min(a, c / 3);\n    var d = \"rr\" + b + \",\" + c + \",\" + a,\n        e = J.Df[d];\n    if (void 0 !== e) return e;\n    var f = a * J.ng;\n    e = new O().add(new Xd(a, 0, !0).add(new Yd(vd, b - a, 0)).add(new Yd(Kd, b, a, b - f, 0, b, f)).add(new Yd(vd, b, c - a)).add(new Yd(Kd, b - a, c, b, c - f, b - f, c)).add(new Yd(vd, a, c)).add(new Yd(Kd, 0, c - a, f, c, 0, c - f)).add(new Yd(vd, 0, a)).add(new Yd(Kd, a, 0, 0, f, f, 0).close()));\n    1 < f && (e.spot1 = new N(0, 0, f, f), e.spot2 = new N(1, 1, -f, -f));\n    J.Ef < J.em && (J.Df[d] = e, J.Ef++);\n    return e;\n  });\n  xo(\"Border\", \"RoundedRectangle\");\n  xo(\"Ellipse\", function (a, b, c) {\n    a = \"e\" + b + \",\" + c;\n    var d = J.Df[a];\n    if (void 0 !== d) return d;\n    d = new O(O.F);\n    d.endX = b;\n    d.endY = c;\n    d.spot1 = gd;\n    d.spot2 = hd;\n    J.Ef < J.em && (J.Df[a] = d, J.Ef++);\n    return d;\n  });\n  xo(\"Circle\", function (a, b, c) {\n    a = \"c\" + b + \",\" + c;\n    var d = J.Df[a];\n    if (void 0 !== d) return d;\n    d = new O(O.F);\n    d.endX = b;\n    d.endY = c;\n    d.spot1 = gd;\n    d.spot2 = hd;\n    d.defaultStretch = ng;\n    J.Ef < J.em && (J.Df[a] = d, J.Ef++);\n    return d;\n  });\n  xo(\"TriangleRight\", function (a, b, c) {\n    return new O().add(new Xd(0, 0).add(new Yd(vd, b, .5 * c)).add(new Yd(vd, 0, c).close())).Yl(0, .25, .5, .75);\n  });\n  xo(\"TriangleDown\", function (a, b, c) {\n    return new O().add(new Xd(0, 0).add(new Yd(vd, b, 0)).add(new Yd(vd, .5 * b, c).close())).Yl(.25, 0, .75, .5);\n  });\n  xo(\"TriangleLeft\", function (a, b, c) {\n    return new O().add(new Xd(b, c).add(new Yd(vd, 0, .5 * c)).add(new Yd(vd, b, 0).close())).Yl(.5, .25, 1, .75);\n  });\n  xo(\"TriangleUp\", function (a, b, c) {\n    return new O().add(new Xd(b, c).add(new Yd(vd, 0, c)).add(new Yd(vd, .5 * b, 0).close())).Yl(.25, .5, .75, 1);\n  });\n  xo(\"Triangle\", \"TriangleUp\");\n  xo(\"Diamond\", function (a, b, c) {\n    return new O().add(new Xd(.5 * b, 0).add(new Yd(vd, 0, .5 * c)).add(new Yd(vd, .5 * b, c)).add(new Yd(vd, b, .5 * c).close())).Yl(.25, .25, .75, .75);\n  });\n  xo(\"LineH\", function (a, b, c) {\n    a = new O(O.j);\n    a.startX = 0;\n    a.startY = c / 2;\n    a.endX = b;\n    a.endY = c / 2;\n    return a;\n  });\n  xo(\"LineV\", function (a, b, c) {\n    a = new O(O.j);\n    a.startX = b / 2;\n    a.startY = 0;\n    a.endX = b / 2;\n    a.endY = c;\n    return a;\n  });\n  xo(\"None\", \"Rectangle\");\n  xo(\"BarH\", \"Rectangle\");\n  xo(\"BarV\", \"Rectangle\");\n  xo(\"MinusLine\", \"LineH\");\n  xo(\"PlusLine\", function (a, b, c) {\n    return new O().add(new Xd(0, c / 2, !1).add(new Yd(vd, b, c / 2)).add(new Yd(Jd, b / 2, 0)).add(new Yd(vd, b / 2, c)));\n  });\n  xo(\"XLine\", function (a, b, c) {\n    return new O().add(new Xd(0, c, !1).add(new Yd(vd, b, 0)).add(new Yd(Jd, 0, 0)).add(new Yd(vd, b, c)));\n  });\n  xo(\"LineRight\", function (a, b, c) {\n    return new O().add(new Xd(.25 * b, 0, !1).add(new Yd(vd, .75 * b, .5 * c)).add(new Yd(vd, .25 * b, c)));\n  });\n  xo(\"LineDown\", function (a, b, c) {\n    return new O().add(new Xd(0, .25 * c, !1).add(new Yd(vd, .5 * b, .75 * c)).add(new Yd(vd, b, .25 * c)));\n  });\n  xo(\"LineLeft\", function (a, b, c) {\n    return new O().add(new Xd(.75 * b, 0, !1).add(new Yd(vd, .25 * b, .5 * c)).add(new Yd(vd, .75 * b, c)));\n  });\n  xo(\"LineUp\", function (a, b, c) {\n    return new O().add(new Xd(0, .75 * c, !1).add(new Yd(vd, .5 * b, .25 * c)).add(new Yd(vd, b, .75 * c)));\n  });\n  J.dm = {\n    \"\": \"\",\n    Standard: \"F1 m 0,0 l 8,4 -8,4 2,-4 z\",\n    Backward: \"F1 m 8,0 l -2,4 2,4 -8,-4 z\",\n    Triangle: \"F1 m 0,0 l 8,4.62 -8,4.62 z\",\n    BackwardTriangle: \"F1 m 8,4 l 0,4 -8,-4 8,-4 0,4 z\",\n    Boomerang: \"F1 m 0,0 l 8,4 -8,4 4,-4 -4,-4 z\",\n    BackwardBoomerang: \"F1 m 8,0 l -8,4 8,4 -4,-4 4,-4 z\",\n    SidewaysV: \"m 0,0 l 8,4 -8,4 0,-1 6,-3 -6,-3 0,-1 z\",\n    BackwardV: \"m 8,0 l -8,4 8,4 0,-1 -6,-3 6,-3 0,-1 z\",\n    OpenTriangle: \"m 0,0 l 8,4 -8,4\",\n    BackwardOpenTriangle: \"m 8,0 l -8,4 8,4\",\n    OpenTriangleLine: \"m 0,0 l 8,4 -8,4 m 8.5,0 l 0,-8\",\n    BackwardOpenTriangleLine: \"m 8,0 l  -8,4 8,4 m -8.5,0 l 0,-8\",\n    OpenTriangleTop: \"m 0,0 l 8,4 m 0,4\",\n    BackwardOpenTriangleTop: \"m 8,0 l -8,4 m 0,4\",\n    OpenTriangleBottom: \"m 0,8 l 8,-4\",\n    BackwardOpenTriangleBottom: \"m 0,4 l 8,4\",\n    HalfTriangleTop: \"F1 m 0,0 l 0,4 8,0 z m 0,8\",\n    BackwardHalfTriangleTop: \"F1 m 8,0 l 0,4 -8,0 z m 0,8\",\n    HalfTriangleBottom: \"F1 m 0,4 l 0,4 8,-4 z\",\n    BackwardHalfTriangleBottom: \"F1 m 8,4 l 0,4 -8,-4 z\",\n    ForwardSemiCircle: \"m 4,0 b 270 180 0 4 4\",\n    BackwardSemiCircle: \"m 4,8 b 90 180 0 -4 4\",\n    Feather: \"m 0,0 l 3,4 -3,4\",\n    BackwardFeather: \"m 3,0 l -3,4 3,4\",\n    DoubleFeathers: \"m 0,0 l 3,4 -3,4 m 3,-8 l 3,4 -3,4\",\n    BackwardDoubleFeathers: \"m 3,0 l -3,4 3,4 m 3,-8 l -3,4 3,4\",\n    TripleFeathers: \"m 0,0 l 3,4 -3,4 m 3,-8 l 3,4 -3,4 m 3,-8 l 3,4 -3,4\",\n    BackwardTripleFeathers: \"m 3,0 l -3,4 3,4 m 3,-8 l -3,4 3,4 m 3,-8 l -3,4 3,4\",\n    ForwardSlash: \"m 0,8 l 5,-8\",\n    BackSlash: \"m 0,0 l 5,8\",\n    DoubleForwardSlash: \"m 0,8 l 4,-8 m -2,8 l 4,-8\",\n    DoubleBackSlash: \"m 0,0 l 4,8 m -2,-8 l 4,8\",\n    TripleForwardSlash: \"m 0,8 l 4,-8 m -2,8 l 4,-8 m -2,8 l 4,-8\",\n    TripleBackSlash: \"m 0,0 l 4,8 m -2,-8 l 4,8 m -2,-8 l 4,8\",\n    Fork: \"m 0,4 l 8,0 m -8,0 l 8,-4 m -8,4 l 8,4\",\n    BackwardFork: \"m 8,4 l -8,0 m 8,0 l -8,-4 m 8,4 l -8,4\",\n    LineFork: \"m 0,0 l 0,8 m 0,-4 l 8,0 m -8,0 l 8,-4 m -8,4 l 8,4\",\n    BackwardLineFork: \"m 8,4 l -8,0 m 8,0 l -8,-4 m 8,4 l -8,4 m 8,-8 l 0,8\",\n    CircleFork: \"F1 m 6,4 b 0 360 -3 0 3 z m 0,0 l 6,0 m -6,0 l 6,-4 m -6,4 l 6,4\",\n    BackwardCircleFork: \"F1 m 0,4 l 6,0 m -6,-4 l 6,4 m -6,4 l 6,-4 m 6,0 b 0 360 -3 0 3\",\n    CircleLineFork: \"F1 m 6,4 b 0 360 -3 0 3 z m 1,-4 l 0,8 m 0,-4 l 6,0 m -6,0 l 6,-4 m -6,4 l 6,4\",\n    BackwardCircleLineFork: \"F1 m 0,4 l 6,0 m -6,-4 l 6,4 m -6,4 l 6,-4 m 0,-4 l 0,8 m 7,-4 b 0 360 -3 0 3\",\n    Circle: \"F1 m 8,4 b 0 360 -4 0 4 z\",\n    Block: \"F1 m 0,0 l 0,8 8,0 0,-8 z\",\n    StretchedDiamond: \"F1 m 0,3 l 5,-3 5,3 -5,3 -5,-3 z\",\n    Diamond: \"F1 m 0,4 l 4,-4 4,4 -4,4 -4,-4 z\",\n    Chevron: \"F1 m 0,0 l 5,0 3,4 -3,4 -5,0 3,-4 -3,-4 z\",\n    StretchedChevron: \"F1 m 0,0 l 8,0 3,4 -3,4 -8,0 3,-4 -3,-4 z\",\n    NormalArrow: \"F1 m 0,2 l 4,0 0,-2 4,4 -4,4 0,-2 -4,0 z\",\n    X: \"m 0,0 l 8,8 m 0,-8 l -8,8\",\n    TailedNormalArrow: \"F1 m 0,0 l 2,0 1,2 3,0 0,-2 2,4 -2,4 0,-2 -3,0 -1,2 -2,0 1,-4 -1,-4 z\",\n    DoubleTriangle: \"F1 m 0,0 l 4,4 -4,4 0,-8 z  m 4,0 l 4,4 -4,4 0,-8 z\",\n    BigEndArrow: \"F1 m 0,0 l 5,2 0,-2 3,4 -3,4 0,-2 -5,2 0,-8 z\",\n    ConcaveTailArrow: \"F1 m 0,2 h 4 v -2 l 4,4 -4,4 v -2 h -4 l 2,-2 -2,-2 z\",\n    RoundedTriangle: \"F1 m 0,1 a 1,1 0 0 1 1,-1 l 7,3 a 0.5,1 0 0 1 0,2 l -7,3 a 1,1 0 0 1 -1,-1 l 0,-6 z\",\n    SimpleArrow: \"F1 m 1,2 l -1,-2 2,0 1,2 -1,2 -2,0 1,-2 5,0 0,-2 2,2 -2,2 0,-2 z\",\n    AccelerationArrow: \"F1 m 0,0 l 0,8 0.2,0 0,-8 -0.2,0 z m 2,0 l 0,8 1,0 0,-8 -1,0 z m 3,0 l 2,0 2,4 -2,4 -2,0 0,-8 z\",\n    BoxArrow: \"F1 m 0,0 l 4,0 0,2 2,0 0,-2 2,4 -2,4 0,-2 -2,0 0,2 -4,0 0,-8 z\",\n    TriangleLine: \"F1 m 8,4 l -8,-4 0,8 8,-4 z m 0.5,4 l 0,-8\",\n    CircleEndedArrow: \"F1 m 10,4 l -2,-3 0,2 -2,0 0,2 2,0 0,2 2,-3 z m -4,0 b 0 360 -3 0 3 z\",\n    DynamicWidthArrow: \"F1 m 0,3 l 2,0 2,-1 2,-2 2,4 -2,4 -2,-2 -2,-1 -2,0 0,-2 z\",\n    EquilibriumArrow: \"m 0,3 l 8,0 -3,-3 m 3,5 l -8,0 3,3\",\n    FastForward: \"F1 m 0,0 l 3.5,4 0,-4 3.5,4 0,-4 1,0 0,8 -1,0 0,-4 -3.5,4 0,-4 -3.5,4 0,-8 z\",\n    Kite: \"F1 m 0,4 l 2,-4 6,4 -6,4 -2,-4 z\",\n    HalfArrowTop: \"F1 m 0,0 l 4,4 4,0 -8,-4 z m 0,8\",\n    HalfArrowBottom: \"F1 m 0,8 l 4,-4 4,0 -8,4 z\",\n    OpposingDirectionDoubleArrow: \"F1 m 0,4 l 2,-4 0,2 4,0 0,-2 2,4 -2,4 0,-2 -4,0 0,2 -2,-4 z\",\n    PartialDoubleTriangle: \"F1 m 0,0 4,3 0,-3 4,4 -4,4 0,-3 -4,3 0,-8 z\",\n    LineCircle: \"F1 m 0,0 l 0,8 m 7 -4 b 0 360 -3 0 3 z\",\n    DoubleLineCircle: \"F1 m 0,0 l 0,8 m 2,-8 l 0,8 m 7 -4 b 0 360 -3 0 3 z\",\n    TripleLineCircle: \"F1 m 0,0 l 0,8 m 2,-8 l 0,8 m 2,-8 l 0,8 m 7 -4 b 0 360 -3 0 3 z\",\n    CircleLine: \"F1 m 6 4 b 0 360 -3 0 3 z m 1,-4 l 0,8\",\n    DiamondCircle: \"F1 m 8,4 l -4,4 -4,-4 4,-4 4,4 m 8,0 b 0 360 -4 0 4 z\",\n    PlusCircle: \"F1 m 8,4 b 0 360 -4 0 4 l -8 0 z m -4 -4 l 0 8\",\n    OpenRightTriangleTop: \"m 8,0 l 0,4 -8,0 m 0,4\",\n    OpenRightTriangleBottom: \"m 8,8 l 0,-4 -8,0\",\n    Line: \"m 0,0 l 0,8\",\n    DoubleLine: \"m 0,0 l 0,8 m 2,0 l 0,-8\",\n    TripleLine: \"m 0,0 l 0,8 m 2,0 l 0,-8 m 2,0 l 0,8\",\n    PentagonArrow: \"F1 m 8,4 l -4,-4 -4,0 0,8 4,0 4,-4 z\"\n  };\n\n  function yo() {\n    this.ic = !1;\n    this.Qq = this.np = this.Zp = null;\n    this.Sq = \"\";\n    this.Eq = this.Qp = this.Rq = null;\n    this.Gq = \"\";\n    this.Fq = Mb;\n    this.Hq = null;\n    this.Iq = \"\";\n    this.Kq = Wc;\n    this.gq = \"\";\n    this.hq = tc;\n    this.oq = rb;\n    this.jq = sb;\n    this.yp = null;\n    this.bq = 127;\n    this.Wq = tb;\n    this.Vq = \"gray\";\n    this.Lg = 4;\n  }\n\n  yo.prototype.copy = function () {\n    var a = new yo();\n    a.Zp = this.Zp;\n    a.np = this.np;\n    a.Qq = this.Qq;\n    a.Sq = this.Sq;\n    a.Rq = this.Rq;\n    a.Qp = this.Qp;\n    a.Eq = this.Eq;\n    a.Gq = this.Gq;\n    a.Fq = this.Fq.J();\n    a.Hq = this.Hq;\n    a.Iq = this.Iq;\n    a.Kq = this.Kq.J();\n    a.gq = this.gq;\n    a.hq = this.hq.J();\n    a.oq = this.oq.J();\n    a.jq = this.jq.J();\n    a.yp = this.yp;\n    a.bq = this.bq;\n    a.Wq = this.Wq.J();\n    a.Vq = this.Vq;\n    a.Lg = this.Lg;\n    return a;\n  };\n\n  function U(a, b) {\n    void 0 === a || a instanceof Kl || \"string\" === typeof a ? W.call(this, a) : (W.call(this), a && (b = a));\n    this.G = 2408959;\n    this.Jf = \"\";\n    this.O = null;\n    this.zg = \"\";\n    this.Hf = this.Kg = null;\n    this.cc = \"\";\n    this.ph = this.Ah = null;\n    this.de = new I(NaN, NaN).freeze();\n    this.af = null;\n    this.eo = NaN;\n    this.aw = -1;\n    this.Vx = new M();\n    this.Kh = null;\n    this.Sf = NaN;\n    b && Object.assign(this, b);\n  }\n\n  la(U, W);\n\n  U.prototype.cloneProtected = function (a) {\n    W.prototype.cloneProtected.call(this, a);\n    a.G = this.G & -4097 | 49152;\n    a.Jf = this.Jf;\n    null !== this.O && (a.O = this.O.ic ? this.O : this.O.copy());\n    a.zg = this.zg;\n    a.Hf = null;\n    a.cc = this.cc;\n    a.de.assign(this.de);\n    a.eo = this.eo;\n  };\n\n  t = U.prototype;\n\n  t.qf = function (a) {\n    W.prototype.qf.call(this, a);\n    a.dh();\n    a.Kg = null;\n    a.af = null;\n    a.Kh = null;\n  };\n\n  t.toString = function () {\n    var a = Ha(this.constructor) + \"#\" + cb(this);\n    null !== this.data && (a += \"(\" + Ia(this.data) + \")\");\n    return a;\n  };\n\n  function zo(a) {\n    null === a.O ? a.O = new yo() : a.O.ic && (a.O = a.O.copy());\n  }\n\n  t.ih = function () {\n    W.prototype.ih.call(this);\n    null !== this.O && (this.O.ic = !0);\n  };\n\n  t.$j = function (a, b, c, d, e, f, g) {\n    var h = this.diagram;\n    null !== h && (a === fe && \"elements\" === b ? e instanceof W ? Aj(e, function (a) {\n      Cj(h.partManager, a);\n      Bj(h, a);\n    }) : Vj(h, e) : a === ge && \"elements\" === b && (e instanceof W ? Aj(e, function (a) {\n      Fj(h.partManager, a, h);\n    }) : Xj(h, e)), h.bb(a, b, c, d, e, f, g));\n  };\n\n  t.Ka = function (a) {\n    W.prototype.Ka.call(this, a);\n\n    if (null !== this.data) {\n      for (var b = this.R.s, c = b.length, d = 0; d < c; d++) {\n        var e = b[d];\n        e instanceof W && Aj(e, function (a) {\n          null !== a.data && a.Ka();\n        });\n      }\n\n      for (b = this.adornments; b.next();) {\n        b.value.Ka(a);\n      }\n    }\n  };\n\n  U.prototype.updateRelationshipsFromData = function () {\n    var a;\n    null !== this.data && (null === (a = this.diagram) || void 0 === a ? void 0 : a.partManager.updateRelationshipsFromData(this));\n  };\n\n  U.prototype.Hj = function (a) {\n    var b = this.Hf;\n    return null === b ? null : b.I(a);\n  };\n\n  U.prototype.Tg = function (a, b) {\n    if (null !== b) {\n      var c = null,\n          d = this.Hf;\n      null !== d && (c = d.I(a));\n\n      if (c !== b) {\n        if (null !== c) {\n          var e = c.diagram;\n          null !== e && e.remove(c);\n        }\n\n        null === d && (this.Hf = d = new pb());\n        b.Jf !== a && (b.category = a);\n        d.add(a, b);\n        a = this.diagram;\n        null !== a && (a.add(b), a = b.adornedObject, null !== a && (a = a.Yg(), null !== a && (b.data = a.data)));\n      }\n    }\n  };\n\n  U.prototype.Af = function (a) {\n    var b = this.Hf;\n\n    if (null !== b) {\n      var c = b.I(a);\n\n      if (null !== c) {\n        var d = c.diagram;\n        null !== d && d.remove(c);\n      }\n\n      b.remove(a);\n      0 === b.count && (this.Hf = null);\n    }\n  };\n\n  U.prototype.zj = function () {\n    var a = this.Hf;\n\n    if (null !== a) {\n      var b = Ea();\n\n      for (a = a.iterator; a.next();) {\n        b.push(a.key);\n      }\n\n      a = b.length;\n\n      for (var c = 0; c < a; c++) {\n        this.Af(b[c]);\n      }\n\n      Ga(b);\n    }\n  };\n\n  U.prototype.updateAdornments = function () {\n    var a = this.diagram;\n\n    if (null !== a) {\n      for (var b = this.adornments; b.next();) {\n        var c = b.value;\n        c.w();\n        c.placeholder && c.placeholder.w();\n      }\n\n      a: {\n        if (this.isSelected && this.selectionAdorned && (b = this.selectionObject, null !== b && this.actualBounds.v() && this.isVisible() && b.zf() && b.actualBounds.v())) {\n          c = this.Hj(\"Selection\");\n\n          if (null === c) {\n            c = this.selectionAdornmentTemplate;\n            null === c && (c = this.eh() ? a.linkSelectionAdornmentTemplate : this instanceof qf ? a.groupSelectionAdornmentTemplate : a.nodeSelectionAdornmentTemplate);\n            if (!(c instanceof ue)) break a;\n            kg(c);\n            c = c.copy();\n            null !== c && (this.eh() && this.selectionObject === this.path && (c.type = W.Link), c.adornedObject = b);\n          }\n\n          if (null !== c) {\n            c.type === W.Link && c.w();\n            this.Tg(\"Selection\", c);\n            break a;\n          }\n        }\n\n        this.Af(\"Selection\");\n      }\n\n      Ao(this, a);\n\n      for (b = this.adornments; b.next();) {\n        b.value.Ka();\n      }\n    }\n  };\n\n  U.prototype.Rb = function () {\n    var a = this.diagram;\n    null !== a && (Ri(a), 0 !== (this.G & 16384) !== !0 && (this.G |= 16384, a.Mb()));\n  };\n\n  function ei(a) {\n    0 !== (a.G & 16384) !== !1 && (a.updateAdornments(), a.G &= -16385);\n  }\n\n  function Ao(a, b) {\n    b.toolManager.mouseDownTools.each(function (b) {\n      b.isEnabled && b.updateAdornments(a);\n    });\n    b.toolManager.updateAdornments(a);\n  }\n\n  function Bo(a) {\n    if (!1 === pj(a)) {\n      Co(a, !0);\n      a.Jk();\n      var b = a.diagram;\n      null !== b && (b.te.add(a), b.Mb());\n    }\n  }\n\n  function Do(a) {\n    a.G |= 2097152;\n\n    if (!1 !== pj(a)) {\n      var b = a.position,\n          c = a.location;\n      c.v() && b.v() || Eo(a, b, c);\n      c = a.Eb;\n      var d = M.alloc().assign(c);\n      c.ja();\n      c.x = b.x;\n      c.y = b.y;\n      c.freeze();\n      a.Fl(d, c);\n      M.free(d);\n      Co(a, !1);\n    }\n  }\n\n  U.prototype.ve = function (a, b, c, d) {\n    var e = this.qc;\n    e.h(a, b, c, d);\n    null === this.Ib && (this.Ib = new md());\n    var f = this.Ib;\n    f.reset();\n    this.Qn(f, a, b, c, d);\n    this.Ib = f;\n    f.Ur() || f.So(e);\n  };\n\n  U.prototype.Qn = function (a, b, c, d, e) {\n    1 !== this.xa && a.scale(this.xa);\n\n    if (0 !== this.Gb) {\n      var f = yc;\n      this.locationSpot.pb() && (f = this.locationSpot);\n      var g = I.alloc();\n      if (this.locationObject !== this) for (b = this.locationObject, c = b.naturalBounds, g.pi(c.x, c.y, c.width, c.height, f), null !== b.Ib && b.Ib.Fa(g), g.offset(-b.measuredBounds.x, -b.measuredBounds.y), f = b.panel; null !== f && f !== this;) {\n        null !== f.Ib && f.Ib.Fa(g), g.offset(-f.measuredBounds.x, -f.measuredBounds.y), f = f.panel;\n      } else g.pi(b, c, d, e, f);\n      a.rotate(this.Gb, g.x, g.y);\n      I.free(g);\n    }\n  };\n\n  U.prototype.move = function (a, b) {\n    !0 === b ? this.location = a : this.position = a;\n  };\n\n  U.prototype.moveTo = function (a, b, c) {\n    a = I.allocAt(a, b);\n    this.move(a, c);\n    I.free(a);\n  };\n\n  U.prototype.isVisible = function () {\n    if (!this.visible) return !1;\n    var a = this.layer;\n\n    if (null !== a) {\n      if (!a.visible) return !1;\n      a = a.diagram;\n      if (null !== a && a.animationManager.es(this)) return !0;\n    }\n\n    a = this.containingGroup;\n    return null === a || a.isSubGraphExpanded && a.isVisible() ? !0 : !1;\n  };\n\n  U.prototype.Ub = function (a) {\n    var b = this.diagram;\n    a ? (this.D(4), this.Rb(), null !== b && b.te.add(this)) : (this.D(8), this.zj());\n    this.dh();\n    null !== b && (b.Va(), b.N());\n  };\n\n  U.prototype.fb = function (a) {\n    if (this.name === a) return this;\n    var b = this.Kh;\n    null === b && (this.Kh = b = new pb());\n    if (null !== b.I(a)) return b.I(a);\n    var c = W.prototype.fb.call(this, a);\n    if (null !== c) return b.set(a, c), c;\n    b.set(a, null);\n    return null;\n  };\n\n  function Fo(a, b, c, d) {\n    void 0 === d && (d = new I());\n    c = c.Fc() ? yc : c;\n    var e = b.naturalBounds;\n    d.h(e.width * c.x + c.offsetX, e.height * c.y + c.offsetY);\n    if (null === b || b === a) return d;\n    b.transform.Fa(d);\n\n    for (b = b.panel; null !== b && b !== a;) {\n      b.transform.Fa(d), b = b.panel;\n    }\n\n    null !== a.Ib && a.Ib.Fa(d);\n    d.offset(-a.qc.x, -a.qc.y);\n    return d;\n  }\n\n  U.prototype.gi = function (a) {\n    void 0 === a && (a = new M());\n    return a.assign(this.actualBounds);\n  };\n\n  U.prototype.Za = function () {\n    !0 === nj(this) && this.measure(Infinity, Infinity);\n    this.arrange();\n  };\n\n  function yj(a, b) {\n    var c = a.Vx;\n    isNaN(a.Sf) && (a.Sf = bn(a));\n    var d = a.Sf;\n    var e = 2 * d;\n    if (!a.isShadowed) return c.h(b.x - 1 - d, b.y - 1 - d, b.width + 2 + e, b.height + 2 + e), c;\n    d = b.x;\n    e = b.y;\n    var f = b.width;\n    b = b.height;\n    var g = a.shadowBlur;\n    a = a.shadowOffset;\n    f += g;\n    b += g;\n    d -= g / 2;\n    e -= g / 2;\n    0 < a.x ? f += a.x : (d += a.x, f -= a.x);\n    0 < a.y ? b += a.y : (e += a.y, b -= a.y);\n    c.h(d - 1, e - 1, f + 2, b + 2);\n    return c;\n  }\n\n  U.prototype.arrange = function () {\n    if (!1 === oj(this)) Do(this);else {\n      il(this, !1);\n      var a = this.Eb,\n          b = M.alloc();\n      b.assign(a);\n      var c = ig(this);\n      this.Vg(0, 0, this.qc.width, this.qc.height);\n      var d = this.position;\n      Eo(this, d, this.location);\n      a.ja();\n      a.x = d.x;\n      a.y = d.y;\n      a.freeze();\n      this.Fl(b, a);\n      b.C(a) ? this.Pd(c) : !this.Tc() || J.B(b.width, a.width) && J.B(b.height, a.height) || 0 <= this.aw && this.D(16);\n      M.free(b);\n      Co(this, !1);\n    }\n  };\n\n  t = U.prototype;\n\n  t.Fl = function (a, b) {\n    var c = this.diagram;\n\n    if (null !== c) {\n      var d = !1;\n\n      if (!1 === c.Si && a.v()) {\n        var e = M.alloc();\n        e.assign(c.documentBounds);\n        e.jv(c.padding);\n        a.x > e.x && a.y > e.y && a.right < e.right && a.bottom < e.bottom && b.x > e.x && b.y > e.y && b.right < e.right && b.bottom < e.bottom && (d = !0);\n        M.free(e);\n      }\n\n      0 !== (this.G & 65536) !== !0 && a.C(b) || Dj(this, d, c);\n      c.N();\n      !a.v() && !b.v() || Tb(a, b) || (this instanceof V && !c.undoManager.isUndoingRedoing && this.vd(), this.dh());\n    }\n  };\n\n  t.fv = function (a, b, c) {\n    if (this.eh() || !a.v()) return !1;\n    var d = this.diagram;\n    null !== d && Go(this, d, a, b, c);\n    this.pa = a;\n    this.G &= -2097153;\n    !this.de.v() || null !== d && !d.animationManager.isTicking && d.undoManager.isUndoingRedoing || (d = this.de, this.de = new I(d.x + (a.x - b), d.y + (a.y - c)), this.g(\"location\", d, this.de.copy()));\n    !1 === pj(this) && !1 === oj(this) && (Bo(this), Do(this));\n    return !0;\n  };\n\n  function Go(a, b, c, d, e) {\n    null === b || a instanceof ue || (b = b.animationManager, b.zb && xh(b, a, new I(d, e), c));\n  }\n\n  t.Ul = function (a, b, c) {\n    var d = this.de,\n        e = this.pa;\n\n    if (c) {\n      if (d.x === a && d.y === b) return;\n      pj(this) || oj(this) ? e.h(NaN, NaN) : e.h(e.x + a - d.x, e.y + b - d.y);\n      d.h(a, b);\n    } else {\n      if (e.x === a && e.y === b) return;\n      pj(this) || oj(this) ? this.ns() : d.h(d.x + a - e.x, d.y + b - e.y);\n      e.h(a, b);\n    }\n\n    Bo(this);\n  };\n\n  t.ns = function () {\n    this.G &= -2097153;\n    Bo(this);\n  };\n\n  function Eo(a, b, c) {\n    var d = I.alloc(),\n        e = a.locationObject,\n        f = e.naturalBounds,\n        g = e instanceof Cf ? e.strokeWidth : 0;\n    d.pi(0, 0, f.width + g, f.height + g, a.locationSpot);\n    if (e !== a) for (d.offset(-g / 2, -g / 2), e.transform.Fa(d), e = e.panel; null !== e && e !== a;) {\n      e.transform.Fa(d), e = e.panel;\n    }\n    null !== a.Ib && a.Ib.Fa(d);\n    d.offset(-a.qc.x, -a.qc.y);\n    e = a.diagram;\n    f = c.v();\n    g = b.v();\n    f && g ? 0 !== (a.G & 2097152) ? Ho(a, b, c, e, d) : Io(a, b, c, e, d) : f ? Ho(a, b, c, e, d) : g && Io(a, b, c, e, d);\n    a.G |= 2097152;\n    I.free(d);\n    a.Jk();\n  }\n\n  function Ho(a, b, c, d, e) {\n    var f = b.x,\n        g = b.y;\n    b.h(c.x - e.x, c.y - e.y);\n    null !== d && (c = d.animationManager, (d = c.defaultAnimation.isAnimating) || !c.zb || a instanceof ue || xh(c, a, new I(f, g), b), d || b.x === f && b.y === g || a.g(\"position\", new I(f, g), b.copy()));\n  }\n\n  function Io(a, b, c, d, e) {\n    var f = c.copy();\n    c.h(b.x + e.x, b.y + e.y);\n    c.C(f) || null === d || a.g(\"location\", f, c.copy());\n  }\n\n  function Dj(a, b, c) {\n    kl(a, !1);\n    a instanceof V && kk(c, a);\n    a.layer.isTemporary || b || c.Va();\n    b = a.Eb;\n    var d = c.viewportBounds;\n    d.v() ? ig(a) ? (Yb(b, d) || a.Pd(!1), a.updateAdornments()) : b.Sc(d) ? (a.Pd(!0), a.updateAdornments()) : a.Rb() : c.Ui = !0;\n  }\n\n  t.mi = function () {\n    return !0;\n  };\n\n  t.Tc = function () {\n    return !0;\n  };\n\n  t.eh = function () {\n    return !1;\n  };\n\n  t.li = function () {\n    return !0;\n  };\n\n  function Jo(a, b, c, d) {\n    b.constructor === a.constructor || Ko || (Ko = !0, xa('Should not change the class of the Part when changing category from \"' + c + '\" to \"' + d + '\"'), xa(\"  Old class: \" + Ha(a.constructor) + \", new class: \" + Ha(b.constructor) + \", part: \" + a.toString()));\n    a.zj();\n    var e = a.data;\n    c = a.layerName;\n    var f = a.isSelected,\n        g = a.isHighlighted,\n        h = !0,\n        k = !0,\n        l = !1;\n    a instanceof V && (h = a.isTreeLeaf, k = a.isTreeExpanded, l = a.wasTreeExpanded);\n    b.qf(a);\n    b.cloneProtected(a);\n    a.Jf = d;\n    a.w();\n    a.N();\n    b = a.diagram;\n    d = !0;\n    null !== b && (d = b.skipsUndoManager, b.skipsUndoManager = !0);\n    a.qb = e;\n    a.G = f ? a.G | 4096 : a.G & -4097;\n    a.G = g ? a.G | 524288 : a.G & -524289;\n    a instanceof V && (a.U = h ? a.U | 4 : a.U & -5, a.U = k ? a.U | 1 : a.U & -2, a.U = l ? a.U | 2 : a.U & -3);\n    null !== e && a.Ka();\n    e = a.layerName;\n    e !== c && (a.zg = c, a.layerName = e);\n    null !== b && (b.skipsUndoManager = d);\n    a.Tc() && a.D(64);\n  }\n\n  U.prototype.canCopy = function () {\n    if (!this.copyable) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowCopy) return !1;\n    a = a.diagram;\n    return null === a ? !0 : a.allowCopy ? !0 : !1;\n  };\n\n  U.prototype.canDelete = function () {\n    if (!this.deletable) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowDelete) return !1;\n    a = a.diagram;\n    return null === a ? !0 : a.allowDelete ? !0 : !1;\n  };\n\n  U.prototype.canEdit = function () {\n    if (!this.textEditable) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowTextEdit) return !1;\n    a = a.diagram;\n    return null === a ? !0 : a.allowTextEdit ? !0 : !1;\n  };\n\n  U.prototype.canGroup = function () {\n    if (!this.groupable) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowGroup) return !1;\n    a = a.diagram;\n    return null === a ? !0 : a.allowGroup ? !0 : !1;\n  };\n\n  U.prototype.canMove = function () {\n    if (!this.movable) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowMove) return !1;\n    a = a.diagram;\n    return null === a ? !0 : a.allowMove ? !0 : !1;\n  };\n\n  U.prototype.canReshape = function () {\n    if (!this.reshapable) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowReshape) return !1;\n    a = a.diagram;\n    return null === a ? !0 : a.allowReshape ? !0 : !1;\n  };\n\n  U.prototype.canResize = function () {\n    if (!this.resizable) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowResize) return !1;\n    a = a.diagram;\n    return null === a ? !0 : a.allowResize ? !0 : !1;\n  };\n\n  U.prototype.canRotate = function () {\n    if (!this.rotatable) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowRotate) return !1;\n    a = a.diagram;\n    return null === a ? !0 : a.allowRotate ? !0 : !1;\n  };\n\n  U.prototype.canSelect = function () {\n    if (!this.selectable) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowSelect) return !1;\n    a = a.diagram;\n    return null === a ? !0 : a.allowSelect ? !0 : !1;\n  };\n\n  function pj(a) {\n    return 0 !== (a.G & 32768);\n  }\n\n  function Co(a, b) {\n    a.G = b ? a.G | 32768 : a.G & -32769;\n  }\n\n  function kl(a, b) {\n    a.G = b ? a.G | 65536 : a.G & -65537;\n  }\n\n  function ig(a) {\n    return 0 !== (a.G & 131072);\n  }\n\n  t = U.prototype;\n\n  t.Pd = function (a) {\n    this.G = a ? this.G | 131072 : this.G & -131073;\n  };\n\n  function Lo(a, b) {\n    a.G = b ? a.G | 1048576 : a.G & -1048577;\n  }\n\n  t.dh = function () {\n    var a = this.containingGroup;\n    null !== a && (a.w(), null !== a.placeholder && a.placeholder.w(), a.vd());\n  };\n\n  t.N = function () {\n    var a = this.diagram;\n    null !== a && !oj(this) && !pj(this) && this.isVisible() && this.Eb.v() && a.N(yj(this, this.Eb));\n  };\n\n  t.w = function () {\n    W.prototype.w.call(this);\n    var a = this.diagram;\n    null !== a && (a.te.add(this), this instanceof V && null !== this.labeledLink && zl(this.labeledLink), a.Mb(!0));\n  };\n\n  t.yo = function (a) {\n    a || (a = this.ph, null !== a && Mo(a, this));\n  };\n\n  t.zo = function (a) {\n    a || (a = this.ph, null !== a && No(a, this));\n  };\n\n  t.Fj = function () {\n    var a = this.data;\n\n    if (null !== a) {\n      var b = this.diagram;\n      null !== b && (b = b.model, null !== b && b.Kl(a));\n    }\n  };\n\n  t.Xy = function () {\n    return Oo(this, this);\n  };\n\n  function Oo(a, b) {\n    var c = b.containingGroup;\n    return null !== c ? 1 + Oo(a, c) : b instanceof V && (b = b.labeledLink, null !== b) ? Oo(a, b) : 0;\n  }\n\n  t.az = function () {\n    return Po(this, this);\n  };\n\n  function Po(a, b) {\n    var c = b.containingGroup;\n    return null !== c || b instanceof V && (c = b.labeledLink, null !== c) ? Po(a, c) : b;\n  }\n\n  t.Md = function (a) {\n    return a instanceof qf ? Qo(this, this, a) : !1;\n  };\n\n  function Qo(a, b, c) {\n    if (b === c || null === c) return !1;\n    var d = b.containingGroup;\n    return null === d || d !== c && !Qo(a, d, c) ? b instanceof V && (b = b.labeledLink, null !== b) ? Qo(a, b, c) : !1 : !0;\n  }\n\n  t.Sw = function (a) {\n    if (null === a) return null;\n    if (this === a) return this.containingGroup;\n\n    for (var b = this; null !== b;) {\n      b instanceof qf && Lo(b, !0);\n\n      if (b instanceof V) {\n        var c = b.labeledLink;\n        null !== c && (b = c);\n      }\n\n      b = b.containingGroup;\n    }\n\n    c = null;\n\n    for (b = a; null !== b;) {\n      if (0 !== (b.G & 1048576)) {\n        c = b;\n        break;\n      }\n\n      b instanceof V && (a = b.labeledLink, null !== a && (b = a));\n      b = b.containingGroup;\n    }\n\n    for (b = this; null !== b;) {\n      b instanceof qf && Lo(b, !1), b instanceof V && (a = b.labeledLink, null !== a && (b = a)), b = b.containingGroup;\n    }\n\n    return c;\n  };\n\n  U.prototype.canLayout = function () {\n    if (!this.isLayoutPositioned || !this.isVisible()) return !1;\n    var a = this.layer;\n    return null !== a && a.isTemporary || this instanceof V && this.isLinkLabel ? !1 : !0;\n  };\n\n  U.prototype.D = function (a) {\n    void 0 === a && (a = 16777215);\n\n    if (this.isLayoutPositioned && 0 !== (a & this.layoutConditions)) {\n      var b = this.layer;\n      null !== b && b.isTemporary || this instanceof V && this.isLinkLabel ? b = !1 : (b = this.diagram, b = null !== b && b.undoManager.isUndoingRedoing ? !1 : !0);\n    } else b = !1;\n\n    if (b) if (b = this.ph, null !== b) {\n      var c = b.layout;\n      null !== c ? c.D() : b.D(a);\n    } else a = this.diagram, null !== a && (a = a.layout, null !== a && a.D());\n  };\n\n  function Ej(a) {\n    if (!a.isVisible()) return !1;\n    a = a.layer;\n    return null !== a && a.isTemporary ? !1 : !0;\n  }\n\n  function Rk(a, b, c, d, e, f) {\n    void 0 === f && (f = null);\n    if (!(a.contains(b) || null !== f && !f(b) || b instanceof ue)) if (a.add(b), b instanceof V) {\n      if (c && b instanceof qf) for (var g = b.memberParts; g.next();) {\n        Rk(a, g.value, c, d, e, f);\n      }\n      if (!1 !== e) for (g = b.linksConnected; g.next();) {\n        var h = g.value;\n\n        if (!a.contains(h)) {\n          var k = h.fromNode,\n              l = h.toNode;\n          k = null === k || a.contains(k);\n          l = null === l || a.contains(l);\n          (e ? k && l : k || l) && Rk(a, h, c, d, e, f);\n        }\n      }\n      if (1 < d) for (b = b.Au(); b.next();) {\n        Rk(a, b.value, c, d - 1, e, f);\n      }\n    } else if (b instanceof T) for (b = b.labelNodes; b.next();) {\n      Rk(a, b.value, c, d, e, f);\n    }\n  }\n\n  ma.Object.defineProperties(U.prototype, {\n    key: {\n      get: function get() {\n        var a = this.diagram;\n        if (null !== a) return a.model.ua(this.data);\n      }\n    },\n    adornments: {\n      get: function get() {\n        return null === this.Hf ? Za : this.Hf.iteratorValues;\n      }\n    },\n    layer: {\n      get: function get() {\n        return this.Ah;\n      }\n    },\n    diagram: {\n      get: function get() {\n        var a = this.Ah;\n        return null === a || void 0 === a ? null : a.diagram;\n      }\n    },\n    layerName: {\n      get: function get() {\n        return this.zg;\n      },\n      set: function set(a) {\n        var b = this.zg;\n\n        if (b !== a) {\n          var c = this.diagram;\n          if (null === c || null !== c.Ij(a) && !c.partManager.addsToTemporaryLayer) if (this.zg = a, null !== c && c.Va(), this.g(\"layerName\", b, a), b = this.layer, null !== b && b.name !== a && (c = b.diagram, null !== c && (a = c.Ij(a), null !== a && a !== b))) {\n            var d = b.lc(-1, this, !0);\n            0 <= d && c.bb(ge, \"parts\", b, this, null, d, !0);\n            d = a.ii(99999999, this, !0);\n            b.visible !== a.visible && this.Ub(a.visible);\n            0 <= d && c.bb(fe, \"parts\", a, null, this, !0, d);\n            d = this.layerChanged;\n\n            if (null !== d) {\n              var e = c.$;\n              c.$ = !0;\n              d(this, b, a);\n              c.$ = e;\n            }\n          }\n        }\n      }\n    },\n    layerChanged: {\n      get: function get() {\n        return null !== this.O ? this.O.Zp : null;\n      },\n      set: function set(a) {\n        var b = this.layerChanged;\n        b !== a && (zo(this), this.O.Zp = a, this.g(\"layerChanged\", b, a));\n      }\n    },\n    zOrder: {\n      get: function get() {\n        return this.eo;\n      },\n      set: function set(a) {\n        var b = this.eo;\n\n        if (b !== a) {\n          this.eo = a;\n          var c = this.layer;\n          null !== c && hi(c, -1, this);\n          this.g(\"zOrder\", b, a);\n          a = this.diagram;\n          null !== a && a.N();\n        }\n      }\n    },\n    locationObject: {\n      get: function get() {\n        if (null === this.af) {\n          var a = this.locationObjectName;\n          \"\" !== a ? (a = this.fb(a), null !== a ? this.af = a : this.af = this) : this instanceof ue ? this.type !== W.Link && null !== this.placeholder ? this.af = this.placeholder : this.af = this : this.af = this;\n        }\n\n        return this.af.visible ? this.af : this;\n      }\n    },\n    minLocation: {\n      get: function get() {\n        return null !== this.O ? this.O.oq : rb;\n      },\n      set: function set(a) {\n        var b = this.minLocation;\n        b.C(a) || (a = a.J(), zo(this), this.O.oq = a, this.g(\"minLocation\", b, a));\n      }\n    },\n    maxLocation: {\n      get: function get() {\n        return null !== this.O ? this.O.jq : sb;\n      },\n      set: function set(a) {\n        var b = this.maxLocation;\n        b.C(a) || (a = a.J(), zo(this), this.O.jq = a, this.g(\"maxLocation\", b, a));\n      }\n    },\n    locationObjectName: {\n      get: function get() {\n        return null !== this.O ? this.O.gq : \"\";\n      },\n      set: function set(a) {\n        var b = this.locationObjectName;\n        b !== a && (zo(this), this.O.gq = a, this.af = null, this.w(), this.g(\"locationObjectName\", b, a));\n      }\n    },\n    locationSpot: {\n      get: function get() {\n        return null !== this.O ? this.O.hq : tc;\n      },\n      set: function set(a) {\n        var b = this.locationSpot;\n        b.C(a) || (a = a.J(), zo(this), this.O.hq = a, this.w(), this.g(\"locationSpot\", b, a));\n      }\n    },\n    location: {\n      get: function get() {\n        return this.de;\n      },\n      set: function set(a) {\n        var b = a.x,\n            c = a.y,\n            d = this.de;\n\n        if (!(d.x === b || isNaN(d.x) && isNaN(b)) || !(d.y === c || isNaN(d.y) && isNaN(c))) {\n          a = a.copy();\n          b = a;\n          if (this.eh()) b = !1;else {\n            this.de = b;\n            this.G |= 2097152;\n\n            if (!1 === oj(this) && (Bo(this), c = this.pa, c.v())) {\n              var e = this.diagram;\n\n              if (null === e || e.animationManager.isTicking || !e.undoManager.isUndoingRedoing) {\n                var f = c.copy();\n                c.h(c.x + (b.x - d.x), c.y + (b.y - d.y));\n                Go(this, e, c, f.x, f.y);\n                this.g(\"position\", f, c.copy());\n              }\n            }\n\n            b = !0;\n          }\n          b && this.g(\"location\", d, a.copy());\n        }\n      }\n    },\n    category: {\n      get: function get() {\n        return this.Jf;\n      },\n      set: function set(a) {\n        var b = this.Jf;\n\n        if (b !== a) {\n          var c = this.diagram,\n              d = this.data,\n              e = null;\n\n          if (null !== c && null !== d && !(this instanceof ue)) {\n            var f = c.model.undoManager;\n            f.isEnabled && !f.isUndoingRedoing && (e = this.clone(), e.R.addAll(this.R));\n          }\n\n          this.Jf = a;\n          this.g(\"category\", b, a);\n          null === c || null === d || this instanceof ue ? this instanceof ue && (e = this.adornedPart, null !== e && (a = e.Hf, null !== a && a.remove(b), e.Tg(this.category, this))) : (f = c.model, f.undoManager.isUndoingRedoing || (this.eh() ? (c.partManager.setLinkCategoryForData(d, a), c = c.partManager.findLinkTemplateForCategory(a), null !== c && (kg(c), c = c.copy(), null !== c && Jo(this, c, b, a))) : (null !== f && f.Rl(d, a), c = Ro(c.partManager, d, a), null !== c && (kg(c), c = c.copy(), null === c || c instanceof T || (d = this.location.copy(), Jo(this, c, b, a), this.location.v() || (this.location = d)))), null !== e && (b = this.clone(), b.R.addAll(this.R), this.g(\"self\", e, b))));\n        }\n      }\n    },\n    self: {\n      get: function get() {\n        return this;\n      },\n      set: function set(a) {\n        Jo(this, a, this.category, a.category);\n      }\n    },\n    copyable: {\n      get: function get() {\n        return 0 !== (this.G & 1);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.G & 1);\n        b !== a && (this.G ^= 1, this.g(\"copyable\", b, a));\n      }\n    },\n    deletable: {\n      get: function get() {\n        return 0 !== (this.G & 2);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.G & 2);\n        b !== a && (this.G ^= 2, this.g(\"deletable\", b, a));\n      }\n    },\n    textEditable: {\n      get: function get() {\n        return 0 !== (this.G & 4);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.G & 4);\n        b !== a && (this.G ^= 4, this.g(\"textEditable\", b, a), this.Rb());\n      }\n    },\n    groupable: {\n      get: function get() {\n        return 0 !== (this.G & 8);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.G & 8);\n        b !== a && (this.G ^= 8, this.g(\"groupable\", b, a));\n      }\n    },\n    movable: {\n      get: function get() {\n        return 0 !== (this.G & 16);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.G & 16);\n        b !== a && (this.G ^= 16, this.g(\"movable\", b, a));\n      }\n    },\n    selectionAdorned: {\n      get: function get() {\n        return 0 !== (this.G & 32);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.G & 32);\n        b !== a && (this.G ^= 32, this.g(\"selectionAdorned\", b, a), this.Rb());\n      }\n    },\n    isInDocumentBounds: {\n      get: function get() {\n        return 0 !== (this.G & 64);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.G & 64);\n\n        if (b !== a) {\n          this.G ^= 64;\n          var c = this.diagram;\n          null !== c && c.Va();\n          this.g(\"isInDocumentBounds\", b, a);\n        }\n      }\n    },\n    isLayoutPositioned: {\n      get: function get() {\n        return 0 !== (this.G & 128);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.G & 128);\n        b !== a && (this.G ^= 128, this.g(\"isLayoutPositioned\", b, a), this.D(a ? 4 : 8));\n      }\n    },\n    selectable: {\n      get: function get() {\n        return 0 !== (this.G & 256);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.G & 256);\n        b !== a && (this.G ^= 256, this.g(\"selectable\", b, a), this.Rb());\n      }\n    },\n    reshapable: {\n      get: function get() {\n        return 0 !== (this.G & 512);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.G & 512);\n        b !== a && (this.G ^= 512, this.g(\"reshapable\", b, a), this.Rb());\n      }\n    },\n    resizable: {\n      get: function get() {\n        return 0 !== (this.G & 1024);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.G & 1024);\n        b !== a && (this.G ^= 1024, this.g(\"resizable\", b, a), this.Rb());\n      }\n    },\n    rotatable: {\n      get: function get() {\n        return 0 !== (this.G & 2048);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.G & 2048);\n        b !== a && (this.G ^= 2048, this.g(\"rotatable\", b, a), this.Rb());\n      }\n    },\n    isSelected: {\n      get: function get() {\n        return 0 !== (this.G & 4096);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.G & 4096);\n\n        if (b !== a) {\n          var c = this.diagram;\n\n          if (!a || this.canSelect() && !(null !== c && c.selection.count >= c.maxSelectionCount)) {\n            this.G ^= 4096;\n            var d = !1;\n\n            if (null !== c) {\n              d = c.skipsUndoManager;\n              c.skipsUndoManager = !0;\n              var e = c.selection;\n              e.ja();\n              a ? e.add(this) : e.remove(this);\n              e.freeze();\n            }\n\n            this.g(\"isSelected\", b, a);\n            this.Rb();\n            a = this.selectionChanged;\n            null !== a && a(this);\n            null !== c && (c.Mb(), c.skipsUndoManager = d);\n          }\n        }\n      }\n    },\n    isHighlighted: {\n      get: function get() {\n        return 0 !== (this.G & 524288);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.G & 524288);\n\n        if (b !== a) {\n          this.G ^= 524288;\n          var c = this.diagram;\n          null !== c && (c = c.highlighteds, c.ja(), a ? c.add(this) : c.remove(this), c.freeze());\n          this.g(\"isHighlighted\", b, a);\n          this.N();\n          a = this.highlightedChanged;\n          null !== a && a(this);\n        }\n      }\n    },\n    isShadowed: {\n      get: function get() {\n        return 0 !== (this.G & 8192);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.G & 8192);\n        b !== a && (this.G ^= 8192, this.g(\"isShadowed\", b, a), this.N());\n      }\n    },\n    isAnimated: {\n      get: function get() {\n        return 0 !== (this.G & 262144);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.G & 262144);\n        b !== a && (this.G ^= 262144, this.g(\"isAnimated\", b, a));\n      }\n    },\n    highlightedChanged: {\n      get: function get() {\n        return null !== this.O ? this.O.Qp : null;\n      },\n      set: function set(a) {\n        var b = this.highlightedChanged;\n        b !== a && (zo(this), this.O.Qp = a, this.g(\"highlightedChanged\", b, a));\n      }\n    },\n    selectionObjectName: {\n      get: function get() {\n        return null !== this.O ? this.O.Sq : \"\";\n      },\n      set: function set(a) {\n        var b = this.selectionObjectName;\n        b !== a && (zo(this), this.O.Sq = a, this.Kg = null, this.g(\"selectionObjectName\", b, a));\n      }\n    },\n    selectionAdornmentTemplate: {\n      get: function get() {\n        return null !== this.O ? this.O.Qq : null;\n      },\n      set: function set(a) {\n        var b = this.selectionAdornmentTemplate;\n        b !== a && (zo(this), this.O.Qq = a, this.g(\"selectionAdornmentTemplate\", b, a));\n      }\n    },\n    selectionObject: {\n      get: function get() {\n        if (null === this.Kg) {\n          var a = this.selectionObjectName;\n          null !== a && \"\" !== a ? (a = this.fb(a), null !== a ? this.Kg = a : this.Kg = this) : this instanceof T ? (a = this.path, null !== a ? this.Kg = a : this.Kg = this) : this.Kg = this;\n        }\n\n        return this.Kg;\n      }\n    },\n    selectionChanged: {\n      get: function get() {\n        return null !== this.O ? this.O.Rq : null;\n      },\n      set: function set(a) {\n        var b = this.selectionChanged;\n        b !== a && (zo(this), this.O.Rq = a, this.g(\"selectionChanged\", b, a));\n      }\n    },\n    resizeAdornmentTemplate: {\n      get: function get() {\n        return null !== this.O ? this.O.Eq : null;\n      },\n      set: function set(a) {\n        var b = this.resizeAdornmentTemplate;\n        b !== a && (zo(this), this.O.Eq = a, this.g(\"resizeAdornmentTemplate\", b, a));\n      }\n    },\n    resizeObjectName: {\n      get: function get() {\n        return null !== this.O ? this.O.Gq : \"\";\n      },\n      set: function set(a) {\n        var b = this.resizeObjectName;\n        b !== a && (zo(this), this.O.Gq = a, this.g(\"resizeObjectName\", b, a));\n      }\n    },\n    resizeObject: {\n      get: function get() {\n        var a = this.resizeObjectName;\n        return \"\" !== a && (a = this.fb(a), null !== a) ? a : this;\n      }\n    },\n    resizeCellSize: {\n      get: function get() {\n        return null !== this.O ? this.O.Fq : Mb;\n      },\n      set: function set(a) {\n        var b = this.resizeCellSize;\n        b.C(a) || (a = a.J(), zo(this), this.O.Fq = a, this.g(\"resizeCellSize\", b, a));\n      }\n    },\n    rotateAdornmentTemplate: {\n      get: function get() {\n        return null !== this.O ? this.O.Hq : null;\n      },\n      set: function set(a) {\n        var b = this.rotateAdornmentTemplate;\n        b !== a && (zo(this), this.O.Hq = a, this.g(\"rotateAdornmentTemplate\", b, a));\n      }\n    },\n    rotateObjectName: {\n      get: function get() {\n        return null !== this.O ? this.O.Iq : \"\";\n      },\n      set: function set(a) {\n        var b = this.rotateObjectName;\n        b !== a && (zo(this), this.O.Iq = a, this.g(\"rotateObjectName\", b, a));\n      }\n    },\n    rotateObject: {\n      get: function get() {\n        var a = this.rotateObjectName;\n        return \"\" !== a && (a = this.fb(a), null !== a) ? a : this;\n      }\n    },\n    rotationSpot: {\n      get: function get() {\n        return null !== this.O ? this.O.Kq : Wc;\n      },\n      set: function set(a) {\n        var b = this.rotationSpot;\n        b.C(a) || (a = a.J(), zo(this), this.O.Kq = a, this.g(\"rotationSpot\", b, a));\n      }\n    },\n    text: {\n      get: function get() {\n        return this.cc;\n      },\n      set: function set(a) {\n        var b = this.cc;\n        b !== a && (this.cc = a, this.g(\"text\", b, a));\n      }\n    },\n    containingGroup: {\n      get: function get() {\n        return this.ph;\n      },\n      set: function set(a) {\n        if (this.Tc()) {\n          var b = this.ph;\n\n          if (b !== a) {\n            null === a || this !== a && !a.Md(this) || (this === a && C(\"Cannot make a Group a member of itself: \" + this.toString()), C(\"Cannot make a Group indirectly contain itself: \" + this.toString() + \" already contains \" + a.toString()));\n            this.D(2);\n            var c = this.diagram;\n            null !== b ? No(b, this) : this instanceof qf && null !== c && c.Uh.remove(this);\n            this.ph = a;\n            null !== a ? Mo(a, this) : this instanceof qf && null !== c && c.Uh.add(this);\n            this.D(1);\n\n            if (null !== c && c.$) {\n              var d = this.data,\n                  e = c.model;\n\n              if (null !== d && e.Oj()) {\n                var f = e.ua(null !== a ? a.data : null);\n                e.Po(d, f);\n              }\n            }\n\n            d = this.containingGroupChanged;\n            null !== d && (e = !0, null !== c && (e = c.$, c.$ = !0), d(this, b, a), null !== c && (c.$ = e));\n            if (this instanceof qf) for (c = new G(), Rk(c, this, !0, 0, !0), c = c.iterator; c.next();) {\n              if (d = c.value, d instanceof V) for (d = d.linksConnected; d.next();) {\n                So(d.value);\n              }\n            }\n\n            if (this instanceof V) {\n              for (c = this.linksConnected; c.next();) {\n                So(c.value);\n              }\n\n              c = this.labeledLink;\n              null !== c && So(c);\n            }\n\n            this.g(\"containingGroup\", b, a);\n            null !== a && (b = a.layer, null !== b && hi(b, -1, a));\n          }\n        } else C(\"cannot set the Part.containingGroup of a Link or Adornment\");\n      }\n    },\n    containingGroupChanged: {\n      get: function get() {\n        return null !== this.O ? this.O.np : null;\n      },\n      set: function set(a) {\n        var b = this.containingGroupChanged;\n        b !== a && (zo(this), this.O.np = a, this.g(\"containingGroupChanged\", b, a));\n      }\n    },\n    isTopLevel: {\n      get: function get() {\n        return null !== this.containingGroup || this instanceof V && null !== this.labeledLink ? !1 : !0;\n      }\n    },\n    layoutConditions: {\n      get: function get() {\n        return null !== this.O ? this.O.bq : 127;\n      },\n      set: function set(a) {\n        var b = this.layoutConditions;\n        b !== a && (zo(this), this.O.bq = a, this.g(\"layoutConditions\", b, a));\n      }\n    },\n    dragComputation: {\n      get: function get() {\n        return null !== this.O ? this.O.yp : null;\n      },\n      set: function set(a) {\n        var b = this.dragComputation;\n        b !== a && (zo(this), this.O.yp = a, this.g(\"dragComputation\", b, a));\n      }\n    },\n    shadowOffset: {\n      get: function get() {\n        return null !== this.O ? this.O.Wq : tb;\n      },\n      set: function set(a) {\n        var b = this.shadowOffset;\n        b.C(a) || (a = a.J(), zo(this), this.O.Wq = a, this.N(), this.g(\"shadowOffset\", b, a));\n      }\n    },\n    shadowColor: {\n      get: function get() {\n        return null !== this.O ? this.O.Vq : \"gray\";\n      },\n      set: function set(a) {\n        var b = this.shadowColor;\n        b !== a && (zo(this), this.O.Vq = a, this.N(), this.g(\"shadowColor\", b, a));\n      }\n    },\n    shadowBlur: {\n      get: function get() {\n        return null !== this.O ? this.O.Lg : 4;\n      },\n      set: function set(a) {\n        var b = this.shadowBlur;\n        b !== a && (zo(this), this.O.Lg = a, this.N(), this.g(\"shadowBlur\", b, a));\n      }\n    }\n  });\n  U.prototype.invalidateLayout = U.prototype.D;\n  U.prototype.findCommonContainingGroup = U.prototype.Sw;\n  U.prototype.isMemberOf = U.prototype.Md;\n  U.prototype.findTopLevelPart = U.prototype.az;\n  U.prototype.findSubGraphLevel = U.prototype.Xy;\n  U.prototype.ensureBounds = U.prototype.Za;\n  U.prototype.getDocumentBounds = U.prototype.gi;\n  U.prototype.findObject = U.prototype.fb;\n  U.prototype.moveTo = U.prototype.moveTo;\n  U.prototype.invalidateAdornments = U.prototype.Rb;\n  U.prototype.clearAdornments = U.prototype.zj;\n  U.prototype.removeAdornment = U.prototype.Af;\n  U.prototype.addAdornment = U.prototype.Tg;\n  U.prototype.findAdornment = U.prototype.Hj;\n  U.prototype.updateTargetBindings = U.prototype.Ka;\n  var Ko = !1;\n  U.className = \"Part\";\n  U.LayoutNone = 0;\n  U.LayoutAdded = 1;\n  U.LayoutRemoved = 2;\n  U.LayoutShown = 4;\n  U.LayoutHidden = 8;\n  U.LayoutNodeSized = 16;\n  U.LayoutGroupLayout = 32;\n  U.LayoutNodeReplaced = 64;\n  U.LayoutStandard = 127;\n  U.LayoutAll = 16777215;\n\n  function ue(a, b) {\n    void 0 === a || a instanceof Kl || \"string\" === typeof a ? U.call(this, a) : (U.call(this), a && (b = a));\n    this.G &= -257;\n    this.zg = \"Adornment\";\n    this.me = null;\n    this.ew = 0;\n    this.yw = !1;\n    this.j = this.Xa = null;\n    b && Object.assign(this, b);\n  }\n\n  la(ue, U);\n\n  ue.prototype.toString = function () {\n    var a = this.adornedPart;\n    return \"Adornment(\" + this.category + \")\" + (null !== a ? a.toString() : \"\");\n  };\n\n  ue.prototype.updateRelationshipsFromData = function () {};\n\n  ue.prototype.Rj = function (a) {\n    var b = this.adornedObject,\n        c = null === b || void 0 === b ? void 0 : b.part;\n\n    if (c instanceof T && b instanceof Cf) {\n      b = c.path;\n      c.Rj(a);\n      a = b.geometry;\n      c = this.R.s;\n      b = c.length;\n\n      for (var d = 0; d < b; d++) {\n        var e = c[d];\n        e.isPanelMain && e instanceof Cf && (e.sa = a);\n      }\n    }\n  };\n\n  ue.prototype.mi = function () {\n    var a = this.me;\n    if (null === a) return !0;\n    a = a.part;\n    return null === a || !oj(a);\n  };\n\n  ue.prototype.Tc = function () {\n    return !1;\n  };\n\n  ue.prototype.$j = function (a, b, c, d, e, f, g) {\n    if (a === fe && \"elements\" === b) {\n      if (e instanceof jg) null === this.Xa && (this.Xa = e);else {\n        if (e instanceof W) {\n          var h = e.vl(function (a) {\n            return a instanceof jg;\n          });\n          h instanceof jg && null === this.Xa && (this.Xa = h);\n        }\n      }\n    } else a === ge && \"elements\" === b && null !== this.Xa && (d === this.Xa ? this.Xa = null : d instanceof W && this.Xa.jg(d) && (this.Xa = null));\n    U.prototype.$j.call(this, a, b, c, d, e, f, g);\n  };\n\n  ue.prototype.updateAdornments = function () {};\n\n  ue.prototype.Fj = function () {};\n\n  ma.Object.defineProperties(ue.prototype, {\n    placeholder: {\n      get: function get() {\n        return this.Xa;\n      }\n    },\n    adornedObject: {\n      get: function get() {\n        return this.me;\n      },\n      set: function set(a) {\n        var b = this.adornedPart,\n            c = null;\n        null !== a && (c = a.part);\n        null === b || null !== a && b === c || b.Af(this.category);\n        this.me = a;\n        null !== c && c.Tg(this.category, this);\n      }\n    },\n    adornedPart: {\n      get: function get() {\n        var a = this.me;\n        return null !== a ? a.part : null;\n      }\n    },\n    containingGroup: {\n      get: function get() {\n        return null;\n      }\n    }\n  });\n  ue.className = \"Adornment\";\n\n  function To() {\n    this.ic = !1;\n    this.ur = this.bj = this.eq = this.cq = null;\n    this.ap = rc;\n    this.Dq = Uo;\n    this.gr = this.dj = this.mq = this.lq = null;\n  }\n\n  To.prototype.copy = function () {\n    var a = new To();\n    a.cq = this.cq;\n    a.eq = this.eq;\n    a.bj = this.bj;\n    a.ur = this.ur;\n    a.ap = this.ap.J();\n    a.Dq = this.Dq;\n    a.lq = this.lq;\n    a.mq = this.mq;\n    a.dj = this.dj;\n    a.gr = this.gr;\n    return a;\n  };\n\n  function V(a, b) {\n    void 0 === a || a instanceof Kl || \"string\" === typeof a ? U.call(this, a) : (U.call(this), a && (b = a));\n    this.U = 13;\n    this.ya = null;\n    this.jb = new E();\n    this.sc = this.Qe = this.Nk = null;\n    this.Rg = !1;\n    b && Object.assign(this, b);\n  }\n\n  la(V, U);\n\n  V.prototype.cloneProtected = function (a) {\n    U.prototype.cloneProtected.call(this, a);\n    a.U = this.U;\n    null !== this.ya && (a.ya = this.ya.ic ? this.ya : this.ya.copy());\n  };\n\n  t = V.prototype;\n\n  t.qf = function (a) {\n    U.prototype.qf.call(this, a);\n    a.vd();\n    a.Qe = this.Qe;\n    a.sc = null;\n  };\n\n  function Vo(a) {\n    null === a.ya ? a.ya = new To() : a.ya.ic && (a.ya = a.ya.copy());\n  }\n\n  t.ih = function () {\n    U.prototype.ih.call(this);\n    null !== this.ya && (this.ya.ic = !0);\n  };\n\n  function Wo(a, b) {\n    null !== b && (null === a.Qe && (a.Qe = new G()), a.Qe.add(b));\n  }\n\n  function Xo(a, b, c, d) {\n    if (null === b || null === a.Qe) return null;\n\n    for (var e = a.Qe.iterator; e.next();) {\n      var f = e.value;\n      if (f.cs === a && f.Pu === b && f.vx === c && f.wx === d || f.cs === b && f.Pu === a && f.vx === d && f.wx === c) return f;\n    }\n\n    return null;\n  }\n\n  t.uz = function (a, b, c) {\n    if (void 0 === b || null === b) b = \"\";\n    if (void 0 === c || null === c) c = \"\";\n    a = Xo(this, a, b, c);\n    null !== a && a.Al();\n  };\n\n  t.$j = function (a, b, c, d, e, f, g) {\n    a === fe && \"elements\" === b ? this.sc = null : a === ge && \"elements\" === b && (this.sc = null);\n    U.prototype.$j.call(this, a, b, c, d, e, f, g);\n  };\n\n  t.vd = function (a) {\n    for (var b = this.linksConnected; b.next();) {\n      var c = b.value;\n      void 0 !== a && a.contains(c) || (Yo(c.fromPort), Yo(c.toPort), c.ab());\n    }\n  };\n\n  function ll(a, b) {\n    for (a = a.linksConnected; a.next();) {\n      var c = a.value;\n      if (c.fromPort === b || c.toPort === b) Yo(c.fromPort), Yo(c.toPort), c.ab();\n    }\n  }\n\n  function Yo(a) {\n    if (null !== a) {\n      var b = a.Hn;\n      null !== b && b.Al();\n      a = a.part;\n      b = a.containingGroup;\n      null === b || a.isVisible() || Yo(b.port);\n    }\n  }\n\n  t.mi = function () {\n    return !0;\n  };\n\n  V.prototype.getAvoidableRect = function (a) {\n    a.set(this.actualBounds);\n    a.fo(this.avoidableMargin);\n    return a;\n  };\n\n  V.prototype.findVisibleNode = function () {\n    for (var a = this; null !== a && !a.isVisible();) {\n      a = a.containingGroup;\n    }\n\n    return a;\n  };\n\n  V.prototype.isVisible = function () {\n    if (!U.prototype.isVisible.call(this)) return !1;\n    var a = !0,\n        b = vi,\n        c = this.diagram;\n\n    if (null !== c) {\n      if (c.animationManager.es(this)) return !0;\n      a = c.isTreePathToChildren;\n      b = c.treeCollapsePolicy;\n    }\n\n    if (b === vi) {\n      if (a = this.ig(), null !== a && !a.isTreeExpanded) return !1;\n    } else if (b === Ck) {\n      if (a = a ? this.xu() : this.yu(), 0 < a.count && a.all(function (a) {\n        return !a.isTreeExpanded;\n      })) return !1;\n    } else if (b === Dk && (a = a ? this.xu() : this.yu(), 0 < a.count && a.any(function (a) {\n      return !a.isTreeExpanded;\n    }))) return !1;\n\n    a = this.labeledLink;\n    return null !== a ? a.isVisible() : !0;\n  };\n\n  V.prototype.Ub = function (a) {\n    U.prototype.Ub.call(this, a);\n\n    for (var b = this.linksConnected; b.next();) {\n      var c = b.value;\n\n      if (a && null !== this.containingGroup) {\n        var d = c.wo(this);\n        null === d || d.Md(this.containingGroup) || c.ab();\n      }\n\n      c.Ub(a);\n    }\n  };\n\n  V.prototype.Tw = function () {\n    var a = new G(),\n        b = new G();\n    Zo(this, this, a, b);\n    return b.iterator;\n  };\n\n  function Zo(a, b, c, d) {\n    if (null !== b && !c.has(b)) {\n      c.add(b);\n      var e = !0,\n          f = a.diagram;\n      null !== f && (e = f.isTreePathToChildren);\n      b.linksConnected.each(function (f) {\n        f.isTreeLink ? (e ? f.fromNode === b : f.toNode === b) && Zo(a, e ? f.toNode : f.fromNode, c, d) : d.add(f);\n      });\n    }\n  }\n\n  V.prototype.findLinksConnected = function (a) {\n    void 0 === a && (a = null);\n    if (null === a) return this.jb.iterator;\n    var b = new ab(this.jb),\n        c = this;\n\n    b.predicate = function (b) {\n      return b.fromNode === c && b.fromPortId === a || b.toNode === c && b.toPortId === a;\n    };\n\n    return b;\n  };\n\n  t = V.prototype;\n\n  t.ro = function (a) {\n    void 0 === a && (a = null);\n    var b = new ab(this.jb),\n        c = this;\n\n    b.predicate = function (b) {\n      return b.fromNode !== c ? !1 : null === a ? !0 : b.fromPortId === a;\n    };\n\n    return b;\n  };\n\n  t.Kd = function (a) {\n    void 0 === a && (a = null);\n    var b = new ab(this.jb),\n        c = this;\n\n    b.predicate = function (b) {\n      return b.toNode !== c ? !1 : null === a ? !0 : b.toPortId === a;\n    };\n\n    return b;\n  };\n\n  t.wu = function (a) {\n    void 0 === a && (a = null);\n\n    for (var b = null, c = null, d = this.jb.iterator; d.next();) {\n      var e = d.value;\n\n      if (e.fromNode === this) {\n        if (null === a || e.fromPortId === a) e = e.toNode, null !== b ? b.add(e) : null !== c && c !== e ? (b = new G(), b.add(c), b.add(e)) : c = e;\n      } else e.toNode !== this || null !== a && e.toPortId !== a || (e = e.fromNode, null !== b ? b.add(e) : null !== c && c !== e ? (b = new G(), b.add(c), b.add(e)) : c = e);\n    }\n\n    return null !== b ? b.iterator : null !== c ? new $a(c) : Za;\n  };\n\n  t.yu = function (a) {\n    void 0 === a && (a = null);\n\n    for (var b = null, c = null, d = this.jb.iterator; d.next();) {\n      var e = d.value;\n      e.fromNode !== this || null !== a && e.fromPortId !== a || (e = e.toNode, null !== b ? b.add(e) : null !== c && c !== e ? (b = new G(), b.add(c), b.add(e)) : c = e);\n    }\n\n    return null !== b ? b.iterator : null !== c ? new $a(c) : Za;\n  };\n\n  t.xu = function (a) {\n    void 0 === a && (a = null);\n\n    for (var b = null, c = null, d = this.jb.iterator; d.next();) {\n      var e = d.value;\n      e.toNode !== this || null !== a && e.toPortId !== a || (e = e.fromNode, null !== b ? b.add(e) : null !== c && c !== e ? (b = new G(), b.add(c), b.add(e)) : c = e);\n    }\n\n    return null !== b ? b.iterator : null !== c ? new $a(c) : Za;\n  };\n\n  t.Sy = function (a, b, c) {\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    var d = new ab(this.jb),\n        e = this;\n\n    d.predicate = function (d) {\n      return (d.fromNode !== e || d.toNode !== a || null !== b && d.fromPortId !== b || null !== c && d.toPortId !== c) && (d.fromNode !== a || d.toNode !== e || null !== c && d.fromPortId !== c || null !== b && d.toPortId !== b) ? !1 : !0;\n    };\n\n    return d;\n  };\n\n  t.Ty = function (a, b, c) {\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    var d = new ab(this.jb),\n        e = this;\n\n    d.predicate = function (d) {\n      return d.fromNode !== e || d.toNode !== a || null !== b && d.fromPortId !== b || null !== c && d.toPortId !== c ? !1 : !0;\n    };\n\n    return d;\n  };\n\n  function $o(a, b, c) {\n    Yo(c);\n    var d = a.jb.contains(b);\n    d || a.jb.add(b);\n\n    if (!d || b.fromNode === b.toNode) {\n      var e = a.linkConnected;\n\n      if (null !== e) {\n        var f = !0,\n            g = a.diagram;\n        null !== g && (f = g.$, g.$ = !0);\n        e(a, b, c);\n        null !== g && (g.$ = f);\n      }\n    }\n\n    !d && b.isTreeLink && (c = b.fromNode, b = b.toNode, null !== c && null !== b && c !== b && (d = !0, a = a.diagram, null !== a && (d = a.isTreePathToChildren), e = d ? b : c, f = d ? c : b, e.Rg || (e.Rg = f), !f.isTreeLeaf || null !== a && a.undoManager.isUndoingRedoing || (d ? c === f && (f.isTreeLeaf = !1) : b === f && (f.isTreeLeaf = !1))));\n  }\n\n  function ap(a, b, c) {\n    Yo(c);\n    var d = a.jb.remove(b),\n        e = null;\n\n    if (d || b.toNode === b.fromNode) {\n      var f = a.linkDisconnected;\n      e = a.diagram;\n\n      if (null !== f) {\n        var g = !0;\n        null !== e && (g = e.$, e.$ = !0);\n        f(a, b, c);\n        null !== e && (e.$ = g);\n      }\n    }\n\n    d && b.isTreeLink && (c = !0, null !== e && (c = e.isTreePathToChildren), a = c ? b.toNode : b.fromNode, b = c ? b.fromNode : b.toNode, null !== a && (a.Rg = !1), null === b || b.isTreeLeaf || (0 === b.jb.count ? (b.Rg = null, null !== e && e.undoManager.isUndoingRedoing || (b.isTreeLeaf = !0)) : Bk(b)));\n  }\n\n  function Bk(a) {\n    a.Rg = !1;\n\n    if (0 !== a.jb.count) {\n      var b = !0,\n          c = a.diagram;\n\n      if (null === c || !c.undoManager.isUndoingRedoing) {\n        null !== c && (b = c.isTreePathToChildren);\n\n        for (c = a.jb.iterator; c.next();) {\n          var d = c.value;\n          if (d.isTreeLink) if (b) {\n            if (d.fromNode === a) {\n              a.isTreeLeaf = !1;\n              return;\n            }\n          } else if (d.toNode === a) {\n            a.isTreeLeaf = !1;\n            return;\n          }\n        }\n\n        a.isTreeLeaf = !0;\n      }\n    }\n  }\n\n  V.prototype.updateRelationshipsFromData = function () {\n    var a = this.diagram;\n    null !== a && a.partManager.updateRelationshipsFromData(this);\n  };\n\n  t = V.prototype;\n\n  t.yo = function (a) {\n    U.prototype.yo.call(this, a);\n    a || (Bk(this), a = this.Nk, null !== a && bp(a, this));\n  };\n\n  t.zo = function (a) {\n    U.prototype.zo.call(this, a);\n    a || (a = this.Nk, null !== a && null !== a.rd && (a.rd.remove(this), a.w()));\n  };\n\n  t.Fj = function () {\n    if (0 < this.jb.count) {\n      var a = this.diagram;\n      if (null !== a) for (var b = null !== a.commandHandler ? a.commandHandler.deletesConnectedLinks : !0, c = this.jb.copy().iterator; c.next();) {\n        var d = c.value;\n        b ? a.remove(d) : (d.fromNode === this && (d.fromNode = null), d.toNode === this && (d.toNode = null));\n      }\n    }\n\n    this.labeledLink = null;\n    U.prototype.Fj.call(this);\n  };\n\n  t.Kr = function (a) {\n    if (null === this.sc) {\n      if (\"\" === a && !1 === this.He) return this;\n      cp(this);\n    }\n\n    var b = this.sc.I(a);\n    return null !== b || \"\" !== a && (b = this.sc.I(\"\"), null !== b) ? b : this;\n  };\n\n  function cp(a) {\n    null === a.sc ? a.sc = new pb() : a.sc.clear();\n    a.$l(a, function (a, c) {\n      Ql(a, c);\n    });\n    0 === a.sc.count && a.sc.add(\"\", a);\n  }\n\n  function Ql(a, b) {\n    var c = b.portId;\n    null !== c && null !== a.sc && a.sc.add(c, b);\n  }\n\n  function Pl(a, b, c) {\n    var d = b.portId;\n\n    if (null !== d && (null !== a.sc && a.sc.remove(d), b = a.diagram, null !== b && c)) {\n      c = null;\n\n      for (a = a.findLinksConnected(d); a.next();) {\n        d = a.value, null === c && (c = Ea()), c.push(d);\n      }\n\n      if (null !== c) {\n        for (a = 0; a < c.length; a++) {\n          b.remove(c[a]);\n        }\n\n        Ga(c);\n      }\n    }\n  }\n\n  t.wz = function (a) {\n    if (null === a || a === this) return !1;\n    var b = !0,\n        c = this.diagram;\n    null !== c && (b = c.isTreePathToChildren);\n    c = this;\n    if (b) for (; c !== a;) {\n      b = null;\n\n      for (var d = c.jb.iterator; d.next();) {\n        var e = d.value;\n        if (e.isTreeLink && (b = e.fromNode, b !== c && b !== this)) break;\n      }\n\n      if (b === this || null === b || b === c) return !1;\n      c = b;\n    } else for (; c !== a;) {\n      b = null;\n\n      for (d = c.jb.iterator; d.next() && (e = d.value, !e.isTreeLink || (b = e.toNode, b === c || b === this));) {\n        ;\n      }\n\n      if (b === this || null === b || b === c) return !1;\n      c = b;\n    }\n    return !0;\n  };\n\n  t.ez = function () {\n    var a = !0,\n        b = this.diagram;\n    null !== b && (a = b.isTreePathToChildren);\n    b = this;\n    if (a) for (;;) {\n      a = null;\n\n      for (var c = b.jb.iterator; c.next();) {\n        var d = c.value;\n        if (d.isTreeLink && (a = d.fromNode, a !== b && a !== this)) break;\n      }\n\n      if (a === this) return this;\n      if (null === a || a === b) return b;\n      b = a;\n    } else for (;;) {\n      a = null;\n\n      for (c = b.jb.iterator; c.next() && (d = c.value, !d.isTreeLink || (a = d.toNode, a === b || a === this));) {\n        ;\n      }\n\n      if (a === this) return this;\n      if (null === a || a === b) return b;\n      b = a;\n    }\n  };\n\n  t.Py = function (a) {\n    if (null === a) return null;\n    if (this === a) return this;\n\n    for (var b = this; null !== b;) {\n      Lo(b, !0), b = b.ig();\n    }\n\n    var c = null;\n\n    for (b = a; null !== b;) {\n      if (0 !== (b.G & 1048576)) {\n        c = b;\n        break;\n      }\n\n      b = b.ig();\n    }\n\n    for (b = this; null !== b;) {\n      Lo(b, !1), b = b.ig();\n    }\n\n    return c;\n  };\n\n  t.$g = function () {\n    var a = !0,\n        b = this.diagram;\n    null !== b && (a = b.isTreePathToChildren);\n    b = this.jb.iterator;\n    if (a) for (; b.next();) {\n      if (a = b.value, a.isTreeLink && a.fromNode !== this) return a;\n    } else for (; b.next();) {\n      if (a = b.value, a.isTreeLink && a.toNode !== this) return a;\n    }\n    return null;\n  };\n\n  t.ig = function () {\n    var a = this.Rg;\n    if (null === a) return null;\n    if (a instanceof V) return a;\n    var b = !0;\n    a = this.diagram;\n    null !== a && (b = a.isTreePathToChildren);\n    a = this.jb.iterator;\n    if (b) for (; a.next();) {\n      if (b = a.value, b.isTreeLink && (b = b.fromNode, b !== this)) return this.Rg = b;\n    } else for (; a.next();) {\n      if (b = a.value, b.isTreeLink && (b = b.toNode, b !== this)) return this.Rg = b;\n    }\n    return this.Rg = null;\n  };\n\n  t.cz = function () {\n    function a(b, d) {\n      d.add(b);\n      var c = b.$g();\n      null !== c && (d.add(c), b = b.ig(), null !== b && a(b, d));\n    }\n\n    var b = new G();\n    a(this, b);\n    return b;\n  };\n\n  t.bz = function () {\n    return dp(this, this);\n  };\n\n  function dp(a, b) {\n    b = b.ig();\n    return null === b ? 0 : 1 + dp(a, b);\n  }\n\n  t.to = function () {\n    var a = !0,\n        b = this.diagram;\n    null !== b && (a = b.isTreePathToChildren);\n    b = new ab(this.jb);\n    var c = this;\n    b.predicate = a ? function (a) {\n      return a.isTreeLink && a.fromNode === c ? !0 : !1;\n    } : function (a) {\n      return a.isTreeLink && a.toNode === c ? !0 : !1;\n    };\n    return b;\n  };\n\n  t.Au = function () {\n    var a = !0,\n        b = this.diagram;\n    null !== b && (a = b.isTreePathToChildren);\n    var c = b = null,\n        d = this.jb.iterator;\n    if (a) for (; d.next();) {\n      a = d.value, a.isTreeLink && a.fromNode === this && (a = a.toNode, null !== b ? b.add(a) : null !== c && c !== a ? (b = new E(), b.add(c), b.add(a)) : c = a);\n    } else for (; d.next();) {\n      a = d.value, a.isTreeLink && a.toNode === this && (a = a.fromNode, null !== b ? b.add(a) : null !== c && c !== a ? (b = new E(), b.add(c), b.add(a)) : c = a);\n    }\n    return null !== b ? b.iterator : null !== c ? new $a(c) : Za;\n  };\n\n  t.dz = function (a) {\n    void 0 === a && (a = Infinity);\n    var b = new G();\n    Rk(b, this, !1, a, !0);\n    return b;\n  };\n\n  V.prototype.collapseTree = function (a) {\n    void 0 === a && (a = 1);\n    1 > a && (a = 1);\n    var b = this.diagram;\n\n    if (null !== b && !b.Ie) {\n      b.Ie = !0;\n      var c = new G();\n      c.add(this);\n      ep(this, c, b.isTreePathToChildren, a, b, this, b.treeCollapsePolicy === vi);\n      b.Ie = !1;\n    }\n  };\n\n  function ep(a, b, c, d, e, f, g) {\n    if (1 < d) for (var h = c ? a.ro() : a.Kd(); h.next();) {\n      var k = h.value;\n      k.isTreeLink && (k = k.wo(a), null === k || k === a || b.contains(k) || (b.add(k), ep(k, b, c, d - 1, e, f, g)));\n    } else fp(a, b, c, e, f, g);\n  }\n\n  function fp(a, b, c, d, e, f) {\n    for (var g = e === a ? !0 : a.isTreeExpanded, h = c ? a.ro() : a.Kd(); h.next();) {\n      var k = h.value;\n\n      if (k.isTreeLink && (k = k.wo(a), null !== k && k !== a)) {\n        var l = b.contains(k);\n        l || b.add(k);\n        g && (f && d.vj(k, e), k.dh(), k.Ub(!1));\n        k.isTreeExpanded && (k.wasTreeExpanded = k.isTreeExpanded, l || fp(k, b, c, d, e, f));\n      }\n    }\n\n    a.isTreeExpanded = !1;\n  }\n\n  V.prototype.expandTree = function (a) {\n    void 0 === a && (a = 2);\n    2 > a && (a = 2);\n    var b = this.diagram;\n\n    if (null !== b && !b.Ie) {\n      b.Ie = !0;\n      var c = new G();\n      c.add(this);\n      gp(this, c, b.isTreePathToChildren, a, b, this, b.treeCollapsePolicy === vi);\n      b.Ie = !1;\n    }\n  };\n\n  function gp(a, b, c, d, e, f, g) {\n    for (var h = f === a ? !1 : a.isTreeExpanded, k = c ? a.ro() : a.Kd(); k.next();) {\n      var l = k.value;\n      l.isTreeLink && (h || l.xd || l.ab(), l = l.wo(a), null !== l && l !== a && !b.contains(l) && (b.add(l), h || (l.Ub(!0), l.dh(), g && e.xj(l, f)), 2 < d || l.wasTreeExpanded)) && (l.wasTreeExpanded = !1, gp(l, b, c, d - 1, e, f, g));\n    }\n\n    a.isTreeExpanded = !0;\n  }\n\n  ma.Object.defineProperties(V.prototype, {\n    portSpreading: {\n      get: function get() {\n        return null !== this.ya ? this.ya.Dq : Uo;\n      },\n      set: function set(a) {\n        var b = this.portSpreading;\n        b !== a && (Vo(this), this.ya.Dq = a, this.g(\"portSpreading\", b, a), a = this.diagram, null !== a && a.undoManager.isUndoingRedoing || this.vd());\n      }\n    },\n    avoidable: {\n      get: function get() {\n        return 0 !== (this.U & 8);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.U & 8);\n\n        if (b !== a) {\n          this.U ^= 8;\n          var c = this.diagram;\n          null !== c && kk(c, this);\n          this.g(\"avoidable\", b, a);\n        }\n      }\n    },\n    avoidableMargin: {\n      get: function get() {\n        return null !== this.ya ? this.ya.ap : rc;\n      },\n      set: function set(a) {\n        \"number\" === typeof a && (a = new ec(a));\n        var b = this.avoidableMargin;\n\n        if (!b.C(a)) {\n          a = a.J();\n          Vo(this);\n          this.ya.ap = a;\n          var c = this.diagram;\n          null !== c && kk(c, this);\n          this.g(\"avoidableMargin\", b, a);\n        }\n      }\n    },\n    linksConnected: {\n      get: function get() {\n        return this.jb.iterator;\n      }\n    },\n    linkConnected: {\n      get: function get() {\n        return null !== this.ya ? this.ya.cq : null;\n      },\n      set: function set(a) {\n        var b = this.linkConnected;\n        b !== a && (Vo(this), this.ya.cq = a, this.g(\"linkConnected\", b, a));\n      }\n    },\n    linkDisconnected: {\n      get: function get() {\n        return null !== this.ya ? this.ya.eq : null;\n      },\n      set: function set(a) {\n        var b = this.linkDisconnected;\n        b !== a && (Vo(this), this.ya.eq = a, this.g(\"linkDisconnected\", b, a));\n      }\n    },\n    linkValidation: {\n      get: function get() {\n        return null !== this.ya ? this.ya.bj : null;\n      },\n      set: function set(a) {\n        var b = this.linkValidation;\n        b !== a && (Vo(this), this.ya.bj = a, this.g(\"linkValidation\", b, a));\n      }\n    },\n    isLinkLabel: {\n      get: function get() {\n        return null !== this.Nk;\n      }\n    },\n    labeledLink: {\n      get: function get() {\n        return this.Nk;\n      },\n      set: function set(a) {\n        var b = this.Nk;\n\n        if (b !== a) {\n          var c = this.diagram,\n              d = this.data;\n\n          if (null !== b) {\n            null !== b.rd && (b.rd.remove(this), b.w());\n\n            if (null !== c && null !== d && !c.undoManager.isUndoingRedoing) {\n              var e = b.data,\n                  f = c.model;\n\n              if (null !== e && f.ki()) {\n                var g = f.ua(d);\n                void 0 !== g && f.xx(e, g);\n              }\n            }\n\n            this.containingGroup = null;\n          }\n\n          this.Nk = a;\n          null !== a && (bp(a, this), null === c || null === d || c.undoManager.isUndoingRedoing || (e = a.data, c = c.model, null !== e && c.ki() && (d = c.ua(d), void 0 !== d && c.hu(e, d))), this.containingGroup = a.containingGroup);\n          zl(this);\n          this.g(\"labeledLink\", b, a);\n        }\n      }\n    },\n    port: {\n      get: function get() {\n        return this.Kr(\"\");\n      }\n    },\n    ports: {\n      get: function get() {\n        null === this.sc && cp(this);\n        return this.sc.iteratorValues;\n      }\n    },\n    isTreeExpanded: {\n      get: function get() {\n        return 0 !== (this.U & 1);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.U & 1);\n\n        if (b !== a) {\n          this.U ^= 1;\n          var c = this.diagram;\n          this.g(\"isTreeExpanded\", b, a);\n          b = this.treeExpandedChanged;\n\n          if (null !== b) {\n            var d = !0;\n            null !== c && (d = c.$, c.$ = !0);\n            b(this);\n            null !== c && (c.$ = d);\n          }\n\n          null !== c && c.undoManager.isUndoingRedoing ? this.Ub(a) : a ? this.expandTree() : this.collapseTree();\n        }\n      }\n    },\n    wasTreeExpanded: {\n      get: function get() {\n        return 0 !== (this.U & 2);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.U & 2);\n        b !== a && (this.U ^= 2, this.g(\"wasTreeExpanded\", b, a));\n      }\n    },\n    treeExpandedChanged: {\n      get: function get() {\n        return null !== this.ya ? this.ya.ur : null;\n      },\n      set: function set(a) {\n        var b = this.treeExpandedChanged;\n        b !== a && (Vo(this), this.ya.ur = a, this.g(\"treeExpandedChanged\", b, a));\n      }\n    },\n    isTreeLeaf: {\n      get: function get() {\n        return 0 !== (this.U & 4);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.U & 4);\n        b !== a && (this.U ^= 4, this.g(\"isTreeLeaf\", b, a));\n      }\n    }\n  });\n  V.prototype.expandTree = V.prototype.expandTree;\n  V.prototype.collapseTree = V.prototype.collapseTree;\n  V.prototype.findTreeParts = V.prototype.dz;\n  V.prototype.findTreeChildrenNodes = V.prototype.Au;\n  V.prototype.findTreeChildrenLinks = V.prototype.to;\n  V.prototype.findTreeLevel = V.prototype.bz;\n  V.prototype.findTreeParentChain = V.prototype.cz;\n  V.prototype.findTreeParentNode = V.prototype.ig;\n  V.prototype.findTreeParentLink = V.prototype.$g;\n  V.prototype.findCommonTreeParent = V.prototype.Py;\n  V.prototype.findTreeRoot = V.prototype.ez;\n  V.prototype.isInTreeOf = V.prototype.wz;\n  V.prototype.findPort = V.prototype.Kr;\n  V.prototype.findLinksTo = V.prototype.Ty;\n  V.prototype.findLinksBetween = V.prototype.Sy;\n  V.prototype.findNodesInto = V.prototype.xu;\n  V.prototype.findNodesOutOf = V.prototype.yu;\n  V.prototype.findNodesConnected = V.prototype.wu;\n  V.prototype.findLinksInto = V.prototype.Kd;\n  V.prototype.findLinksOutOf = V.prototype.ro;\n  V.prototype.findExternalTreeLinksConnected = V.prototype.Tw;\n  V.prototype.invalidateConnectedLinks = V.prototype.vd;\n  V.prototype.invalidateLinkBundle = V.prototype.uz;\n  var hp = new D(V, \"SpreadingNone\", 10),\n      Uo = new D(V, \"SpreadingEvenly\", 11),\n      ip = new D(V, \"SpreadingPacked\", 12);\n  V.className = \"Node\";\n  V.SpreadingNone = hp;\n  V.SpreadingEvenly = Uo;\n  V.SpreadingPacked = ip;\n\n  function qf(a, b) {\n    void 0 === a || a instanceof Kl || \"string\" === typeof a ? V.call(this, a) : (V.call(this), a && (b = a));\n    this.U |= 4608;\n    this.on = new G();\n    this.Xa = null;\n    this.Kc = new qi();\n    this.Kc.group = this;\n    this.Vk = new G();\n    this.ib = this.Dp = null;\n    b && Object.assign(this, b);\n  }\n\n  la(qf, V);\n\n  qf.prototype.cloneProtected = function (a) {\n    V.prototype.cloneProtected.call(this, a);\n    this.U = this.U & -32769;\n    var b = a.vl(function (a) {\n      return a instanceof jg;\n    });\n    b instanceof jg ? a.Xa = b : a.Xa = null;\n    null !== this.Kc ? (a.Kc = this.Kc.copy(), a.Kc.group = a) : (null !== a.Kc && (a.Kc.group = null), a.Kc = null);\n    null !== this.ib && (a.ib = this.ib.copy());\n  };\n\n  t = qf.prototype;\n\n  t.qf = function (a) {\n    V.prototype.qf.call(this, a);\n    var b = a.Jj();\n\n    for (a = a.memberParts; a.next();) {\n      var c = a.value;\n      c.w();\n      c.D(8);\n      c.zj();\n      if (c instanceof V) c.vd(b);else if (c instanceof T) for (c = c.labelNodes; c.next();) {\n        c.value.vd(b);\n      }\n    }\n  };\n\n  t.$j = function (a, b, c, d, e, f, g) {\n    if (a === fe && \"elements\" === b) {\n      if (e instanceof jg) null === this.Xa ? this.Xa = e : this.Xa !== e && C(\"Cannot insert a second Placeholder into the visual tree of a Group.\");else {\n        if (e instanceof W) {\n          var h = e.vl(function (a) {\n            return a instanceof jg;\n          });\n          h instanceof jg && (null === this.Xa ? this.Xa = h : this.Xa !== h && C(\"Cannot insert a second Placeholder into the visual tree of a Group.\"));\n        }\n      }\n    } else a === ge && \"elements\" === b && null !== this.Xa && (d === this.Xa ? this.Xa = null : d instanceof W && this.Xa.jg(d) && (this.Xa = null));\n    V.prototype.$j.call(this, a, b, c, d, e, f, g);\n  };\n\n  t.Fl = function (a, b) {\n    V.prototype.Fl.call(this, a, b);\n    this.isClipping && this.type !== W.Spot && this.isSubGraphExpanded && (a = this.resizeObject, a instanceof W && (a = a.vb()), null === this.ib && (this.ib = new M()), a.gi(this.ib), a instanceof Cf && this.ib.vc(-a.strokeWidth, -a.strokeWidth));\n  };\n\n  t.Vg = function (a, b, c, d) {\n    this.af = this.Xa;\n    V.prototype.Vg.call(this, a, b, c, d);\n  };\n\n  t.Za = function () {\n    var a = this;\n    a.isSubGraphExpanded && this.memberParts.each(function (b) {\n      !a.computesBoundsIncludingLinks && b instanceof T || b.Za();\n    });\n    V.prototype.Za.call(this);\n  };\n\n  t.mi = function () {\n    if (!V.prototype.mi.call(this)) return !1;\n\n    for (var a = this.memberParts; a.next();) {\n      var b = a.value;\n\n      if (b instanceof V) {\n        if (b.isVisible() && oj(b)) return !1;\n      } else if (b instanceof T && b.isVisible() && oj(b) && b.fromNode !== this && b.toNode !== this) return !1;\n    }\n\n    return !0;\n  };\n\n  function Mo(a, b) {\n    if (a.on.add(b)) {\n      b instanceof qf && a.Vk.add(b);\n      var c = a.memberAdded;\n\n      if (null !== c) {\n        var d = !0,\n            e = a.diagram;\n        null !== e && (d = e.$, e.$ = !0);\n        c(a, b);\n        null !== e && (e.$ = d);\n      }\n\n      a.isVisible() && a.isSubGraphExpanded || b.Ub(!1);\n    }\n\n    b instanceof T && !a.computesBoundsIncludingLinks || (b = a.Xa, null === b && (b = a), b.w());\n  }\n\n  function No(a, b) {\n    if (a.on.remove(b)) {\n      b instanceof qf && a.Vk.remove(b);\n      var c = a.memberRemoved;\n\n      if (null !== c) {\n        var d = !0,\n            e = a.diagram;\n        null !== e && (d = e.$, e.$ = !0);\n        c(a, b);\n        null !== e && (e.$ = d);\n      }\n\n      a.isVisible() && a.isSubGraphExpanded || b.Ub(!0);\n    }\n\n    b instanceof T && !a.computesBoundsIncludingLinks || (b = a.Xa, null === b && (b = a), b.w());\n  }\n\n  t.Fj = function () {\n    if (0 < this.on.count) {\n      var a = this.diagram;\n      if (null !== a) for (var b = this.on.copy().iterator; b.next();) {\n        a.remove(b.value);\n      }\n    }\n\n    V.prototype.Fj.call(this);\n  };\n\n  qf.prototype.canAddMembers = function (a) {\n    var b = this.diagram;\n    if (null === b) return !1;\n    b = b.commandHandler;\n\n    for (a = Tk(a).iterator; a.next();) {\n      if (!b.isValidMember(this, a.value)) return !1;\n    }\n\n    return !0;\n  };\n\n  qf.prototype.addMembers = function (a, b) {\n    var c = this.diagram;\n    if (null === c) return !1;\n    c = c.commandHandler;\n    var d = !0;\n\n    for (a = Tk(a).iterator; a.next();) {\n      var e = a.value;\n      !b || c.isValidMember(this, e) ? e.containingGroup = this : d = !1;\n    }\n\n    return d;\n  };\n\n  qf.prototype.canUngroup = function () {\n    if (!this.ungroupable) return !1;\n    var a = this.layer;\n    if (null === a || !a.allowUngroup) return !1;\n    a = a.diagram;\n    return null === a || a.allowUngroup ? !0 : !1;\n  };\n\n  t = qf.prototype;\n\n  t.vd = function (a) {\n    var b = 0 !== (this.U & 65536);\n    V.prototype.vd.call(this, a);\n    if (!b) for (0 !== (this.U & 65536) !== !0 && (this.U = this.U ^ 65536), b = this.vu(); b.next();) {\n      var c = b.value;\n\n      if (void 0 === a || !a.contains(c)) {\n        var d = c.fromNode;\n        null !== d && d !== this && d.Md(this) && !d.isVisible() ? (Yo(c.fromPort), Yo(c.toPort), c.ab()) : (d = c.toNode, null !== d && d !== this && d.Md(this) && !d.isVisible() && (Yo(c.fromPort), Yo(c.toPort), c.ab()));\n      }\n    }\n  };\n\n  t.vu = function () {\n    var a = null !== this.diagram && this.diagram.tw;\n    if (a && null !== this.Dp) return this.Dp.iterator;\n    var b = this.Jj();\n    b.add(this);\n\n    for (var c = new G(), d = b.iterator; d.next();) {\n      var e = d.value;\n      if (e instanceof V) for (e = e.linksConnected; e.next();) {\n        var f = e.value;\n        b.contains(f) || c.add(f);\n      }\n    }\n\n    a && (this.Dp = c);\n    return c.iterator;\n  };\n\n  t.Ry = function () {\n    var a = this.Jj();\n    a.add(this);\n\n    for (var b = new G(), c = a.iterator; c.next();) {\n      var d = c.value;\n      if (d instanceof V) for (d = d.linksConnected; d.next();) {\n        var e = d.value,\n            f = e.fromNode;\n        null === f || a.contains(f) && f !== this || b.add(f);\n        e = e.toNode;\n        null === e || a.contains(e) && e !== this || b.add(e);\n      }\n    }\n\n    return b.iterator;\n  };\n\n  t.Qy = function () {\n    function a(b, d) {\n      null !== b && (d.add(b), a(b.containingGroup, d));\n    }\n\n    var b = new G();\n    a(this, b);\n    return b;\n  };\n\n  t.Jj = function () {\n    var a = new G();\n    Rk(a, this, !0, 0, !0);\n    a.remove(this);\n    return a;\n  };\n\n  t.Ub = function (a) {\n    V.prototype.Ub.call(this, a);\n\n    for (var b = this.memberParts; b.next();) {\n      b.value.Ub(a);\n    }\n  };\n\n  qf.prototype.collapseSubGraph = function () {\n    var a = this.diagram;\n\n    if (null !== a && !a.Ie) {\n      a.Ie = !0;\n      var b = this.Jj();\n      jp(this, b, a, this);\n      a.Ie = !1;\n    }\n  };\n\n  function jp(a, b, c, d) {\n    for (var e = a.memberParts; e.next();) {\n      var f = e.value;\n      f.Ub(!1);\n      f instanceof qf && f.isSubGraphExpanded && (f.wasSubGraphExpanded = f.isSubGraphExpanded, jp(f, b, c, d));\n      if (f instanceof V) f.vd(b), c.vj(f, d);else if (f instanceof T) for (f = f.labelNodes; f.next();) {\n        f.value.vd(b);\n      }\n    }\n\n    a.isSubGraphExpanded = !1;\n  }\n\n  qf.prototype.expandSubGraph = function () {\n    var a = this.diagram;\n\n    if (null !== a && !a.Ie) {\n      a.Ie = !0;\n      var b = this.Jj();\n      kp(this, b, a, this);\n      a.Ie = !1;\n    }\n  };\n\n  function kp(a, b, c, d) {\n    for (var e = a.memberParts; e.next();) {\n      var f = e.value;\n      f.Ub(!0);\n      f instanceof qf && f.wasSubGraphExpanded && (f.wasSubGraphExpanded = !1, kp(f, b, c, d));\n      if (f instanceof V) f.vd(b), c.xj(f, d);else if (f instanceof T) for (f = f.labelNodes; f.next();) {\n        f.value.vd(b);\n      }\n    }\n\n    a.isSubGraphExpanded = !0;\n  }\n\n  qf.prototype.move = function (a, b) {\n    void 0 === b && (b = !1);\n    var c = b ? this.location : this.position,\n        d = c.x;\n    c = c.y;\n    var e = a.x,\n        f = a.y;\n\n    if (!(d === e || isNaN(d) && isNaN(e)) || !(c === f || isNaN(c) && isNaN(f))) {\n      d = e - (isNaN(d) ? 0 : d);\n      c = f - (isNaN(c) ? 0 : c);\n      f = I.alloc();\n      V.prototype.move.call(this, a, b);\n      a = new G();\n\n      for (b = this.Jj().iterator; b.next();) {\n        if (e = b.value, e instanceof T && (e.suspendsRouting && a.add(e), e.xd || e.fromNode !== this && e.toNode !== this)) e.suspendsRouting = !0;\n      }\n\n      for (b.reset(); b.next();) {\n        if (e = b.value, !(e.eh() || e instanceof V && e.isLinkLabel)) {\n          var g = e.position,\n              h = e.location;\n          g.v() ? (f.x = g.x + d, f.y = g.y + c, e.position = f) : h.v() && (f.x = h.x + d, f.y = h.y + c, e.location = f);\n        }\n      }\n\n      for (b.reset(); b.next();) {\n        if (e = b.value, e instanceof T && (e.suspendsRouting = a.contains(e), e.xd || e.fromNode !== this && e.toNode !== this)) g = e.position, f.x = g.x + d, f.y = g.y + c, f.v() ? e.move(f) : e.ab(), Lj(e) && e.ab();\n      }\n\n      I.free(f);\n    }\n  };\n\n  ma.Object.defineProperties(qf.prototype, {\n    placeholder: {\n      get: function get() {\n        return this.Xa;\n      }\n    },\n    computesBoundsAfterDrag: {\n      get: function get() {\n        return 0 !== (this.U & 2048);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.U & 2048);\n        b !== a && (this.U ^= 2048, this.g(\"computesBoundsAfterDrag\", b, a));\n      }\n    },\n    computesBoundsIncludingLinks: {\n      get: function get() {\n        return 0 !== (this.U & 4096);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.U & 4096);\n        b !== a && (this.U ^= 4096, this.g(\"computesBoundsIncludingLinks\", b, a));\n      }\n    },\n    computesBoundsIncludingLocation: {\n      get: function get() {\n        return 0 !== (this.U & 8192);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.U & 8192);\n        b !== a && (this.U ^= 8192, this.g(\"computesBoundsIncludingLocation\", b, a));\n      }\n    },\n    handlesDragDropForMembers: {\n      get: function get() {\n        return 0 !== (this.U & 16384);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.U & 16384);\n        b !== a && (this.U ^= 16384, this.g(\"handlesDragDropForMembers\", b, a));\n      }\n    },\n    memberParts: {\n      get: function get() {\n        return this.on.iterator;\n      }\n    },\n    layout: {\n      get: function get() {\n        return this.Kc;\n      },\n      set: function set(a) {\n        var b = this.Kc;\n\n        if (b !== a) {\n          null !== a && null !== a.diagram && a.diagram.layout === a && C(\"A layout cannot be both the Diagram.layout and a Group.layout: \" + a);\n          null !== b && (b.diagram = null, b.group = null);\n          this.Kc = a;\n          var c = this.diagram;\n          null !== a && (a.diagram = c, a.group = this);\n          null !== c && (c.mh = !0);\n          this.g(\"layout\", b, a);\n          null !== c && c.Mb();\n        }\n      }\n    },\n    memberAdded: {\n      get: function get() {\n        return null !== this.ya ? this.ya.lq : null;\n      },\n      set: function set(a) {\n        var b = this.memberAdded;\n        b !== a && (Vo(this), this.ya.lq = a, this.g(\"memberAdded\", b, a));\n      }\n    },\n    memberRemoved: {\n      get: function get() {\n        return null !== this.ya ? this.ya.mq : null;\n      },\n      set: function set(a) {\n        var b = this.memberRemoved;\n        b !== a && (Vo(this), this.ya.mq = a, this.g(\"memberRemoved\", b, a));\n      }\n    },\n    memberValidation: {\n      get: function get() {\n        return null !== this.ya ? this.ya.dj : null;\n      },\n      set: function set(a) {\n        var b = this.memberValidation;\n        b !== a && (Vo(this), this.ya.dj = a, this.g(\"memberValidation\", b, a));\n      }\n    },\n    ungroupable: {\n      get: function get() {\n        return 0 !== (this.U & 256);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.U & 256);\n        b !== a && (this.U ^= 256, this.g(\"ungroupable\", b, a));\n      }\n    },\n    isSubGraphExpanded: {\n      get: function get() {\n        return 0 !== (this.U & 512);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.U & 512);\n\n        if (b !== a) {\n          this.U ^= 512;\n          var c = this.diagram;\n          this.g(\"isSubGraphExpanded\", b, a);\n          b = this.subGraphExpandedChanged;\n\n          if (null !== b) {\n            var d = !0;\n            null !== c && (d = c.$, c.$ = !0);\n            b(this);\n            null !== c && (c.$ = d);\n          }\n\n          null !== c && c.undoManager.isUndoingRedoing ? (null !== this.Xa && this.Xa.w(), this.memberParts.each(function (a) {\n            a.updateAdornments();\n          })) : a ? this.expandSubGraph() : this.collapseSubGraph();\n        }\n      }\n    },\n    wasSubGraphExpanded: {\n      get: function get() {\n        return 0 !== (this.U & 1024);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.U & 1024);\n        b !== a && (this.U ^= 1024, this.g(\"wasSubGraphExpanded\", b, a));\n      }\n    },\n    subGraphExpandedChanged: {\n      get: function get() {\n        return null !== this.ya ? this.ya.gr : null;\n      },\n      set: function set(a) {\n        var b = this.subGraphExpandedChanged;\n        b !== a && (Vo(this), this.ya.gr = a, this.g(\"subGraphExpandedChanged\", b, a));\n      }\n    },\n    gh: {\n      get: function get() {\n        return 0 !== (this.U & 32768);\n      },\n      set: function set(a) {\n        0 !== (this.U & 32768) !== a && (this.U ^= 32768);\n      }\n    }\n  });\n  qf.prototype.expandSubGraph = qf.prototype.expandSubGraph;\n  qf.prototype.collapseSubGraph = qf.prototype.collapseSubGraph;\n  qf.prototype.findSubGraphParts = qf.prototype.Jj;\n  qf.prototype.findContainingGroupChain = qf.prototype.Qy;\n  qf.prototype.findExternalNodesConnected = qf.prototype.Ry;\n  qf.prototype.findExternalLinksConnected = qf.prototype.vu;\n  qf.prototype.ensureBounds = qf.prototype.Za;\n  qf.className = \"Group\";\n\n  function jg(a) {\n    Y.call(this);\n    this.ub = qc;\n    this.Nn = new M(NaN, NaN, NaN, NaN);\n    a && Object.assign(this, a);\n  }\n\n  la(jg, Y);\n\n  jg.prototype.cloneProtected = function (a) {\n    Y.prototype.cloneProtected.call(this, a);\n    a.ub = this.ub.J();\n    a.Nn = this.Nn.copy();\n  };\n\n  jg.prototype.Xg = function (a) {\n    if (null === this.background && null === this.areaBackground) return !1;\n    var b = this.naturalBounds;\n    return $b(0, 0, b.width, b.height, a.x, a.y);\n  };\n\n  jg.prototype.El = function () {\n    var a = this.part;\n    null !== a && (a instanceof qf || a instanceof ue) || C(\"Placeholder is not inside a Group or Adornment.\");\n\n    if (a instanceof qf) {\n      var b = this.computeBorder(this.Nn),\n          c = this.minSize,\n          d = this.bc;\n      Qb(d, (isFinite(c.width) ? Math.max(c.width, b.width) : b.width) || 0, (isFinite(c.height) ? Math.max(c.height, b.height) : b.height) || 0);\n      this.ve(0, 0, d.width, d.height);\n      d = a.memberParts;\n\n      for (c = !1; d.next();) {\n        if (d.value.isVisible()) {\n          c = !0;\n          break;\n        }\n      }\n\n      d = a.diagram;\n      !c || null === d || d.animationManager.Ju(a) || isNaN(b.x) || isNaN(b.y) || (c = I.alloc(), c.oi(b, a.locationSpot), c.C(a.location) || (a.location = c), I.free(c));\n    } else {\n      b = this.bc;\n      c = this.ub;\n      d = c.left + c.right;\n      var e = c.top + c.bottom,\n          f = a.adornedObject;\n      a.angle = f.fi();\n      var g = 0;\n      f instanceof Cf && (g = f.strokeWidth);\n      var h = f.uf(),\n          k = f.naturalBounds,\n          l = (k.width + g) * h;\n      g = (k.height + g) * h;\n      a.type !== W.Link && (h = f.ia(\"Selection\" === a.category ? tc : a.locationSpot, I.alloc()), a.location = h, I.free(h));\n      isNaN(l) || isNaN(g) ? (a = f.ia(tc, I.alloc()), l = M.allocAt(a.x, a.y, 0, 0), l.Me(f.ia(Cc, a)), l.Me(f.ia(vc, a)), l.Me(f.ia(Ac, a)), Qb(b, l.width + d || 0, l.height + e || 0), this.ve(-c.left, -c.top, b.width, b.height), I.free(a), M.free(l)) : (Qb(b, l + d || 0, g + e || 0), this.ve(-c.left, -c.top, b.width, b.height));\n    }\n  };\n\n  jg.prototype.Vg = function (a, b, c, d) {\n    this.actualBounds.h(a, b, c, d);\n  };\n\n  jg.prototype.computeBorder = function (a) {\n    var b = this.part,\n        c = b.diagram;\n\n    if (null !== c && b instanceof qf && !b.layer.isTemporary && b.computesBoundsAfterDrag && this.Nn.v()) {\n      var d = c.toolManager.findTool(\"Dragging\");\n      if (d === c.currentTool && (c = d.computeBorder(b, this.Nn, a), null !== c)) return c;\n    }\n\n    c = M.alloc();\n    d = this.computeMemberBounds(c);\n    var e = this.ub;\n    b instanceof qf && !b.isSubGraphExpanded ? a.h(d.x - e.left, d.y - e.top, 0, 0) : a.h(d.x - e.left, d.y - e.top, Math.max(d.width + e.left + e.right, 0), Math.max(d.height + e.top + e.bottom, 0));\n    M.free(c);\n    b instanceof qf && b.computesBoundsIncludingLocation && b.location.v() && a.Me(b.location);\n    return a;\n  };\n\n  jg.prototype.computeMemberBounds = function (a) {\n    if (!(this.part instanceof qf)) return a.h(0, 0, 0, 0), a;\n\n    for (var b = this.part, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = b.memberParts; g.next();) {\n      var h = g.value;\n\n      if (h.isVisible()) {\n        if (h instanceof T) {\n          if (!b.computesBoundsIncludingLinks) continue;\n          if (nj(h)) continue;\n          if (h.fromNode === b || h.toNode === b) continue;\n        }\n\n        h = h.actualBounds;\n        h.left < c && (c = h.left);\n        h.top < d && (d = h.top);\n        h.right > e && (e = h.right);\n        h.bottom > f && (f = h.bottom);\n      }\n    }\n\n    isFinite(c) && isFinite(d) ? a.h(c, d, e - c, f - d) : (b = b.location, a.h(b.x, b.y, 0, 0));\n    return a;\n  };\n\n  ma.Object.defineProperties(jg.prototype, {\n    padding: {\n      get: function get() {\n        return this.ub;\n      },\n      set: function set(a) {\n        \"number\" === typeof a && (a = new ec(a));\n        var b = this.ub;\n        b.C(a) || (this.ub = a = a.J(), this.g(\"padding\", b, a), this.w());\n      }\n    }\n  });\n  jg.className = \"Placeholder\";\n\n  function T(a) {\n    U.call(this, W.Link);\n    this.Oa = 8;\n    this.Ue = null;\n    this.Ve = \"\";\n    this.hf = this.Om = null;\n    this.jf = \"\";\n    this.Xn = null;\n    this.dk = $f;\n    this.wm = 0;\n    this.ym = $f;\n    this.zm = NaN;\n    this.kj = lp;\n    this.Sn = .5;\n    this.rd = null;\n    this.Jb = new E().freeze();\n    this.ef = this.Eg = null;\n    this.bl = new M();\n    this.sa = new O();\n    this.u = this.m = this.If = this.Mf = null;\n    this.Yt = new I();\n    this.Gp = this.qw = this.pw = null;\n    this.Ys = NaN;\n    this.aa = null;\n    this.j = [];\n    a && Object.assign(this, a);\n  }\n\n  la(T, U);\n\n  T.prototype.cloneProtected = function (a) {\n    U.prototype.cloneProtected.call(this, a);\n    a.Oa = this.Oa & -113;\n    a.Ve = this.Ve;\n    a.Om = this.Om;\n    a.jf = this.jf;\n    a.Xn = this.Xn;\n    a.dk = this.dk;\n    a.wm = this.wm;\n    a.ym = this.ym;\n    a.zm = this.zm;\n    a.kj = this.kj;\n    a.Sn = this.Sn;\n    null !== this.aa && (a.aa = this.aa.copy());\n  };\n\n  t = T.prototype;\n\n  t.qf = function (a) {\n    U.prototype.qf.call(this, a);\n    this.Ve = a.Ve;\n    this.jf = a.jf;\n    a.Eg = null;\n    a.ab();\n    a.If = this.If;\n    var b = a.fromPort;\n    null !== b && Yo(b);\n    a = a.toPort;\n    null !== a && Yo(a);\n  };\n\n  t.ob = function (a) {\n    a.classType === T ? 2 === (a.value & 2) ? this.routing = a : a === cg || a === Zf || a === Yf ? this.curve = a : a === mp || a === np || a === op ? this.adjusting = a : a !== lp && a !== $f && C(\"Unknown Link enum value for a Link property: \" + a) : U.prototype.ob.call(this, a);\n  };\n\n  t.Rc = function () {\n    null === this.aa && (this.aa = new cl());\n  };\n\n  t.mi = function () {\n    var a = this.fromNode;\n\n    if (null !== a) {\n      var b = a.findVisibleNode();\n      null !== b && (a = b);\n      if (oj(a) || pj(a)) return !1;\n    }\n\n    a = this.toNode;\n    return null !== a && (b = a.findVisibleNode(), null !== b && (a = b), oj(a) || pj(a)) ? !1 : !0;\n  };\n\n  t.fv = function () {\n    return !1;\n  };\n\n  t.ns = function () {};\n\n  t.Tc = function () {\n    return !1;\n  };\n\n  T.prototype.computeAngle = function (a, b, c) {\n    return T.computeAngle(b, c);\n  };\n\n  T.computeAngle = function (a, b) {\n    switch (a) {\n      default:\n      case $f:\n        a = 0;\n        break;\n\n      case Sm:\n        a = b;\n        break;\n\n      case Lm:\n        a = b + 90;\n        break;\n\n      case Nm:\n        a = b - 90;\n        break;\n\n      case pp:\n        a = b + 180;\n        break;\n\n      case Tm:\n        a = J.Eo(b);\n        90 < a && 270 > a && (a -= 180);\n        break;\n\n      case Mm:\n        a = J.Eo(b + 90);\n        90 < a && 270 > a && (a -= 180);\n        break;\n\n      case Om:\n        a = J.Eo(b - 90);\n        90 < a && 270 > a && (a -= 180);\n        break;\n\n      case Pm:\n        a = J.Eo(b);\n        if (45 < a && 135 > a || 225 < a && 315 > a) return 0;\n        90 < a && 270 > a && (a -= 180);\n    }\n\n    return J.Eo(a);\n  };\n\n  function So(a) {\n    var b = a.fromNode,\n        c = a.toNode,\n        d = null;\n    null !== b ? d = null !== c ? b.Sw(c) : b.containingGroup : null !== c ? d = c.containingGroup : d = null;\n    b = d;\n    c = a.ph;\n\n    if (c !== b) {\n      null !== c && No(c, a);\n      a.ph = b;\n      null !== b && Mo(b, a);\n      var e = a.containingGroupChanged;\n\n      if (null !== e) {\n        var f = !0,\n            g = a.diagram;\n        null !== g && (f = g.$, g.$ = !0);\n        e(a, c, b);\n        null !== g && (g.$ = f);\n      }\n\n      !a.xd || a.pw !== c && a.qw !== c || a.ab();\n    }\n\n    if (a.isLabeledLink) for (a = a.labelNodes; a.next();) {\n      a.value.containingGroup = d;\n    }\n  }\n\n  t = T.prototype;\n\n  t.dh = function () {\n    var a = this.containingGroup;\n    null !== a && this.fromNode !== a && this.toNode !== a && a.computesBoundsIncludingLinks && U.prototype.dh.call(this);\n  };\n\n  t.wo = function (a) {\n    var b = this.fromNode;\n    return a === b ? this.toNode : b;\n  };\n\n  t.jz = function (a) {\n    var b = this.fromPort;\n    return a === b ? this.toPort : b;\n  };\n\n  function bp(a, b) {\n    null === a.rd && (a.rd = new G());\n    a.rd.add(b);\n    a.w();\n  }\n\n  t.yo = function (a) {\n    U.prototype.yo.call(this, a);\n    qp(this) && this.Ao(this.actualBounds);\n\n    if (!a) {\n      a = this.Ue;\n      var b = null;\n      null !== a && (b = this.fromPort, $o(a, this, b));\n      var c = this.hf;\n\n      if (null !== c) {\n        var d = this.toPort;\n        c === a && d === b || $o(c, this, d);\n      }\n\n      rp(this);\n    }\n  };\n\n  t.zo = function (a) {\n    U.prototype.zo.call(this, a);\n    qp(this) && this.Ao(this.actualBounds);\n\n    if (!a) {\n      a = this.Ue;\n      var b = null;\n      null !== a && (b = this.fromPort, ap(a, this, b));\n      var c = this.hf;\n\n      if (null !== c) {\n        var d = this.toPort;\n        c === a && d === b || ap(c, this, d);\n      }\n\n      sp(this);\n    }\n  };\n\n  t.Fj = function () {\n    this.xd = !0;\n\n    if (null !== this.rd) {\n      var a = this.diagram;\n      if (null !== a) for (var b = this.rd.copy().iterator; b.next();) {\n        a.remove(b.value);\n      }\n    }\n\n    null !== this.data && (a = this.diagram, null !== a && a.partManager.removeDataForLink(this));\n  };\n\n  T.prototype.updateRelationshipsFromData = function () {\n    if (null !== this.data) {\n      var a = this.diagram;\n      null !== a && a.partManager.updateRelationshipsFromData(this);\n    }\n  };\n\n  T.prototype.move = function (a, b) {\n    var c = b ? this.location : this.position,\n        d = c.x;\n    isNaN(d) && (d = 0);\n    var e = c.y;\n    isNaN(e) && (e = 0);\n    d = a.x - d;\n    e = a.y - e;\n    !0 === b ? U.prototype.move.call(this, a, !1) : (a = I.allocAt(c.x + d, c.y + e), U.prototype.move.call(this, a, !1), I.free(a));\n    cf(this, d, e);\n\n    for (a = this.labelNodes; a.next();) {\n      b = a.value, c = b.position, b.moveTo(c.x + d, c.y + e);\n    }\n  };\n\n  T.prototype.canRelinkFrom = function () {\n    if (!this.relinkableFrom) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowRelink) return !1;\n    a = a.diagram;\n    return null === a || a.allowRelink ? !0 : !1;\n  };\n\n  T.prototype.canRelinkTo = function () {\n    if (!this.relinkableTo) return !1;\n    var a = this.layer;\n    if (null === a) return !0;\n    if (!a.allowRelink) return !1;\n    a = a.diagram;\n    return null === a || a.allowRelink ? !0 : !1;\n  };\n\n  T.prototype.computeMidPoint = function (a) {\n    var b = this.pointsCount;\n    if (0 === b) return a.assign(ub), a;\n    if (1 === b) return a.assign(this.i(0)), a;\n\n    if (2 === b) {\n      var c = this.i(0),\n          d = this.i(1);\n      a.h((c.x + d.x) / 2, (c.y + d.y) / 2);\n      return a;\n    }\n\n    if (this.isOrthogonal && (15 <= this.computeCorner() || this.computeCurve() === cg)) return this.sa.Bu(.5, a), a.add(this.i(0)), c = this.sa.figures.first(), a.offset(-c.startX, -c.startY), a;\n\n    if (this.computeCurve() === cg) {\n      if (3 === b) {\n        c = this.i(0);\n        d = this.i(1);\n        var e = this.i(2);\n        J.Gw(c.x, c.y, d.x, d.y, d.x, d.y, e.x, e.y, a);\n        return a;\n      }\n\n      d = (b - 1) / 3 | 0;\n      c = 3 * (d / 2 | 0);\n\n      if (1 === d % 2) {\n        d = this.i(c);\n        e = this.i(c + 1);\n        var f = this.i(c + 2);\n        c = this.i(c + 3);\n        J.Gw(d.x, d.y, e.x, e.y, f.x, f.y, c.x, c.y, a);\n      } else a.assign(this.i(c));\n\n      return a;\n    }\n\n    var g = this.flattenedLengths;\n    c = this.flattenedTotalLength;\n\n    for (e = f = d = 0; d < c / 2 && f < b;) {\n      e = g[f];\n      if (d + e > c / 2) break;\n      d += e;\n      f++;\n    }\n\n    b = this.i(f);\n    f = this.i(f + 1);\n    1 > Math.abs(b.x - f.x) ? b.y > f.y ? a.h(b.x, b.y - (c / 2 - d)) : a.h(b.x, b.y + (c / 2 - d)) : 1 > Math.abs(b.y - f.y) ? b.x > f.x ? a.h(b.x - (c / 2 - d), b.y) : a.h(b.x + (c / 2 - d), b.y) : (c = (c / 2 - d) / e, a.h(b.x + c * (f.x - b.x), b.y + c * (f.y - b.y)));\n    return a;\n  };\n\n  T.prototype.computeMidAngle = function () {\n    var a = this.pointsCount;\n    if (2 > a) return NaN;\n    if (2 === a) return this.i(0).Ya(this.i(1));\n    if (this.isOrthogonal && (15 <= this.computeCorner() || this.computeCurve() === cg)) return this.sa.Yw(.5);\n\n    if (this.computeCurve() === cg && 4 <= a) {\n      var b = (a - 1) / 3 | 0,\n          c = 3 * (b / 2 | 0);\n\n      if (1 === b % 2) {\n        c = Math.floor(c);\n        a = this.i(c);\n        b = this.i(c + 1);\n        var d = this.i(c + 2);\n        c = this.i(c + 3);\n        return J.ty(a.x, a.y, b.x, b.y, d.x, d.y, c.x, c.y);\n      }\n\n      if (0 < c && c + 1 < a) return this.i(c - 1).Ya(this.i(c + 1));\n    }\n\n    b = this.flattenedLengths;\n    d = this.flattenedTotalLength;\n    var e = 0;\n    c = 0;\n\n    for (var f; e < d / 2 && c < a;) {\n      f = b[c];\n      if (e + f > d / 2) break;\n      e += f;\n      c++;\n    }\n\n    b = this.i(c);\n    d = this.i(c + 1);\n\n    if (1 > Math.abs(b.x - d.x) && 1 > Math.abs(b.y - d.y)) {\n      if (0 < c && c + 2 < a) return this.i(c - 1).Ya(this.i(c + 2));\n    } else {\n      if (1 > Math.abs(b.x - d.x)) return b.y > d.y ? 270 : 90;\n      if (1 > Math.abs(b.y - d.y)) return b.x > d.x ? 180 : 0;\n    }\n\n    return b.Ya(d);\n  };\n\n  t = T.prototype;\n\n  t.i = function (a) {\n    return this.Jb.s[a];\n  };\n\n  t.Wc = function (a, b) {\n    this.Jb.Vc(a, b);\n  };\n\n  t.M = function (a, b, c) {\n    this.Jb.Vc(a, new I(b, c));\n  };\n\n  t.sz = function (a, b) {\n    this.Jb.Cb(a, b);\n  };\n\n  t.l = function (a, b, c) {\n    this.Jb.Cb(a, new I(b, c));\n  };\n\n  t.fe = function (a) {\n    this.Jb.add(a);\n  };\n\n  t.mf = function (a, b) {\n    this.Jb.add(new I(a, b));\n  };\n\n  t.Yu = function (a) {\n    this.Jb.mb(a);\n  };\n\n  t.Aj = function () {\n    this.Jb.clear();\n  };\n\n  function cf(a, b, c) {\n    if (0 !== b || 0 !== c) if (0 === a.pointsCount) a.defaultFromPoint && a.defaultFromPoint.offset(b, c), a.defaultToPoint && a.defaultToPoint.offset(b, c);else {\n      for (var d = a.xd, e = new E(), f = a.Jb.iterator; f.next();) {\n        var g = f.value;\n        e.add(new I(g.x + b, g.y + c).freeze());\n      }\n\n      e.freeze();\n      f = a.Jb;\n      a.Jb = e;\n      g = a.diagram;\n      isNaN(b) || isNaN(c) || null !== g && g.animationManager.zb ? a.w() : (a.de.h(a.de.x + b, a.de.y + c), a.pa.h(a.pa.x + b, a.pa.y + c), zl(a));\n      d ? tp(a) : (a.defaultFromPoint && (a.defaultFromPoint = a.i(0)), a.defaultToPoint && (a.defaultToPoint = a.i(a.pointsCount - 1)));\n      null !== g && g.animationManager.zb && (b = g.animationManager, a.ef = e, b.dl.add(a));\n      a.g(\"points\", f, e);\n    }\n  }\n\n  t.jh = function () {\n    null === this.Eg && (this.Eg = this.Jb, this.Jb = this.Jb.copy());\n  };\n\n  t.pf = function () {\n    if (null !== this.Eg) {\n      for (var a = this.Eg, b = this.Jb, c = Infinity, d = Infinity, e = a.s, f = e.length, g = 0; g < f; g++) {\n        var h = e[g];\n        c = Math.min(h.x, c);\n        d = Math.min(h.y, d);\n      }\n\n      h = g = Infinity;\n\n      for (var k = b.s, l = k.length, m = 0; m < l; m++) {\n        var n = k[m];\n        g = Math.min(n.x, g);\n        h = Math.min(n.y, h);\n        n.freeze();\n      }\n\n      b.freeze();\n      if (l === f) for (f = 0; f < l; f++) {\n        if (m = e[f], n = k[f], m.x - c !== n.x - g || m.y - d !== n.y - h) {\n          this.mc(!0);\n          break;\n        }\n      } else this.mc(!0);\n      this.Eg = null;\n      c = this.diagram;\n      null !== c && c.animationManager.zb && (c = c.animationManager, this.ef = b, c.dl.add(this));\n      tp(this);\n      this.g(\"points\", a, b);\n    }\n  };\n\n  t.$u = function () {\n    null !== this.Eg && (this.Jb = this.Eg, this.Eg = null);\n  };\n\n  function tp(a) {\n    0 === a.Jb.count ? a.xd = !1 : (a.xd = !0, a.Gp = null, a.Ys = NaN, a.defaultFromPoint = a.i(0), a.defaultToPoint = a.i(a.pointsCount - 1), up(a, !1));\n  }\n\n  t.ab = function () {\n    if (!this.suspendsRouting) {\n      var a = this.diagram;\n\n      if (a) {\n        if (a.Zr.contains(this) || a.undoManager.isUndoingRedoing) return;\n        a = a.animationManager;\n        if (a.isTicking && !a.isAnimating) return;\n        null !== this.ef && !a.isTicking && a.isAnimating && (this.ef = null);\n      }\n\n      a = this.path;\n      null !== a && (this.xd = !1, this.w(), a.w());\n    }\n  };\n\n  t.mg = function () {\n    if (!this.xd && !this.computingPoints) {\n      var a = !0;\n\n      try {\n        this.computingPoints = !0, this.jh(), a = this.computePoints();\n      } catch (b) {\n        this.computingPoints = !1, this.$u();\n      } finally {\n        this.computingPoints = !1, a ? this.pf() : this.$u();\n      }\n    }\n  };\n\n  T.prototype.computePoints = function () {\n    if (null === this.diagram) return !1;\n    var a = this.fromNode,\n        b = null;\n    null === a ? (vp || (vp = new V(), vp.desiredSize = Db, vp.Za()), this.defaultFromPoint && (vp.location = this.defaultFromPoint, vp.Za(), b = a = vp)) : b = this.fromPort;\n\n    if (null !== b && !a.isVisible()) {\n      var c = a.findVisibleNode();\n      null !== c && c !== a ? (a = c, b = c.port) : a = c;\n    }\n\n    this.pw = a;\n    if (null === a || !a.location.v()) return !1;\n\n    for (; !(null === b || b.actualBounds.v() && b.zf());) {\n      b = b.panel;\n    }\n\n    if (null === b) return !1;\n    var d = this.toNode,\n        e = null;\n    null === d ? (wp || (wp = new V(), wp.desiredSize = Db, wp.Za()), this.defaultToPoint && (wp.location = this.defaultToPoint, wp.Za(), e = d = wp)) : e = this.toPort;\n    null === e || d.isVisible() || (c = d.findVisibleNode(), null !== c && c !== d ? (d = c, e = c.port) : d = c);\n    this.qw = d;\n    if (null === d || !d.location.v()) return !1;\n\n    for (; !(null === e || e.actualBounds.v() && e.zf());) {\n      e = e.panel;\n    }\n\n    if (null === e) return !1;\n    var f = this.pointsCount,\n        g = this.computeSpot(!0, b);\n    c = this.computeSpot(!1, e);\n    var h = xp(g),\n        k = xp(c),\n        l = b === e && null !== b,\n        m = this.isOrthogonal,\n        n = this.curve === cg;\n    this.Mf = l && !m ? n = !0 : !1;\n    var p = this.computeAdjusting() === $f || l;\n\n    if (!m && !l && h && k) {\n      if (h = !1, !p && 3 <= f && (p = this.getLinkPoint(a, b, g, !0, !1, d, e), k = this.getLinkPoint(d, e, c, !1, !1, a, b), h = this.adjustPoints(0, p, f - 1, k)) && (p = this.getLinkPoint(a, b, g, !0, !1, d, e), k = this.getLinkPoint(d, e, c, !1, !1, a, b), this.adjustPoints(0, p, f - 1, k)), !h) if (this.Aj(), n) {\n        f = this.getLinkPoint(a, b, g, !0, !1, d, e);\n        p = this.getLinkPoint(d, e, c, !1, !1, a, b);\n        h = p.x - f.x;\n        k = p.y - f.y;\n        l = this.computeCurviness();\n        n = m = 0;\n        var r = f.x + h / 3,\n            q = f.y + k / 3,\n            u = r,\n            w = q;\n        J.B(k, 0) ? w = 0 < h ? w - l : w + l : (m = -h / k, n = Math.sqrt(l * l / (m * m + 1)), 0 > l && (n = -n), u = (0 > k ? -1 : 1) * n + r, w = m * (u - r) + q);\n        r = f.x + 2 * h / 3;\n        q = f.y + 2 * k / 3;\n        var v = r,\n            z = q;\n        J.B(k, 0) ? z = 0 < h ? z - l : z + l : (v = (0 > k ? -1 : 1) * n + r, z = m * (v - r) + q);\n        this.Aj();\n        this.fe(f);\n        this.mf(u, w);\n        this.mf(v, z);\n        this.fe(p);\n        this.Wc(0, this.getLinkPoint(a, b, g, !0, !1, d, e));\n        this.Wc(3, this.getLinkPoint(d, e, c, !1, !1, a, b));\n      } else if (f = d, p = e, d = this.getLinkPoint(a, b, g, !0, !1, f, p), e = this.getLinkPoint(f, p, c, !1, !1, a, b), this.hasCurviness()) p = e.x - d.x, c = e.y - d.y, g = this.computeCurviness(), a = d.x + p / 2, b = d.y + c / 2, f = a, h = b, J.B(c, 0) ? h = 0 < p ? h - g : h + g : (p = -p / c, f = Math.sqrt(g * g / (p * p + 1)), 0 > g && (f = -f), f = (0 > c ? -1 : 1) * f + a, h = p * (f - a) + b), this.fe(d), this.mf(f, h), this.fe(e);else {\n        this.fe(d);\n        this.fe(e);\n        h = M.alloc();\n        b.gi(h);\n        k = h.ba(e);\n        p.gi(h);\n        l = h.ba(d);\n        if (k || l) g = b.ia(yp(g), new I()), this.Wc(0, this.getLinkPointFromPoint(a, b, g, e, !0, g)), c = p.ia(yp(c), new I()), this.Wc(1, this.getLinkPointFromPoint(f, p, c, d, !1, c));\n        M.free(h);\n      }\n    } else {\n      n = this.isAvoiding;\n      p && (m && n || l) && this.Aj();\n      var y = l ? this.computeCurviness() : 0;\n      n = this.getLinkPoint(a, b, g, !0, m, d, e);\n      r = u = q = 0;\n      if (m || !h || l) w = this.computeEndSegmentLength(a, b, g, !0), r = this.getLinkDirection(a, b, n, g, !0, m, d, e), l && (h || g.C(c) || !m && 1 === g.x + c.x && 1 === g.y + c.y) && (r -= m ? 90 : 30, 0 > y && (r -= 180)), 0 > r ? r += 360 : 360 <= r && (r -= 360), l && (w += Math.abs(y) * (m ? 1 : 2)), 0 === r ? q = w : 90 === r ? u = w : 180 === r ? q = -w : 270 === r ? u = -w : (q = w * Math.cos(r * Math.PI / 180), u = w * Math.sin(r * Math.PI / 180)), g.Fc() && l && (w = b.ia(yc, I.alloc()), v = I.allocAt(w.x + 1E3 * q, w.y + 1E3 * u), this.getLinkPointFromPoint(a, b, w, v, !0, n), I.free(w), I.free(v));\n      w = this.getLinkPoint(d, e, c, !1, m, a, b);\n      var A = z = v = 0;\n\n      if (m || !k || l) {\n        var B = this.computeEndSegmentLength(d, e, c, !1);\n        A = this.getLinkDirection(d, e, w, c, !1, m, a, b);\n        l && (k || g.C(c) || !m && 1 === g.x + c.x && 1 === g.y + c.y) && (A += m ? 0 : 30, 0 > y && (A += 180));\n        0 > A ? A += 360 : 360 <= A && (A -= 360);\n        l && (B += Math.abs(y) * (m ? 1 : 2));\n        0 === A ? v = B : 90 === A ? z = B : 180 === A ? v = -B : 270 === A ? z = -B : (v = B * Math.cos(A * Math.PI / 180), z = B * Math.sin(A * Math.PI / 180));\n        c.Fc() && l && (c = e.ia(yc, I.alloc()), g = I.allocAt(c.x + 1E3 * v, c.y + 1E3 * z), this.getLinkPointFromPoint(d, e, c, g, !1, w), I.free(c), I.free(g));\n      }\n\n      c = n;\n      if (m || !h || l) c = new I(n.x + q, n.y + u);\n      g = w;\n      if (m || !k || l) g = new I(w.x + v, w.y + z);\n      !p && !m && h && 3 < f && this.adjustPoints(0, n, f - 2, g) ? this.Wc(f - 1, w) : !p && !m && k && 3 < f && this.adjustPoints(1, c, f - 1, w) ? this.Wc(0, n) : !p && (m ? 6 <= f : 4 < f) && this.adjustPoints(1, c, f - 2, g) ? (this.Wc(0, n), this.Wc(f - 1, w)) : (this.Aj(), this.fe(n), (m || !h || l) && this.fe(c), m && this.addOrthoPoints(c, r, g, A, a, d), (m || !k || l) && this.fe(g), this.fe(w));\n    }\n\n    return !0;\n  };\n\n  function zp(a, b) {\n    Math.abs(b.x - a.x) > Math.abs(b.y - a.y) ? (b.x >= a.x ? b.x = a.x + 9E9 : b.x = a.x - 9E9, b.y = a.y) : (b.y >= a.y ? b.y = a.y + 9E9 : b.y = a.y - 9E9, b.x = a.x);\n    return b;\n  }\n\n  T.prototype.getLinkPointFromPoint = function (a, b, c, d, e, f) {\n    void 0 === f && (f = new I());\n    if (null === a || null === b) return f.assign(c), f;\n    a.isVisible() || (e = a.findVisibleNode(), null !== e && e !== a && (b = e.port));\n    a = null;\n    e = b.panel;\n    null === e || e.ke() || (e = e.panel);\n\n    if (null === e) {\n      e = d.x;\n      d = d.y;\n      var g = c.x;\n      c = c.y;\n    } else {\n      a = e.ge;\n      e = 1 / (a.m11 * a.m22 - a.m12 * a.m21);\n      g = a.m22 * e;\n      var h = -a.m12 * e,\n          k = -a.m21 * e,\n          l = a.m11 * e,\n          m = e * (a.m21 * a.dy - a.m22 * a.dx),\n          n = e * (a.m12 * a.dx - a.m11 * a.dy);\n      e = d.x * g + d.y * k + m;\n      d = d.x * h + d.y * l + n;\n      g = c.x * g + c.y * k + m;\n      c = c.x * h + c.y * l + n;\n    }\n\n    b.Kj(e, d, g, c, f);\n    null !== a && f.transform(a);\n    return f;\n  };\n\n  function Ap(a, b) {\n    var c = b.Hn;\n    null === c && (c = new Bp(), c.port = b, c.node = b.part, b.Hn = c);\n    return Cp(c, a);\n  }\n\n  T.prototype.getLinkPoint = function (a, b, c, d, e, f, g, h) {\n    void 0 === h && (h = new I());\n    if (c.pb() && !xp(c)) return b.ia(c, h), h;\n\n    if (c.Uc()) {\n      var k = Ap(this, b);\n\n      if (null !== k) {\n        h.assign(k.Co);\n\n        if (e && this.routing === Dp) {\n          var l = Ap(this, g);\n\n          if (null !== l && k.tl < l.tl) {\n            k = I.alloc();\n            l = I.alloc();\n            var m = new M(b.ia(tc, k), b.ia(Cc, l)),\n                n = this.computeSpot(!d, g);\n            a = this.getLinkPoint(f, g, n, !d, e, a, b, l);\n            (c.xf(Ec) || c.xf(Gc)) && a.y >= m.y && a.y <= m.y + m.height ? h.y = a.y : (c.xf(Dc) || c.xf(Hc)) && a.x >= m.x && a.x <= m.x + m.width && (h.x = a.x);\n            I.free(k);\n            I.free(l);\n          }\n        }\n\n        return h;\n      }\n    }\n\n    c = b.ia(yp(c), I.alloc());\n    this.pointsCount > (e ? 6 : 2) ? (g = d ? this.i(1) : this.i(this.pointsCount - 2), e && (g = zp(c, g.copy()))) : (k = this.computeSpot(!d, g), f = I.alloc(), g = g.ia(yp(k), f), e && (g = zp(c, g)), I.free(f));\n    this.getLinkPointFromPoint(a, b, c, g, d, h);\n    I.free(c);\n    return h;\n  };\n\n  T.prototype.getLinkDirection = function (a, b, c, d, e, f, g, h) {\n    a: if (d.pb()) var k = d.x > d.y ? d.x > 1 - d.y ? 0 : d.x < 1 - d.y ? 270 : 315 : d.x < d.y ? d.x > 1 - d.y ? 90 : d.x < 1 - d.y ? 180 : 135 : .5 > d.x ? 225 : .5 < d.x ? 45 : 0;else {\n      if (d.Uc() && (k = Ap(this, b), null !== k)) switch (k.Gc) {\n        case 1:\n          k = 270;\n          break a;\n\n        case 2:\n          k = 180;\n          break a;\n\n        default:\n        case 4:\n          k = 0;\n          break a;\n\n        case 8:\n          k = 90;\n          break a;\n      }\n      k = b.ia(yc, I.alloc());\n      this.pointsCount > (f ? 6 : 2) ? (h = e ? this.i(1) : this.i(this.pointsCount - 2), h = f ? zp(k, h.copy()) : c) : (c = I.alloc(), h = h.ia(yc, c), I.free(c));\n      c = Math.abs(h.x - k.x) > Math.abs(h.y - k.y) ? h.x >= k.x ? 0 : 180 : h.y >= k.y ? 90 : 270;\n      I.free(k);\n      k = c;\n    }\n\n    d.Fc() && g.Md(a) && (k += 180, 360 <= k && (k -= 360));\n    if (xp(d)) return k;\n    a = b.fi();\n    if (0 === a) return k;\n    45 <= a && 135 > a ? k += 90 : 135 <= a && 225 > a ? k += 180 : 225 <= a && 315 > a && (k += 270);\n    360 <= k && (k -= 360);\n    return k;\n  };\n\n  T.prototype.computeEndSegmentLength = function (a, b, c, d) {\n    if (null !== b && c.Uc() && (a = Ap(this, b), null !== a)) return a.tu;\n    a = d ? this.fromEndSegmentLength : this.toEndSegmentLength;\n    null !== b && isNaN(a) && (a = d ? b.fromEndSegmentLength : b.toEndSegmentLength);\n    isNaN(a) && (a = 10);\n    return a;\n  };\n\n  T.prototype.computeSpot = function (a, b) {\n    void 0 === b && (b = null);\n    a ? (a = b ? b : this.fromPort, null === a ? a = yc : (b = this.fromSpot, b.Sb() && (b = a.fromSpot), a = b === Wc ? sc : b)) : (a = b ? b : this.toPort, null === a ? a = yc : (b = this.toSpot, b.Sb() && (b = a.toSpot), a = b === Wc ? sc : b));\n    return a;\n  };\n\n  function xp(a) {\n    return a === sc || .5 === a.x && .5 === a.y;\n  }\n\n  function yp(a) {\n    return .5 === a.x && .5 === a.y ? a : yc;\n  }\n\n  T.prototype.computeOtherPoint = function (a, b) {\n    if (this.computeAdjusting() !== $f && 4 < this.pointsCount) return this.computeMidPoint(new I());\n    a = b.Hn;\n    a = null !== a ? Cp(a, this) : null;\n    return null !== a ? a.Co : b.ia(yc);\n  };\n\n  T.prototype.computeShortLength = function (a) {\n    if (a) {\n      a = this.fromShortLength;\n\n      if (isNaN(a)) {\n        var b = this.fromPort;\n        null !== b && (a = b.fromShortLength);\n      }\n\n      return isNaN(a) ? 0 : a;\n    }\n\n    a = this.toShortLength;\n    isNaN(a) && (b = this.toPort, null !== b && (a = b.toShortLength));\n    return isNaN(a) ? 0 : a;\n  };\n\n  T.prototype.tf = function (a, b, c, d, e, f) {\n    if (!1 === this.pickable) return !1;\n    void 0 === b && (b = null);\n    void 0 === c && (c = null);\n    var g = f;\n    void 0 === f && (g = md.alloc(), g.reset());\n    g.multiply(this.transform);\n    if (this.Wg(a, g)) return cn(this, b, c, e), void 0 === f && md.free(g), !0;\n\n    if (this.Sc(a, g)) {\n      var h = !1;\n      if (!this.isAtomic) for (var k = this.R.s, l = k.length; l--;) {\n        var m = k[l];\n\n        if (m.visible || m === this.locationObject) {\n          var n = m.actualBounds,\n              p = this.naturalBounds;\n\n          if (!(n.x > p.width || n.y > p.height || 0 > n.x + n.width || 0 > n.y + n.height)) {\n            n = md.alloc();\n            n.set(g);\n            if (m instanceof W) h = m.tf(a, b, c, d, e, n);else if (this.path === m) {\n              if (m instanceof Cf) if (h = a, p = d, !1 === m.pickable) h = !1;else if (n.multiply(m.transform), p) b: {\n                var r = h,\n                    q = n;\n                if (m.Wg(r, q)) h = !0;else {\n                  if (void 0 === q && (q = m.transform, r.Ee(m.actualBounds))) {\n                    h = !0;\n                    break b;\n                  }\n\n                  h = r.left;\n                  p = r.right;\n                  var u = r.top;\n                  r = r.bottom;\n                  var w = I.alloc(),\n                      v = I.alloc(),\n                      z = I.alloc(),\n                      y = md.alloc();\n                  y.set(q);\n                  y.Ou(m.transform);\n                  y.Tr();\n                  v.x = p;\n                  v.y = u;\n                  v.transform(y);\n                  w.x = h;\n                  w.y = u;\n                  w.transform(y);\n                  q = !1;\n                  Bn(m, w, v, z) ? q = !0 : (w.x = p, w.y = r, w.transform(y), Bn(m, w, v, z) ? q = !0 : (v.x = h, v.y = r, v.transform(y), Bn(m, w, v, z) ? q = !0 : (w.x = h, w.y = u, w.transform(y), Bn(m, w, v, z) && (q = !0))));\n                  md.free(y);\n                  I.free(w);\n                  I.free(v);\n                  I.free(z);\n                  h = q;\n                }\n              } else h = m.Wg(h, n);\n            } else h = gl(m, a, d, n);\n            h && (p = m, null !== b && (p = b(m)), p && (null === c || c(p)) && e.add(p));\n            md.free(n);\n          }\n        }\n      }\n      void 0 === f && md.free(g);\n      return h || null !== this.background || null !== this.areaBackground;\n    }\n\n    void 0 === f && md.free(g);\n    return !1;\n  };\n\n  T.prototype.computeCurve = function () {\n    if (null === this.Mf) {\n      var a = this.fromPort,\n          b = this.isOrthogonal;\n      this.Mf = null !== a && a === this.toPort && !b;\n    }\n\n    return this.Mf ? cg : this.curve;\n  };\n\n  T.prototype.computeCorner = function () {\n    if (this.curve === cg) return 0;\n    var a = this.corner;\n    if (isNaN(a) || 0 > a) a = 10;\n    return a;\n  };\n\n  T.prototype.findMidLabel = function () {\n    for (var a = this.path, b = this.R.s, c = b.length, d = 0; d < c; d++) {\n      var e = b[d];\n      if (e !== a && !e.isPanelMain && (-Infinity === e.segmentIndex || isNaN(e.segmentIndex))) return e;\n    }\n\n    for (a = this.labelNodes; a.next();) {\n      if (b = a.value, -Infinity === b.segmentIndex || isNaN(b.segmentIndex)) return b;\n    }\n\n    return null;\n  };\n\n  T.prototype.computeSpacing = function () {\n    if (!this.isVisible()) return 0;\n    var a = Ep;\n    a = Math.max(a, this.computeThickness());\n    var b = this.fromPort,\n        c = this.toPort;\n\n    if (null !== b && null !== c) {\n      var d = this.findMidLabel();\n\n      if (null !== d) {\n        var e = d.naturalBounds,\n            f = d.margin,\n            g = isNaN(e.width) ? 30 : e.width * d.scale + f.left + f.right;\n        e = isNaN(e.height) ? 14 : e.height * d.scale + f.top + f.bottom;\n        d = d.segmentOrientation;\n        d === Sm || d === Tm || d === pp ? a = Math.max(a, e) : d === Nm || d === Om || d === Lm || d === Mm ? a = Math.max(a, g) : (b = b.ia(yc).Ya(c.ia(yc)) / 180 * Math.PI, a = Math.max(a, Math.abs(Math.sin(b) * g) + Math.abs(Math.cos(b) * e) + 1));\n        this.curve === cg && (a *= 1.333);\n      }\n    }\n\n    return a;\n  };\n\n  T.prototype.arrangeBundledLinks = function (a, b) {\n    if (b) for (b = 0; b < a.length; b++) {\n      var c = a[b];\n      c.computeAdjusting() === $f && c.ab();\n    }\n  };\n\n  T.prototype.computeCurviness = function () {\n    var a = this.curviness;\n\n    if (isNaN(a)) {\n      a = Fp;\n      var b = this.If;\n\n      if (null !== b) {\n        for (var c = Ea(), d = 0, e = b.links, f = 0; f < e.length; f++) {\n          var g = e[f].computeSpacing();\n          c.push(g);\n          d += g;\n        }\n\n        d = -d / 2;\n\n        for (f = 0; f < e.length; f++) {\n          if (e[f] === this) {\n            a = d + c[f] / 2;\n            break;\n          }\n\n          d += c[f];\n        }\n\n        b.cs === this.fromNode && (a = -a);\n        Ga(c);\n      }\n    }\n\n    return a;\n  };\n\n  T.prototype.computeThickness = function () {\n    if (!this.isVisible()) return 0;\n    var a = this.path;\n    return null !== a ? Math.max(a.strokeWidth, 1) : 1;\n  };\n\n  T.prototype.hasCurviness = function () {\n    return !isNaN(this.curviness) || null !== this.If;\n  };\n\n  T.prototype.adjustPoints = function (a, b, c, d) {\n    var e = this.computeAdjusting();\n\n    if (this.isOrthogonal) {\n      if (e === np) return !1;\n      e === op && (e = mp);\n    }\n\n    switch (e) {\n      case np:\n        var f = this.i(a),\n            g = this.i(c);\n\n        if (!f.$a(b) || !g.$a(d)) {\n          e = f.x;\n          f = f.y;\n          var h = g.x - e,\n              k = g.y - f,\n              l = Math.sqrt(h * h + k * k);\n\n          if (!J.ca(l, 0)) {\n            if (J.ca(h, 0)) var m = 0 > k ? -Math.PI / 2 : Math.PI / 2;else m = Math.atan(k / Math.abs(h)), 0 > h && (m = Math.PI - m);\n            g = b.x;\n            var n = b.y;\n            h = d.x - g;\n            var p = d.y - n;\n            k = Math.sqrt(h * h + p * p);\n            J.ca(h, 0) ? p = 0 > p ? -Math.PI / 2 : Math.PI / 2 : (p = Math.atan(p / Math.abs(h)), 0 > h && (p = Math.PI - p));\n            l = k / l;\n            m = p - m;\n            this.Wc(a, b);\n\n            for (a += 1; a < c; a++) {\n              b = this.i(a), h = b.x - e, k = b.y - f, b = Math.sqrt(h * h + k * k), J.ca(b, 0) || (J.ca(h, 0) ? k = 0 > k ? -Math.PI / 2 : Math.PI / 2 : (k = Math.atan(k / Math.abs(h)), 0 > h && (k = Math.PI - k)), h = k + m, b *= l, this.M(a, g + b * Math.cos(h), n + b * Math.sin(h)));\n            }\n\n            this.Wc(c, d);\n          }\n        }\n\n        return !0;\n\n      case op:\n        f = this.i(a);\n        n = this.i(c);\n\n        if (!f.$a(b) || !n.$a(d)) {\n          e = f.x;\n          f = f.y;\n          g = n.x;\n          n = n.y;\n          l = (g - e) * (g - e) + (n - f) * (n - f);\n          h = b.x;\n          m = b.y;\n          k = d.x;\n          p = d.y;\n          var r = 1;\n\n          if (0 !== k - h) {\n            var q = (p - m) / (k - h);\n            r = Math.sqrt(1 + 1 / (q * q));\n          } else q = 9E9;\n\n          this.Wc(a, b);\n\n          for (a += 1; a < c; a++) {\n            b = this.i(a);\n            var u = b.x,\n                w = b.y,\n                v = .5;\n            0 !== l && (v = ((e - u) * (e - g) + (f - w) * (f - n)) / l);\n            var z = e + v * (g - e),\n                y = f + v * (n - f);\n            b = Math.sqrt((u - z) * (u - z) + (w - y) * (w - y));\n            w < q * (u - z) + y && (b = -b);\n            0 < q && (b = -b);\n            u = h + v * (k - h);\n            v = m + v * (p - m);\n            0 !== q ? (b = u + b / r, this.M(a, b, v - (b - u) / q)) : this.M(a, u, v + b);\n          }\n\n          this.Wc(c, d);\n        }\n\n        return !0;\n\n      case mp:\n        a: {\n          if (this.isOrthogonal && (e = this.i(a), f = this.i(a + 1), g = this.i(a + 2), h = f.x, m = f.y, n = h, l = m, J.B(e.y, f.y) ? J.B(f.x, g.x) ? m = b.y : J.B(f.y, g.y) && (h = b.x) : J.B(e.x, f.x) && (J.B(f.y, g.y) ? h = b.x : J.B(f.x, g.x) && (m = b.y)), this.M(a + 1, h, m), e = this.i(c), f = this.i(c - 1), g = this.i(c - 2), h = f.x, m = f.y, k = h, p = m, J.B(e.y, f.y) ? J.B(f.x, g.x) ? m = d.y : J.B(f.y, g.y) && (h = d.x) : J.B(e.x, f.x) && (J.B(f.y, g.y) ? h = d.x : J.B(f.x, g.x) && (m = d.y)), this.M(c - 1, h, m), Lj(this))) {\n            this.M(a + 1, n, l);\n            this.M(c - 1, k, p);\n            c = !1;\n            break a;\n          }\n\n          this.Wc(a, b);\n          this.Wc(c, d);\n          c = !0;\n        }\n\n        return c;\n\n      default:\n        return !1;\n    }\n  };\n\n  T.prototype.addOrthoPoints = function (a, b, c, d, e, f) {\n    0 > b ? b += 360 : 360 <= b && (b -= 360);\n    0 > d ? d += 360 : 360 <= d && (d -= 360);\n    var g = d;\n    b = 315 <= b || 45 > b ? 0 : 45 <= b && 135 > b ? 90 : 135 <= b && 225 > b ? 180 : 270;\n    d = 315 <= d || 45 > d ? 0 : 45 <= d && 135 > d ? 90 : 135 <= d && 225 > d ? 180 : 270;\n    var h = e.actualBounds.copy(),\n        k = f.actualBounds.copy();\n\n    if (h.v() && k.v()) {\n      h.vc(Gp, Gp);\n      k.vc(Gp, Gp);\n      h.Me(a);\n      k.Me(c);\n      var l = I.alloc(),\n          m = I.alloc();\n      if (0 === b) {\n        if (c.x > a.x || 270 === d && c.y < a.y && k.right > a.x || 90 === d && c.y > a.y && k.right > a.x) l.h(c.x, a.y), m.h(c.x, (a.y + c.y) / 2), 180 === d ? (l.x = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1), m.x = l.x, m.y = c.y) : 270 === d && c.y < a.y || 90 === d && c.y > a.y ? (l.x = a.x < k.left ? this.computeMidOrthoPosition(a.x, a.y, k.left, c.y, !1) : a.x < k.right && (270 === d && a.y < k.top || 90 === d && a.y > k.bottom) ? this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1) : k.right, m.x = l.x, m.y = c.y) : 0 === d && a.x < k.left && a.y > k.top && a.y < k.bottom && (l.x = a.x, l.y = a.y < c.y ? Math.min(c.y, k.top) : Math.max(c.y, k.bottom), m.y = l.y);else {\n          l.h(a.x, c.y);\n          m.h((a.x + c.x) / 2, c.y);\n          if (180 === d || 90 === d && c.y < h.top || 270 === d && c.y > h.bottom) 180 === d && (k.ba(a) || h.ba(c)) ? l.y = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0) : c.y < a.y && (180 === d || 90 === d) ? l.y = this.computeMidOrthoPosition(a.x, h.top, c.x, Math.max(c.y, k.bottom), !0) : c.y > a.y && (180 === d || 270 === d) && (l.y = this.computeMidOrthoPosition(a.x, h.bottom, c.x, Math.min(c.y, k.top), !0)), m.x = c.x, m.y = l.y;\n          if (l.y > h.top && l.y < h.bottom) if (c.x >= h.left && c.x <= a.x || a.x <= k.right && a.x >= c.x) {\n            if (90 === d || 270 === d) l.h(Math.max((a.x + c.x) / 2, a.x), a.y), m.h(l.x, c.y);\n          } else l.y = 270 === d || (0 === d || 180 === d) && c.y < a.y ? Math.min(c.y, 0 === d ? h.top : Math.min(h.top, k.top)) : Math.max(c.y, 0 === d ? h.bottom : Math.max(h.bottom, k.bottom)), m.x = c.x, m.y = l.y;\n        }\n      } else if (180 === b) {\n        if (c.x < a.x || 270 === d && c.y < a.y && k.left < a.x || 90 === d && c.y > a.y && k.left < a.x) l.h(c.x, a.y), m.h(c.x, (a.y + c.y) / 2), 0 === d ? (l.x = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1), m.x = l.x, m.y = c.y) : 270 === d && c.y < a.y || 90 === d && c.y > a.y ? (l.x = a.x > k.right ? this.computeMidOrthoPosition(a.x, a.y, k.right, c.y, !1) : a.x > k.left && (270 === d && a.y < k.top || 90 === d && a.y > k.bottom) ? this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1) : k.left, m.x = l.x, m.y = c.y) : 180 === d && a.x > k.right && a.y > k.top && a.y < k.bottom && (l.x = a.x, l.y = a.y < c.y ? Math.min(c.y, k.top) : Math.max(c.y, k.bottom), m.y = l.y);else {\n          l.h(a.x, c.y);\n          m.h((a.x + c.x) / 2, c.y);\n          if (0 === d || 90 === d && c.y < h.top || 270 === d && c.y > h.bottom) 0 === d && (k.ba(a) || h.ba(c)) ? l.y = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0) : c.y < a.y && (0 === d || 90 === d) ? l.y = this.computeMidOrthoPosition(a.x, h.top, c.x, Math.max(c.y, k.bottom), !0) : c.y > a.y && (0 === d || 270 === d) && (l.y = this.computeMidOrthoPosition(a.x, h.bottom, c.x, Math.min(c.y, k.top), !0)), m.x = c.x, m.y = l.y;\n          if (l.y > h.top && l.y < h.bottom) if (c.x <= h.right && c.x >= a.x || a.x >= k.left && a.x <= c.x) {\n            if (90 === d || 270 === d) l.h(Math.min((a.x + c.x) / 2, a.x), a.y), m.h(l.x, c.y);\n          } else l.y = 270 === d || (0 === d || 180 === d) && c.y < a.y ? Math.min(c.y, 180 === d ? h.top : Math.min(h.top, k.top)) : Math.max(c.y, 180 === d ? h.bottom : Math.max(h.bottom, k.bottom)), m.x = c.x, m.y = l.y;\n        }\n      } else if (90 === b) {\n        if (c.y > a.y || 180 === d && c.x < a.x && k.bottom > a.y || 0 === d && c.x > a.x && k.bottom > a.y) l.h(a.x, c.y), m.h((a.x + c.x) / 2, c.y), 270 === d ? (l.y = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0), m.x = c.x, m.y = l.y) : 180 === d && c.x < a.x || 0 === d && c.x > a.x ? (l.y = a.y < k.top ? this.computeMidOrthoPosition(a.x, a.y, c.x, k.top, !0) : a.y < k.bottom && (180 === d && a.x < k.left || 0 === d && a.x > k.right) ? this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0) : k.bottom, m.x = c.x, m.y = l.y) : 90 === d && a.y < k.top && a.x > k.left && a.x < k.right && (l.x = a.x < c.x ? Math.min(c.x, k.left) : Math.max(c.x, k.right), l.y = a.y, m.x = l.x);else {\n          l.h(c.x, a.y);\n          m.h(c.x, (a.y + c.y) / 2);\n          if (270 === d || 0 === d && c.x < h.left || 180 === d && c.x > h.right) 270 === d && (k.ba(a) || h.ba(c)) ? l.x = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1) : c.x < a.x && (270 === d || 0 === d) ? l.x = this.computeMidOrthoPosition(h.left, a.y, Math.max(c.x, k.right), c.y, !1) : c.x > a.x && (270 === d || 180 === d) && (l.x = this.computeMidOrthoPosition(h.right, a.y, Math.min(c.x, k.left), c.y, !1)), m.x = l.x, m.y = c.y;\n          if (l.x > h.left && l.x < h.right) if (c.y >= h.top && c.y <= a.y || a.y <= k.bottom && a.y >= c.y) {\n            if (0 === d || 180 === d) l.h(a.x, Math.max((a.y + c.y) / 2, a.y)), m.h(c.x, l.y);\n          } else l.x = 180 === d || (90 === d || 270 === d) && c.x < a.x ? Math.min(c.x, 90 === d ? h.left : Math.min(h.left, k.left)) : Math.max(c.x, 90 === d ? h.right : Math.max(h.right, k.right)), m.x = l.x, m.y = c.y;\n        }\n      } else if (c.y < a.y || 180 === d && c.x < a.x && k.top < a.y || 0 === d && c.x > a.x && k.top < a.y) l.h(a.x, c.y), m.h((a.x + c.x) / 2, c.y), 90 === d ? (l.y = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0), m.x = c.x, m.y = l.y) : 180 === d && c.x < a.x || 0 === d && c.x >= a.x ? (l.y = a.y > k.bottom ? this.computeMidOrthoPosition(a.x, a.y, c.x, k.bottom, !0) : a.y > k.top && (180 === d && a.x < k.left || 0 === d && a.x > k.right) ? this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !0) : k.top, m.x = c.x, m.y = l.y) : 270 === d && a.y > k.bottom && a.x > k.left && a.x < k.right && (l.x = a.x < c.x ? Math.min(c.x, k.left) : Math.max(c.x, k.right), l.y = a.y, m.x = l.x);else {\n        l.h(c.x, a.y);\n        m.h(c.x, (a.y + c.y) / 2);\n        if (90 === d || 0 === d && c.x < h.left || 180 === d && c.x > h.right) 90 === d && (k.ba(a) || h.ba(c)) ? l.x = this.computeMidOrthoPosition(a.x, a.y, c.x, c.y, !1) : c.x < a.x && (90 === d || 0 === d) ? l.x = this.computeMidOrthoPosition(h.left, a.y, Math.max(c.x, k.right), c.y, !1) : c.x > a.x && (90 === d || 180 === d) && (l.x = this.computeMidOrthoPosition(h.right, a.y, Math.min(c.x, k.left), c.y, !1)), m.x = l.x, m.y = c.y;\n        if (l.x > h.left && l.x < h.right) if (c.y <= h.bottom && c.y >= a.y || a.y >= k.top && a.y <= c.y) {\n          if (0 === d || 180 === d) l.h(a.x, Math.min((a.y + c.y) / 2, a.y)), m.h(c.x, l.y);\n        } else l.x = 180 === d || (90 === d || 270 === d) && c.x < a.x ? Math.min(c.x, 270 === d ? h.left : Math.min(h.left, k.left)) : Math.max(c.x, 270 === d ? h.right : Math.max(h.right, k.right)), m.x = l.x, m.y = c.y;\n      }\n      var n = c;\n\n      if (this.isAvoiding) {\n        var p = this.diagram;\n        if (null === p || e === f || this.layer.isTemporary || !ck(p) || h.ba(n) && !f.Md(e) || k.ba(a) && !e.Md(f)) b = !1;else {\n          var r = dk(p, !0, this.containingGroup, null);\n          if (17 !== this.segmentIndex && r.Pj(Math.min(a.x, l.x), Math.min(a.y, l.y), Math.abs(a.x - l.x), Math.abs(a.y - l.y)) && r.Pj(Math.min(l.x, m.x), Math.min(l.y, m.y), Math.abs(l.x - m.x), Math.abs(l.y - m.y)) && r.Pj(Math.min(m.x, n.x), Math.min(m.y, n.y), Math.abs(m.x - n.x), Math.abs(m.y - n.y))) b = !1;else {\n            e = a;\n            f = n;\n            var q = c = null;\n\n            if (p.isVirtualized) {\n              p = r.bounds.copy();\n              p.vc(-r.lo, -r.ko);\n              var u = I.alloc();\n              ik(r, a.x, a.y) || (J.wf(p.x, p.y, p.x + p.width, p.y + p.height, a.x, a.y, l.x, l.y, u) ? (c = a = u.copy(), b = u.Ya(l)) : J.wf(p.x, p.y, p.x + p.width, p.y + p.height, l.x, l.y, m.x, m.y, u) ? (c = a = u.copy(), b = u.Ya(m)) : J.wf(p.x, p.y, p.x + p.width, p.y + p.height, m.x, m.y, n.x, n.y, u) && (c = a = u.copy(), b = u.Ya(n)));\n              ik(r, n.x, n.y) || (J.wf(p.x, p.y, p.x + p.width, p.y + p.height, n.x, n.y, m.x, m.y, u) ? (q = n = u.copy(), d = m.Ya(u)) : J.wf(p.x, p.y, p.x + p.width, p.y + p.height, m.x, m.y, l.x, l.y, u) ? (q = n = u.copy(), d = l.Ya(u)) : J.wf(p.x, p.y, p.x + p.width, p.y + p.height, l.x, l.y, a.x, a.y, u) && (q = n = u.copy(), d = a.Ya(u)));\n              I.free(u);\n            }\n\n            h = h.copy().Xc(k);\n            h.vc(r.lo * r.ps, r.ko * r.ps);\n            Hp(r, a, b, n, d, h, !0);\n            k = Ip(r, n.x, n.y);\n            !r.abort && k >= Jp && (hk(r), h.vc(r.lo * r.mx, r.ko * r.nx), Hp(r, a, b, n, d, h, !1), k = Ip(r, n.x, n.y));\n\n            if (!r.abort && k < Jp && Ip(r, n.x, n.y) !== jk) {\n              Kp(this, r, n.x, n.y, d, !0, g);\n              h = this.i(2);\n              if (4 > this.pointsCount) 0 === b || 180 === b ? (h.x = a.x, h.y = n.y) : (h.x = n.x, h.y = a.y), this.M(2, h.x, h.y), this.l(3, h.x, h.y);else if (g = this.i(3), 0 === b || 180 === b) J.B(h.x, g.x) ? (h = 0 === b ? Math.max(h.x, a.x) : Math.min(h.x, a.x), this.M(2, h, a.y), this.M(3, h, g.y)) : J.B(h.y, g.y) ? (Math.abs(a.y - h.y) <= r.ko / 2 && (this.M(2, h.x, a.y), this.M(3, g.x, a.y)), this.l(2, h.x, a.y)) : this.M(2, a.x, h.y);else if (90 === b || 270 === b) J.B(h.y, g.y) ? (h = 90 === b ? Math.max(h.y, a.y) : Math.min(h.y, a.y), this.M(2, a.x, h), this.M(3, g.x, h)) : J.B(h.x, g.x) ? (Math.abs(a.x - h.x) <= r.lo / 2 && (this.M(2, a.x, h.y), this.M(3, a.x, g.y)), this.l(2, a.x, h.y)) : this.M(2, h.x, a.y);\n              null !== c && (a = this.i(1), g = this.i(2), a.x !== g.x && a.y !== g.y ? 0 === b || 180 === b ? this.l(2, a.x, g.y) : this.l(2, g.x, a.y) : 0 === b || 180 === b ? this.l(2, e.x, c.y) : this.l(2, c.x, e.y));\n              null !== q && (0 === d || 180 === d ? this.mf(f.x, q.y) : this.mf(q.x, f.y));\n              b = !0;\n            } else b = !1;\n          }\n        }\n      } else b = !1;\n\n      b || (this.fe(l.copy()), this.fe(m.copy()));\n      I.free(l);\n      I.free(m);\n    }\n  };\n\n  T.prototype.computeMidOrthoPosition = function (a, b, c, d, e) {\n    var f = 0;\n    !this.hasCurviness() || this.computeSpot(!0, this.fromPort).Uc() || this.computeSpot(!1, this.toPort).Uc() || (f = this.computeCurviness());\n    return e ? (b + d) / 2 + f : (a + c) / 2 + f;\n  };\n\n  function Lj(a) {\n    if (null === a.diagram || !a.isAvoiding || !ck(a.diagram)) return !1;\n    var b = a.points.s,\n        c = b.length;\n    if (4 > c) return !1;\n    a = dk(a.diagram, !0, a.containingGroup, null);\n\n    for (var d = 1; d < c - 2; d++) {\n      var e = b[d],\n          f = b[d + 1];\n      if (!a.Pj(Math.min(e.x, f.x), Math.min(e.y, f.y), Math.abs(e.x - f.x), Math.abs(e.y - f.y))) return !0;\n    }\n\n    return !1;\n  }\n\n  function Kp(a, b, c, d, e, f, g) {\n    var h = b.lo,\n        k = b.ko,\n        l = Ip(b, c, d),\n        m = c,\n        n = d;\n    0 === e ? m += h : 90 === e ? n += k : 180 === e ? m -= h : n -= k;\n    e !== g && l > Lp && Ip(b, m, n) !== l - 1 && (Ip(b, c - h, d) === l - 1 ? (e = 180, m = c - h, n = d) : Ip(b, c + h, d) === l - 1 ? (e = 0, m = c + h, n = d) : Ip(b, c, d - k) === l - 1 ? (e = 270, m = c, n = d - k) : Ip(b, c, d + k) === l - 1 && (e = 90, m = c, n = d + k));\n\n    for (; l > Lp && Ip(b, m, n) === l - 1;) {\n      c = m, d = n, 0 === e ? m += h : 90 === e ? n += k : 180 === e ? m -= h : n -= k, --l;\n    }\n\n    if (f) {\n      if (l > Lp) if (180 === e || 0 === e) c = Math.floor(c / h) * h + h / 2;else if (90 === e || 270 === e) d = Math.floor(d / k) * k + k / 2;\n    } else c = Math.floor(c / h) * h + h / 2, d = Math.floor(d / k) * k + k / 2;\n\n    l > Lp && (f = e, g = c, m = d, 0 === e ? (f = 90, m += k) : 90 === e ? (f = 180, g -= h) : 180 === e ? (f = 270, m -= k) : 270 === e && (f = 0, g += h), Ip(b, g, m) === l - 1 ? Kp(a, b, g, m, f, !1, f) : (g = c, m = d, 0 === e ? (f = 270, m -= k) : 90 === e ? (f = 0, g += h) : 180 === e ? (f = 90, m += k) : 270 === e && (f = 180, g -= h), Ip(b, g, m) === l - 1 && Kp(a, b, g, m, f, !1, f)));\n    a.mf(c, d);\n  }\n\n  T.prototype.Ny = function (a) {\n    var b = a.x;\n    a = a.y;\n\n    for (var c = this.i(0), d = this.i(1), e = zb(b, a, c.x, c.y, d.x, d.y), f = 0, g = 1; g < this.pointsCount - 1; g++) {\n      c = this.i(g + 1);\n      var h = zb(b, a, d.x, d.y, c.x, c.y);\n      d = c;\n      h < e && (f = g, e = h);\n    }\n\n    return f;\n  };\n\n  T.prototype.mc = function (a) {\n    this.Zl = !1;\n    a && this.w();\n  };\n\n  T.prototype.Rj = function (a) {\n    if (!a) {\n      if (!1 === this.xd) return;\n      a = this.vb();\n      if (this.Zl && (null === a || null !== a.geometry)) return;\n    }\n\n    this.sa = this.makeGeometry();\n    a = this.path;\n\n    if (null !== a) {\n      a.sa = this.sa;\n\n      for (var b = this.R.s, c = b.length, d = 0; d < c; d++) {\n        var e = b[d];\n        e !== a && e.isPanelMain && e instanceof Cf && (e.sa = this.sa);\n      }\n    }\n  };\n\n  T.prototype.makeGeometry = function () {\n    var a = this.sa,\n        b = this.pointsCount;\n    if (2 > b) return a.type = O.j, this.Zl = !0, a;\n    var c = !1,\n        d = this.diagram;\n    null !== d && qp(this) && d.th.contains(this) && (0 !== this.bl.width || 0 !== this.bl.height) && (c = !0);\n    var e = this.i(0).copy(),\n        f = e.copy();\n    d = this.Jb.s;\n    var g = this.computeCurve();\n    if (g === cg && 3 <= b && !J.ca(this.smoothness, 0)) {\n      if (3 === b) {\n        var h = this.i(1);\n        d = Math.min(e.x, h.x);\n        var k = Math.min(e.y, h.y);\n        h = this.i(2);\n        d = Math.min(d, h.x);\n        k = Math.min(k, h.y);\n      } else {\n        if (this.isOrthogonal) for (k = 0; k < b; k++) {\n          h = d[k], f.x = Math.min(h.x, f.x), f.y = Math.min(h.y, f.y);\n        } else for (d = 3; d < b; d += 3) {\n          d + 3 >= b && (d = b - 1), k = this.i(d), f.x = Math.min(k.x, f.x), f.y = Math.min(k.y, f.y);\n        }\n        d = f.x;\n        k = f.y;\n      }\n    } else {\n      for (k = 0; k < b; k++) {\n        h = d[k], f.x = Math.min(h.x, f.x), f.y = Math.min(h.y, f.y);\n      }\n\n      d = f.x;\n      k = f.y;\n    }\n    d -= this.Yt.x;\n    k -= this.Yt.y;\n    e.x -= d;\n    e.y -= k;\n\n    if (2 !== b || qp(this)) {\n      a.type = O.m;\n      h = wd(a);\n      0 !== this.computeShortLength(!0) && (e = Mp(this, e, !0, f));\n      xd(h, e.x, e.y, !1);\n      if (g === cg && 3 <= b && !J.ca(this.smoothness, 0)) {\n        if (3 === b) c = this.i(1), b = c.x - d, c = c.y - k, e = this.i(2).copy(), e.x -= d, e.y -= k, 0 !== this.computeShortLength(!1) && (e = Mp(this, e, !1, f)), yd(h, b, c, b, c, e.x, e.y);else if (this.isOrthogonal) {\n          b = I.allocAt(d, k);\n          c = I.alloc();\n          c.assign(this.i(1));\n          f = I.allocAt(d, k);\n          e = I.allocAt(d, k);\n          g = this.i(0);\n\n          for (var l, m = this.smoothness / 3, n = 1; n < this.pointsCount - 1; n++) {\n            l = this.i(n);\n            var p = g,\n                r = l,\n                q = this.i(Np(this, l, n, !1));\n            if (!J.ca(p.x, r.x) || !J.ca(r.x, q.x)) if (!J.ca(p.y, r.y) || !J.ca(r.y, q.y)) {\n              var u = m;\n              isNaN(u) && (u = this.smoothness / 3);\n              var w = p.x;\n              p = p.y;\n              var v = r.x;\n              r = r.y;\n              var z = q.x;\n              q = q.y;\n              var y = u * Op(w, p, v, r);\n              u *= Op(v, r, z, q);\n              J.ca(p, r) && J.ca(v, z) && (v > w ? q > r ? (f.x = v - y, f.y = r - y, e.x = v + u, e.y = r + u) : (f.x = v - y, f.y = r + y, e.x = v + u, e.y = r - u) : q > r ? (f.x = v + y, f.y = r - y, e.x = v - u, e.y = r + u) : (f.x = v + y, f.y = r + y, e.x = v - u, e.y = r - u));\n              J.ca(w, v) && J.ca(r, q) && (r > p ? (z > v ? (f.x = v - y, f.y = r - y, e.x = v + u) : (f.x = v + y, f.y = r - y, e.x = v - u), e.y = r + u) : (z > v ? (f.x = v - y, f.y = r + y, e.x = v + u) : (f.x = v + y, f.y = r + y, e.x = v - u), e.y = r - u));\n              if (J.ca(w, v) && J.ca(v, z) || J.ca(p, r) && J.ca(r, q)) w = .5 * (w + z), p = .5 * (p + q), f.x = w, f.y = p, e.x = w, e.y = p;\n              1 === n ? (c.x = .5 * (g.x + l.x), c.y = .5 * (g.y + l.y)) : 2 === n && J.ca(g.x, this.i(0).x) && J.ca(g.y, this.i(0).y) && (c.x = .5 * (g.x + l.x), c.y = .5 * (g.y + l.y));\n              yd(h, c.x - d, c.y - k, f.x - d, f.y - k, l.x - d, l.y - k);\n              b.set(f);\n              c.set(e);\n              g = l;\n            }\n          }\n\n          l = g.x;\n          g = g.y;\n          m = this.i(this.pointsCount - 1);\n          0 !== this.computeShortLength(!1) && (m = Mp(this, m.copy(), !1, qb));\n          l = .5 * (l + m.x);\n          g = .5 * (g + m.y);\n          yd(h, e.x - d, e.y - k, l - d, g - k, m.x - d, m.y - k);\n          I.free(b);\n          I.free(c);\n          I.free(f);\n          I.free(e);\n        } else for (c = 3; c < b; c += 3) {\n          f = this.i(c - 2), c + 3 >= b && (c = b - 1), e = this.i(c - 1), g = this.i(c), c === b - 1 && 0 !== this.computeShortLength(!1) && (g = Mp(this, g.copy(), !1, qb)), yd(h, f.x - d, f.y - k, e.x - d, e.y - k, g.x - d, g.y - k);\n        }\n      } else {\n        f = I.alloc();\n        f.assign(this.i(0));\n        e = I.alloc();\n        e.assign(f);\n        g = this.computeCorner();\n        n = 1;\n\n        for (l = 0; n < b;) {\n          n = Np(this, f, n, 1 < n);\n          m = this.i(n);\n\n          if (n >= b - 1) {\n            if (!f.C(m)) 0 !== this.computeShortLength(!1) && (m = Mp(this, m.copy(), !1, qb)), Pp(this, h, -d, -k, f, m, c);else if (0 === l) for (n = 1; n < b;) {\n              e.assign(f), m = this.i(n++), Pp(this, h, -d, -k, f, m, c), f.assign(m);\n            }\n            break;\n          }\n\n          l = Np(this, m, n + 1, n < b - 3);\n          n = -d;\n          w = -k;\n          p = m;\n          v = this.i(l);\n          u = c;\n          if (J.B(f.y, p.y) && J.B(p.x, v.x)) {\n            if (q = Math.min(g, Math.abs(p.x - e.x) / 2), q = y = Math.min(q, Math.abs(v.y - p.y) / 2), J.B(q, 0)) Pp(this, h, n, w, f, p, u), f.assign(p);else {\n              var A = p.x,\n                  B = p.y;\n              r = A;\n              z = B;\n              p.x > f.x ? A = p.x - q : A = p.x + q;\n              v.y > p.y ? z = p.y + y : z = p.y - y;\n              v = I.allocAt(A, B);\n              Pp(this, h, n, w, f, v, u);\n              I.free(v);\n              zd(h, p.x + n, p.y + w, r + n, z + w);\n              f.h(r, z);\n            }\n          } else J.B(f.x, p.x) && J.B(p.y, v.y) ? (q = Math.min(g, Math.abs(p.y - e.y) / 2), q = y = Math.min(q, Math.abs(v.x - p.x) / 2), J.B(y, 0) ? (Pp(this, h, n, w, f, p, u), f.assign(p)) : (A = p.x, B = p.y, r = A, z = B, p.y > f.y ? B = p.y - q : B = p.y + q, v.x > p.x ? r = p.x + y : r = p.x - y, v = I.allocAt(A, B), Pp(this, h, n, w, f, v, u), I.free(v), zd(h, p.x + n, p.y + w, r + n, z + w), f.h(r, z))) : (Pp(this, h, n, w, f, p, u), f.assign(p));\n          e.assign(m);\n          n = l;\n        }\n\n        I.free(f);\n      }\n      Hd = h;\n    } else h = this.i(1).copy(), h.x -= d, h.y -= k, 0 !== this.computeShortLength(!0) && (e = Mp(this, e, !0, f)), 0 !== this.computeShortLength(!1) && (h = Mp(this, h, !1, f)), a.type = O.j, a.startX = e.x, a.startY = e.y, a.endX = h.x, a.endY = h.y;\n\n    this.Zl = !0;\n    return a;\n  };\n\n  function Op(a, b, c, d) {\n    a = c - a;\n    if (isNaN(a) || Infinity === a || -Infinity === a) return NaN;\n    0 > a && (a = -a);\n    b = d - b;\n    if (isNaN(b) || Infinity === b || -Infinity === b) return NaN;\n    0 > b && (b = -b);\n    return J.ca(a, 0) ? b : J.ca(b, 0) ? a : Math.sqrt(a * a + b * b);\n  }\n\n  function Mp(a, b, c, d) {\n    var e = a.pointsCount;\n    if (2 > e) return b;\n\n    if (c) {\n      var f = a.i(1);\n      c = f.x - d.x;\n      f = f.y - d.y;\n      d = Op(b.x, b.y, c, f);\n      if (0 === d) return b;\n      e = 2 === e ? .5 * d : d;\n      a = a.computeShortLength(!0);\n      a > e && (a = e);\n      e = a * (f - b.y) / d;\n      b.x += a * (c - b.x) / d;\n      b.y += e;\n    } else {\n      f = a.i(e - 2);\n      c = f.x - d.x;\n      f = f.y - d.y;\n      d = Op(b.x, b.y, c, f);\n      if (0 === d) return b;\n      e = 2 === e ? .5 * d : d;\n      a = a.computeShortLength(!1);\n      a > e && (a = e);\n      e = a * (b.y - f) / d;\n      b.x -= a * (b.x - c) / d;\n      b.y -= e;\n    }\n\n    return b;\n  }\n\n  function Np(a, b, c, d) {\n    for (var e = a.pointsCount, f = b; J.ca(b.x, f.x) && J.ca(b.y, f.y);) {\n      if (c >= e) return e - 1;\n      f = a.i(c++);\n    }\n\n    if (!J.ca(b.x, f.x) && !J.ca(b.y, f.y)) return c - 1;\n\n    for (var g = f; J.ca(b.x, f.x) && J.ca(f.x, g.x) && (!d || (b.y >= f.y ? f.y >= g.y : f.y <= g.y)) || J.ca(b.y, f.y) && J.ca(f.y, g.y) && (!d || (b.x >= f.x ? f.x >= g.x : f.x <= g.x));) {\n      if (c >= e) return e - 1;\n      g = a.i(c++);\n    }\n\n    return c - 2;\n  }\n\n  T.prototype.computeJumpLength = function () {\n    return 10;\n  };\n\n  function Pp(a, b, c, d, e, f, g) {\n    if (!g && qp(a)) {\n      g = a.computeJumpLength();\n      var h = g / 2,\n          k = [],\n          l = 0;\n      a.isVisible() && (l = Qp(a, e, f, k));\n      if (0 < l) if (J.B(e.y, f.y)) {\n        if (e.x < f.x) for (var m = 0; m < l;) {\n          var n = Math.max(e.x, Math.min(k[m++] - h, f.x - g));\n          b.lineTo(n + c, f.y + d);\n          var p = n + c;\n\n          for (var r = Math.min(n + g, f.x); m < l;) {\n            if (n = k[m], n < r + g) m++, r = Math.min(n + h, f.x);else break;\n          }\n\n          n = f.y - g + d;\n          r += c;\n          var q = f.y + d;\n          a.curve === Zf ? xd(b, r, q, !1) : yd(b, p, n, r, n, r, q);\n        } else for (--l; 0 <= l;) {\n          m = Math.min(e.x, Math.max(k[l--] + h, f.x + g));\n          b.lineTo(m + c, f.y + d);\n          p = m + c;\n\n          for (n = Math.max(m - g, f.x); 0 <= l;) {\n            if (m = k[l], m > n - g) l--, n = Math.max(m - h, f.x);else break;\n          }\n\n          m = f.y - g + d;\n          n += c;\n          r = f.y + d;\n          a.curve === Zf ? xd(b, n, r, !1) : yd(b, p, m, n, m, n, r);\n        }\n      } else if (J.B(e.x, f.x)) if (e.y < f.y) for (m = 0; m < l;) {\n        n = Math.max(e.y, Math.min(k[m++] - h, f.y - g));\n        b.lineTo(f.x + c, n + d);\n        p = n + d;\n\n        for (n = Math.min(n + g, f.y); m < l;) {\n          if (r = k[m], r < n + g) m++, n = Math.min(r + h, f.y);else break;\n        }\n\n        r = f.x - g + c;\n        q = f.x + c;\n        n += d;\n        a.curve === Zf ? xd(b, q, n, !1) : yd(b, r, p, r, n, q, n);\n      } else for (--l; 0 <= l;) {\n        m = Math.min(e.y, Math.max(k[l--] + h, f.y + g));\n        b.lineTo(f.x + c, m + d);\n        p = m + d;\n\n        for (m = Math.max(m - g, f.y); 0 <= l;) {\n          if (n = k[l], n > m - g) l--, m = Math.max(n - h, f.y);else break;\n        }\n\n        n = f.x - g + c;\n        r = f.x + c;\n        m += d;\n        a.curve === Zf ? xd(b, r, m, !1) : yd(b, n, p, n, m, r, m);\n      }\n    }\n\n    b.lineTo(f.x + c, f.y + d);\n  }\n\n  function Qp(a, b, c, d) {\n    var e = a.diagram;\n    if (null === e || b.C(c)) return 0;\n\n    for (e = e.layers; e.next();) {\n      var f = e.value;\n\n      if (null !== f && f.visible) {\n        f = f.Ma.s;\n\n        for (var g = f.length, h = 0; h < g; h++) {\n          var k = f[h];\n\n          if (k instanceof T) {\n            if (k === a) return 0 < d.length && d.sort(function (a, b) {\n              return a - b;\n            }), d.length;\n\n            if (k.isVisible() && qp(k)) {\n              var l = k.routeBounds;\n              l.v() && a.routeBounds.Sc(l) && !a.usesSamePort(k) && (l = k.path, null !== l && l.zf() && Rp(b, c, d, k));\n            }\n          }\n        }\n      }\n    }\n\n    0 < d.length && d.sort(function (a, b) {\n      return a - b;\n    });\n    return d.length;\n  }\n\n  function Rp(a, b, c, d) {\n    for (var e = J.B(a.y, b.y), f = d.pointsCount, g = d.i(0), h = I.alloc(), k = 1; k < f; k++) {\n      var l = d.i(k);\n\n      if (k < f - 1) {\n        var m = d.i(k + 1);\n\n        if (g.y === l.y && l.y === m.y) {\n          if (l.x > g.x && m.x >= l.x || l.x < g.x && m.x <= l.x) continue;\n        } else if (g.x === l.x && l.x === m.x && (l.y > g.y && m.y >= l.y || l.y < g.y && m.y <= l.y)) continue;\n      }\n\n      a: {\n        m = a.x;\n        var n = a.y,\n            p = b.x,\n            r = b.y,\n            q = g.x;\n        g = g.y;\n        var u = l.x,\n            w = l.y;\n\n        if (!J.B(m, p)) {\n          if (J.B(n, r) && J.B(q, u) && Math.min(m, p) < q && Math.max(m, p) > q && Math.min(g, w) < n && Math.max(g, w) > n && !J.B(g, w)) {\n            h.x = q;\n            h.y = n;\n            m = !0;\n            break a;\n          }\n        } else if (!J.B(n, r) && J.B(g, w) && Math.min(n, r) < g && Math.max(n, r) > g && Math.min(q, u) < m && Math.max(q, u) > m && !J.B(q, u)) {\n          h.x = m;\n          h.y = g;\n          m = !0;\n          break a;\n        }\n\n        h.x = 0;\n        h.y = 0;\n        m = !1;\n      }\n\n      m && (e ? c.push(h.x) : c.push(h.y));\n      g = l;\n    }\n\n    I.free(h);\n  }\n\n  function qp(a) {\n    a = a.curve;\n    return a === Yf || a === Zf;\n  }\n\n  function up(a, b) {\n    if (b || qp(a)) b = a.diagram, null === b || b.animationManager.isTicking || b.th.contains(a) || 0 === a.bl.width && 0 === a.bl.height || b.th.add(a, a.bl.copy());\n  }\n\n  T.prototype.Ao = function (a) {\n    var b = this.layer;\n\n    if (null !== b && b.visible && !b.isTemporary) {\n      var c = b.diagram;\n\n      if (null !== c && !c.animationManager.isTicking) {\n        var d = !1;\n\n        for (c = c.layers; c.next();) {\n          var e = c.value;\n          if (e.visible) if (e === b) {\n            d = !0;\n            var f = !1;\n            e = e.Ma.s;\n\n            for (var g = e.length, h = 0; h < g; h++) {\n              var k = e[h];\n              k instanceof T && (k === this ? f = !0 : f && Sp(this, k, a));\n            }\n          } else if (d) for (f = e.Ma.s, e = f.length, g = 0; g < e; g++) {\n            h = f[g], h instanceof T && Sp(this, h, a);\n          }\n        }\n      }\n    }\n  };\n\n  function Sp(a, b, c) {\n    if (null !== b && b.Zl && b.xd && qp(b)) {\n      var d = b.routeBounds;\n      d.v() && (a.routeBounds.Sc(d) || c.Sc(d)) && (a.usesSamePort(b) || b.mc(!1));\n    }\n  }\n\n  T.prototype.usesSamePort = function (a) {\n    var b = this.pointsCount,\n        c = a.pointsCount;\n\n    if (0 < b && 0 < c) {\n      var d = this.i(0),\n          e = a.i(0);\n      if (d.$a(e)) return !0;\n      b = this.i(b - 1);\n      a = a.i(c - 1);\n      if (b.$a(a) || d.$a(a) || b.$a(e)) return !0;\n    } else if (this.fromNode === a.fromNode || this.toNode === a.toNode || this.fromNode === a.toNode || this.toNode === a.fromNode) return !0;\n\n    return !1;\n  };\n\n  T.prototype.isVisible = function () {\n    if (!U.prototype.isVisible.call(this)) return !1;\n    var a = this.containingGroup,\n        b = !0,\n        c = this.diagram;\n    null !== c && (b = c.isTreePathToChildren);\n    c = this.fromNode;\n\n    if (null !== c) {\n      if (this.isTreeLink && b && !c.isTreeExpanded) return !1;\n      if (c === a) return !0;\n\n      for (var d = c; null !== d;) {\n        if (d.labeledLink === this) return !0;\n        d = d.containingGroup;\n      }\n\n      c = c.findVisibleNode();\n      if (null === c || c === a) return !1;\n    }\n\n    c = this.toNode;\n\n    if (null !== c) {\n      if (this.isTreeLink && !b && !c.isTreeExpanded) return !1;\n      if (c === a) return !0;\n\n      for (b = c; null !== b;) {\n        if (b.labeledLink === this) return !0;\n        b = b.containingGroup;\n      }\n\n      b = c.findVisibleNode();\n      if (null === b || b === a) return !1;\n    }\n\n    return !0;\n  };\n\n  T.prototype.Ub = function (a) {\n    U.prototype.Ub.call(this, a);\n    null !== this.If && this.If.Al();\n    if (null !== this.rd) for (var b = this.rd.iterator; b.next();) {\n      b.value.Ub(a);\n    }\n  };\n\n  T.prototype.computeAdjusting = function () {\n    return this.isAvoiding && null !== this.diagram && this.diagram.animationManager.defaultAnimation.isAnimating ? mp : this.dk;\n  };\n\n  function rp(a) {\n    var b = a.Ue;\n\n    if (null !== b) {\n      var c = a.hf;\n\n      if (null !== c && isNaN(a.curviness)) {\n        for (var d = a.Ve, e = a.jf, f = a = null, g = b.jb.s, h = g.length, k = 0; k < h; k++) {\n          var l = g[k];\n          if (l.Ue === b && l.Ve === d && l.hf === c && l.jf === e || l.Ue === c && l.Ve === e && l.hf === b && l.jf === d) null === f ? f = l : (null === a && (a = [], a.push(f)), a.push(l));\n        }\n\n        if (null !== a) {\n          f = Xo(b, c, d, e);\n          null === f && (f = new Tp(b, d, c, e), Wo(b, f), Wo(c, f));\n          f.links = a;\n\n          for (b = 0; b < a.length; b++) {\n            a[b].If = f;\n          }\n\n          f.Al();\n        }\n      }\n    }\n  }\n\n  function sp(a) {\n    var b = a.If;\n    null !== b && isNaN(a.curviness) && (a.If = null, a = b.links.indexOf(a), 0 <= a && (Da(b.links, a), b.Al()));\n  }\n\n  T.prototype.eh = function () {\n    return !0;\n  };\n\n  ma.Object.defineProperties(T.prototype, {\n    fromNode: {\n      get: function get() {\n        return this.Ue;\n      },\n      set: function set(a) {\n        var b = this.Ue;\n\n        if (b !== a) {\n          var c = this.fromPort;\n          null !== b && (this.hf !== b && ap(b, this, c), sp(this), this.D(2));\n          this.Ue = a;\n          null !== a && this.Ub(a.isVisible());\n          this.Mf = null;\n          this.ab();\n          var d = this.diagram;\n          null !== d && d.$ && d.partManager.setFromNodeForLink(this, a, b);\n          var e = this.fromPort,\n              f = this.fromPortChanged;\n\n          if (null !== f) {\n            var g = !0;\n            null !== d && (g = d.$, d.$ = !0);\n            f(this, c, e);\n            null !== d && (d.$ = g);\n          }\n\n          null !== a && (this.hf !== a && $o(a, this, e), rp(this), this.D(1));\n          this.g(\"fromNode\", b, a);\n          So(this);\n        }\n      }\n    },\n    fromPortId: {\n      get: function get() {\n        return this.Ve;\n      },\n      set: function set(a) {\n        var b = this.Ve;\n\n        if (b !== a) {\n          var c = this.fromPort;\n          null !== c && Yo(c);\n          sp(this);\n          this.Ve = a;\n          var d = this.fromPort;\n          null !== d && Yo(d);\n          var e = this.diagram;\n\n          if (null !== e) {\n            var f = this.data,\n                g = e.model;\n            null !== f && g.ki() && g.dv(f, a);\n          }\n\n          c !== d && (this.Mf = null, this.ab(), f = this.fromPortChanged, null !== f && (g = !0, null !== e && (g = e.$, e.$ = !0), f(this, c, d), null !== e && (e.$ = g)));\n          rp(this);\n          this.g(\"fromPortId\", b, a);\n        }\n      }\n    },\n    fromPort: {\n      get: function get() {\n        var a = this.Ue;\n        return null === a ? null : a.Kr(this.Ve);\n      }\n    },\n    fromPortChanged: {\n      get: function get() {\n        return this.Om;\n      },\n      set: function set(a) {\n        var b = this.Om;\n        b !== a && (this.Om = a, this.g(\"fromPortChanged\", b, a));\n      }\n    },\n    toNode: {\n      get: function get() {\n        return this.hf;\n      },\n      set: function set(a) {\n        var b = this.hf;\n\n        if (b !== a) {\n          var c = this.toPort;\n          null !== b && (this.Ue !== b && ap(b, this, c), sp(this), this.D(2));\n          this.hf = a;\n          null !== a && this.Ub(a.isVisible());\n          this.Mf = null;\n          this.ab();\n          var d = this.diagram;\n          null !== d && d.$ && d.partManager.setToNodeForLink(this, a, b);\n          var e = this.toPort,\n              f = this.toPortChanged;\n\n          if (null !== f) {\n            var g = !0;\n            null !== d && (g = d.$, d.$ = !0);\n            f(this, c, e);\n            null !== d && (d.$ = g);\n          }\n\n          null !== a && (this.Ue !== a && $o(a, this, e), rp(this), this.D(1));\n          this.g(\"toNode\", b, a);\n          So(this);\n        }\n      }\n    },\n    toPortId: {\n      get: function get() {\n        return this.jf;\n      },\n      set: function set(a) {\n        var b = this.jf;\n\n        if (b !== a) {\n          var c = this.toPort;\n          null !== c && Yo(c);\n          sp(this);\n          this.jf = a;\n          var d = this.toPort;\n          null !== d && Yo(d);\n          var e = this.diagram;\n\n          if (null !== e) {\n            var f = this.data,\n                g = e.model;\n            null !== f && g.ki() && g.hv(f, a);\n          }\n\n          c !== d && (this.Mf = null, this.ab(), f = this.toPortChanged, null !== f && (g = !0, null !== e && (g = e.$, e.$ = !0), f(this, c, d), null !== e && (e.$ = g)));\n          rp(this);\n          this.g(\"toPortId\", b, a);\n        }\n      }\n    },\n    toPort: {\n      get: function get() {\n        var a = this.hf;\n        return null === a ? null : a.Kr(this.jf);\n      }\n    },\n    toPortChanged: {\n      get: function get() {\n        return this.Xn;\n      },\n      set: function set(a) {\n        var b = this.Xn;\n        b !== a && (this.Xn = a, this.g(\"toPortChanged\", b, a));\n      }\n    },\n    fromSpot: {\n      get: function get() {\n        return null !== this.aa ? this.aa.Qi : Wc;\n      },\n      set: function set(a) {\n        var b = this.fromSpot;\n        b.C(a) || (a = a.J(), this.Rc(), this.aa.Qi = a, this.g(\"fromSpot\", b, a), (b.Uc() || a.Uc()) && null !== this.fromNode && Yo(this.fromPort), this.ab());\n      }\n    },\n    fromEndSegmentLength: {\n      get: function get() {\n        return null !== this.aa ? this.aa.Oi : NaN;\n      },\n      set: function set(a) {\n        var b = this.fromEndSegmentLength;\n        b !== a && (0 > a && wa(a, \">= 0\", T, \"fromEndSegmentLength\"), this.Rc(), this.aa.Oi = a, this.g(\"fromEndSegmentLength\", b, a), this.ab());\n      }\n    },\n    fromShortLength: {\n      get: function get() {\n        return null !== this.aa ? this.aa.Pi : NaN;\n      },\n      set: function set(a) {\n        var b = this.fromShortLength;\n        b !== a && (this.Rc(), this.aa.Pi = a, this.mc(!0), this.g(\"fromShortLength\", b, a));\n      }\n    },\n    toSpot: {\n      get: function get() {\n        return null !== this.aa ? this.aa.tj : Wc;\n      },\n      set: function set(a) {\n        var b = this.toSpot;\n        b.C(a) || (a = a.J(), this.Rc(), this.aa.tj = a, this.g(\"toSpot\", b, a), (b.Uc() || a.Uc()) && null !== this.toNode && Yo(this.toPort), this.ab());\n      }\n    },\n    toEndSegmentLength: {\n      get: function get() {\n        return null !== this.aa ? this.aa.rj : NaN;\n      },\n      set: function set(a) {\n        var b = this.toEndSegmentLength;\n        b !== a && (0 > a && wa(a, \">= 0\", T, \"toEndSegmentLength\"), this.Rc(), this.aa.rj = a, this.g(\"toEndSegmentLength\", b, a), this.ab());\n      }\n    },\n    toShortLength: {\n      get: function get() {\n        return null !== this.aa ? this.aa.sj : NaN;\n      },\n      set: function set(a) {\n        var b = this.toShortLength;\n        b !== a && (this.Rc(), this.aa.sj = a, this.mc(!0), this.g(\"toShortLength\", b, a));\n      }\n    },\n    isLabeledLink: {\n      get: function get() {\n        return null === this.rd ? !1 : 0 < this.rd.count;\n      }\n    },\n    labelNodes: {\n      get: function get() {\n        return null === this.rd ? Za : this.rd.iterator;\n      }\n    },\n    relinkableFrom: {\n      get: function get() {\n        return 0 !== (this.Oa & 1);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.Oa & 1);\n        b !== a && (this.Oa ^= 1, this.g(\"relinkableFrom\", b, a), this.Rb());\n      }\n    },\n    relinkableTo: {\n      get: function get() {\n        return 0 !== (this.Oa & 2);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.Oa & 2);\n        b !== a && (this.Oa ^= 2, this.g(\"relinkableTo\", b, a), this.Rb());\n      }\n    },\n    resegmentable: {\n      get: function get() {\n        return 0 !== (this.Oa & 4);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.Oa & 4);\n        b !== a && (this.Oa ^= 4, this.g(\"resegmentable\", b, a), this.Rb());\n      }\n    },\n    isTreeLink: {\n      get: function get() {\n        return 0 !== (this.Oa & 8);\n      },\n      set: function set(a) {\n        var b = 0 !== (this.Oa & 8);\n        b !== a && (this.Oa ^= 8, this.g(\"isTreeLink\", b, a), null !== this.fromNode && Bk(this.fromNode), null !== this.toNode && Bk(this.toNode));\n      }\n    },\n    path: {\n      get: function get() {\n        var a = this.vb();\n        return a instanceof Cf ? a : null;\n      }\n    },\n    routeBounds: {\n      get: function get() {\n        this.mg();\n        var a = this.bl,\n            b = Infinity,\n            c = Infinity,\n            d = this.pointsCount;\n        if (0 === d) a.h(NaN, NaN, 0, 0);else {\n          if (1 === d) d = this.i(0), b = Math.min(d.x, b), c = Math.min(d.y, c), a.h(d.x, d.y, 0, 0);else if (2 === d) {\n            d = this.i(0);\n            var e = this.i(1);\n            b = Math.min(d.x, e.x);\n            c = Math.min(d.y, e.y);\n            a.h(d.x, d.y, 0, 0);\n            a.Me(e);\n          } else if (this.computeCurve() === cg && 3 <= d && !this.isOrthogonal) {\n            if (e = this.i(0), b = e.x, c = e.y, a.h(b, c, 0, 0), 3 === d) {\n              d = this.i(1);\n              b = Math.min(d.x, b);\n              c = Math.min(d.y, c);\n              var f = this.i(2);\n              b = Math.min(f.x, b);\n              c = Math.min(f.y, c);\n              J.ql(e.x, e.y, d.x, d.y, d.x, d.y, f.x, f.y, .5, a);\n            } else for (f = 3; f < d; f += 3) {\n              var g = this.i(f - 2);\n              f + 3 >= d && (f = d - 1);\n              var h = this.i(f - 1),\n                  k = this.i(f);\n              J.ql(e.x, e.y, g.x, g.y, h.x, h.y, k.x, k.y, .5, a);\n              b = Math.min(k.x, b);\n              c = Math.min(k.y, c);\n              e = k;\n            }\n          } else for (e = this.i(0), f = this.i(1), b = Math.min(e.x, f.x), c = Math.min(e.y, f.y), a.h(e.x, e.y, 0, 0), a.Me(f), e = 2; e < d; e++) {\n            f = this.i(e), b = Math.min(f.x, b), c = Math.min(f.y, c), a.Me(f);\n          }\n          this.Yt.h(b - a.x, c - a.y);\n        }\n        return a;\n      }\n    },\n    midPoint: {\n      get: function get() {\n        this.mg();\n        return this.computeMidPoint(new I());\n      }\n    },\n    midAngle: {\n      get: function get() {\n        this.mg();\n        return this.computeMidAngle();\n      }\n    },\n    flattenedLengths: {\n      get: function get() {\n        if (null === this.Gp) {\n          this.xd || tp(this);\n\n          for (var a = this.Gp = [], b = this.pointsCount, c = 0; c < b - 1; c++) {\n            var d = this.i(c);\n            var e = this.i(c + 1);\n            J.ca(d.x, e.x) ? (d = e.y - d.y, 0 > d && (d = -d)) : J.ca(d.y, e.y) ? (d = e.x - d.x, 0 > d && (d = -d)) : d = Math.sqrt(d.rf(e));\n            a.push(d);\n          }\n        }\n\n        return this.Gp;\n      }\n    },\n    flattenedTotalLength: {\n      get: function get() {\n        var a = this.Ys;\n\n        if (isNaN(a)) {\n          for (var b = this.flattenedLengths, c = b.length, d = a = 0; d < c; d++) {\n            a += b[d];\n          }\n\n          this.Ys = a;\n        }\n\n        return a;\n      }\n    },\n    points: {\n      get: function get() {\n        return this.Jb;\n      },\n      set: function set(a) {\n        var b = this.Jb;\n\n        if (b !== a) {\n          var c = null;\n\n          if (Array.isArray(a)) {\n            var d = 0 === a.length % 2;\n            if (d) for (var e = 0; e < a.length; e++) {\n              if (\"number\" !== typeof a[e] || isNaN(a[e])) {\n                d = !1;\n                break;\n              }\n            }\n            if (d) for (c = new E(), d = 0; d < a.length / 2; d++) {\n              e = new I(a[2 * d], a[2 * d + 1]).freeze(), c.add(e);\n            } else {\n              d = !0;\n\n              for (e = 0; e < a.length; e++) {\n                var f = a[e];\n\n                if (!ya(f) || \"number\" !== typeof f.x || isNaN(f.x) || \"number\" !== typeof f.y || isNaN(f.y)) {\n                  d = !1;\n                  break;\n                }\n              }\n\n              if (d) for (c = new E(), d = 0; d < a.length; d++) {\n                e = a[d], c.add(new I(e.x, e.y).freeze());\n              }\n            }\n          } else if (a instanceof E) for (c = a.copy(), a = c.iterator; a.next();) {\n            a.value.freeze();\n          } else C(\"Link.points value is not an instance of List or Array: \" + a);\n\n          c.freeze();\n          this.Jb = c;\n          this.mc(!0);\n          tp(this);\n          a = this.diagram;\n          null !== a && (a.ji || a.undoManager.isUndoingRedoing || a.Zr.add(this), a.animationManager.zb && (a = a.animationManager, this.ef = c, a.dl.add(this)));\n          this.g(\"points\", b, c);\n        }\n      }\n    },\n    pointsCount: {\n      get: function get() {\n        return this.Jb.count;\n      }\n    },\n    xd: {\n      get: function get() {\n        return 0 !== (this.Oa & 16);\n      },\n      set: function set(a) {\n        0 !== (this.Oa & 16) !== a && (this.Oa ^= 16);\n      }\n    },\n    suspendsRouting: {\n      get: function get() {\n        return 0 !== (this.Oa & 32);\n      },\n      set: function set(a) {\n        0 !== (this.Oa & 32) !== a && (this.Oa ^= 32);\n      }\n    },\n    computingPoints: {\n      get: function get() {\n        return 0 !== (this.Oa & 64);\n      },\n      set: function set(a) {\n        0 !== (this.Oa & 64) !== a && (this.Oa ^= 64);\n      }\n    },\n    defaultFromPoint: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        this.m = a.copy();\n      }\n    },\n    defaultToPoint: {\n      get: function get() {\n        return this.u;\n      },\n      set: function set(a) {\n        this.u = a.copy();\n      }\n    },\n    isOrthogonal: {\n      get: function get() {\n        return 2 === (this.kj.value & 2);\n      }\n    },\n    isAvoiding: {\n      get: function get() {\n        return 4 === (this.kj.value & 4);\n      }\n    },\n    Zl: {\n      get: function get() {\n        return 0 !== (this.Oa & 128);\n      },\n      set: function set(a) {\n        0 !== (this.Oa & 128) !== a && (this.Oa ^= 128);\n      }\n    },\n    geometry: {\n      get: function get() {\n        this.Zl || (this.mg(), this.sa = this.makeGeometry());\n        return this.sa;\n      }\n    },\n    firstPickIndex: {\n      get: function get() {\n        return 2 >= this.pointsCount ? 0 : this.isOrthogonal || !xp(this.computeSpot(!0)) ? 1 : 0;\n      }\n    },\n    lastPickIndex: {\n      get: function get() {\n        var a = this.pointsCount;\n        return 0 === a ? 0 : 2 >= a ? a - 1 : this.isOrthogonal || !xp(this.computeSpot(!1)) ? a - 2 : a - 1;\n      }\n    },\n    adjusting: {\n      get: function get() {\n        return this.dk;\n      },\n      set: function set(a) {\n        var b = this.dk;\n        b !== a && (this.dk = a, this.g(\"adjusting\", b, a));\n      }\n    },\n    corner: {\n      get: function get() {\n        return this.wm;\n      },\n      set: function set(a) {\n        var b = this.wm;\n        b !== a && (this.wm = a, this.mc(!0), this.g(\"corner\", b, a));\n      }\n    },\n    curve: {\n      get: function get() {\n        return this.ym;\n      },\n      set: function set(a) {\n        var b = this.ym;\n        b !== a && (this.ym = a, this.ab(), this.mc(!0), up(this, b === Zf || b === Yf || a === Zf || a === Yf), this.g(\"curve\", b, a));\n      }\n    },\n    curviness: {\n      get: function get() {\n        return this.zm;\n      },\n      set: function set(a) {\n        var b = this.zm;\n        b !== a && (this.zm = a, this.ab(), this.mc(!1), this.g(\"curviness\", b, a));\n      }\n    },\n    routing: {\n      get: function get() {\n        return this.kj;\n      },\n      set: function set(a) {\n        var b = this.kj;\n        b !== a && (this.kj = a, this.Mf = null, this.ab(), up(this, 2 === (b.value & 2) || 2 === (a.value & 2)), this.g(\"routing\", b, a));\n      }\n    },\n    smoothness: {\n      get: function get() {\n        return this.Sn;\n      },\n      set: function set(a) {\n        var b = this.Sn;\n        b !== a && (this.Sn = a, this.mc(!0), this.g(\"smoothness\", b, a));\n      }\n    },\n    key: {\n      get: function get() {\n        var a = this.diagram;\n        if (null !== a && a.model.ki()) return a.model.uc(this.data);\n      }\n    }\n  });\n  T.prototype.invalidateOtherJumpOvers = T.prototype.Ao;\n  T.prototype.findClosestSegment = T.prototype.Ny;\n  T.prototype.updateRoute = T.prototype.mg;\n  T.prototype.invalidateRoute = T.prototype.ab;\n  T.prototype.rollbackRoute = T.prototype.$u;\n  T.prototype.commitRoute = T.prototype.pf;\n  T.prototype.startRoute = T.prototype.jh;\n  T.prototype.clearPoints = T.prototype.Aj;\n  T.prototype.removePoint = T.prototype.Yu;\n  T.prototype.addPointAt = T.prototype.mf;\n  T.prototype.addPoint = T.prototype.fe;\n  T.prototype.insertPointAt = T.prototype.l;\n  T.prototype.insertPoint = T.prototype.sz;\n  T.prototype.setPointAt = T.prototype.M;\n  T.prototype.setPoint = T.prototype.Wc;\n  T.prototype.getPoint = T.prototype.i;\n  T.prototype.getOtherPort = T.prototype.jz;\n  T.prototype.getOtherNode = T.prototype.wo;\n  var vp = null,\n      wp = null,\n      lp = new D(T, \"Normal\", 1),\n      Up = new D(T, \"Orthogonal\", 2),\n      Vp = new D(T, \"AvoidsNodes\", 6),\n      Dp = new D(T, \"AvoidsNodesStraight\", 7),\n      $f = new D(T, \"None\", 0),\n      cg = new D(T, \"Bezier\", 9),\n      Zf = new D(T, \"JumpGap\", 10),\n      Yf = new D(T, \"JumpOver\", 11),\n      mp = new D(T, \"End\", 17),\n      np = new D(T, \"Scale\", 18),\n      op = new D(T, \"Stretch\", 19),\n      Sm = new D(T, \"OrientAlong\", 21),\n      Lm = new D(T, \"OrientPlus90\", 22),\n      Nm = new D(T, \"OrientMinus90\", 23),\n      pp = new D(T, \"OrientOpposite\", 24),\n      Tm = new D(T, \"OrientUpright\", 25),\n      Mm = new D(T, \"OrientPlus90Upright\", 26),\n      Om = new D(T, \"OrientMinus90Upright\", 27),\n      Pm = new D(T, \"OrientUpright45\", 28),\n      Fp = 16,\n      Ep = 14,\n      Gp = 8;\n  T.className = \"Link\";\n  T.Normal = lp;\n  T.Orthogonal = Up;\n  T.AvoidsNodes = Vp;\n  T.AvoidsNodesStraight = Dp;\n  T.None = $f;\n  T.Bezier = cg;\n  T.JumpGap = Zf;\n  T.JumpOver = Yf;\n  T.End = mp;\n  T.Scale = np;\n  T.Stretch = op;\n  T.OrientAlong = Sm;\n  T.OrientPlus90 = Lm;\n  T.OrientMinus90 = Nm;\n  T.OrientOpposite = pp;\n  T.OrientUpright = Tm;\n  T.OrientPlus90Upright = Mm;\n  T.OrientMinus90Upright = Om;\n  T.OrientUpright45 = Pm;\n  T.EndSegmentStep = 8;\n  T.CurvinessStart = Fp;\n  T.SpacingMin = Ep;\n  T.OrthoShortCut = Gp;\n\n  function Tp(a, b, c, d) {\n    Ra(this);\n    this.ue = this.Sp = !1;\n    this.cs = a;\n    this.vx = b;\n    this.Pu = c;\n    this.wx = d;\n    this.links = [];\n  }\n\n  Tp.prototype.Al = function () {\n    if (!this.Sp) {\n      var a = this.links;\n      0 < a.length && (a = a[0].diagram, null !== a && (a.Uv.add(this), this.ue = a.undoManager.isUndoingRedoing));\n    }\n\n    this.Sp = !0;\n  };\n\n  Tp.prototype.rv = function () {\n    if (this.Sp) {\n      this.Sp = !1;\n      var a = this.links;\n\n      if (0 < a.length) {\n        var b = a[0],\n            c = b.diagram;\n        c = null === c || c.ji && !this.ue;\n        this.ue = !1;\n        b.arrangeBundledLinks(a, c);\n        1 === a.length && (b.If = null, a.length = 0);\n      }\n\n      0 === a.length && (a = this.cs, null !== this && null !== a.Qe && a.Qe.remove(this), a = this.Pu, null !== this && null !== a.Qe && a.Qe.remove(this));\n    }\n  };\n\n  Tp.className = \"LinkBundle\";\n\n  function ek(a) {\n    Ra(this);\n    this.Hx = this.group = null;\n    this.Sr = !0;\n    this.abort = !1;\n    this.Ed = this.Dd = 1;\n    this.mn = this.ln = -1;\n    this.nc = a.width;\n    this.oc = a.height;\n    this.Xb = null;\n    this.Xh = this.Wh = 0;\n    this.ps = 11;\n    this.nx = this.mx = 22;\n  }\n\n  ek.prototype.initialize = function (a) {\n    if (!(0 >= a.width || 0 >= a.height)) {\n      var b = a.y,\n          c = a.x + a.width,\n          d = a.y + a.height;\n      this.Dd = Math.floor((a.x - this.nc) / this.nc) * this.nc;\n      this.Ed = Math.floor((b - this.oc) / this.oc) * this.oc;\n      this.ln = Math.ceil((c + 2 * this.nc) / this.nc) * this.nc;\n      this.mn = Math.ceil((d + 2 * this.oc) / this.oc) * this.oc;\n      a = 1 + (Math.ceil((this.ln - this.Dd) / this.nc) | 0);\n      b = 1 + (Math.ceil((this.mn - this.Ed) / this.oc) | 0);\n\n      if (null === this.Xb || this.Wh < a - 1 || this.Xh < b - 1) {\n        c = [];\n\n        for (d = 0; d <= a; d++) {\n          c[d] = new Uint32Array(b);\n        }\n\n        this.Xb = c;\n        this.Wh = a - 1;\n        this.Xh = b - 1;\n      }\n\n      a = Wp;\n      if (null !== this.Xb) for (b = 0; b <= this.Wh; b++) {\n        if (c = this.Xb[b], c.fill) c.fill(a);else for (d = 0; d <= this.Xh; d++) {\n          c[d] = a;\n        }\n      }\n    }\n  };\n\n  function ik(a, b, c) {\n    return a.Dd <= b && b <= a.ln && a.Ed <= c && c <= a.mn;\n  }\n\n  function Ip(a, b, c) {\n    if (!ik(a, b, c)) return Wp;\n    b -= a.Dd;\n    b /= a.nc;\n    c -= a.Ed;\n    c /= a.oc;\n    return a.Xb[b | 0][c | 0];\n  }\n\n  function hk(a) {\n    if (null !== a.Xb) for (var b = 0; b <= a.Wh; b++) {\n      for (var c = a.Xb[b], d = 0; d <= a.Xh; d++) {\n        c[d] >= Lp && (c[d] = Wp);\n      }\n    }\n  }\n\n  ek.prototype.Pj = function (a, b, c, d) {\n    if (a > this.ln || a + c < this.Dd || b > this.mn || b + d < this.Ed) return !0;\n    a = (a - this.Dd) / this.nc | 0;\n    b = (b - this.Ed) / this.oc | 0;\n    c = Math.max(0, c) / this.nc + 1 | 0;\n    var e = Math.max(0, d) / this.oc + 1 | 0;\n    0 > a && (c += a, a = 0);\n    0 > b && (e += b, b = 0);\n    if (0 > c || 0 > e) return !0;\n    d = Math.min(a + c - 1, this.Wh) | 0;\n\n    for (c = Math.min(b + e - 1, this.Xh) | 0; a <= d; a++) {\n      e = this.Xb[a];\n\n      for (var f = b; f <= c; f++) {\n        if (e[f] === jk) return !1;\n      }\n    }\n\n    return !0;\n  };\n\n  function Xp(a, b, c, d, e, f, g, h, k) {\n    if (!(b < f || b > g || c < h || c > k)) {\n      var l = b | 0;\n      var m = c | 0;\n      var n = a.Xb[l][m];\n      if (n >= Lp && n < Jp) for (e ? m += d : l += d, n += 1; f <= l && l <= g && h <= m && m <= k && !(n >= a.Xb[l][m]);) {\n        a.Xb[l][m] = n, n += 1, e ? m += d : l += d;\n      }\n      l = e ? m : l;\n      if (e) {\n        if (0 < d) for (c += d; c < l; c += d) {\n          Xp(a, b, c, 1, !e, f, g, h, k), Xp(a, b, c, -1, !e, f, g, h, k);\n        } else for (c += d; c > l; c += d) {\n          Xp(a, b, c, 1, !e, f, g, h, k), Xp(a, b, c, -1, !e, f, g, h, k);\n        }\n      } else if (0 < d) for (b += d; b < l; b += d) {\n        Xp(a, b, c, 1, !e, f, g, h, k), Xp(a, b, c, -1, !e, f, g, h, k);\n      } else for (b += d; b > l; b += d) {\n        Xp(a, b, c, 1, !e, f, g, h, k), Xp(a, b, c, -1, !e, f, g, h, k);\n      }\n    }\n  }\n\n  function Yp(a, b, c, d, e, f, g, h, k) {\n    b |= 0;\n    c |= 0;\n    var l = jk,\n        m = Lp;\n\n    for (a.Xb[b][c] = m; l === jk && b > f && b < g && c > h && c < k;) {\n      m += 1, a.Xb[b][c] = m, e ? c += d : b += d, l = a.Xb[b][c];\n    }\n  }\n\n  function Zp(a, b, c, d, e, f, g, h, k) {\n    b |= 0;\n    c |= 0;\n    var l = jk,\n        m = Jp;\n\n    for (a.Xb[b][c] = m; l === jk && b > f && b < g && c > h && c < k;) {\n      a.Xb[b][c] = m, e ? c += d : b += d, l = a.Xb[b][c];\n    }\n  }\n\n  function Hp(a, b, c, d, e, f, g) {\n    if (null !== a.Xb) {\n      a.abort = !1;\n      var h = b.x,\n          k = b.y;\n\n      if (ik(a, h, k)) {\n        h -= a.Dd;\n        h /= a.nc;\n        k -= a.Ed;\n        k /= a.oc;\n        var l = d.x,\n            m = d.y;\n        if (ik(a, l, m)) if (l -= a.Dd, l /= a.nc, m -= a.Ed, m /= a.oc, 1 >= Math.abs(h - l) && 1 >= Math.abs(k - m)) a.abort = !0;else {\n          var n = f.x;\n          d = f.y;\n          b = f.x + f.width;\n          var p = f.y + f.height;\n          n -= a.Dd;\n          n /= a.nc;\n          d -= a.Ed;\n          d /= a.oc;\n          b -= a.Dd;\n          b /= a.nc;\n          p -= a.Ed;\n          p /= a.oc;\n          f = Math.max(0, Math.min(a.Wh, n | 0));\n          b = Math.min(a.Wh, Math.max(0, b | 0));\n          n = Math.max(0, Math.min(a.Xh, d | 0));\n          p = Math.min(a.Xh, Math.max(0, p | 0));\n          d = a.Xb;\n          h |= 0;\n          k |= 0;\n          l |= 0;\n          m |= 0;\n          var r = 0 === c || 90 === c ? 1 : -1;\n          c = 90 === c || 270 === c;\n          d[h][k] === jk ? (Yp(a, h, k, r, c, f, b, n, p), Yp(a, h, k, 1, !c, f, b, n, p), Yp(a, h, k, -1, !c, f, b, n, p)) : Yp(a, h, k, r, c, h, k, h, k);\n          d[l][m] === jk ? (Zp(a, l, m, 0 === e || 90 === e ? 1 : -1, 90 === e || 270 === e, f, b, n, p), Zp(a, l, m, 1, !(90 === e || 270 === e), f, b, n, p), Zp(a, l, m, -1, !(90 === e || 270 === e), f, b, n, p)) : Zp(a, l, m, r, c, l, m, l, m);\n          c = Ea();\n\n          if (g && $p(a, l, m, e, h, k, c)) {\n            if (c[0] !== l || c[1] !== m) c.unshift(m), c.unshift(l);\n            if (c[c.length - 2] !== h || c[c.length - 1] !== k) c.push(h), c.push(k);\n            a = Lp;\n            e = c[c.length - 2];\n            g = c[c.length - 1];\n            d[e][g] = a++;\n\n            for (f = c.length - 4; 0 <= f; f -= 2) {\n              for (e = c[f + 2], g = c[f + 3], b = c[f], l = c[f + 1]; b > e ? e++ : b < e ? e-- : l > g ? g++ : l < g && g--, d[e][g] = a++, e !== b || g !== l;) {\n                ;\n              }\n            }\n          } else Xp(a, h, k, 1, !1, f, b, n, p), Xp(a, h, k, -1, !1, f, b, n, p), Xp(a, h, k, 1, !0, f, b, n, p), Xp(a, h, k, -1, !0, f, b, n, p);\n\n          Ga(c);\n        }\n      }\n    }\n  }\n\n  function $p(a, b, c, d, e, f, g) {\n    for (var h = a.Xb, k = b, l = c;;) {\n      if (k === e && l === f) return !0;\n      var m = k,\n          n = l;\n      if (0 === d) {\n        if (m < e) m++;else break;\n      } else if (90 === d) {\n        if (n < f) n++;else break;\n      } else if (180 === d) {\n        if (m > e) m--;else break;\n      } else if (n > f) n--;else break;\n      var p = h[m][n];\n      if (0 === p || p === aq) break;\n      k = m;\n      l = n;\n    }\n\n    for (;;) {\n      m = d;\n      n = k;\n      p = l;\n      0 === d ? p < f ? (m = 90, p++) : p > f && (m = 270, p--) : 90 === d ? n < e ? (m = 0, n++) : n > e && (m = 180, n--) : 180 === d ? p < f ? (m = 90, p++) : p > f && (m = 270, p--) : n < e ? (m = 0, n++) : n > e && (m = 180, n--);\n      n = h[n][p];\n\n      if (m !== d && 0 !== n && n !== aq) {\n        g.push(k);\n        g.push(l);\n        if ($p(a, k, l, m, e, f, g)) return !0;\n        g.pop();\n        g.pop();\n      }\n\n      h[k][l] = aq;\n\n      if (0 === d) {\n        if (k === b) return !1;\n        k--;\n      } else if (90 === d) {\n        if (l === c) return !1;\n        l--;\n      } else if (180 === d) {\n        if (k === b) return !1;\n        k++;\n      } else {\n        if (l === c) return !1;\n        l++;\n      }\n    }\n  }\n\n  ma.Object.defineProperties(ek.prototype, {\n    bounds: {\n      get: function get() {\n        return new M(this.Dd, this.Ed, this.ln - this.Dd, this.mn - this.Ed);\n      }\n    },\n    lo: {\n      get: function get() {\n        return this.nc;\n      },\n      set: function set(a) {\n        0 < a && a !== this.nc && (this.nc = a, this.initialize(this.bounds));\n      }\n    },\n    ko: {\n      get: function get() {\n        return this.oc;\n      },\n      set: function set(a) {\n        0 < a && a !== this.oc && (this.oc = a, this.initialize(this.bounds));\n      }\n    }\n  });\n  var jk = 0,\n      Lp = 1,\n      Jp = 999999,\n      Wp = Jp + 1,\n      aq = Jp + 2;\n  ek.className = \"PositionArray\";\n\n  function Bp() {\n    Ra(this);\n    this.port = this.node = null;\n    this.he = [];\n    this.Do = !1;\n  }\n\n  Bp.prototype.toString = function () {\n    for (var a = this.he, b = this.node.toString() + \" \" + a.length.toString() + \":\", c = 0; c < a.length; c++) {\n      var d = a[c];\n      null !== d && (b += \"\\n  \" + d.toString());\n    }\n\n    return b;\n  };\n\n  function bq(a, b, c, d) {\n    b = b.offsetY;\n\n    switch (b) {\n      case 8:\n        return 90;\n\n      case 2:\n        return 180;\n\n      case 1:\n        return 270;\n\n      case 4:\n        return 0;\n    }\n\n    switch (b) {\n      case 9:\n        return 180 < c ? 270 : 90;\n\n      case 6:\n        return 90 < c && 270 >= c ? 180 : 0;\n    }\n\n    a = 180 * Math.atan2(a.height, a.width) / Math.PI;\n\n    switch (b) {\n      case 3:\n        return c > a && c <= 180 + a ? 180 : 270;\n\n      case 5:\n        return c > 180 - a && c <= 360 - a ? 270 : 0;\n\n      case 12:\n        return c > a && c <= 180 + a ? 90 : 0;\n\n      case 10:\n        return c > 180 - a && c <= 360 - a ? 180 : 90;\n\n      case 7:\n        return 90 < c && c <= 180 + a ? 180 : c > 180 + a && c <= 360 - a ? 270 : 0;\n\n      case 13:\n        return 180 < c && c <= 360 - a ? 270 : c > a && 180 >= c ? 90 : 0;\n\n      case 14:\n        return c > a && c <= 180 - a ? 90 : c > 180 - a && 270 >= c ? 180 : 0;\n\n      case 11:\n        return c > 180 - a && c <= 180 + a ? 180 : c > 180 + a ? 270 : 90;\n    }\n\n    d && 15 !== b && (c -= 15, 0 > c && (c += 360));\n    return c > a && c < 180 - a ? 90 : c >= 180 - a && c <= 180 + a ? 180 : c > 180 + a && c < 360 - a ? 270 : 0;\n  }\n\n  Bp.prototype.Al = function () {\n    this.he.length = 0;\n  };\n\n  function Cp(a, b) {\n    var c = a.he;\n\n    if (0 === c.length) {\n      a: if (!a.Do) {\n        c = a.Do;\n        a.Do = !0;\n        var d = null,\n            e = a.node,\n            f = e instanceof qf ? e : null;\n        if (null === f || f.isSubGraphExpanded) var g = e.isTreeExpanded ? e.findLinksConnected(a.port.portId) : e.Tw();else {\n          if (!f.actualBounds.v()) {\n            a.Do = c;\n            break a;\n          }\n\n          d = f;\n          g = d.vu();\n        }\n        f = a.he.length = 0;\n        var h = a.port.ia(tc, I.alloc()),\n            k = a.port.ia(Cc, I.alloc());\n        e = M.allocAt(h.x, h.y, 0, 0);\n        e.Me(k);\n        I.free(h);\n        I.free(k);\n        h = I.allocAt(e.x + e.width / 2, e.y + e.height / 2);\n        k = a.port.fi();\n\n        for (g = g.iterator; g.next();) {\n          var l = g.value;\n\n          if (l.isVisible() && l.fromPort !== l.toPort) {\n            var m = l.fromPort === a.port || null !== l.fromNode && l.fromNode.Md(d),\n                n = l.computeSpot(m, a.port);\n\n            if (n.Uc() && (m = m ? l.toPort : l.fromPort, null !== m)) {\n              var p = m.part;\n\n              if (null !== p) {\n                var r = p.findVisibleNode();\n                null !== r && r !== p && (p = r, m = p.port);\n                m = l.computeOtherPoint(p, m);\n                p = h.Ya(m);\n                p -= k;\n                0 > p ? p += 360 : 360 <= p && (p -= 360);\n                n = bq(e, n, p, l.isOrthogonal);\n                0 === n ? (n = 4, 180 < p && (p -= 360)) : 90 === n ? (n = 8, 270 < p && (p -= 360)) : 180 === n ? n = 2 : (n = 1, 90 > p && (p += 360));\n                r = a.he[f];\n                void 0 === r ? (r = new cq(l, p, n), a.he[f] = r) : (r.link = l, r.angle = p, r.Gc = n);\n                r.Ru.set(m);\n                f++;\n              }\n            }\n          }\n        }\n\n        I.free(h);\n        a.he.sort(Bp.prototype.j);\n        k = a.he.length;\n        d = -1;\n\n        for (f = h = 0; f < k; f++) {\n          g = a.he[f], void 0 !== g && (g.Gc !== d && (d = g.Gc, h = 0), g.xo = h, h++);\n        }\n\n        d = -1;\n        h = 0;\n\n        for (f = k - 1; 0 <= f; f--) {\n          k = a.he[f], void 0 !== k && (k.Gc !== d && (d = k.Gc, h = k.xo + 1), k.tl = h);\n        }\n\n        f = a.he;\n        n = a.port;\n        d = a.node.portSpreading;\n        h = I.alloc();\n        k = I.alloc();\n        g = I.alloc();\n        l = I.alloc();\n        n.ia(tc, h);\n        n.ia(vc, k);\n        n.ia(Cc, g);\n        n.ia(Ac, l);\n        r = p = m = n = 0;\n        if (d === ip) for (var q = 0; q < f.length; q++) {\n          var u = f[q];\n\n          if (null !== u) {\n            var w = u.link.computeThickness();\n\n            switch (u.Gc) {\n              case 8:\n                p += w;\n                break;\n\n              case 2:\n                r += w;\n                break;\n\n              case 1:\n                n += w;\n                break;\n\n              default:\n              case 4:\n                m += w;\n            }\n          }\n        }\n        var v = q = 0,\n            z = 1,\n            y = u = 0;\n\n        for (w = 0; w < f.length; w++) {\n          var A = f[w];\n\n          if (null !== A) {\n            if (q !== A.Gc) {\n              q = A.Gc;\n\n              switch (q) {\n                case 8:\n                  var B = g;\n                  v = l;\n                  break;\n\n                case 2:\n                  B = l;\n                  v = h;\n                  break;\n\n                case 1:\n                  B = h;\n                  v = k;\n                  break;\n\n                default:\n                case 4:\n                  B = k, v = g;\n              }\n\n              u = v.x - B.x;\n              y = v.y - B.y;\n\n              switch (q) {\n                case 8:\n                  p > Math.abs(u) ? (z = Math.abs(u) / p, p = Math.abs(u)) : z = 1;\n                  break;\n\n                case 2:\n                  r > Math.abs(y) ? (z = Math.abs(y) / r, r = Math.abs(y)) : z = 1;\n                  break;\n\n                case 1:\n                  n > Math.abs(u) ? (z = Math.abs(u) / n, n = Math.abs(u)) : z = 1;\n                  break;\n\n                default:\n                case 4:\n                  m > Math.abs(y) ? (z = Math.abs(y) / m, m = Math.abs(y)) : z = 1;\n              }\n\n              v = 0;\n            }\n\n            var F = A.Co;\n\n            if (d === ip) {\n              A = A.link.computeThickness();\n              A *= z;\n              F.set(B);\n\n              switch (q) {\n                case 8:\n                  F.x = B.x + u / 2 + p / 2 - v - A / 2;\n                  break;\n\n                case 2:\n                  F.y = B.y + y / 2 + r / 2 - v - A / 2;\n                  break;\n\n                case 1:\n                  F.x = B.x + u / 2 - n / 2 + v + A / 2;\n                  break;\n\n                default:\n                case 4:\n                  F.y = B.y + y / 2 - m / 2 + v + A / 2;\n              }\n\n              v += A;\n            } else {\n              var L = .5;\n              d === Uo && (L = (A.xo + 1) / (A.tl + 1));\n              F.x = B.x + u * L;\n              F.y = B.y + y * L;\n            }\n          }\n        }\n\n        I.free(h);\n        I.free(k);\n        I.free(g);\n        I.free(l);\n        B = a.he;\n\n        for (f = 0; f < B.length; f++) {\n          d = B[f], null !== d && (d.tu = a.computeEndSegmentLength(d));\n        }\n\n        a.Do = c;\n        M.free(e);\n      }\n\n      c = a.he;\n    }\n\n    for (a = 0; a < c.length; a++) {\n      if (e = c[a], null !== e && e.link === b) return e;\n    }\n\n    return null;\n  }\n\n  Bp.prototype.j = function (a, b) {\n    return a === b ? 0 : null === a ? -1 : null === b ? 1 : a.Gc < b.Gc ? -1 : a.Gc > b.Gc ? 1 : a.angle < b.angle ? -1 : a.angle > b.angle ? 1 : 0;\n  };\n\n  Bp.prototype.computeEndSegmentLength = function (a) {\n    var b = a.link,\n        c = b.computeEndSegmentLength(this.node, this.port, sc, b.fromPort === this.port),\n        d = a.xo;\n    if (0 > d) return c;\n    var e = a.tl;\n    if (1 >= e || !b.isOrthogonal) return c;\n    b = a.Ru;\n    var f = a.Co;\n    if (2 === a.Gc || 8 === a.Gc) d = e - 1 - d;\n    return ((a = 2 === a.Gc || 4 === a.Gc) ? b.y < f.y : b.x < f.x) ? c + 8 * d : (a ? b.y === f.y : b.x === f.x) ? c : c + 8 * (e - 1 - d);\n  };\n\n  Bp.className = \"Knot\";\n\n  function cq(a, b, c) {\n    this.link = a;\n    this.angle = b;\n    this.Gc = c;\n    this.Ru = new I();\n    this.tl = this.xo = 0;\n    this.Co = new I();\n    this.tu = 0;\n  }\n\n  cq.prototype.toString = function () {\n    return this.link.toString() + \" \" + this.angle.toString() + \" \" + this.Gc.toString() + \":\" + this.xo.toString() + \"/\" + this.tl.toString() + \" \" + this.Co.toString() + \" \" + this.tu.toString() + \" \" + this.Ru.toString();\n  };\n\n  cq.className = \"LinkInfo\";\n\n  function qi(a) {\n    Ra(this);\n    this.m = this.H = null;\n    this.wh = this.Zm = !0;\n    this.en = !1;\n    this.im = new I(0, 0).freeze();\n    this.bn = !0;\n    this.mm = this.an = null;\n    this.dn = !1;\n    this.j = null;\n    this.u = 0;\n    this.nn = this.ao = null;\n    this.zr = !1;\n    this.dg = this.lj = null;\n    this.ir = !1;\n    a && Object.assign(this, a);\n  }\n\n  qi.prototype.cloneProtected = function (a) {\n    a.Zm = this.Zm;\n    a.wh = this.wh;\n    a.en = this.en;\n    a.im.assign(this.im);\n    a.bn = this.bn;\n    a.an = this.an;\n    a.mm = this.mm;\n    a.dn = !0;\n    a.nn = this.nn;\n    a.ao = this.ao;\n  };\n\n  qi.prototype.copy = function () {\n    var a = new this.constructor();\n    this.cloneProtected(a);\n    return a;\n  };\n\n  qi.prototype.serializeLayoutProperties = function (a) {\n    a.arrangementOrigin = {\n      x: this.arrangementOrigin.x,\n      y: this.arrangementOrigin.y\n    };\n    a.isRouting = this.isRouting;\n  };\n\n  qi.prototype.deserializeLayoutProperties = function (a) {\n    null !== a && (this.arrangementOrigin = new I(a.arrangementOrigin.x, a.arrangementOrigin.y), this.isRouting = a.isRouting);\n  };\n\n  qi.prototype.ob = function () {};\n\n  qi.prototype.toString = function () {\n    var a = Ha(this.constructor);\n    a += \"(\";\n    null !== this.group && (a += \" in \" + this.group);\n    null !== this.diagram && (a += \" for \" + this.diagram);\n    return a + \")\";\n  };\n\n  qi.prototype.D = function () {\n    if (this.isValidLayout) {\n      var a = this.diagram;\n\n      if (null !== a && !a.undoManager.isUndoingRedoing) {\n        var b = a.animationManager;\n        !b.isTicking && (b.defaultAnimation.isAnimating && b.wc(), this.isOngoing && a.ji || this.isInitial && !a.ji) && (this.isValidLayout = !1, a.Mb());\n      }\n    }\n  };\n\n  qi.prototype.createNetwork = function () {\n    return new dq(this);\n  };\n\n  qi.prototype.makeNetwork = function (a) {\n    var b = this.createNetwork();\n    a instanceof Q ? (b.eg(a.nodes, !0), b.eg(a.links, !0)) : a instanceof qf ? b.eg(a.memberParts) : b.eg(a.iterator);\n    return b;\n  };\n\n  qi.prototype.updateParts = function () {\n    this.isValidLayout = !0;\n\n    if (!this.workerLayout()) {\n      var a = this.diagram;\n      if (null === a && null !== this.network) for (var b = this.network.vertexes.iterator; b.next();) {\n        var c = b.value.node;\n        if (null !== c && (a = c.diagram, null !== a)) break;\n      }\n\n      try {\n        null !== a && a.Da(\"Layout\"), this.commitLayout();\n      } finally {\n        null !== a && a.eb(\"Layout\");\n      }\n    }\n  };\n\n  qi.prototype.commitLayout = function () {\n    if (null !== this.network) {\n      for (var a = this.network.vertexes.iterator; a.next();) {\n        a.value.commit();\n      }\n\n      if (this.isRouting) for (a = this.network.edges.iterator; a.next();) {\n        a.value.commit();\n      }\n    }\n  };\n\n  qi.prototype.doLayout = function (a) {\n    var b = new G();\n    a instanceof Q ? (eq(this, b, a.nodes, !0, this.gh, !0, !1, !0), eq(this, b, a.parts, !0, this.gh, !0, !1, !0)) : a instanceof qf ? eq(this, b, a.memberParts, !1, this.gh, !0, !1, !0) : b.addAll(a.iterator);\n    0 < b.count && (a = this.diagram, null !== a && a.Da(\"Layout\"), this.doMinimalNoNetworkLayout(b), null !== a && a.eb(\"Layout\"));\n    this.isValidLayout = !0;\n  };\n\n  qi.prototype.doMinimalNoNetworkLayout = function (a) {\n    var b = Math.ceil(Math.sqrt(a.count));\n    this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);\n    var c = this.arrangementOrigin.x,\n        d = c,\n        e = this.arrangementOrigin.y,\n        f = 0,\n        g = 0;\n\n    for (a = a.iterator; a.next();) {\n      var h = a.value;\n      fq(h);\n      var k = h.measuredBounds,\n          l = k.width;\n      k = k.height;\n      h.moveTo(d, e);\n      h instanceof qf && (h.gh = !1);\n      d += Math.max(l, 50) + 20;\n      g = Math.max(g, Math.max(k, 50));\n      f >= b - 1 ? (f = 0, d = c, e += g + 20, g = 0) : f++;\n    }\n  };\n\n  qi.prototype.doMinimalNetworkLayout = function () {\n    var a = Math.ceil(Math.sqrt(this.network.vertexes.count));\n    this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);\n\n    for (var b = this.arrangementOrigin.x, c = b, d = this.arrangementOrigin.y, e = 0, f = 0, g = this.network.vertexes.iterator; g.next();) {\n      var h = g.value.node;\n\n      if (!(null === h || h instanceof T) && (fq(h), this.gh(h))) {\n        var k = h.measuredBounds,\n            l = k.width;\n        k = k.height;\n        h.moveTo(c, d);\n        h instanceof qf && (h.gh = !1);\n        c += Math.max(l, 50) + 20;\n        f = Math.max(f, Math.max(k, 50));\n        e >= a - 1 ? (e = 0, c = b, d += f + 20, f = 0) : e++;\n      }\n    }\n  };\n\n  qi.prototype.gh = function (a) {\n    return !a.location.v() || a instanceof qf && a.gh ? !0 : !1;\n  };\n\n  function eq(a, b, c, d, e, f, g, h) {\n    for (c = c.iterator; c.next();) {\n      var k = c.value;\n      d && !k.isTopLevel || null !== e && !e(k) || !k.canLayout() || (f && k instanceof V ? k.isLinkLabel || (k instanceof qf ? null === k.layout ? eq(a, b, k.memberParts, !1, e, f, g, h) : (fq(k), b.add(k)) : (fq(k), b.add(k))) : g && k instanceof T ? b.add(k) : !h || !k.Tc() || k instanceof V || (fq(k), b.add(k)));\n    }\n  }\n\n  function fq(a) {\n    var b = a.actualBounds;\n    (0 === b.width || 0 === b.height || isNaN(b.width) || isNaN(b.height)) && a.Za();\n  }\n\n  qi.prototype.hi = function (a, b) {\n    var c = this.boundsComputation;\n    if (null !== c) return b || (b = new M()), c(a, this, b);\n    if (!b) return a.actualBounds;\n    b.set(a.actualBounds);\n    return b;\n  };\n\n  qi.prototype.Iw = function (a) {\n    var b = new G();\n    a instanceof Q ? (eq(this, b, a.nodes, !0, null, !0, !0, !0), eq(this, b, a.links, !0, null, !0, !0, !0), eq(this, b, a.parts, !0, null, !0, !0, !0)) : a instanceof qf ? eq(this, b, a.memberParts, !1, null, !0, !0, !0) : eq(this, b, a.iterator, !1, null, !0, !0, !0);\n    return b;\n  };\n\n  qi.prototype.initialOrigin = function (a) {\n    var b = this.group;\n\n    if (null !== b) {\n      var c = b.position.copy();\n      (isNaN(c.x) || isNaN(c.y)) && c.set(a);\n      b = b.placeholder;\n      null !== b && (c = b.ia(tc), (isNaN(c.x) || isNaN(c.y)) && c.set(a), a = b.padding, c.x += a.left, c.y += a.top);\n      return c;\n    }\n\n    return a;\n  };\n\n  qi.prototype.mayUseWorker = function () {\n    return this.mayUseWorkerFunction ? this.mayUseWorkerFunction(this) : !1;\n  };\n\n  qi.prototype.workerLayout = function () {\n    return !1;\n  };\n\n  function gq(a, b) {\n    if (null !== a.workerStateChanged) {\n      var c = {\n        key: a.group ? a.group.key : null\n      };\n      void 0 !== b && (c.time = b);\n      null !== a.lj && (c.running = hq(a.lj));\n      null !== a.dg && (c.waiting = hq(a.dg));\n      a.workerStateChanged(c, a);\n    }\n  }\n\n  function hq(a) {\n    return {\n      vertexes: a.vertexes.count,\n      edges: a.edges.count\n    };\n  }\n\n  qi.prototype.uy = function () {\n    var a = iq(this.constructor);\n    a && (null !== a.Ne && a.Ne.terminate(), a.Ne = null, a.Cl.iteratorValues.each(function (a) {\n      a.zr = !1;\n      a.lj = null;\n      a.dg = null;\n      a.ir = !1;\n      gq(a);\n    }), a.Cl.clear());\n  };\n\n  function jq(a, b) {\n    var c = iq(a);\n\n    if (c) {\n      if (b) for (var d in b) {\n        c[d] = b[d];\n      }\n    } else throw Error(\"Unknown Layout class: \" + a);\n  }\n\n  function iq(a) {\n    var b = null;\n\n    if (\"function\" === typeof a) {\n      if (b = kq.get(a), !b) {\n        var c = Ha(a);\n        b = kq.get(c);\n        b || (b = new lq(), b.pu = a, b.name = c, b.j = a.name, b.hx = mq, kq.set(c, b), kq.set(a, b), kq.set(a.name, b));\n      }\n    } else \"string\" === typeof a && (b = kq.get(a));\n\n    return b;\n  }\n\n  qi.prototype.qv = function () {\n    if (\"undefined\" === typeof Worker || !nq || \"undefined\" === typeof self || \"undefined\" !== typeof self.DedicatedWorkerGlobalScope) return !1;\n    if (!this.mayUseWorker()) return this.zr && (this.ir = !0, this.dg = this.lj = null, gq(this)), !1;\n    var a = iq(this.constructor);\n    if (null === a) return !1;\n    null === a.Ne && (a.Ne = new Worker(nq), a.Ne.onerror = function (a) {\n      a.preventDefault();\n      xa(\"Worker Error at: \" + a.filename + \" \" + a.lineno + \" \" + a.colno + \"\\n  \" + a.message);\n    }, a.Ne.j = function (a) {\n      xa(\"Worker serialization error: \" + a);\n    }, a.Ne.onmessage = function (b) {\n      var c = b.data;\n      if (\"_GoJS\" === c._GoJS) if (c.version && Q.version && c.version !== Q.version) xa(\"Failure: GoJS v\" + Q.version + \"  Worker v\" + c.version);else if (b = a.Cl.get(c.id)) {\n        a.Cl.remove(c.id);\n        b.zr = !1;\n        b.lj = null;\n        if (b.ir) b.ir = !1, b.dg = null;else {\n          var d = oq(b, c, !1);\n          b.network = d;\n          b.updateParts();\n          b.network = null;\n          b.isValidLayout = !0;\n        }\n        gq(b, c.time);\n        c = b.dg;\n        if (null !== c) b.dg = null;else for (d = a.Cl.iteratorValues; d.next();) {\n          var e = d.value;\n          c = e.dg;\n\n          if (null !== c) {\n            e.dg = null;\n            break;\n          }\n        }\n        null !== c && pq(b, c);\n      }\n    }, a.Ne.postMessage({\n      _GoJS: \"_GoJS\",\n      url: a.hx\n    }), Array.isArray(a.scripts) && a.scripts.forEach(function (b) {\n      a.Ne.postMessage({\n        _GoJS: \"_GoJS\",\n        url: b\n      });\n    }), a.Ne.postMessage({\n      _GoJS: \"_GoJS\",\n      version: -1\n    }));\n    null !== this.lj ? this.dg = this.network : pq(this, this.network);\n    gq(this);\n    this.doMinimalNetworkLayout();\n    this.network = null;\n    return this.isValidLayout = !0;\n  };\n\n  function pq(a, b) {\n    a.zr = !0;\n    var c = iq(a.constructor),\n        d = qq(a, b, !0);\n    d._GoJS = \"_GoJS\";\n    c.Ne.postMessage(d);\n    c.Cl.set(cb(a), a);\n    a.lj = b;\n  }\n\n  function qq(a, b, c) {\n    a.onNetworkSerialization(1, c, b, null);\n    var d = {};\n    a.serializeLayoutProperties(d, c);\n    var e = [];\n    b.vertexes.each(function (a) {\n      var b = {};\n      a.serializeVertexProperties(b, c);\n      e.push(b);\n    });\n    var f = [];\n    b.edges.each(function (a) {\n      var b = {};\n      a.serializeEdgeProperties(b, c);\n      f.push(b);\n    });\n    d = {\n      id: c ? cb(a) : a.id,\n      layout: Ha(a.constructor),\n      p: d,\n      hA: e,\n      Ly: f\n    };\n    a.onNetworkSerialization(2, c, b, d);\n    return d;\n  }\n\n  function oq(a, b, c) {\n    c && (a.id = b.id);\n    var d = a.diagram,\n        e = a.createNetwork();\n    a.onNetworkSerialization(3, c, e, b);\n    var f = b.hA,\n        g = new pb();\n    f && f.forEach(function (a) {\n      var b = null;\n      null === a.key || null === d || c || (b = d.Lb(a.key));\n      null !== b ? b = e.yj(b) : (b = e.createVertex(), e.fg(b));\n      c && null !== a.key && (b.data = {\n        yh: a.key\n      });\n      g.set(a.id, b);\n    });\n    var h = b.Ly,\n        k = new pb();\n    h && h.forEach(function (a) {\n      var b = null;\n      null === a.key || null === d || c || (b = d.findLinkForKey(a.key));\n      var f = e.createEdge();\n      e.ol(f);\n      f.link = b;\n      c && null !== a.key && (f.data = {\n        yh: a.key\n      });\n      k.set(a.id, f);\n    });\n    f && f.forEach(function (a) {\n      var b = g.get(a.id);\n      b && b.deserializeVertexProperties(a, g, k, c);\n    });\n    h && h.forEach(function (a) {\n      var b = k.get(a.id);\n      b && b.deserializeEdgeProperties(a, g, k, c);\n    });\n    a.deserializeLayoutProperties(b.p, g, k, c, e);\n    a.onNetworkSerialization(4, c, e, b);\n    return e;\n  }\n\n  qi.prototype.onNetworkSerialization = function () {};\n\n  ma.Object.defineProperties(qi.prototype, {\n    diagram: {\n      get: function get() {\n        return this.H;\n      },\n      set: function set(a) {\n        this.H = a;\n      }\n    },\n    group: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        this.m !== a && (this.m = a, null !== a && (this.H = a.diagram));\n      }\n    },\n    isOngoing: {\n      get: function get() {\n        return this.Zm;\n      },\n      set: function set(a) {\n        this.Zm !== a && (this.Zm = a);\n      }\n    },\n    isInitial: {\n      get: function get() {\n        return this.wh;\n      },\n      set: function set(a) {\n        this.wh = a;\n        a || (this.dn = !0);\n      }\n    },\n    isViewportSized: {\n      get: function get() {\n        return this.en;\n      },\n      set: function set(a) {\n        this.en !== a && (this.en = a) && this.D();\n      }\n    },\n    isRouting: {\n      get: function get() {\n        return this.bn;\n      },\n      set: function set(a) {\n        this.bn !== a && (this.bn = a);\n      }\n    },\n    isRealtime: {\n      get: function get() {\n        return this.an;\n      },\n      set: function set(a) {\n        this.an !== a && (this.an = a);\n      }\n    },\n    isValidLayout: {\n      get: function get() {\n        return this.dn;\n      },\n      set: function set(a) {\n        this.dn !== a && (this.dn = a, a || (a = this.diagram, null !== a && (a.mh = !0)));\n      }\n    },\n    network: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        this.j !== a && (this.j = a, null !== a && (a.layout = this));\n      }\n    },\n    boundsComputation: {\n      get: function get() {\n        return this.mm;\n      },\n      set: function set(a) {\n        this.mm !== a && (this.mm = a, this.D());\n      }\n    },\n    arrangementOrigin: {\n      get: function get() {\n        return this.im;\n      },\n      set: function set(a) {\n        this.im.C(a) || (this.im.assign(a), this.D());\n      }\n    },\n    id: {\n      get: function get() {\n        return this.u;\n      },\n      set: function set(a) {\n        this.u = a;\n      }\n    },\n    mayUseWorkerFunction: {\n      get: function get() {\n        return this.nn;\n      },\n      set: function set(a) {\n        this.nn !== a && (this.nn = a);\n      }\n    },\n    workerStateChanged: {\n      get: function get() {\n        return this.ao;\n      },\n      set: function set(a) {\n        this.ao !== a && (this.ao = a);\n      }\n    }\n  });\n  qi.prototype.useWorker = qi.prototype.qv;\n  qi.declareWorkerLayout = jq;\n  qi.prototype.cancelWorker = qi.prototype.uy;\n  qi.prototype.collectParts = qi.prototype.Iw;\n  qi.prototype.getLayoutBounds = qi.prototype.hi;\n  qi.prototype.invalidateLayout = qi.prototype.D;\n  var kq = new pb(),\n      mq = \"object\" === typeof x.document && x.document.currentScript ? x.document.currentScript.src : \"\",\n      nq = \"undefined\" !== typeof URL && \"function\" === typeof URL.createObjectURL && \"function\" === typeof Blob ? URL.createObjectURL(new Blob([\"self.onmessage=function(e){if(e.data.url){\\nimportScripts(e.data.url);}}\"], {\n    type: \"text/javascript\"\n  })) : \"\";\n  qi.className = \"Layout\";\n  qi.GoJSScriptURL = mq;\n  qi.declareWorkerLayout = jq;\n  \"undefined\" !== typeof self && \"undefined\" !== typeof self.DedicatedWorkerGlobalScope && \"undefined\" !== typeof self && \"undefined\" !== typeof self.DedicatedWorkerGlobalScope && (self.onmessage = function (a) {\n    a = a.data;\n    if (\"_GoJS\" === a._GoJS) if (a.url) importScripts(a.url);else if (a.version) self.postMessage({\n      _GoJS: \"_GoJS\",\n      version: Q.version\n    }, void 0);else {\n      var b = performance.now(),\n          c = null;\n      a.layout && (c = iq(a.layout));\n      var d = null;\n      c && c.pu && (d = new c.pu());\n      if (!d) throw Error(\"no registered Worker Layout: \" + a.layout);\n      d.network = oq(d, a, !0);\n\n      d.workerLayout = function () {\n        var a = qq(d, d.network, !1);\n        a._GoJS = \"_GoJS\";\n        a.time = performance.now() - b;\n        self.postMessage(a, void 0);\n        return !0;\n      };\n\n      d.doLayout(new E());\n    }\n  });\n\n  function lq() {\n    this.pu = null;\n    this.hx = this.j = this.name = \"\";\n    this.scripts = [];\n    this.Ne = null;\n    this.Cl = new pb();\n  }\n\n  function dq(a) {\n    Ra(this);\n    this.Kc = a;\n    this.kf = new G();\n    this.pe = new G();\n    this.ds = new pb();\n    this.Yr = new pb();\n  }\n\n  dq.prototype.clear = function () {\n    if (this.kf) for (var a = this.kf.iterator; a.next();) {\n      a.value.clear();\n    }\n    if (this.pe) for (a = this.pe.iterator; a.next();) {\n      a.value.clear();\n    }\n    this.kf = new G();\n    this.pe = new G();\n    this.ds = new pb();\n    this.Yr = new pb();\n  };\n\n  dq.prototype.toString = function (a) {\n    void 0 === a && (a = 0);\n    var b = \"LayoutNetwork\" + (null !== this.layout ? \"(\" + this.layout.toString() + \")\" : \"\");\n    if (0 >= a) return b;\n    b += \" vertexes: \" + this.kf.count + \" edges: \" + this.pe.count;\n\n    if (1 < a) {\n      for (var c = this.kf.iterator; c.next();) {\n        b += \"\\n    \" + c.value.toString(a - 1);\n      }\n\n      for (c = this.pe.iterator; c.next();) {\n        b += \"\\n    \" + c.value.toString(a - 1);\n      }\n    }\n\n    return b;\n  };\n\n  dq.prototype.createVertex = function () {\n    return new rq(this);\n  };\n\n  dq.prototype.createEdge = function () {\n    return new sq(this);\n  };\n\n  dq.prototype.eg = function (a, b, c) {\n    if (null !== a) {\n      void 0 === b && (b = !1);\n      void 0 === c && (c = null);\n      null === c && (c = function c(a) {\n        if (a instanceof V) return !a.isLinkLabel;\n\n        if (a instanceof T) {\n          var b = a.fromNode;\n          if (null === b || b.isLinkLabel) return !1;\n          a = a.toNode;\n          return null === a || a.isLinkLabel ? !1 : !0;\n        }\n\n        return !1;\n      });\n\n      for (a = a.iterator; a.next();) {\n        var d = a.value;\n        if (d instanceof V && (!b || d.isTopLevel) && d.canLayout() && c(d)) if (d instanceof qf && null === d.layout) this.eg(d.memberParts, !1);else if (null === this.ei(d)) {\n          var e = this.createVertex();\n          e.node = d;\n          this.fg(e);\n        }\n      }\n\n      for (a.reset(); a.next();) {\n        if (d = a.value, d instanceof T && (!b || d.isTopLevel) && d.canLayout() && c(d) && null === this.qo(d)) {\n          var f = d.fromNode;\n          e = d.toNode;\n          null !== f && null !== e && f !== e && (f = this.findGroupVertex(f), e = this.findGroupVertex(e), null !== f && null !== e && this.Qj(f, e, d));\n        }\n      }\n    }\n  };\n\n  dq.prototype.findGroupVertex = function (a) {\n    if (null === a) return null;\n    var b = a.findVisibleNode();\n    if (null === b) return null;\n    a = this.ei(b);\n    if (null !== a) return a;\n\n    for (b = b.containingGroup; null !== b;) {\n      a = this.ei(b);\n      if (null !== a) return a;\n      b = b.containingGroup;\n    }\n\n    return null;\n  };\n\n  t = dq.prototype;\n\n  t.fg = function (a) {\n    if (null !== a) {\n      this.kf.add(a);\n      var b = a.node;\n      null !== b && this.ds.add(b, a);\n      a.network = this;\n    }\n  };\n\n  t.yj = function (a) {\n    if (null === a) return null;\n    var b = this.ei(a);\n    null === b && (b = this.createVertex(), b.node = a, this.fg(b));\n    return b;\n  };\n\n  t.su = function (a) {\n    if (null !== a && tq(this, a)) {\n      for (var b = a.wd, c = b.count - 1; 0 <= c; c--) {\n        var d = b.K(c);\n        this.Gj(d);\n      }\n\n      b = a.Jd;\n\n      for (a = b.count - 1; 0 <= a; a--) {\n        c = b.K(a), this.Gj(c);\n      }\n    }\n  };\n\n  function tq(a, b) {\n    if (null === b) return !1;\n    var c = a.kf.remove(b);\n    c && (b = b.node, null !== b && a.ds.remove(b));\n    return c;\n  }\n\n  t.Gy = function (a) {\n    null !== a && (a = this.ei(a), null !== a && this.su(a));\n  };\n\n  t.ei = function (a) {\n    return null === a ? null : this.ds.I(a);\n  };\n\n  t.ol = function (a) {\n    if (null !== a) {\n      uq(this, a);\n      var b = a.toVertex;\n      null !== b && b.iu(a);\n      b = a.fromVertex;\n      null !== b && b.gu(a);\n    }\n  };\n\n  function uq(a, b) {\n    if (null !== b) {\n      a.pe.add(b);\n      var c = b.link;\n      null !== c && null === a.qo(c) && a.Yr.add(c, b);\n      b.network = a;\n    }\n  }\n\n  t.ky = function (a) {\n    if (null === a) return null;\n    var b = a.fromNode,\n        c = a.toNode,\n        d = this.qo(a);\n    null === d ? (d = this.createEdge(), d.link = a, null !== b && (d.fromVertex = this.yj(b)), null !== c && (d.toVertex = this.yj(c)), this.ol(d)) : (null !== b ? d.fromVertex = this.yj(b) : d.fromVertex = null, null !== c ? d.toVertex = this.yj(c) : d.toVertex = null);\n    return d;\n  };\n\n  t.Gj = function (a) {\n    if (null !== a) {\n      var b = a.toVertex;\n      null !== b && b.ru(a);\n      b = a.fromVertex;\n      null !== b && b.qu(a);\n      vq(this, a);\n    }\n  };\n\n  function vq(a, b) {\n    null !== b && a.pe.remove(b) && (b = b.link, null !== b && a.Yr.remove(b));\n  }\n\n  t.Fy = function (a) {\n    null !== a && (a = this.qo(a), null !== a && this.Gj(a));\n  };\n\n  t.qo = function (a) {\n    return null === a ? null : this.Yr.I(a);\n  };\n\n  t.Qj = function (a, b, c) {\n    if (null === a || null === b) return null;\n\n    if (a.network === this && b.network === this) {\n      var d = this.createEdge();\n      d.link = c;\n      d.fromVertex = a;\n      d.toVertex = b;\n      this.ol(d);\n      return d;\n    }\n\n    return null;\n  };\n\n  t.Ol = function (a) {\n    if (null !== a) {\n      var b = a.fromVertex,\n          c = a.toVertex;\n      null !== b && null !== c && (b.qu(a), c.ru(a), a.Ol(), b.iu(a), c.gu(a));\n    }\n  };\n\n  t.oo = function () {\n    for (var a = Ea(), b = this.pe.iterator; b.next();) {\n      var c = b.value;\n      c.fromVertex === c.toVertex && a.push(c);\n    }\n\n    b = a.length;\n\n    for (c = 0; c < b; c++) {\n      this.Gj(a[c]);\n    }\n\n    Ga(a);\n  };\n\n  dq.prototype.deleteArtificialVertexes = function () {\n    for (var a = Ea(), b = this.kf.iterator; b.next();) {\n      var c = b.value;\n      null === c.node && null === c.data && a.push(c);\n    }\n\n    c = a.length;\n\n    for (b = 0; b < c; b++) {\n      this.su(a[b]);\n    }\n\n    b = Ea();\n\n    for (c = this.pe.iterator; c.next();) {\n      var d = c.value;\n      null === d.link && null === d.data && b.push(d);\n    }\n\n    c = b.length;\n\n    for (d = 0; d < c; d++) {\n      this.Gj(b[d]);\n    }\n\n    Ga(a);\n    Ga(b);\n  };\n\n  function wq(a) {\n    for (var b = Ea(), c = a.pe.iterator; c.next();) {\n      var d = c.value;\n      null !== d.fromVertex && null !== d.toVertex || b.push(d);\n    }\n\n    c = b.length;\n\n    for (d = 0; d < c; d++) {\n      a.Gj(b[d]);\n    }\n\n    Ga(b);\n  }\n\n  dq.prototype.Ix = function (a) {\n    void 0 === a && (a = !0);\n    a && (this.deleteArtificialVertexes(), wq(this), this.oo());\n    a = new E();\n\n    for (var b = !0; b;) {\n      b = !1;\n\n      for (var c = this.kf.iterator; c.next();) {\n        var d = c.value;\n\n        if (0 < d.wd.count || 0 < d.Jd.count) {\n          b = this.layout.createNetwork();\n          a.add(b);\n          xq(this, b, d);\n          b = !0;\n          break;\n        }\n      }\n    }\n\n    a.sort(function (a, b) {\n      return null === a || null === b || a === b ? 0 : b.vertexes.count - a.vertexes.count;\n    });\n    return a;\n  };\n\n  function xq(a, b, c) {\n    if (null !== c && c.network !== b) {\n      tq(a, c);\n      b.fg(c);\n\n      for (var d = c.sourceEdges; d.next();) {\n        var e = d.value;\n        e.network !== b && (vq(a, e), uq(b, e), xq(a, b, e.fromVertex));\n      }\n\n      for (d = c.destinationEdges; d.next();) {\n        c = d.value, c.network !== b && (vq(a, c), uq(b, c), xq(a, b, c.toVertex));\n      }\n    }\n  }\n\n  dq.prototype.My = function () {\n    for (var a = new G(), b = this.kf.iterator; b.next();) {\n      a.add(b.value.node);\n    }\n\n    for (b = this.pe.iterator; b.next();) {\n      a.add(b.value.link);\n    }\n\n    return a;\n  };\n\n  ma.Object.defineProperties(dq.prototype, {\n    layout: {\n      get: function get() {\n        return this.Kc;\n      },\n      set: function set(a) {\n        null !== a && (this.Kc = a);\n      }\n    },\n    vertexes: {\n      get: function get() {\n        return this.kf;\n      }\n    },\n    edges: {\n      get: function get() {\n        return this.pe;\n      }\n    }\n  });\n  dq.prototype.findAllParts = dq.prototype.My;\n  dq.prototype.splitIntoSubNetworks = dq.prototype.Ix;\n  dq.prototype.deleteSelfEdges = dq.prototype.oo;\n  dq.prototype.reverseEdge = dq.prototype.Ol;\n  dq.prototype.linkVertexes = dq.prototype.Qj;\n  dq.prototype.findEdge = dq.prototype.qo;\n  dq.prototype.deleteLink = dq.prototype.Fy;\n  dq.prototype.deleteEdge = dq.prototype.Gj;\n  dq.prototype.addLink = dq.prototype.ky;\n  dq.prototype.addEdge = dq.prototype.ol;\n  dq.prototype.findVertex = dq.prototype.ei;\n  dq.prototype.deleteNode = dq.prototype.Gy;\n  dq.prototype.deleteVertex = dq.prototype.su;\n  dq.prototype.addNode = dq.prototype.yj;\n  dq.prototype.addVertex = dq.prototype.fg;\n  dq.prototype.addParts = dq.prototype.eg;\n  dq.className = \"LayoutNetwork\";\n\n  function rq(a) {\n    Ra(this);\n    this.nb = a;\n    this.j = new M(0, 0, 10, 10).freeze();\n    this.m = new I(5, 5).freeze();\n    this.Lh = this.qb = null;\n    this.wd = new E();\n    this.Jd = new E();\n  }\n\n  rq.prototype.serializeVertexProperties = function (a) {\n    a.id = cb(this);\n    a.key = this.node ? this.node.key : this.data ? this.data.yh : void 0;\n    void 0 === a.key && (a.key = null);\n    a.x = this.bounds.x;\n    a.y = this.bounds.y;\n    a.iA = this.bounds.width;\n    a.pz = this.bounds.height;\n    a.fx = this.focus.x;\n    a.fy = this.focus.y;\n    var b = [];\n    this.wd.each(function (a) {\n      b.push(cb(a));\n    });\n    a.Gx = b;\n    var c = [];\n    this.Jd.each(function (a) {\n      c.push(cb(a));\n    });\n    a.Ow = c;\n  };\n\n  rq.prototype.deserializeVertexProperties = function (a, b, c) {\n    if (null !== a) {\n      this.x = a.x;\n      this.y = a.y;\n      this.width = a.iA;\n      this.height = a.pz;\n      this.focusX = a.fx;\n      this.focusY = a.fy;\n      var d = this;\n      a.Gx && a.Gx.forEach(function (a) {\n        (a = c.get(a)) && d.wd.add(a);\n      });\n      a.Ow && a.Ow.forEach(function (a) {\n        (a = c.get(a)) && d.Jd.add(a);\n      });\n    }\n  };\n\n  rq.prototype.clear = function () {\n    this.Lh = this.qb = null;\n    this.wd = new E();\n    this.Jd = new E();\n  };\n\n  rq.prototype.toString = function (a) {\n    void 0 === a && (a = 0);\n    var b = \"LayoutVertex#\" + cb(this);\n\n    if (0 < a && (b += null !== this.node ? \"(\" + this.node.toString() + \")\" : \"\", 1 < a)) {\n      a = \"\";\n\n      for (var c = !0, d = this.wd.iterator; d.next();) {\n        var e = d.value;\n        c ? c = !1 : a += \",\";\n        a += e.toString(0);\n      }\n\n      e = \"\";\n      c = !0;\n\n      for (d = this.Jd.iterator; d.next();) {\n        var f = d.value;\n        c ? c = !1 : e += \",\";\n        e += f.toString(0);\n      }\n\n      b += \" sources: \" + a + \" destinations: \" + e;\n    }\n\n    return b;\n  };\n\n  rq.prototype.commit = function () {\n    var a = this.qb;\n\n    if (null !== a) {\n      var b = this.bounds,\n          c = a.bounds;\n      ya(c) ? (c.x = b.x, c.y = b.y, c.width = b.width, c.height = b.height) : a.bounds = b.copy();\n    } else if (a = this.node, null !== a) {\n      b = this.bounds;\n\n      if (!(a instanceof qf)) {\n        c = M.alloc();\n        var d = this.network.layout.hi(a, c),\n            e = a.locationObject.ia(yc);\n\n        if (d.v() && e.v()) {\n          a.moveTo(b.x + this.focusX - (e.x - d.x), b.y + this.focusY - (e.y - d.y));\n          M.free(c);\n          return;\n        }\n\n        M.free(c);\n      }\n\n      a.moveTo(b.x, b.y);\n    }\n  };\n\n  rq.prototype.iu = function (a) {\n    null !== a && (this.wd.contains(a) || this.wd.add(a));\n  };\n\n  rq.prototype.ru = function (a) {\n    null !== a && this.wd.remove(a);\n  };\n\n  rq.prototype.gu = function (a) {\n    null !== a && (this.Jd.contains(a) || this.Jd.add(a));\n  };\n\n  rq.prototype.qu = function (a) {\n    null !== a && this.Jd.remove(a);\n  };\n\n  function yq(a, b) {\n    a = a.Lh;\n    b = b.Lh;\n    return a ? b ? (a = a.text, b = b.text, a < b ? -1 : a > b ? 1 : 0) : 1 : null !== b ? -1 : 0;\n  }\n\n  ma.Object.defineProperties(rq.prototype, {\n    sourceEdgesArrayAccess: {\n      get: function get() {\n        return this.wd._dataArray;\n      }\n    },\n    destinationEdgesArrayAccess: {\n      get: function get() {\n        return this.Jd._dataArray;\n      }\n    },\n    data: {\n      get: function get() {\n        return this.qb;\n      },\n      set: function set(a) {\n        this.qb = a;\n\n        if (null !== a && a.bounds) {\n          var b = a.bounds;\n          a = b.x;\n          var c = b.y,\n              d = b.width;\n          b = b.height;\n          this.m.h(d / 2, b / 2);\n          this.j.h(a, c, d, b);\n        }\n      }\n    },\n    node: {\n      get: function get() {\n        return this.Lh;\n      },\n      set: function set(a) {\n        if (this.Lh !== a) {\n          this.Lh = a;\n          a.Za();\n          var b = this.network.layout,\n              c = M.alloc(),\n              d = b.hi(a, c);\n          b = d.x;\n          var e = d.y,\n              f = d.width;\n          d = d.height;\n          isNaN(b) && (b = 0);\n          isNaN(e) && (e = 0);\n          this.j.h(b, e, f, d);\n          M.free(c);\n\n          if (!(a instanceof qf) && (a = a.locationObject.ia(yc), a.v())) {\n            this.m.h(a.x - b, a.y - e);\n            return;\n          }\n\n          this.m.h(f / 2, d / 2);\n        }\n      }\n    },\n    bounds: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        this.j.C(a) || this.j.assign(a);\n      }\n    },\n    focus: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        this.m.C(a) || this.m.assign(a);\n      }\n    },\n    centerX: {\n      get: function get() {\n        return this.j.x + this.m.x;\n      },\n      set: function set(a) {\n        var b = this.j;\n        b.x + this.m.x !== a && (b.ja(), b.x = a - this.m.x, b.freeze());\n      }\n    },\n    centerY: {\n      get: function get() {\n        return this.j.y + this.m.y;\n      },\n      set: function set(a) {\n        var b = this.j;\n        b.y + this.m.y !== a && (b.ja(), b.y = a - this.m.y, b.freeze());\n      }\n    },\n    focusX: {\n      get: function get() {\n        return this.m.x;\n      },\n      set: function set(a) {\n        var b = this.m;\n        b.x !== a && (b.ja(), b.x = a, b.freeze());\n      }\n    },\n    focusY: {\n      get: function get() {\n        return this.m.y;\n      },\n      set: function set(a) {\n        var b = this.m;\n        b.y !== a && (b.ja(), b.y = a, b.freeze());\n      }\n    },\n    x: {\n      get: function get() {\n        return this.j.x;\n      },\n      set: function set(a) {\n        var b = this.j;\n        b.x !== a && (b.ja(), b.x = a, b.freeze());\n      }\n    },\n    y: {\n      get: function get() {\n        return this.j.y;\n      },\n      set: function set(a) {\n        var b = this.j;\n        b.y !== a && (b.ja(), b.y = a, b.freeze());\n      }\n    },\n    width: {\n      get: function get() {\n        return this.j.width;\n      },\n      set: function set(a) {\n        var b = this.j;\n        b.width !== a && (b.ja(), b.width = a, b.freeze());\n      }\n    },\n    height: {\n      get: function get() {\n        return this.j.height;\n      },\n      set: function set(a) {\n        var b = this.j;\n        b.height !== a && (b.ja(), b.height = a, b.freeze());\n      }\n    },\n    network: {\n      get: function get() {\n        return this.nb;\n      },\n      set: function set(a) {\n        this.nb = a;\n      }\n    },\n    sourceVertexes: {\n      get: function get() {\n        for (var a = new G(), b = this.sourceEdges; b.next();) {\n          a.add(b.value.fromVertex);\n        }\n\n        return a.iterator;\n      }\n    },\n    destinationVertexes: {\n      get: function get() {\n        for (var a = new G(), b = this.destinationEdges; b.next();) {\n          a.add(b.value.toVertex);\n        }\n\n        return a.iterator;\n      }\n    },\n    vertexes: {\n      get: function get() {\n        for (var a = new G(), b = this.sourceEdges; b.next();) {\n          a.add(b.value.fromVertex);\n        }\n\n        for (b = this.destinationEdges; b.next();) {\n          a.add(b.value.toVertex);\n        }\n\n        return a.iterator;\n      }\n    },\n    sourceEdges: {\n      get: function get() {\n        return this.wd.iterator;\n      }\n    },\n    destinationEdges: {\n      get: function get() {\n        return this.Jd.iterator;\n      }\n    },\n    edges: {\n      get: function get() {\n        for (var a = new E(), b = this.sourceEdges; b.next();) {\n          a.add(b.value);\n        }\n\n        for (b = this.destinationEdges; b.next();) {\n          a.add(b.value);\n        }\n\n        return a.iterator;\n      }\n    },\n    edgesCount: {\n      get: function get() {\n        return this.wd.count + this.Jd.count;\n      }\n    }\n  });\n  rq.prototype.deleteDestinationEdge = rq.prototype.qu;\n  rq.prototype.addDestinationEdge = rq.prototype.gu;\n  rq.prototype.deleteSourceEdge = rq.prototype.ru;\n  rq.prototype.addSourceEdge = rq.prototype.iu;\n  rq.className = \"LayoutVertex\";\n  rq.standardComparer = yq;\n\n  rq.smartComparer = function (a, b) {\n    if (null !== a) {\n      if (null !== b) {\n        a = a.Lh;\n        var c = b.Lh;\n\n        if (null !== a) {\n          if (null !== c) {\n            b = a.text.toLocaleLowerCase().split(/([+-]?[.]?\\d+(?:\\.\\d*)?(?:e[+-]?\\d+)?)/);\n            a = c.text.toLocaleLowerCase().split(/([+-]?[.]?\\d+(?:\\.\\d*)?(?:e[+-]?\\d+)?)/);\n\n            for (c = 0; c < b.length; c++) {\n              if (\"\" !== a[c] && void 0 !== a[c]) {\n                var d = parseFloat(b[c]),\n                    e = parseFloat(a[c]);\n                if (isNaN(d)) {\n                  if (isNaN(e)) {\n                    if (0 !== b[c].localeCompare(a[c])) return b[c].localeCompare(a[c]);\n                  } else return 1;\n                } else {\n                  if (isNaN(e)) return -1;\n                  if (0 !== d - e) return d - e;\n                }\n              } else if (\"\" !== b[c]) return 1;\n            }\n\n            return \"\" !== a[c] && void 0 !== a[c] ? -1 : 0;\n          }\n\n          return 1;\n        }\n\n        return null !== c ? -1 : 0;\n      }\n\n      return 1;\n    }\n\n    return null !== b ? -1 : 0;\n  };\n\n  function sq(a) {\n    Ra(this);\n    this.hb = a;\n    this.jd = this.ad = this.Pk = this.qb = null;\n  }\n\n  sq.prototype.clear = function () {\n    this.jd = this.ad = this.Pk = this.qb = null;\n  };\n\n  sq.prototype.serializeEdgeProperties = function (a) {\n    a.id = cb(this);\n    a.key = this.link ? this.link.key : this.data ? this.data.yh : void 0;\n    void 0 === a.key && (a.key = null);\n    a.from = this.fromVertex ? cb(this.fromVertex) : null;\n    a.dA = this.toVertex ? cb(this.toVertex) : null;\n  };\n\n  sq.prototype.deserializeEdgeProperties = function (a, b) {\n    if (null !== a) {\n      var c = b.get(a.from);\n      c && (this.fromVertex = c);\n      if (a = b.get(a.dA)) this.toVertex = a;\n    }\n  };\n\n  sq.prototype.toString = function (a) {\n    void 0 === a && (a = 0);\n    var b = \"LayoutEdge#\" + cb(this);\n    0 < a && (b += null !== this.Pk ? \"(\" + this.Pk.toString() + \")\" : \"\", 1 < a && (b += \" \" + (this.ad ? this.ad.toString() : \"null\") + \" --\\x3e \" + (this.jd ? this.jd.toString() : \"null\")));\n    return b;\n  };\n\n  sq.prototype.Ol = function () {\n    var a = this.ad;\n    this.ad = this.jd;\n    this.jd = a;\n  };\n\n  sq.prototype.commit = function () {};\n\n  sq.prototype.bx = function (a) {\n    return this.jd === a ? this.ad : this.ad === a ? this.jd : null;\n  };\n\n  ma.Object.defineProperties(sq.prototype, {\n    network: {\n      get: function get() {\n        return this.hb;\n      },\n      set: function set(a) {\n        this.hb = a;\n      }\n    },\n    data: {\n      get: function get() {\n        return this.qb;\n      },\n      set: function set(a) {\n        this.qb !== a && (this.qb = a);\n      }\n    },\n    link: {\n      get: function get() {\n        return this.Pk;\n      },\n      set: function set(a) {\n        this.Pk !== a && (this.Pk = a);\n      }\n    },\n    fromVertex: {\n      get: function get() {\n        return this.ad;\n      },\n      set: function set(a) {\n        this.ad !== a && (this.ad = a);\n      }\n    },\n    toVertex: {\n      get: function get() {\n        return this.jd;\n      },\n      set: function set(a) {\n        this.jd !== a && (this.jd = a);\n      }\n    }\n  });\n  sq.prototype.getOtherVertex = sq.prototype.bx;\n  sq.className = \"LayoutEdge\";\n\n  function Lk(a) {\n    qi.call(this);\n    this.isViewportSized = !0;\n    this.bo = this.co = NaN;\n    this.pg = new K(NaN, NaN).freeze();\n    this.gf = new K(10, 10).freeze();\n    this.Fb = zq;\n    this.Nb = Aq;\n    this.fd = Bq;\n    this.Zc = Cq;\n    a && Object.assign(this, a);\n  }\n\n  la(Lk, qi);\n\n  Lk.prototype.cloneProtected = function (a) {\n    qi.prototype.cloneProtected.call(this, a);\n    a.co = this.co;\n    a.bo = this.bo;\n    a.pg.assign(this.pg);\n    a.gf.assign(this.gf);\n    a.Fb = this.Fb;\n    a.Nb = this.Nb;\n    a.fd = this.fd;\n    a.Zc = this.Zc;\n  };\n\n  Lk.prototype.ob = function (a) {\n    a.classType === Lk ? a === Bq || a === Dq || a === Eq || a === Fq ? this.sorting = a : a === Aq || a === Gq ? this.arrangement = a : a === zq || a === Hq ? this.alignment = a : C(\"Unknown enum value: \" + a) : qi.prototype.ob.call(this, a);\n  };\n\n  Lk.prototype.doLayout = function (a) {\n    this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);\n    var b = this.Iw(a);\n    a = this.diagram;\n\n    for (var c = b.copy().iterator; c.next();) {\n      var d = c.value;\n\n      if (!d.eh() || null === d.fromNode && null === d.toNode) {\n        if (d.Za(), d instanceof qf) for (d = d.memberParts; d.next();) {\n          b.remove(d.value);\n        }\n      } else b.remove(d);\n    }\n\n    var e = b.Ea();\n\n    if (0 !== e.length) {\n      switch (this.sorting) {\n        case Fq:\n          e.reverse();\n          break;\n\n        case Bq:\n          e.sort(this.comparer);\n          break;\n\n        case Dq:\n          e.sort(this.comparer), e.reverse();\n      }\n\n      var f = this.wrappingColumn;\n      isNaN(f) && (f = 0);\n      var g = this.wrappingWidth;\n      isNaN(g) && null !== a ? (b = a.padding, g = Math.max(a.viewportBounds.width - b.left - b.right, 0)) : g = Math.max(this.wrappingWidth, 0);\n      0 >= f && 0 >= g && (f = 1);\n      b = this.spacing.width;\n      isFinite(b) || (b = 0);\n      c = this.spacing.height;\n      isFinite(c) || (c = 0);\n      null !== a && a.Da(\"Layout\");\n      d = [];\n\n      switch (this.alignment) {\n        case Hq:\n          var h = b,\n              k = c,\n              l = M.alloc(),\n              m = Math.max(this.cellSize.width, 1);\n          if (!isFinite(m)) for (var n = m = 0; n < e.length; n++) {\n            var p = this.hi(e[n], l);\n            m = Math.max(m, p.width);\n          }\n          m = Math.max(m + h, 1);\n          n = Math.max(this.cellSize.height, 1);\n          if (!isFinite(n)) for (p = n = 0; p < e.length; p++) {\n            var r = this.hi(e[p], l);\n            n = Math.max(n, r.height);\n          }\n          n = Math.max(n + k, 1);\n          p = this.arrangement;\n\n          for (var q = r = this.arrangementOrigin.x, u = this.arrangementOrigin.y, w = 0, v = 0, z = 0; z < e.length; z++) {\n            var y = e[z],\n                A = this.hi(y, l),\n                B = Math.ceil((A.width + h) / m) * m,\n                F = Math.ceil((A.height + k) / n) * n;\n\n            switch (p) {\n              case Gq:\n                var L = Math.abs(q - A.width);\n                break;\n\n              default:\n                L = q + A.width;\n            }\n\n            if (0 < f && w > f - 1 || 0 < g && 0 < w && L - r > g) d.push(new M(0, u, g + h, v)), w = 0, q = r, u += v, v = 0;\n            v = Math.max(v, F);\n\n            switch (p) {\n              case Gq:\n                A = -A.width;\n                break;\n\n              default:\n                A = 0;\n            }\n\n            y.moveTo(q + A, u);\n\n            switch (p) {\n              case Gq:\n                q -= B;\n                break;\n\n              default:\n                q += B;\n            }\n\n            w++;\n          }\n\n          d.push(new M(0, u, g + h, v));\n          M.free(l);\n          break;\n\n        case zq:\n          k = g;\n          m = f;\n          n = b;\n          p = c;\n          g = M.alloc();\n          r = Math.max(this.cellSize.width, 1);\n          f = u = l = 0;\n          h = I.alloc();\n\n          for (q = 0; q < e.length; q++) {\n            v = e[q], w = this.hi(v, g), v = Fo(v, v.locationObject, v.locationSpot, h), l = Math.max(l, v.x), u = Math.max(u, w.width - v.x), f = Math.max(f, v.y);\n          }\n\n          q = this.arrangement;\n\n          switch (q) {\n            case Gq:\n              l += n;\n              break;\n\n            default:\n              u += n;\n          }\n\n          r = isFinite(r) ? Math.max(r + n, 1) : Math.max(l + u, 1);\n          var S = v = this.arrangementOrigin.x;\n          z = this.arrangementOrigin.y;\n          u = 0;\n          k >= l && (k -= l);\n          l = y = 0;\n          B = Math.max(this.cellSize.height, 1);\n          A = f = 0;\n          F = !0;\n          w = I.alloc();\n\n          for (L = 0; L < e.length; L++) {\n            var R = e[L],\n                P = this.hi(R, g),\n                H = Fo(R, R.locationObject, R.locationSpot, h);\n            if (0 < u) switch (q) {\n              case Gq:\n                S = (S - v - (P.width - H.x)) / r;\n                S = J.ca(Math.round(S), S) ? Math.round(S) : Math.floor(S);\n                S = S * r + v;\n                break;\n\n              default:\n                S = (S - v + H.x) / r, S = J.ca(Math.round(S), S) ? Math.round(S) : Math.ceil(S), S = S * r + v;\n            } else switch (q) {\n              case Gq:\n                y = S + H.x + P.width;\n                break;\n\n              default:\n                y = S - H.x;\n            }\n\n            switch (q) {\n              case Gq:\n                var da = -(S + H.x) + y;\n                break;\n\n              default:\n                da = S + P.width - H.x - y;\n            }\n\n            if (0 < m && u > m - 1 || 0 < k && 0 < u && da > k) {\n              d.push(new M(0, F ? z - f : z, k + n, A + f + p));\n\n              for (S = 0; S < u && L !== u; S++) {\n                da = e[L - u + S];\n                var X = Fo(da, da.locationObject, da.locationSpot, w);\n                da.moveTo(da.position.x, da.position.y + f - X.y);\n              }\n\n              A += p;\n              z = F ? z + A : z + (A + f);\n              u = A = f = 0;\n              S = v;\n              F = !1;\n            }\n\n            S === v && (l = q === Gq ? Math.max(l, P.width - H.x) : Math.min(l, -H.x));\n            f = Math.max(f, H.y);\n            A = Math.max(A, P.height - H.y);\n            isFinite(B) && (A = Math.max(A, Math.max(P.height, B) - H.y));\n            F ? R.moveTo(S - H.x, z - H.y) : R.moveTo(S - H.x, z);\n\n            switch (q) {\n              case Gq:\n                S -= H.x + n;\n                break;\n\n              default:\n                S += P.width - H.x + n;\n            }\n\n            u++;\n          }\n\n          d.push(new M(0, z, k + n, (F ? A : A + f) + p));\n          if (e.length !== u) for (k = 0; k < u; k++) {\n            m = e[e.length - u + k], n = Fo(m, m.locationObject, m.locationSpot, h), m.moveTo(m.position.x, m.position.y + f - n.y);\n          }\n          I.free(h);\n          I.free(w);\n          if (q === Gq) for (e = 0; e < d.length; e++) {\n            f = d[e], f.width += l, f.x -= l;\n          } else for (e = 0; e < d.length; e++) {\n            f = d[e], f.x > l && (f.width += f.x - l, f.x = l);\n          }\n          M.free(g);\n      }\n\n      for (h = f = g = e = 0; h < d.length; h++) {\n        k = d[h], e = Math.min(e, k.x), g = Math.min(g, k.y), f = Math.max(f, k.x + k.width);\n      }\n\n      this.arrangement === Gq ? this.commitLayers(d, new I(e + b / 2 - (f + e), g - c / 2)) : this.commitLayers(d, new I(e - b / 2, g - c / 2));\n      null !== a && a.eb(\"Layout\");\n      this.isValidLayout = !0;\n    }\n  };\n\n  Lk.prototype.commitLayers = function () {};\n\n  function Cq(a, b) {\n    a = a.text;\n    b = b.text;\n    return a < b ? -1 : a > b ? 1 : 0;\n  }\n\n  ma.Object.defineProperties(Lk.prototype, {\n    wrappingWidth: {\n      get: function get() {\n        return this.co;\n      },\n      set: function set(a) {\n        this.co !== a && (0 < a || isNaN(a)) && (this.co = a, this.isViewportSized = isNaN(a), this.D());\n      }\n    },\n    wrappingColumn: {\n      get: function get() {\n        return this.bo;\n      },\n      set: function set(a) {\n        this.bo !== a && (0 < a || isNaN(a)) && (this.bo = a, this.D());\n      }\n    },\n    cellSize: {\n      get: function get() {\n        return this.pg;\n      },\n      set: function set(a) {\n        this.pg.C(a) || (this.pg.assign(a), this.D());\n      }\n    },\n    spacing: {\n      get: function get() {\n        return this.gf;\n      },\n      set: function set(a) {\n        this.gf.C(a) || (this.gf.assign(a), this.D());\n      }\n    },\n    alignment: {\n      get: function get() {\n        return this.Fb;\n      },\n      set: function set(a) {\n        this.Fb === a || a !== zq && a !== Hq || (this.Fb = a, this.D());\n      }\n    },\n    arrangement: {\n      get: function get() {\n        return this.Nb;\n      },\n      set: function set(a) {\n        this.Nb === a || a !== Aq && a !== Gq || (this.Nb = a, this.D());\n      }\n    },\n    sorting: {\n      get: function get() {\n        return this.fd;\n      },\n      set: function set(a) {\n        this.fd === a || a !== Eq && a !== Fq && a !== Bq && a !== Dq || (this.fd = a, this.D());\n      }\n    },\n    comparer: {\n      get: function get() {\n        return this.Zc;\n      },\n      set: function set(a) {\n        this.Zc !== a && (this.Zc = a, this.D());\n      }\n    }\n  });\n  var Hq = new D(Lk, \"Position\", 0),\n      zq = new D(Lk, \"Location\", 1),\n      Aq = new D(Lk, \"LeftToRight\", 2),\n      Gq = new D(Lk, \"RightToLeft\", 3),\n      Eq = new D(Lk, \"Forward\", 4),\n      Fq = new D(Lk, \"Reverse\", 5),\n      Bq = new D(Lk, \"Ascending\", 6),\n      Dq = new D(Lk, \"Descending\", 7);\n  Lk.className = \"GridLayout\";\n  Lk.standardComparer = Cq;\n\n  Lk.smartComparer = function (a, b) {\n    if (null !== a) {\n      if (null !== b) {\n        a = a.text.toLocaleLowerCase().split(/([+-]?[.]?\\d+(?:\\.\\d*)?(?:e[+-]?\\d+)?)/);\n        b = b.text.toLocaleLowerCase().split(/([+-]?[.]?\\d+(?:\\.\\d*)?(?:e[+-]?\\d+)?)/);\n\n        for (var c = 0; c < a.length; c++) {\n          if (\"\" !== b[c] && void 0 !== b[c]) {\n            var d = parseFloat(a[c]),\n                e = parseFloat(b[c]);\n            if (isNaN(d)) {\n              if (isNaN(e)) {\n                if (0 !== a[c].localeCompare(b[c])) return a[c].localeCompare(b[c]);\n              } else return 1;\n            } else {\n              if (isNaN(e)) return -1;\n              if (0 !== d - e) return d - e;\n            }\n          } else if (\"\" !== a[c]) return 1;\n        }\n\n        return \"\" !== b[c] && void 0 !== b[c] ? -1 : 0;\n      }\n\n      return 1;\n    }\n\n    return null !== b ? -1 : 0;\n  };\n\n  Lk.Position = Hq;\n  Lk.Location = zq;\n  Lk.LeftToRight = Aq;\n  Lk.RightToLeft = Gq;\n  Lk.Forward = Eq;\n  Lk.Reverse = Fq;\n  Lk.Ascending = Bq;\n  Lk.Descending = Dq;\n\n  function mi() {\n    this.vn = new G();\n    this.kn = new G();\n    this.Ma = new G();\n    this.Se = new pb();\n    this.Re = new pb();\n    this.Wi = new pb();\n    this.H = null;\n    this.Xo = !1;\n  }\n\n  t = mi.prototype;\n\n  t.clear = function () {\n    this.vn.clear();\n    this.kn.clear();\n    this.Ma.clear();\n    this.Se.clear();\n    this.Re.clear();\n    this.Wi.clear();\n  };\n\n  t.Le = function (a) {\n    this.H = a;\n  };\n\n  t.ii = function (a) {\n    if (a instanceof V) {\n      if (this.vn.add(a), a instanceof qf) {\n        var b = a.containingGroup;\n        null === b ? this.H.Uh.add(a) : b.Vk.add(a);\n        b = a.layout;\n        null !== b && (b.diagram = this.H);\n      }\n    } else a instanceof T ? this.kn.add(a) : a instanceof ue || this.Ma.add(a);\n\n    b = a.data;\n    null === b || a instanceof ue || (a instanceof T ? this.Re.add(b, a) : this.Se.add(b, a));\n  };\n\n  t.lc = function (a) {\n    a.zj();\n\n    if (a instanceof V) {\n      if (this.vn.remove(a), a instanceof qf) {\n        var b = a.containingGroup;\n        null === b ? this.H.Uh.remove(a) : b.Vk.remove(a);\n        b = a.layout;\n        null !== b && (b.diagram = null);\n      }\n    } else a instanceof T ? this.kn.remove(a) : a instanceof ue || this.Ma.remove(a);\n\n    b = a.data;\n    null === b || a instanceof ue || (a instanceof T ? this.Re.remove(b) : this.Se.remove(b));\n  };\n\n  t.Od = function () {\n    var a = this.H;\n\n    if (null !== a) {\n      for (var b = a.nodeTemplateMap.iterator; b.next();) {\n        var c = b.value,\n            d = b.key;\n        (!c.Tc() || c instanceof qf) && C('Invalid node template in Diagram.nodeTemplateMap: template for \"' + d + '\" must be a Node or a simple Part, not a Group or Link: ' + c);\n      }\n\n      for (b = a.groupTemplateMap.iterator; b.next();) {\n        c = b.value, d = b.key, c instanceof qf || C('Invalid group template in Diagram.groupTemplateMap: template for \"' + d + '\" must be a Group, not a normal Node or Link: ' + c);\n      }\n\n      for (b = a.linkTemplateMap.iterator; b.next();) {\n        c = b.value, d = b.key, c instanceof T || C('Invalid link template in Diagram.linkTemplateMap: template for \"' + d + '\" must be a Link, not a normal Node or simple Part: ' + c);\n      }\n\n      b = Ea();\n\n      for (c = a.selection.iterator; c.next();) {\n        (d = c.value.data) && b.push(d);\n      }\n\n      c = Ea();\n\n      for (a = a.highlighteds.iterator; a.next();) {\n        (d = a.value.data) && c.push(d);\n      }\n\n      a = Ea();\n\n      for (d = this.nodes.iterator; d.next();) {\n        var e = d.value;\n        null !== e.data && (a.push(e.data), a.push(e.location));\n      }\n\n      for (d = this.links.iterator; d.next();) {\n        e = d.value, null !== e.data && (a.push(e.data), a.push(e.location));\n      }\n\n      for (d = this.parts.iterator; d.next();) {\n        e = d.value, null !== e.data && (a.push(e.data), a.push(e.location));\n      }\n\n      this.removeAllModeledParts();\n      this.addAllModeledParts();\n\n      for (d = 0; d < b.length; d++) {\n        e = this.Ec(b[d]), null !== e && (e.isSelected = !0);\n      }\n\n      for (d = 0; d < c.length; d++) {\n        e = this.Ec(c[d]), null !== e && (e.isHighlighted = !0);\n      }\n\n      for (d = 0; d < a.length; d += 2) {\n        e = this.Ec(a[d]), null !== e && (e.location = a[d + 1]);\n      }\n\n      Ga(b);\n      Ga(c);\n      Ga(a);\n    }\n  };\n\n  mi.prototype.addAllModeledParts = function () {\n    this.addModeledParts(this.diagram.model.nodeDataArray);\n  };\n\n  mi.prototype.addModeledParts = function (a, b) {\n    var c = this,\n        d = this.diagram.model;\n    a.forEach(function (a) {\n      d.lb(a) && Iq(c, a, !1);\n    });\n    a.forEach(function (a) {\n      d.lb(a) && c.resolveReferencesForData(a);\n    });\n    !1 !== b && Yj(this.diagram, !1);\n  };\n\n  function Iq(a, b, c) {\n    if (void 0 !== b && null !== b && !a.diagram.undoManager.isUndoingRedoing && !a.Se.contains(b)) {\n      void 0 === c && (c = !0);\n\n      a: {\n        if (void 0 !== b && null !== b && !a.H.undoManager.isUndoingRedoing && !a.Se.contains(b)) {\n          var d = a.uo(b);\n          var e = Ro(a, b, d);\n\n          if (null !== e && (kg(e), e = e.copy(), null !== e)) {\n            var f = a.diagram.skipsModelSourceBindings;\n            a.diagram.skipsModelSourceBindings = !0;\n            e.Jf = d;\n            e.qb = b;\n            a.Xo && (e.zg = \"Tool\");\n            a.diagram.add(e);\n            e.qb = null;\n            e.data = b;\n            a.diagram.skipsModelSourceBindings = f;\n            d = e;\n            break a;\n          }\n        }\n\n        d = null;\n      }\n\n      null !== d && c && a.resolveReferencesForData(b);\n    }\n  }\n\n  mi.prototype.insertLink = function () {\n    return null;\n  };\n\n  mi.prototype.resolveReferencesForData = function () {};\n\n  mi.prototype.uo = function (a) {\n    return this.H.model.uo(a);\n  };\n\n  function Ro(a, b, c) {\n    a = a.H;\n    var d = a.model;\n    d.Oj() && d.Ku(b) ? (b = a.groupTemplateMap.I(c), null === b && (b = a.groupTemplateMap.I(\"\"), null === b && (Jq || (Jq = !0, xa('No Group template found for category \"' + c + '\"'), xa(\"  Using default group template\")), b = a.Rx))) : (b = a.nodeTemplateMap.I(c), null === b && (b = a.nodeTemplateMap.I(\"\"), null === b && (Kq || (Kq = !0, xa('No Node template found for category \"' + c + '\"'), xa(\"  Using default node template\")), b = a.Tx)));\n    return b;\n  }\n\n  mi.prototype.getLinkCategoryForData = function () {\n    return \"\";\n  };\n\n  mi.prototype.setLinkCategoryForData = function () {};\n\n  mi.prototype.setFromNodeForLink = function () {};\n\n  mi.prototype.setToNodeForLink = function () {};\n\n  mi.prototype.findLinkTemplateForCategory = function (a) {\n    var b = this.H,\n        c = b.linkTemplateMap.I(a);\n    null === c && (c = b.linkTemplateMap.I(\"\"), null === c && (Lq || (Lq = !0, xa('No Link template found for category \"' + a + '\"'), xa(\"  Using default link template\")), c = b.Sx));\n    return c;\n  };\n\n  mi.prototype.removeAllModeledParts = function () {\n    this.gs(this.diagram.model.nodeDataArray);\n  };\n\n  mi.prototype.gs = function (a) {\n    var b = this;\n    a.forEach(function (a) {\n      b.Lo(a);\n    });\n  };\n\n  mi.prototype.Lo = function (a) {\n    a = this.Ec(a);\n    null !== a && (Gj(this.diagram, a, !1), this.unresolveReferencesForPart(a));\n  };\n\n  mi.prototype.unresolveReferencesForPart = function () {};\n\n  mi.prototype.removeDataForLink = function () {};\n\n  mi.prototype.findPartForKey = function (a) {\n    if (null === a || void 0 === a) return null;\n    a = this.H.model.dc(a);\n    return null !== a ? this.Se.I(a) : null;\n  };\n\n  mi.prototype.Lb = function (a) {\n    if (null === a || void 0 === a) return null;\n    a = this.H.model.dc(a);\n    if (null === a) return null;\n    a = this.Se.I(a);\n    return a instanceof V ? a : null;\n  };\n\n  mi.prototype.findLinkForKey = function () {\n    return null;\n  };\n\n  t = mi.prototype;\n\n  t.Ec = function (a) {\n    if (null === a) return null;\n    var b = this.Se.I(a);\n    return null !== b ? b : b = this.Re.I(a);\n  };\n\n  t.ci = function (a) {\n    if (null === a) return null;\n    a = this.Se.I(a);\n    return a instanceof V ? a : null;\n  };\n\n  t.Dc = function (a) {\n    return null === a ? null : this.Re.I(a);\n  };\n\n  t.Jr = function (a) {\n    for (var b = 0; b < arguments.length; ++b) {\n      ;\n    }\n\n    b = new G();\n\n    for (var c = this.vn.iterator; c.next();) {\n      var d = c.value,\n          e = d.data;\n      if (null !== e) for (var f = 0; f < arguments.length; f++) {\n        var g = arguments[f];\n\n        if (ya(g) && Mq(this, e, g)) {\n          b.add(d);\n          break;\n        }\n      }\n    }\n\n    return b.iterator;\n  };\n\n  t.Ir = function (a) {\n    for (var b = 0; b < arguments.length; ++b) {\n      ;\n    }\n\n    b = new G();\n\n    for (var c = this.kn.iterator; c.next();) {\n      var d = c.value,\n          e = d.data;\n      if (null !== e) for (var f = 0; f < arguments.length; f++) {\n        var g = arguments[f];\n\n        if (ya(g) && Mq(this, e, g)) {\n          b.add(d);\n          break;\n        }\n      }\n    }\n\n    return b.iterator;\n  };\n\n  function Mq(a, b, c) {\n    for (var d in c) {\n      var e = b[d],\n          f = c[d];\n\n      if (za(f)) {\n        if (!za(e) || e.length < f.length) return !1;\n\n        for (var g = 0; g < e.length; g++) {\n          var h = f[g];\n          if (void 0 !== h && !Nq(a, e[g], h)) return !1;\n        }\n      } else if (!Nq(a, e, f)) return !1;\n    }\n\n    return !0;\n  }\n\n  function Nq(a, b, c) {\n    if (\"function\" === typeof c) {\n      if (!c(b)) return !1;\n    } else if (c instanceof RegExp) {\n      if (!b || !c.test(b.toString())) return !1;\n    } else if (ya(b) && ya(c)) {\n      if (!Mq(a, b, c)) return !1;\n    } else if (b !== c) return !1;\n\n    return !0;\n  }\n\n  mi.prototype.doModelChanged = function (a) {\n    if (this.H) {\n      var b = this.H;\n\n      if (a.model === b.model) {\n        var c = a.change;\n        b.doModelChanged(a);\n\n        if (b.$) {\n          b.$ = !1;\n\n          try {\n            var d = a.modelChange;\n            if (\"\" !== d) {\n              if (c === de) {\n                if (\"nodeCategory\" === d) {\n                  var e = this.Ec(a.object),\n                      f = a.newValue;\n                  null !== e && \"string\" === typeof f && (e.category = f);\n                } else \"nodeDataArray\" === d && (this.gs(a.oldValue), this.addModeledParts(a.newValue));\n\n                b.isModified = !0;\n              } else if (c === fe) {\n                var g = a.newValue;\n                \"nodeDataArray\" === d && ya(g) && Iq(this, g);\n                b.isModified = !0;\n              } else if (c === ge) {\n                var h = a.oldValue;\n                \"nodeDataArray\" === d && ya(h) && this.Lo(h);\n                b.isModified = !0;\n              } else c === ee && (\"SourceChanged\" === d ? null !== a.object ? this.updateDataBindings(a.object, a.propertyName) : (this.Uo(), this.updateAllTargetBindings()) : \"ModelDisplaced\" === d && this.Od());\n            } else if (c === de) {\n              var k = a.propertyName,\n                  l = a.object;\n\n              if (l === b.model) {\n                if (\"nodeKeyProperty\" === k || \"nodeCategoryProperty\" === k) b.undoManager.isUndoingRedoing || this.Od();\n              } else this.updateDataBindings(l, k);\n\n              b.isModified = !0;\n            } else if (c === fe || c === ge) {\n              var m = a.change === fe,\n                  n = m ? a.newParam : a.oldParam,\n                  p = m ? a.newValue : a.oldValue,\n                  r = this.Wi.I(a.object);\n              if (Array.isArray(r)) for (a = 0; a < r.length; a++) {\n                var q = r[a];\n                if (m) jn(q, p, n, !0);else if (!(0 > n)) {\n                  var u = n + an(q);\n                  q.lc(u, !0);\n                  mn(q, u, n);\n                }\n              }\n              b.isModified = !0;\n            }\n          } finally {\n            b.$ = !0;\n          }\n        }\n      }\n    }\n  };\n\n  mi.prototype.updateAllTargetBindings = function (a) {\n    void 0 === a && (a = \"\");\n\n    for (var b = this.parts.iterator; b.next();) {\n      b.value.Ka(a);\n    }\n\n    for (b = this.nodes.iterator; b.next();) {\n      b.value.Ka(a);\n    }\n\n    for (b = this.links.iterator; b.next();) {\n      b.value.Ka(a);\n    }\n  };\n\n  mi.prototype.Uo = function () {\n    for (var a = this.H.model, b = new G(), c = a.nodeDataArray, d = 0; d < c.length; d++) {\n      b.add(c[d]);\n    }\n\n    var e = [];\n    this.nodes.each(function (a) {\n      null === a.data || b.contains(a.data) || e.push(a.data);\n    });\n    this.parts.each(function (a) {\n      null === a.data || b.contains(a.data) || e.push(a.data);\n    });\n    e.forEach(function (b) {\n      Oq(a, b, !1);\n    });\n\n    for (d = 0; d < c.length; d++) {\n      var f = c[d];\n      null === this.Ec(f) && Pq(a, f, !1);\n    }\n\n    this.refreshDataBoundLinks();\n\n    for (c = this.parts.iterator; c.next();) {\n      c.value.updateRelationshipsFromData();\n    }\n\n    for (c = this.nodes.iterator; c.next();) {\n      c.value.updateRelationshipsFromData();\n    }\n\n    for (c = this.links.iterator; c.next();) {\n      c.value.updateRelationshipsFromData();\n    }\n  };\n\n  mi.prototype.refreshDataBoundLinks = function () {};\n\n  mi.prototype.updateRelationshipsFromData = function () {};\n\n  mi.prototype.updateDataBindings = function (a, b) {\n    if (\"string\" === typeof b) {\n      var c = this.Ec(a);\n      if (null !== c) c.Ka(b);else {\n        c = null;\n\n        for (var d = this.Wi.iterator; d.next();) {\n          for (var e = d.value, f = 0; f < e.length; f++) {\n            var g = e[f].Uw(a);\n            null !== g && (null === c && (c = Ea()), c.push(g));\n          }\n\n          if (null !== c) break;\n        }\n\n        if (null !== c) {\n          for (d = 0; d < c.length; d++) {\n            c[d].Ka(b);\n          }\n\n          Ga(c);\n        }\n      }\n      a === this.diagram.model.modelData && this.updateAllTargetBindings(b);\n    }\n  };\n\n  function Cj(a, b) {\n    var c = b.xh;\n\n    if (za(c)) {\n      var d = a.Wi.I(c);\n      if (null === d) d = [], d.push(b), a.Wi.add(c, d);else {\n        for (a = 0; a < d.length; a++) {\n          if (d[a] === b) return;\n        }\n\n        d.push(b);\n      }\n    }\n  }\n\n  function Fj(a, b, c) {\n    Aj(b, function (a) {\n      a = a.R.s;\n\n      for (var b = a.length, d = 0; d < b; d++) {\n        Xj(c, a[d]);\n      }\n    });\n    var d = b.xh;\n\n    if (za(d)) {\n      var e = a.Wi.I(d);\n      if (null !== e) for (var f = 0; f < e.length; f++) {\n        if (e[f] === b) {\n          e.splice(f, 1);\n          0 === e.length && a.Wi.remove(d);\n          break;\n        }\n      }\n    }\n  }\n\n  mi.prototype.Ej = function (a, b, c) {\n    void 0 === c && (c = !1);\n    var d = new pb();\n    if (za(a)) for (var e = 0; e < a.length; e++) {\n      Qq(this, a[e], b, d, c);\n    } else for (a = a.iterator; a.next();) {\n      Qq(this, a.value, b, d, c);\n    }\n\n    if (null !== b) {\n      c = b.model;\n      a = b.toolManager.findTool(\"Dragging\");\n      a = null !== a ? a.dragOptions.dragsLink : b.Em.dragsLink;\n      e = new G();\n\n      for (var f = new pb(), g = d.iterator; g.next();) {\n        var h = g.value;\n        if (h instanceof T) a || null !== h.fromNode && null !== h.toNode || e.add(h);else if (h instanceof V && null !== h.data && c.Bl()) {\n          var k = h;\n          h = g.key;\n          var l = h.ig();\n          null !== l && (l = d.I(l), null !== l ? (c.ie(k.data, c.ua(l.data)), k = b.Dc(k.data), h = h.$g(), null !== h && null !== k && f.add(h, k)) : c.ie(k.data, void 0));\n        }\n      }\n\n      0 < e.count && b.hs(e, !1);\n      if (0 < f.count) for (c = f.iterator; c.next();) {\n        d.add(c.key, c.value);\n      }\n    }\n\n    if (null !== b && null !== this.H && (b = b.model, c = b.afterCopyFunction, null !== c)) {\n      var m = new pb();\n      d.each(function (a) {\n        null !== a.key.data && m.add(a.key.data, a.value.data);\n      });\n      c(m, b, this.H.model);\n    }\n\n    for (b = d.iterator; b.next();) {\n      b.value.Ka();\n    }\n\n    return d;\n  };\n\n  function Qq(a, b, c, d, e) {\n    if (null === b || e && !b.canCopy()) return null;\n    if (d.contains(b)) return d.I(b);\n    var f = a.copyPartData(b, c);\n    if (!(f instanceof U)) return null;\n    f.isSelected = !1;\n    f.isHighlighted = !1;\n    d.add(b, f);\n\n    if (b instanceof V) {\n      for (var g = b.linksConnected; g.next();) {\n        var h = g.value;\n\n        if (h.fromNode === b) {\n          var k = d.I(h);\n          null !== k && (k.fromNode = f);\n        }\n\n        h.toNode === b && (h = d.I(h), null !== h && (h.toNode = f));\n      }\n\n      if (b instanceof qf && f instanceof qf) for (b = b.memberParts; b.next();) {\n        g = Qq(a, b.value, c, d, e), g instanceof T || null === g || (g.containingGroup = f);\n      }\n    } else if (b instanceof T && f instanceof T) for (g = b.fromNode, null !== g && (g = d.I(g), null !== g && (f.fromNode = g)), g = b.toNode, null !== g && (g = d.I(g), null !== g && (f.toNode = g)), b = b.labelNodes; b.next();) {\n      g = Qq(a, b.value, c, d, e), null !== g && g instanceof V && (g.labeledLink = f);\n    }\n\n    return f;\n  }\n\n  mi.prototype.copyPartData = function (a, b) {\n    var c = null,\n        d = a.data;\n\n    if (null !== d && null !== b) {\n      var e = b.model;\n      a instanceof T || (d = e.copyNodeData(d), ya(d) && (e.lf(d), c = b.Ec(d)));\n    } else kg(a), c = a.copy(), null !== c && (e = this.H, null !== b ? b.add(c) : null !== d && null !== e && null !== e.commandHandler && e.commandHandler.copiesClipboardData && (b = e.model, e = null, c instanceof T || (e = b.copyNodeData(d)), ya(e) && (c.data = e)));\n\n    return c;\n  };\n\n  ma.Object.defineProperties(mi.prototype, {\n    nodes: {\n      get: function get() {\n        return this.vn;\n      }\n    },\n    links: {\n      get: function get() {\n        return this.kn;\n      }\n    },\n    parts: {\n      get: function get() {\n        return this.Ma;\n      }\n    },\n    diagram: {\n      get: function get() {\n        return this.H;\n      }\n    },\n    addsToTemporaryLayer: {\n      get: function get() {\n        return this.Xo;\n      },\n      set: function set(a) {\n        this.Xo = a;\n      }\n    }\n  });\n  mi.prototype.updateAllRelationshipsFromData = mi.prototype.Uo;\n  mi.prototype.findLinksByExample = mi.prototype.Ir;\n  mi.prototype.findNodesByExample = mi.prototype.Jr;\n  mi.prototype.findLinkForData = mi.prototype.Dc;\n  mi.prototype.findNodeForData = mi.prototype.ci;\n  mi.prototype.findPartForData = mi.prototype.Ec;\n  mi.prototype.findNodeForKey = mi.prototype.Lb;\n  mi.prototype.removeModeledPart = mi.prototype.Lo;\n  mi.prototype.removeModeledParts = mi.prototype.gs;\n  mi.prototype.rebuildParts = mi.prototype.Od;\n  var Kq = !1,\n      Jq = !1,\n      Lq = !1;\n  mi.className = \"PartManager\";\n\n  function Rq(a) {\n    mi.apply(this, arguments);\n  }\n\n  la(Rq, mi);\n\n  Rq.prototype.addAllModeledParts = function () {\n    var a = this.diagram.model;\n    this.addModeledParts(a.nodeDataArray);\n    Sq(this, a.linkDataArray);\n  };\n\n  Rq.prototype.addModeledParts = function (a) {\n    mi.prototype.addModeledParts.call(this, a, !1);\n\n    for (a = this.links.iterator; a.next();) {\n      So(a.value);\n    }\n\n    Yj(this.diagram, !1);\n  };\n\n  function Sq(a, b) {\n    b.forEach(function (b) {\n      Tq(a, b);\n    });\n    Yj(a.diagram, !1);\n  }\n\n  function Tq(a, b) {\n    if (void 0 !== b && null !== b && !a.diagram.undoManager.isUndoingRedoing && !a.Re.contains(b)) {\n      var c = a.getLinkCategoryForData(b),\n          d = a.findLinkTemplateForCategory(c);\n\n      if (null !== d) {\n        kg(d);\n        var e = d.copy();\n\n        if (null !== e) {\n          d = a.diagram.skipsModelSourceBindings;\n          a.diagram.skipsModelSourceBindings = !0;\n          e.Jf = c;\n          e.qb = b;\n          c = a.diagram.model;\n          var f = Uq(c, b, !0);\n          \"\" !== f && (e.fromPortId = f);\n          f = Vq(c, b, !0);\n          void 0 !== f && (f = a.Lb(f), f instanceof V && (e.fromNode = f));\n          f = Uq(c, b, !1);\n          \"\" !== f && (e.toPortId = f);\n          f = Vq(c, b, !1);\n          void 0 !== f && (f = a.Lb(f), f instanceof V && (e.toNode = f));\n          c = c.vf(b);\n          Array.isArray(c) && c.forEach(function (b) {\n            b = a.Lb(b);\n            null !== b && (b.labeledLink = e);\n          });\n          a.Xo && (e.zg = \"Tool\");\n          a.diagram.add(e);\n          e.qb = null;\n          e.data = b;\n          a.diagram.skipsModelSourceBindings = d;\n        }\n      }\n    }\n  }\n\n  Rq.prototype.removeAllModeledParts = function () {\n    var a = this.diagram.model;\n    Wq(this, a.linkDataArray);\n    this.gs(a.nodeDataArray);\n  };\n\n  function Wq(a, b) {\n    b.forEach(function (b) {\n      a.Lo(b);\n    });\n  }\n\n  Rq.prototype.getLinkCategoryForData = function (a) {\n    return this.diagram.model.Mr(a);\n  };\n\n  Rq.prototype.setLinkCategoryForData = function (a, b) {\n    return this.diagram.model.Oo(a, b);\n  };\n\n  Rq.prototype.setFromNodeForLink = function (a, b) {\n    var c = this.diagram.model;\n    c.cv(a.data, c.ua(null !== b ? b.data : null));\n  };\n\n  Rq.prototype.setToNodeForLink = function (a, b) {\n    var c = this.diagram.model;\n    c.gv(a.data, c.ua(null !== b ? b.data : null));\n  };\n\n  Rq.prototype.removeDataForLink = function (a) {\n    this.diagram.model.Jl(a.data);\n  };\n\n  Rq.prototype.findPartForKey = function (a) {\n    var b = mi.prototype.findPartForKey.call(this, a);\n    return null === b && (a = this.diagram.model.Zg(a), null !== a) ? this.Re.I(a) : b;\n  };\n\n  Rq.prototype.findLinkForKey = function (a) {\n    if (null === a || void 0 === a) return null;\n    a = this.diagram.model.Zg(a);\n    return null !== a ? this.Re.I(a) : null;\n  };\n\n  Rq.prototype.doModelChanged = function (a) {\n    var b = this;\n    mi.prototype.doModelChanged.call(this, a);\n\n    if (this.diagram) {\n      var c = this.diagram;\n\n      if (a.model === c.model) {\n        var d = a.change;\n\n        if (c.$) {\n          c.$ = !1;\n\n          try {\n            var e = a.modelChange;\n            if (\"\" !== e) {\n              if (d === de) {\n                if (\"linkFromKey\" === e) {\n                  var f = this.Dc(a.object);\n\n                  if (null !== f) {\n                    var g = this.Lb(a.newValue);\n                    f.fromNode = g;\n                  }\n                } else if (\"linkToKey\" === e) {\n                  var h = this.Dc(a.object);\n\n                  if (null !== h) {\n                    var k = this.Lb(a.newValue);\n                    h.toNode = k;\n                  }\n                } else if (\"linkFromPortId\" === e) {\n                  var l = this.Dc(a.object);\n\n                  if (null !== l) {\n                    var m = a.newValue;\n                    \"string\" === typeof m && (l.fromPortId = m);\n                  }\n                } else if (\"linkToPortId\" === e) {\n                  var n = this.Dc(a.object);\n\n                  if (null !== n) {\n                    var p = a.newValue;\n                    \"string\" === typeof p && (n.toPortId = p);\n                  }\n                } else if (\"nodeGroupKey\" === e) {\n                  var r = this.Ec(a.object);\n\n                  if (null !== r) {\n                    var q = a.newValue;\n\n                    if (void 0 !== q) {\n                      var u = this.Lb(q);\n                      u instanceof qf ? r.containingGroup = u : r.containingGroup = null;\n                    } else r.containingGroup = null;\n                  }\n                } else if (\"linkLabelKeys\" === e) {\n                  var w = this.Dc(a.object);\n\n                  if (null !== w) {\n                    var v = a.oldValue,\n                        z = a.newValue;\n                    Array.isArray(v) && v.forEach(function (a) {\n                      0 <= z.indexOf(a) || (a = b.Lb(a), null !== a && (a.labeledLink = null));\n                    });\n                    Array.isArray(z) && z.forEach(function (a) {\n                      a = b.Lb(a);\n                      null !== a && (a.labeledLink = w);\n                    });\n                  }\n                } else if (\"linkCategory\" === e) {\n                  var y = this.Dc(a.object),\n                      A = a.newValue;\n                  null !== y && \"string\" === typeof A && (y.category = A);\n                } else \"linkDataArray\" === e && (Wq(this, a.oldValue), Sq(this, a.newValue));\n\n                c.isModified = !0;\n              } else if (d === fe) {\n                var B = a.newValue;\n                if (\"linkDataArray\" === e && \"object\" === typeof B && null !== B) Tq(this, B);else if (\"linkLabelKeys\" === e && Xq(B)) {\n                  var F = this.Dc(a.object),\n                      L = this.Lb(B);\n                  null !== F && null !== L && (L.labeledLink = F);\n                }\n                c.isModified = !0;\n              } else {\n                if (d === ge) {\n                  var S = a.oldValue;\n                  if (\"linkDataArray\" === e && \"object\" === typeof S && null !== S) this.Lo(S);else if (\"linkLabelKeys\" === e && Xq(S)) {\n                    var R = this.Lb(S);\n                    null !== R && (R.labeledLink = null);\n                  }\n                  c.isModified = !0;\n                }\n              }\n            } else if (d === de) {\n              var P = a.propertyName;\n              a.object !== c.model || \"linkFromKeyProperty\" !== P && \"linkToKeyProperty\" !== P && \"linkFromPortIdProperty\" !== P && \"linkToPortIdProperty\" !== P && \"linkLabelKeysProperty\" !== P && \"nodeIsGroupProperty\" !== P && \"nodeGroupKeyProperty\" !== P && \"linkCategoryProperty\" !== P || c.undoManager.isUndoingRedoing || this.Od();\n              c.isModified = !0;\n            }\n          } finally {\n            c.$ = !0;\n          }\n        }\n      }\n    }\n  };\n\n  Rq.prototype.refreshDataBoundLinks = function () {\n    var a = this,\n        b = this.diagram.model,\n        c = new G(),\n        d = b.linkDataArray;\n    d.forEach(function (a) {\n      c.add(a);\n    });\n    var e = [];\n    this.links.each(function (a) {\n      null === a.data || c.contains(a.data) || e.push(a.data);\n    });\n    e.forEach(function (a) {\n      Yq(b, a, !1);\n    });\n    d.forEach(function (c) {\n      null === a.Dc(c) && Zq(b, c, !1);\n    });\n  };\n\n  Rq.prototype.updateRelationshipsFromData = function (a) {\n    var b = a.data;\n\n    if (null !== b) {\n      var c = a.diagram;\n\n      if (null !== c) {\n        var d = c.model;\n\n        if (a instanceof T) {\n          var e = Vq(d, b, !0);\n          e = c.Lb(e);\n          a.fromNode = e;\n          e = Vq(d, b, !1);\n          e = c.Lb(e);\n          a.toNode = e;\n          b = d.vf(b);\n\n          if (0 < b.length || 0 < a.labelNodes.count) {\n            if (1 === b.length && 1 === a.labelNodes.count) {\n              e = b[0];\n              var f = a.labelNodes.first();\n              if (d.ua(f.data) === e) return;\n            }\n\n            e = new G().addAll(b);\n            var g = new G();\n            a.labelNodes.each(function (a) {\n              null !== a.data && (a = d.ua(a.data), void 0 !== a && g.add(a));\n            });\n            b = g.copy();\n            b.Ko(e);\n            e = e.copy();\n            e.Ko(g);\n            if (0 < b.count || 0 < e.count) b.each(function (b) {\n              b = c.Lb(b);\n              null !== b && b.labeledLink === a && (b.labeledLink = null);\n            }), e.each(function (b) {\n              b = c.Lb(b);\n              null !== b && b.labeledLink !== a && (b.labeledLink = a);\n            });\n          }\n        } else !(a instanceof ue) && (b = d.ah(b), b = c.findPartForKey(b), null === b || b instanceof qf) && (a.containingGroup = b);\n      }\n    }\n  };\n\n  Rq.prototype.resolveReferencesForData = function (a) {\n    var b = this.diagram.model,\n        c = b.ua(a);\n\n    if (void 0 !== c) {\n      var d = $q(b, c),\n          e = this.Ec(a);\n\n      if (null !== d && null !== e) {\n        d = d.iterator;\n\n        for (var f = {}; d.next();) {\n          var g = d.value;\n          b.lb(g) ? e instanceof qf && b.ah(g) === c && (g = this.Ec(g), null !== g && (g.containingGroup = e)) : (f.link = this.Dc(g), null !== f.link && e instanceof V && (Vq(b, g, !0) === c && (f.link.fromNode = e), Vq(b, g, !1) === c && (f.link.toNode = e), g = b.vf(g), Array.isArray(g) && g.some(function (a) {\n            return function (b) {\n              return b === c ? (e.labeledLink = a.link, !0) : !1;\n            };\n          }(f))));\n          f = {\n            link: f.link\n          };\n        }\n\n        ar(b, c);\n      }\n\n      a = b.ah(a);\n      void 0 !== a && (a = this.Lb(a), a instanceof qf && (e.containingGroup = a));\n    }\n  };\n\n  Rq.prototype.unresolveReferencesForPart = function (a) {\n    var b = this.diagram.model;\n\n    if (a instanceof V) {\n      var c = b.ua(a.data);\n\n      if (void 0 !== c) {\n        for (var d = a.linksConnected; d.next();) {\n          br(b, c, d.value.data);\n        }\n\n        a.isLinkLabel && (d = a.labeledLink, null !== d && br(b, c, d.data));\n        if (a instanceof qf) for (a = a.memberParts; a.next();) {\n          d = a.value.data, b.lb(d) && br(b, c, d);\n        }\n      }\n    }\n  };\n\n  Rq.prototype.copyPartData = function (a, b) {\n    var c = mi.prototype.copyPartData.call(this, a, b);\n    if (a instanceof T) if (a = a.data, null !== a && null !== b) {\n      var d = b.model;\n      a = d.no(a);\n      \"object\" === typeof a && null !== a && (d.Yh(a), c = b.Dc(a));\n    } else null !== c && (b = this.diagram, null !== a && null !== b && null !== b.commandHandler && b.commandHandler.copiesClipboardData && (b = b.model.no(a), \"object\" === typeof b && null !== b && (c.data = b)));\n    return c;\n  };\n\n  Rq.prototype.insertLink = function (a, b, c, d) {\n    var e = this.diagram,\n        f = e.model,\n        g = e.toolManager.findTool(\"Linking\"),\n        h = \"\";\n    null !== a && (null === b && (b = a), h = b.portId, null === h && (h = \"\"));\n    b = \"\";\n    null !== c && (null === d && (d = c), b = d.portId, null === b && (b = \"\"));\n    d = g.archetypeLinkData;\n\n    if (d instanceof T) {\n      if (kg(d), f = d.copy(), null !== f) return f.fromNode = a, f.fromPortId = h, f.toNode = c, f.toPortId = b, e.add(f), a = g.archetypeLabelNodeData, a instanceof V && (kg(a), a = a.copy(), null !== a && (a.labeledLink = f, e.add(a))), f;\n    } else if (null !== d && (d = f.no(d), \"object\" === typeof d && null !== d)) return null !== a && cr(f, d, f.ua(a.data), !0), dr(f, d, h, !0), null !== c && cr(f, d, f.ua(c.data), !1), dr(f, d, b, !1), f.Yh(d), a = g.archetypeLabelNodeData, null === a || a instanceof V || (a = f.copyNodeData(a), \"object\" === typeof a && null !== a && (f.lf(a), a = f.ua(a), void 0 !== a && f.hu(d, a))), e.Dc(d);\n\n    return null;\n  };\n\n  Rq.prototype.findLinkForKey = Rq.prototype.findLinkForKey;\n  Rq.prototype.findPartForKey = Rq.prototype.findPartForKey;\n  Rq.prototype.removeAllModeledParts = Rq.prototype.removeAllModeledParts;\n  Rq.prototype.addModeledParts = Rq.prototype.addModeledParts;\n  Rq.prototype.addAllModeledParts = Rq.prototype.addAllModeledParts;\n  Rq.className = \"GraphLinksPartManager\";\n\n  function er() {\n    mi.apply(this, arguments);\n    this.Jg = null;\n  }\n\n  la(er, mi);\n\n  function fr(a, b, c) {\n    if (null !== b && null !== c && null === c.$g()) {\n      var d = a.diagram.toolManager.findTool(\"Linking\"),\n          e = b,\n          f = c;\n      a.diagram.isTreePathToChildren || (e = c, f = b);\n      if (null === d || !Gf(d, e, f, null, !0)) if (b = a.getLinkCategoryForData(c.data), d = a.findLinkTemplateForCategory(b), null !== d && (kg(d), d = d.copy(), null !== d)) {\n        var g = a.diagram.skipsModelSourceBindings;\n        a.diagram.skipsModelSourceBindings = !0;\n        d.Jf = b;\n        d.qb = c.data;\n        d.fromNode = e;\n        d.toNode = f;\n        a.diagram.add(d);\n        d.qb = null;\n        d.data = c.data;\n        a.diagram.skipsModelSourceBindings = g;\n      }\n    }\n  }\n\n  er.prototype.getLinkCategoryForData = function (a) {\n    return this.diagram.model.Pr(a);\n  };\n\n  er.prototype.setLinkCategoryForData = function (a, b) {\n    this.diagram.model.ms(a, b);\n  };\n\n  er.prototype.setFromNodeForLink = function (a, b, c) {\n    var d = this.diagram.model;\n    void 0 === c && (c = null);\n    b = null !== b ? b.data : null;\n    if (this.diagram.isTreePathToChildren) d.ie(a.data, d.ua(b));else {\n      var e = this.Jg;\n      this.Jg = a;\n      null !== c && d.ie(c.data, void 0);\n      d.ie(b, d.ua(null !== a.toNode ? a.toNode.data : null));\n      this.Jg = e;\n    }\n  };\n\n  er.prototype.setToNodeForLink = function (a, b, c) {\n    var d = this.diagram.model;\n    void 0 === c && (c = null);\n    b = null !== b ? b.data : null;\n\n    if (this.diagram.isTreePathToChildren) {\n      var e = this.Jg;\n      this.Jg = a;\n      null !== c && d.ie(c.data, void 0);\n      d.ie(b, d.ua(null !== a.fromNode ? a.fromNode.data : null));\n      this.Jg = e;\n    } else d.ie(a.data, d.ua(b));\n  };\n\n  er.prototype.removeDataForLink = function (a) {\n    this.diagram.model.ie(a.data, void 0);\n  };\n\n  er.prototype.findLinkForKey = function (a) {\n    if (null === a || void 0 === a) return null;\n    a = this.diagram.model.dc(a);\n    return null !== a ? this.Re.I(a) : null;\n  };\n\n  er.prototype.doModelChanged = function (a) {\n    mi.prototype.doModelChanged.call(this, a);\n\n    if (this.diagram) {\n      var b = this.diagram;\n\n      if (a.model === b.model) {\n        var c = a.change;\n\n        if (b.$) {\n          b.$ = !1;\n\n          try {\n            var d = a.modelChange;\n\n            if (\"\" !== d) {\n              if (c === de) {\n                if (\"nodeParentKey\" === d) {\n                  var e = a.object,\n                      f = this.Lb(a.newValue),\n                      g = this.ci(e);\n                  if (null !== this.Jg) null !== f && (this.Jg.data = e, this.Jg.category = this.getLinkCategoryForData(e));else if (null !== g) {\n                    var h = g.$g();\n                    null !== h ? null === f ? b.remove(h) : b.isTreePathToChildren ? h.fromNode = f : h.toNode = f : fr(this, f, g);\n                  }\n                } else if (\"parentLinkCategory\" === d) {\n                  var k = this.ci(a.object),\n                      l = a.newValue;\n\n                  if (null !== k && \"string\" === typeof l) {\n                    var m = k.$g();\n                    null !== m && (m.category = l);\n                  }\n                }\n\n                b.isModified = !0;\n              }\n            } else if (c === de) {\n              var n = a.propertyName;\n              a.object === b.model && \"nodeParentKeyProperty\" === n && (b.undoManager.isUndoingRedoing || this.Od());\n              b.isModified = !0;\n            }\n          } finally {\n            b.$ = !0;\n          }\n        }\n      }\n    }\n  };\n\n  er.prototype.updateRelationshipsFromData = function (a) {\n    var b = a.data;\n\n    if (null !== b) {\n      var c = a.diagram;\n\n      if (null !== c) {\n        var d = c.model;\n        a instanceof V && (b = d.bh(b), b = c.Lb(b), d = a.ig(), b !== d && (d = a.$g(), null !== b ? null !== d ? c.isTreePathToChildren ? d.fromNode = b : d.toNode = b : fr(this, b, a) : null !== d && Gj(c, d, !1)));\n      }\n    }\n  };\n\n  er.prototype.updateDataBindings = function (a, b) {\n    mi.prototype.updateDataBindings.call(this, a, b);\n    \"string\" === typeof b && null !== this.Ec(a) && (a = this.Dc(a), null !== a && a.Ka(b));\n  };\n\n  er.prototype.resolveReferencesForData = function (a) {\n    var b = this.diagram.model,\n        c = b.ua(a);\n\n    if (void 0 !== c) {\n      var d = $q(b, c),\n          e = this.Ec(a);\n\n      if (null !== d && null !== e) {\n        for (d = d.iterator; d.next();) {\n          var f = d.value;\n          b.lb(f) && e instanceof V && b.bh(f) === c && fr(this, e, this.ci(f));\n        }\n\n        ar(b, c);\n      }\n\n      a = b.bh(a);\n      void 0 !== a && e instanceof V && (a = this.Lb(a), fr(this, a, e));\n    }\n  };\n\n  er.prototype.unresolveReferencesForPart = function (a) {\n    var b = this.diagram.model;\n\n    if (a instanceof V) {\n      var c = b.ua(a.data),\n          d = this.Dc(a.data);\n\n      if (null !== d) {\n        d.isSelected = !1;\n        d.isHighlighted = !1;\n        var e = d.layer;\n\n        if (null !== e) {\n          var f = e.lc(-1, d, !1);\n          0 <= f && this.diagram.bb(ge, \"parts\", e, d, null, f, null);\n          f = d.layerChanged;\n          null !== f && f(d, e, null);\n        }\n      }\n\n      d = this.diagram.isTreePathToChildren;\n\n      for (a = a.linksConnected; a.next();) {\n        e = a.value, e = (d ? e.toNode : e.fromNode).data, b.lb(e) && br(b, c, e);\n      }\n    }\n  };\n\n  er.prototype.insertLink = function (a, b, c) {\n    b = this.diagram.model;\n    var d = a,\n        e = c;\n    this.diagram.isTreePathToChildren || (d = c, e = a);\n    return null !== d && null !== e ? (b.ie(e.data, b.ua(d.data)), e.$g()) : null;\n  };\n\n  er.prototype.findLinkForKey = er.prototype.findLinkForKey;\n  er.className = \"TreePartManager\";\n\n  function Z(a, b) {\n    this.Zk = new G();\n    this.Xk = new G();\n    this.Av = ',\\n  \"insertedNodeKeys\": ';\n    this.Px = ',\\n  \"modifiedNodeData\": ';\n    this.Cv = ',\\n  \"removedNodeKeys\": ';\n    this.kh = null;\n    Ra(this);\n    this.Am = this.va = \"\";\n    this.xg = !1;\n    this.j = {};\n    this.Mc = [];\n    this.kb = new pb();\n    this.Mh = \"key\";\n    this.pk = this.Rk = null;\n    this.rm = this.sm = !1;\n    this.um = !0;\n    this.fm = null;\n    this.gj = \"category\";\n    this.Lf = new pb();\n    this.ot = new E();\n    this.Mg = !1;\n    this.m = null;\n    this.undoManager = new ie();\n    void 0 !== a && (za(a) ? this.nodeDataArray = a : Object.assign(this, a));\n    b && Object.assign(this, b);\n  }\n\n  Z.prototype.cloneProtected = function (a) {\n    a.va = this.va;\n    a.Am = this.Am;\n    a.xg = this.xg;\n    a.Mh = this.Mh;\n    a.Rk = this.Rk;\n    a.pk = this.pk;\n    a.sm = this.sm;\n    a.rm = this.rm;\n    a.um = this.um;\n    a.fm = this.fm;\n    a.gj = this.gj;\n  };\n\n  Z.prototype.copy = function () {\n    var a = new this.constructor();\n    this.cloneProtected(a);\n    return a;\n  };\n\n  Z.prototype.clear = function () {\n    this.Mc = [];\n    this.kb.clear();\n    this.Lf.clear();\n    this.undoManager.clear();\n  };\n\n  Z.prototype.toString = function (a) {\n    void 0 === a && (a = 0);\n    if (1 < a) return this.Qo();\n    var b = (\"\" !== this.name ? this.name : \"\") + \" Model\";\n\n    if (0 < a) {\n      b += \"\\n node data:\";\n      a = this.nodeDataArray;\n\n      for (var c = a.length, d = 0; d < c; d++) {\n        var e = a[d];\n        b += \" \" + this.ua(e) + \":\" + Ia(e);\n      }\n    }\n\n    return b;\n  };\n\n  Z.prototype.eA = function (a) {\n    a.change !== ee && C(\"Model.toIncrementalData argument is not a Transaction ChangedEvent:\" + a.toString());\n    var b = a.object;\n    if (!(a.isTransactionFinished && b instanceof he)) return null;\n    gr(this, b);\n    a = this.uv(b, \"FinishedUndo\" === a.propertyName);\n    this.kh = null;\n    return a;\n  };\n\n  Z.prototype.uv = function (a, b) {\n    var c = this,\n        d = !1,\n        e = new G(),\n        f = new G(),\n        g = new G(),\n        h = this.kh;\n    a.changes.each(function (a) {\n      a.model === c && (\"nodeDataArray\" === a.modelChange ? a.change === fe ? e.add(a.newValue) : a.change === ge && g.add(a.oldValue) : c.lb(a.object) ? f.add(a.object) : a.change !== de || c.modelData !== a.object && \"modelData\" !== a.propertyName ? null !== a.object && (h && h.contains(a.object) ? h.get(a.object).each(function (a) {\n        c.lb(a) && f.add(a);\n      }) : a.object instanceof Z || c.ki() && c.Cc(a.object) || hr(c, a.object).each(function (a) {\n        f.add(a);\n      })) : d = !0);\n    });\n    var k = this.Xk;\n    k.clear();\n    e.each(function (a) {\n      k.add(c.ua(a));\n      b || f.add(a);\n    });\n    var l = this.Zk;\n    l.clear();\n    g.each(function (a) {\n      l.add(c.ua(a));\n      b && f.add(a);\n    });\n    a = c.cloneDeep(f.Ea());\n    var m = null;\n    d && (null === m && (m = {}), m.modelData = this.cloneDeep(this.modelData));\n    0 < k.count && (null === m && (m = {}), b ? m.removedNodeKeys = k.Ea() : m.insertedNodeKeys = k.Ea());\n    0 < a.length && (null === m && (m = {}), m.modifiedNodeData = a);\n    0 < l.count && (null === m && (m = {}), b ? m.insertedNodeKeys = l.Ea() : m.removedNodeKeys = l.Ea());\n    l.clear();\n    k.clear();\n    return m;\n  };\n\n  Z.prototype.cloneDeep = function (a) {\n    return ir(this, a, !0);\n  };\n\n  function ir(a, b, c, d, e, f) {\n    function g(a, c) {\n      h ? (void 0 === a.__gohashid && f.push(a), d.set(a, c)) : (a = kb++, d.set(a, c), e.set(a, b));\n    }\n\n    if (!ya(b)) return b;\n    f || (f = []);\n    var h = Object.isExtensible(b);\n    d || (d = new pb());\n\n    if (h) {\n      var k = d.get(b);\n      if (k) return k;\n    } else for (e || (e = new pb()), k = e.iterator; k.next();) {\n      var l = k.key;\n      if (k.value === b && (l = d.get(l))) return l;\n    }\n\n    if (Array.isArray(b)) {\n      k = [];\n      g(b, k);\n\n      for (var m = 0; m < b.length; m++) {\n        k.push(ir(a, b[m], !1, d, e, f));\n      }\n    } else if (b instanceof I || b instanceof K || b instanceof M || b instanceof ec || b instanceof N) k = b.copy(), g(b, k);else {\n      if (b instanceof ml || b instanceof O || b instanceof D) return b;\n      if (b instanceof E) k = new E().addAll(ir(a, b.Ea(), !1, d, e, f)), g(b, k);else if (b instanceof G) k = new G().addAll(ir(a, b.Ea(), !1, d, e, f)), g(b, k);else if (b instanceof pb) k = new pb().addAll(ir(a, b.Ea(), !1, d, e, f)), g(b, k);else if (b instanceof Date) k = new Date(b.getTime()), g(b, k);else if (b instanceof RegExp) k = new RegExp(b), g(b, k), k.lastIndex = b.lastIndex;else if (\"function\" === typeof b.copy) k = b.copy(), g(b, k);else for (m in k = {}, g(b, k), b) {\n        \"__gohashid\" !== m && (k[m] = ir(a, b[m], !1, d, e, f));\n      }\n    }\n\n    c && f.forEach(function (a) {\n      delete a.__gohashid;\n    });\n    return k;\n  }\n\n  t = Z.prototype;\n\n  t.quote = function (a) {\n    return JSON.stringify(a).replace(/[\\u007F-\\uFFFF]/g, function (a) {\n      return \"\\\\u\" + (\"0000\" + a.charCodeAt(0).toString(16)).substr(-4);\n    });\n  };\n\n  t.am = function () {\n    var a = \"\";\n    \"\" !== this.name && (a += ',\\n  \"name\": ' + this.quote(this.name));\n    \"\" !== this.dataFormat && (a += ',\\n  \"dataFormat\": ' + this.quote(this.dataFormat));\n    this.isReadOnly && (a += ',\\n  \"isReadOnly\": ' + this.isReadOnly);\n    \"key\" !== this.nodeKeyProperty && \"string\" === typeof this.nodeKeyProperty && (a += ',\\n  \"nodeKeyProperty\": ' + this.quote(this.nodeKeyProperty));\n    this.copiesArrays && (a += ',\\n  \"copiesArrays\": true');\n    this.copiesArrayObjects && (a += ',\\n  \"copiesArrayObjects\": true');\n    this.copiesKey || (a += ',\\n  \"copiesKey\": false');\n    \"category\" !== this.nodeCategoryProperty && \"string\" === typeof this.nodeCategoryProperty && (a += ',\\n  \"nodeCategoryProperty\": ' + this.quote(this.nodeCategoryProperty));\n    return a;\n  };\n\n  t.Io = function (a) {\n    a.name && (this.name = a.name);\n    a.dataFormat && (this.dataFormat = a.dataFormat);\n    a.isReadOnly && (this.isReadOnly = !0);\n    a.nodeKeyProperty && (this.nodeKeyProperty = a.nodeKeyProperty);\n    a.copiesArrays && (this.copiesArrays = !0);\n    a.copiesArrayObjects && (this.copiesArrayObjects = !0);\n    !1 === a.copiesKey && (this.copiesKey = !1);\n    a.nodeCategoryProperty && (this.nodeCategoryProperty = a.nodeCategoryProperty);\n  };\n\n  function jr(a, b) {\n    b = b.modelData;\n    ya(b) && (a.Ll(b), a.modelData = b);\n  }\n\n  t.vv = function () {\n    var a = this.modelData,\n        b = !1,\n        c;\n\n    for (c in a) {\n      if (!kr(c, a[c])) {\n        b = !0;\n        break;\n      }\n    }\n\n    a = \"\";\n    b && (a = ',\\n  \"modelData\": ' + lr(this, this.modelData));\n    return a + ',\\n  \"nodeDataArray\": ' + mr(this, this.nodeDataArray, !0);\n  };\n\n  t.Uu = function (a) {\n    jr(this, a);\n    a = a.nodeDataArray;\n    za(a) && (this.Ll(a), this.nodeDataArray = a);\n  };\n\n  function gr(a, b) {\n    function c(a, b) {\n      if (b = b.part) if (b = b.data, a !== b) {\n        var c = d.get(a);\n        null === c ? (c = new G(), c.add(b), d.add(a, c)) : c.add(b);\n      }\n    }\n\n    var d = a.kh;\n    null === d && (d = new pb(), b.changes.each(function (a) {\n      if (null !== a.diagram) {\n        var b = a.change;\n        if (b === de) (a = a.object.panel) && (b = a.data) && c(b, a);else if (b === fe || b === ge) a = a.object, (b = a.itemArray) && c(b, a);\n      }\n    }), a.kh = d);\n  }\n\n  function hr(a, b) {\n    for (var c = new G(), d = 0; d < a.nodeDataArray.length; d++) {\n      var e = a.nodeDataArray[d];\n      nr(a, b, e, e, c);\n    }\n\n    return c;\n  }\n\n  function nr(a, b, c, d, e) {\n    if (Array.isArray(c)) for (var f = 0; f < c.length; f++) {\n      var g = c[f];\n      if (g === b) return e.add(d), !0;\n      if (nr(a, b, g, d, e)) return !0;\n    } else if (ya(c) && Object.getPrototypeOf(c) === Object.prototype) for (f in c) {\n      g = c[f];\n      if (g === b) return e.add(d), !0;\n      if (nr(a, b, g, d, e)) return !0;\n    }\n    return !1;\n  }\n\n  t.tv = function (a, b) {\n    var c = this,\n        d = !1,\n        e = new G(),\n        f = new G(),\n        g = new G(),\n        h = this.kh;\n    a.changes.each(function (a) {\n      a.model === c && (\"nodeDataArray\" === a.modelChange ? a.change === fe ? e.add(a.newValue) : a.change === ge && g.add(a.oldValue) : c.lb(a.object) ? f.add(a.object) : a.change !== de || c.modelData !== a.object && \"modelData\" !== a.propertyName ? null !== a.object && (h && h.contains(a.object) ? h.get(a.object).each(function (a) {\n        c.lb(a) && f.add(a);\n      }) : a.object instanceof Z || c.ki() && c.Cc(a.object) || hr(c, a.object).each(function (a) {\n        f.add(a);\n      })) : d = !0);\n    });\n    var k = this.Xk;\n    k.clear();\n    e.each(function (a) {\n      k.add(c.ua(a));\n      b || f.add(a);\n    });\n    var l = this.Zk;\n    l.clear();\n    g.each(function (a) {\n      l.add(c.ua(a));\n      b && f.add(a);\n    });\n    a = \"\";\n    d && (a += ',\\n  \"modelData\": ' + lr(this, this.modelData));\n    0 < k.count && (a += (b ? this.Cv : this.Av) + mr(this, k.Ea(), !0));\n    0 < f.count && (a += this.Px + mr(this, f.Ea(), !0));\n    0 < l.count && (a += (b ? this.Av : this.Cv) + mr(this, l.Ea(), !0));\n    l.clear();\n    k.clear();\n    return a;\n  };\n\n  t.Ho = function (a) {\n    (void 0 !== a.name && a.name !== this.name || void 0 !== a.dataFormat && a.dataFormat !== this.dataFormat || void 0 !== a.isReadOnly && a.isReadOnly !== this.isReadOnly || void 0 !== a.nodeKeyProperty && a.nodeKeyProperty !== this.nodeKeyProperty || void 0 !== a.copiesArrays && a.copiesArrays !== this.copiesArrays || void 0 !== a.copiesArrayObjects && a.copiesArrayObjects !== this.copiesArrayObjects || void 0 !== a.copiesKey && a.copiesKey !== this.copiesKey || void 0 !== a.nodeCategoryProperty && a.nodeCategoryProperty !== this.nodeCategoryProperty) && C(\"applyIncrementalJson cannot change Model properties\");\n    jr(this, a);\n    var b = a.insertedNodeKeys,\n        c = a.modifiedNodeData,\n        d = new pb();\n    if (Array.isArray(c)) for (var e = 0; e < c.length; e++) {\n      var f = c[e],\n          g = this.ua(f);\n      void 0 !== g && null !== g && d.set(g, f);\n    }\n    if (Array.isArray(b)) for (e = b.length, f = 0; f < e; f++) {\n      g = b[f];\n      var h = this.dc(g);\n      null === h && (h = (h = d.get(g)) ? h : this.copyNodeData({}), this.Sl(h, g), this.lf(h));\n    }\n    if (Array.isArray(c)) for (b = c.length, d = 0; d < b; d++) {\n      if (e = c[d], f = this.ua(e), f = this.dc(f), null !== f) {\n        for (var k in e) {\n          \"__gohashid\" === k || k === this.nodeKeyProperty || this.Nj() && k === this.nodeIsGroupProperty || this.setDataProperty(f, k, e[k]);\n        }\n\n        this.Tl(e, f);\n      }\n    }\n    a = a.removedNodeKeys;\n    if (Array.isArray(a)) for (c = a.length, k = 0; k < c; k++) {\n      b = this.dc(a[k]), null !== b && this.Kl(b);\n    }\n  };\n\n  t.Jx = function (a, b) {\n    a.change !== ee && C(\"Model.toIncrementalJson argument is not a Transaction ChangedEvent:\" + a.toString());\n    var c = a.object;\n    if (!(a.isTransactionFinished && c instanceof he)) return '{ \"incremental\": 0 }';\n    void 0 === b && (b = or(this, this));\n    gr(this, c);\n    a = this.tv(c, \"FinishedUndo\" === a.propertyName);\n    this.kh = null;\n    return \"2\" === b ? '{ \"incremental\": 2' + a + \"}\" : '{ \"class\": ' + this.quote(b) + ', \"incremental\": 1' + this.am() + a + \"}\";\n  };\n\n  t.fA = function (a, b) {\n    return this.Jx(a, b);\n  };\n\n  t.Qo = function (a) {\n    void 0 === a && (a = or(this, this));\n    return '{ \"class\": ' + this.quote(a) + this.am() + this.vv() + \"}\";\n  };\n\n  t.toJSON = function (a) {\n    return this.Qo(a);\n  };\n\n  t.Dw = function (a) {\n    var b = null;\n    if (\"string\" === typeof a) try {\n      b = x.JSON.parse(a);\n    } catch (d) {} else \"object\" === typeof a ? b = a : C(\"Unable to modify a Model from: \" + a);\n    var c = b.incremental;\n    \"number\" !== typeof c && C(\"Unable to apply non-incremental changes to Model: \" + a);\n    0 !== c && (this.Da(\"applyIncrementalJson\"), this.Ho(b), this.eb(\"applyIncrementalJson\"));\n  };\n\n  t.qy = function (a) {\n    return this.Dw(a);\n  };\n\n  Z.constructGraphLinksModel = function () {\n    return new Z();\n  };\n\n  t = Z.prototype;\n\n  t.Ll = function (a) {\n    if (za(a)) for (var b = a.length, c = 0; c < b; c++) {\n      var d = a[c];\n\n      if (ya(d)) {\n        var e = c;\n        d = this.Ll(d);\n        Array.isArray(a) ? a[e] = d : C(\"Cannot replace an object in an HTMLCollection or NodeList at \" + e);\n      }\n    } else if (ya(a)) {\n      for (b in a) {\n        if (c = a[b], ya(c) && (c = this.Ll(c), a[b] = c, \"points\" === b && Array.isArray(c))) {\n          e = 0 === c.length % 2;\n\n          for (d = 0; d < c.length; d++) {\n            if (\"number\" !== typeof c[d]) {\n              e = !1;\n              break;\n            }\n          }\n\n          if (e) {\n            e = new E();\n\n            for (d = 0; d < c.length / 2; d++) {\n              e.add(new I(c[2 * d], c[2 * d + 1]));\n            }\n\n            e.freeze();\n            a[b] = e;\n          }\n        }\n      }\n\n      return pr(a);\n    }\n    return a;\n  };\n\n  t.bm = function (a) {\n    return void 0 === a ? \"undefined\" : null === a ? \"null\" : !0 === a ? \"true\" : !1 === a ? \"false\" : \"string\" === typeof a ? this.quote(a) : \"number\" === typeof a ? Infinity === a ? \"9e9999\" : -Infinity === a ? \"-9e9999\" : isNaN(a) ? '{\"class\":\"NaN\"}' : a.toString() : a instanceof Date ? '{\"class\":\"Date\", \"value\":\"' + a.toJSON() + '\"}' : a instanceof Number ? this.bm(a.valueOf()) : za(a) ? mr(this, a) : ya(a) ? lr(this, a) : \"function\" === typeof a ? \"null\" : a.toString();\n  };\n\n  function mr(a, b, c) {\n    void 0 === c && (c = !1);\n    var d = b.length;\n    if (0 >= d) return \"[]\";\n    var e = new Ta();\n    e.add(\"[\");\n    c && 1 < d && e.add(\"\\n\");\n\n    for (var f = 0; f < d; f++) {\n      var g = b[f];\n      void 0 !== g && (0 < f && (e.add(\",\"), c && e.add(\"\\n\")), e.add(a.bm(g)));\n    }\n\n    c && 1 < d && e.add(\"\\n\");\n    e.add(\"]\");\n    return e.toString();\n  }\n\n  function kr(a, b) {\n    return void 0 === b || \"__gohashid\" === a || \"_\" === a[0] || \"function\" === typeof b ? !0 : !1;\n  }\n\n  function qr(a) {\n    return isNaN(a) ? \"NaN\" : Infinity === a ? \"9e9999\" : -Infinity === a ? \"-9e9999\" : a;\n  }\n\n  function lr(a, b) {\n    var c = b;\n    if (c instanceof I) b = {\n      \"class\": \"go.Point\",\n      x: qr(c.x),\n      y: qr(c.y)\n    };else if (c instanceof K) b = {\n      \"class\": \"go.Size\",\n      width: qr(c.width),\n      height: qr(c.height)\n    };else if (c instanceof M) b = {\n      \"class\": \"go.Rect\",\n      x: qr(c.x),\n      y: qr(c.y),\n      width: qr(c.width),\n      height: qr(c.height)\n    };else if (c instanceof ec) b = {\n      \"class\": \"go.Margin\",\n      top: qr(c.top),\n      right: qr(c.right),\n      bottom: qr(c.bottom),\n      left: qr(c.left)\n    };else if (c instanceof N) c.pb() ? b = {\n      \"class\": \"go.Spot\",\n      x: qr(c.x),\n      y: qr(c.y),\n      offsetX: qr(c.offsetX),\n      offsetY: qr(c.offsetY)\n    } : b = {\n      \"class\": \"go.Spot\",\n      \"enum\": c.toString()\n    };else if (c instanceof ml) {\n      b = {\n        \"class\": \"go.Brush\",\n        type: c.type.name\n      };\n      if (c.type === tl) b.color = c.color;else if (c.type === wl || c.type === nl) b.start = c.start, b.end = c.end, c.type === nl && (0 !== c.startRadius && (b.startRadius = qr(c.startRadius)), isNaN(c.endRadius) || (b.endRadius = qr(c.endRadius)));\n\n      if (null !== c.colorStops) {\n        var d = {};\n\n        for (c = c.colorStops.iterator; c.next();) {\n          d[c.key] = c.value;\n        }\n\n        b.colorStops = d;\n      }\n    } else c instanceof O ? (b = {\n      \"class\": \"go.Geometry\",\n      type: c.type.name\n    }, 0 !== c.startX && (b.startX = qr(c.startX)), 0 !== c.startY && (b.startY = qr(c.startY)), 0 !== c.endX && (b.endX = qr(c.endX)), 0 !== c.endY && (b.endY = qr(c.endY)), c.spot1.C(tc) || (b.spot1 = c.spot1), c.spot2.C(Cc) || (b.spot2 = c.spot2), c.type === O.m && (b.path = O.ga(c))) : c instanceof D && (b = {\n      \"class\": \"go.EnumValue\",\n      classType: or(a, c.classType),\n      name: c.name\n    });\n    d = \"{\";\n    c = !0;\n\n    for (var e in b) {\n      var f = nn(b, e);\n      if (!kr(e, f)) if (c ? c = !1 : d += \",\", d += a.quote(e) + \":\", \"points\" === e && f instanceof E) {\n        var g = \"[\";\n\n        for (f = f.iterator; f.next();) {\n          var h = f.value;\n          1 < g.length && (g += \",\");\n          g += a.bm(h.x);\n          g += \",\";\n          g += a.bm(h.y);\n        }\n\n        g += \"]\";\n        d += g;\n      } else d += a.bm(f);\n    }\n\n    return d + \"}\";\n  }\n\n  function rr(a) {\n    return \"number\" === typeof a ? a : \"NaN\" === a ? NaN : \"9e9999\" === a ? Infinity : \"-9e9999\" === a ? -Infinity : parseFloat(a);\n  }\n\n  function pr(a) {\n    if (\"object\" !== typeof a) return a;\n    var b = a[\"class\"] || \"\";\n    if (\"NaN\" === b) return NaN;\n    if (\"Date\" === b) return new Date(a.value);\n    if (0 !== b.indexOf(\"go.\")) return a;\n    b = b.substr(3);\n    var c = a;\n    if (\"Point\" === b) c = new I(rr(a.x), rr(a.y));else if (\"Size\" === b) c = new K(rr(a.width), rr(a.height));else if (\"Rect\" === b) c = new M(rr(a.x), rr(a.y), rr(a.width), rr(a.height));else if (\"Margin\" === b) c = new ec(rr(a.top), rr(a.right), rr(a.bottom), rr(a.left));else if (\"Spot\" === b) \"string\" === typeof a[\"enum\"] ? c = jd(a[\"enum\"]) : c = new N(rr(a.x), rr(a.y), rr(a.offsetX), rr(a.offsetY));else if (\"Brush\" === b) {\n      if (c = new ml(), c.type = Sa(ml, a.type), \"string\" === typeof a.color && (c.color = a.color), a.start instanceof N && (c.start = a.start), a.end instanceof N && (c.end = a.end), \"number\" === typeof a.startRadius && (c.startRadius = rr(a.startRadius)), \"number\" === typeof a.endRadius && (c.endRadius = rr(a.endRadius)), a = a.colorStops, ya(a)) for (var d in a) {\n        c.addColorStop(parseFloat(d), a[d]);\n      }\n    } else \"Geometry\" === b ? (c = null, \"string\" === typeof a.path ? c = O.parse(a.path) : c = new O(), c.type = Sa(O, a.type), \"number\" === typeof a.startX && (c.startX = rr(a.startX)), \"number\" === typeof a.startY && (c.startY = rr(a.startY)), \"number\" === typeof a.endX && (c.endX = rr(a.endX)), \"number\" === typeof a.endY && (c.endY = rr(a.endY)), a.spot1 instanceof N && (c.spot1 = a.spot1), a.spot2 instanceof N && (c.spot2 = a.spot2)) : \"EnumValue\" === b && (d = a.classType, 0 === d.indexOf(\"go.\") && (d = d.substr(3)), d = sr(d), \"function\" === typeof d && (c = Sa(d, a.name)));\n    return c;\n  }\n\n  t.Ug = function (a) {\n    this.ot.add(a);\n    return this;\n  };\n\n  t.ak = function (a) {\n    this.ot.remove(a);\n  };\n\n  t.Cr = function (a) {\n    this.skipsUndoManager || this.undoManager.Fu(a);\n\n    for (var b = this.ot, c = b.length, d = 0; d < c; d++) {\n      b.K(d)(a);\n    }\n  };\n\n  t.bb = function (a, b, c, d, e, f, g) {\n    tr(this, \"\", a, b, c, d, e, f, g);\n  };\n\n  t.g = function (a, b, c, d, e) {\n    tr(this, \"\", de, a, this, b, c, d, e);\n  };\n\n  t.fs = function (a, b, c, d, e, f) {\n    tr(this, \"\", de, b, a, c, d, e, f);\n  };\n\n  function tr(a, b, c, d, e, f, g, h, k) {\n    void 0 === h && (h = null);\n    void 0 === k && (k = null);\n    var l = new ce();\n    l.model = a;\n    l.change = c;\n    l.modelChange = b;\n    l.propertyName = d;\n    l.object = e;\n    l.oldValue = f;\n    l.oldParam = h;\n    l.newValue = g;\n    l.newParam = k;\n    a.Cr(l);\n  }\n\n  Z.prototype.changeState = function (a, b) {\n    if (null !== a && a.model === this) if (a.change === de) {\n      var c = a.object,\n          d = a.propertyName,\n          e = a.I(b);\n      d === this.nodeKeyProperty && this.lb(c) && (b = a.I(!b), void 0 !== b && this.kb.remove(b), void 0 !== e && this.kb.add(e, c));\n      Nj(c, d, e);\n    } else a.change === fe ? (c = a.newParam, \"nodeDataArray\" === a.modelChange ? (a = a.newValue, ya(a) && \"number\" === typeof c && (d = this.ua(a), b ? (this.Mc[c] === a && Da(this.Mc, c), void 0 !== d && this.kb.remove(d)) : (this.Mc[c] !== a && Ca(this.Mc, c, a), void 0 !== d && this.kb.add(d, a)))) : \"\" === a.modelChange ? ((d = a.object) && !za(d) && a.propertyName && (d = nn(a.object, a.propertyName)), za(d) && \"number\" === typeof c && (a = a.newValue, b ? Da(d, c) : Ca(d, c, a))) : C(\"unknown ChangedEvent.Insert modelChange: \" + a.toString())) : a.change === ge ? (c = a.oldParam, \"nodeDataArray\" === a.modelChange ? (a = a.oldValue, ya(a) && \"number\" === typeof c && (d = this.ua(a), b ? (this.Mc[c] !== a && Ca(this.Mc, c, a), void 0 !== d && this.kb.add(d, a)) : (this.Mc[c] === a && Da(this.Mc, c), void 0 !== d && this.kb.remove(d)))) : \"\" === a.modelChange ? ((d = a.object) && !za(d) && a.propertyName && (d = nn(a.object, a.propertyName)), za(d) && \"number\" === typeof c && (a = a.oldValue, b ? Ca(d, c, a) : Da(d, c))) : C(\"unknown ChangedEvent.Remove modelChange: \" + a.toString())) : a.change !== ee && C(\"unknown ChangedEvent: \" + a.toString());\n  };\n\n  Z.prototype.Da = function (a) {\n    return this.undoManager.Da(a);\n  };\n\n  Z.prototype.eb = function (a) {\n    return this.undoManager.eb(a);\n  };\n\n  Z.prototype.Bf = function () {\n    return this.undoManager.Bf();\n  };\n\n  Z.prototype.commit = function (a, b) {\n    void 0 === b && (b = \"\");\n    var c = this.skipsUndoManager;\n    null === b && (this.skipsUndoManager = !0, b = \"\");\n    this.undoManager.Da(b);\n    var d = !1;\n\n    try {\n      a(this), d = !0;\n    } finally {\n      d ? this.undoManager.eb(b) : this.undoManager.Bf(), this.skipsUndoManager = c;\n    }\n  };\n\n  t = Z.prototype;\n\n  t.Ka = function (a, b) {\n    void 0 === b && (b = \"\");\n    tr(this, \"SourceChanged\", ee, b, a, null, null);\n  };\n\n  t.ua = function (a) {\n    if (null !== a) {\n      var b = this.Mh;\n\n      if (\"\" !== b && (b = nn(a, b), void 0 !== b)) {\n        if (Xq(b)) return b;\n        C(\"Key value for node data \" + a + \" is not a number or a string: \" + b);\n      }\n    }\n  };\n\n  t.Sl = function (a, b) {\n    if (null !== a) {\n      var c = this.Mh;\n      if (\"\" !== c) if (this.lb(a)) {\n        var d = nn(a, c);\n        d !== b && null === this.dc(b) && (Nj(a, c, b), void 0 !== d && this.kb.remove(d), this.kb.add(b, a), tr(this, \"nodeKey\", de, c, a, d, b), \"string\" === typeof c && this.Ka(a, c), this.Mo(d, b));\n      } else Nj(a, c, b);\n    }\n  };\n\n  function Xq(a) {\n    return \"number\" === typeof a || \"string\" === typeof a;\n  }\n\n  t.lb = function (a) {\n    var b = this.ua(a);\n    return void 0 === b ? !1 : this.kb.I(b) === a;\n  };\n\n  t.dc = function (a) {\n    null === a && C(\"Model.findNodeDataForKey:key must not be null\");\n    return void 0 !== a && Xq(a) ? this.kb.I(a) : null;\n  };\n\n  t.Mu = function (a) {\n    if (null !== a) {\n      var b = this.Mh;\n\n      if (\"\" !== b) {\n        var c = this.ua(a);\n\n        if (void 0 === c || this.kb.contains(c)) {\n          var d = this.Rk;\n\n          if (null !== d && (c = d(this, a), void 0 !== c && null !== c && !this.kb.contains(c))) {\n            Nj(a, b, c);\n            return;\n          }\n\n          if (\"string\" === typeof c) {\n            for (d = 2; this.kb.contains(c + d);) {\n              d++;\n            }\n\n            Nj(a, b, c + d);\n          } else if (void 0 === c || \"number\" === typeof c) {\n            for (c = -this.kb.count - 1; this.kb.contains(c);) {\n              c--;\n            }\n\n            Nj(a, b, c);\n          }\n        }\n      }\n    }\n  };\n\n  t.lf = function (a) {\n    null !== a && (gb(a), this.lb(a) || Pq(this, a, !0));\n  };\n\n  function Pq(a, b, c) {\n    var d = a.ua(b);\n    if (void 0 === d || a.kb.I(d) !== b) a.Mu(b), d = a.ua(b), void 0 === d && C(\"Model.makeNodeDataKeyUnique failed on \" + b + \".  Data not added to Model.\"), a.kb.add(d, b), d = null, c && (d = a.Mc.length, Ca(a.Mc, d, b)), tr(a, \"nodeDataArray\", fe, \"nodeDataArray\", a, null, b, null, d), a.Nl(b), a.Ml(b);\n  }\n\n  t.my = function (a) {\n    if (za(a)) for (var b = a.length, c = 0; c < b; c++) {\n      this.lf(a[c]);\n    } else for (a = a.iterator; a.next();) {\n      this.lf(a.value);\n    }\n  };\n\n  t.Kl = function (a) {\n    null !== a && Oq(this, a, !0);\n  };\n\n  function Oq(a, b, c) {\n    var d = a.ua(b);\n    void 0 !== d && a.kb.remove(d);\n    d = null;\n\n    if (c) {\n      a: if (c = a.Mc, Array.isArray(c)) d = c.indexOf(b);else {\n        d = c.length;\n\n        for (var e = 0; e < d; e++) {\n          if (c[e] === b) {\n            d = e;\n            break a;\n          }\n        }\n\n        d = -1;\n      }\n\n      if (0 > d) return;\n      Da(a.Mc, d);\n    }\n\n    tr(a, \"nodeDataArray\", ge, \"nodeDataArray\", a, b, null, d, null);\n    a.To(b);\n  }\n\n  t.Uz = function (a) {\n    if (za(a)) for (var b = a.length, c = 0; c < b; c++) {\n      this.Kl(a[c]);\n    } else for (a = a.iterator; a.next();) {\n      this.Kl(a.value);\n    }\n  };\n\n  t.Hz = function (a) {\n    if (a !== this.nodeDataArray && za(a)) {\n      var b = this.Zk;\n      b.clear();\n      b.addAll(this.kb.iteratorKeys);\n      var c = this.Xk;\n      c.clear();\n\n      for (var d = a.length, e = 0; e < d; e++) {\n        var f = a[e],\n            g = this.ua(f);\n\n        if (void 0 !== g) {\n          c.add(g);\n          var h = this.dc(g);\n          h !== f && (null !== h ? (this.ho(h, f), this.Tl(f, h)) : (f = this.cloneDeep(f), this.Sl(f, g), this.lf(f)));\n        } else g = this.cloneDeep(f), this.lf(g), c.add(this.ua(g));\n      }\n\n      for (a = b.iterator; a.next();) {\n        d = a.value, c.contains(d) || (d = this.dc(d)) && this.Kl(d);\n      }\n\n      b.clear();\n      c.clear();\n    }\n  };\n\n  t.Mo = function (a, b) {\n    void 0 !== b && (a = $q(this, a), a instanceof G && this.Lf.add(b, a));\n  };\n\n  t.ov = function () {};\n\n  t.Nl = function () {};\n\n  t.Ml = function () {};\n\n  t.To = function () {};\n\n  function br(a, b, c) {\n    if (void 0 !== b) {\n      var d = a.Lf.I(b);\n      null === d && (d = new G(), a.Lf.add(b, d));\n      d.add(c);\n    }\n  }\n\n  function ar(a, b, c) {\n    if (void 0 !== b) {\n      var d = a.Lf.I(b);\n      d instanceof G && (void 0 === c || null === c ? a.Lf.remove(b) : (d.remove(c), 0 === d.count && a.Lf.remove(b)));\n    }\n  }\n\n  function $q(a, b) {\n    if (void 0 === b) return null;\n    a = a.Lf.I(b);\n    return a instanceof G ? a : null;\n  }\n\n  t.xy = function (a) {\n    void 0 === a ? this.Lf.clear() : this.Lf.remove(a);\n  };\n\n  Z.prototype.copyNodeData = function (a) {\n    if (null === a) return null;\n    var b = this.pk;\n    a = null !== b ? b(a, this) : vr(this, a, !0);\n    ya(a) && Ra(a);\n    return a;\n  };\n\n  function vr(a, b, c) {\n    if (a.copiesArrays && Array.isArray(b)) {\n      var d = [];\n\n      for (c = 0; c < b.length; c++) {\n        var e = vr(a, b[c], a.copiesArrayObjects);\n        d.push(e);\n      }\n\n      Ra(d);\n      return d;\n    }\n\n    if (c && ya(b)) {\n      c = (c = b.constructor) ? new c() : {};\n      e = a.copiesKey || \"string\" !== typeof a.nodeKeyProperty ? null : a.nodeKeyProperty;\n\n      for (d in b) {\n        if (\"__gohashid\" === d) c.__gohashid = void 0;else if (d === e) c[e] = void 0;else {\n          var f = nn(b, d),\n              g = or(a, f);\n          \"GraphObject\" === g || \"Diagram\" === g || \"Layer\" === g || \"RowColumnDefinition\" === g || \"AnimationManager\" === g || \"Tool\" === g || \"CommandHandler\" === g || \"Layout\" === g || \"InputEvent\" === g || \"DiagramEvent\" === g || f instanceof Z || f instanceof ie || f instanceof he || f instanceof ce ? Nj(c, d, f) : (f = vr(a, f, !1), Nj(c, d, f));\n        }\n      }\n\n      Ra(c);\n      return c;\n    }\n\n    return b instanceof I ? b.copy() : b instanceof K ? b.copy() : b instanceof M ? b.copy() : b instanceof N ? b.copy() : b instanceof ec ? b.copy() : b;\n  }\n\n  Z.prototype.setDataProperty = function (a, b, c) {\n    if (this.lb(a)) {\n      if (b === this.nodeKeyProperty) {\n        this.Sl(a, c);\n        return;\n      }\n\n      if (b === this.nodeCategoryProperty) {\n        this.Rl(a, c);\n        return;\n      }\n    } else !wr && a instanceof Y && (wr = !0, xa('Model.setDataProperty is modifying a GraphObject, \"' + a.toString() + '\"'), xa(\"  Is that really your intent?\"));\n\n    var d = nn(a, b);\n    d !== c && (Nj(a, b, c), this.fs(a, b, d, c));\n  };\n\n  t = Z.prototype;\n\n  t.set = function (a, b, c) {\n    this.setDataProperty(a, b, c);\n  };\n\n  t.ho = function (a, b) {\n    if (b) {\n      var c = this.lb(a),\n          d;\n\n      for (d in b) {\n        \"__gohashid\" === d || c && d === this.nodeKeyProperty || this.setDataProperty(a, d, b[d]);\n      }\n    }\n  };\n\n  t.iy = function (a, b) {\n    this.Qr(a, -1, b);\n  };\n\n  t.Qr = function (a, b, c) {\n    0 > b && (b = a.length);\n    Ca(a, b, c);\n    tr(this, \"\", fe, \"\", a, null, c, null, b);\n  };\n\n  t.Xu = function (a, b) {\n    void 0 === b && (b = -1);\n    a === this.Mc && C(\"Model.removeArrayItem should not be called on the Model.nodeDataArray\");\n    -1 === b && (b = a.length - 1);\n    var c = a[b];\n    Da(a, b);\n    tr(this, \"\", ge, \"\", a, c, null, b, null);\n  };\n\n  t.uo = function (a) {\n    if (null === a) return \"\";\n    var b = this.gj;\n    if (\"\" === b) return \"\";\n    b = nn(a, b);\n    if (void 0 === b) return \"\";\n    if (\"string\" === typeof b) return b;\n    C(\"getCategoryForNodeData found a non-string category for \" + a + \": \" + b);\n  };\n\n  t.Rl = function (a, b) {\n    if (null !== a) {\n      var c = this.gj;\n      if (\"\" !== c) if (this.lb(a)) {\n        var d = nn(a, c);\n        void 0 === d && (d = \"\");\n        d !== b && (Nj(a, c, b), tr(this, \"nodeCategory\", de, c, a, d, b));\n      } else Nj(a, c, b);\n    }\n  };\n\n  t.Tl = function (a, b) {\n    this.Rl(b, this.uo(a));\n  };\n\n  t.Bl = function () {\n    return !1;\n  };\n\n  t.Nj = function () {\n    return !1;\n  };\n\n  t.ki = function () {\n    return !1;\n  };\n\n  t.Vr = function () {\n    return !1;\n  };\n\n  t.Oj = function () {\n    return !1;\n  };\n\n  function oi() {\n    return new Z();\n  }\n\n  function or(a, b) {\n    if (\"function\" === typeof b) {\n      if (b.className) return b.className;\n      if (b.name) return b.name;\n    } else if (\"object\" === typeof b && null !== b && b.constructor) return or(a, b.constructor);\n\n    return typeof b;\n  }\n\n  function sr(a) {\n    return xr[a] ? xr[a] : void 0 !== x.go && x.go[a] ? x.go[a] : null;\n  }\n\n  function nn(a, b) {\n    if (!a || !b) return null;\n\n    try {\n      if (\"function\" === typeof b) var c = b(a);else \"function\" === typeof a.getAttribute ? (c = a.getAttribute(b), null === c && (c = void 0)) : c = a[b];\n    } catch (d) {}\n\n    return c;\n  }\n\n  function Nj(a, b, c) {\n    if (a && b) try {\n      \"function\" === typeof b ? b(a, c) : \"function\" === typeof a.setAttribute ? a.setAttribute(b, c) : a[b] = c;\n    } catch (d) {}\n  }\n\n  ma.Object.defineProperties(Z.prototype, {\n    name: {\n      get: function get() {\n        return this.va;\n      },\n      set: function set(a) {\n        var b = this.va;\n        b !== a && (this.va = a, this.g(\"name\", b, a));\n      }\n    },\n    dataFormat: {\n      get: function get() {\n        return this.Am;\n      },\n      set: function set(a) {\n        var b = this.Am;\n        b !== a && (this.Am = a, this.g(\"dataFormat\", b, a));\n      }\n    },\n    isReadOnly: {\n      get: function get() {\n        return this.xg;\n      },\n      set: function set(a) {\n        var b = this.xg;\n        b !== a && (this.xg = a, this.g(\"isReadOnly\", b, a));\n      }\n    },\n    modelData: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        var b = this.j;\n        b !== a && (this.j = a, this.g(\"modelData\", b, a), this.Ka(a));\n      }\n    },\n    undoManager: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        var b = this.m;\n        b !== a && (null !== b && b.yx(this), this.m = a, null !== a && a.Bw(this));\n      }\n    },\n    skipsUndoManager: {\n      get: function get() {\n        return this.Mg;\n      },\n      set: function set(a) {\n        this.Mg = a;\n      }\n    },\n    nodeKeyProperty: {\n      get: function get() {\n        return this.Mh;\n      },\n      set: function set(a) {\n        var b = this.Mh;\n        b !== a && (\"\" === a && C(\"Model.nodeKeyProperty may not be the empty string\"), 0 < this.kb.count && C(\"Cannot set Model.nodeKeyProperty when there is existing node data\"), this.Mh = a, this.g(\"nodeKeyProperty\", b, a));\n      }\n    },\n    makeUniqueKeyFunction: {\n      get: function get() {\n        return this.Rk;\n      },\n      set: function set(a) {\n        var b = this.Rk;\n        b !== a && (this.Rk = a, this.g(\"makeUniqueKeyFunction\", b, a));\n      }\n    },\n    nodeDataArray: {\n      get: function get() {\n        return this.Mc;\n      },\n      set: function set(a) {\n        var b = this.Mc;\n\n        if (b !== a) {\n          this.kb.clear();\n          this.ov();\n\n          for (var c = a.length, d = 0; d < c; d++) {\n            var e = a[d];\n            ya(e) || C(\"Model.nodeDataArray must only contain Objects, not: \" + e);\n            gb(e);\n          }\n\n          this.Mc = a;\n          d = new E();\n\n          for (e = 0; e < c; e++) {\n            var f = a[e],\n                g = this.ua(f);\n            void 0 === g ? d.add(f) : null !== this.kb.I(g) ? d.add(f) : this.kb.add(g, f);\n          }\n\n          for (d = d.iterator; d.next();) {\n            e = d.value, this.Mu(e), f = this.ua(e), void 0 !== f && this.kb.add(f, e);\n          }\n\n          tr(this, \"nodeDataArray\", de, \"nodeDataArray\", this, b, a);\n\n          for (b = 0; b < c; b++) {\n            d = a[b], this.Nl(d), this.Ml(d);\n          }\n\n          Array.isArray(a) || (this.isReadOnly = !0);\n        }\n      }\n    },\n    copyNodeDataFunction: {\n      get: function get() {\n        return this.pk;\n      },\n      set: function set(a) {\n        var b = this.pk;\n        b !== a && (this.pk = a, this.g(\"copyNodeDataFunction\", b, a));\n      }\n    },\n    copiesArrays: {\n      get: function get() {\n        return this.sm;\n      },\n      set: function set(a) {\n        var b = this.sm;\n        b !== a && (this.sm = a, this.g(\"copiesArrays\", b, a));\n      }\n    },\n    copiesArrayObjects: {\n      get: function get() {\n        return this.rm;\n      },\n      set: function set(a) {\n        var b = this.rm;\n        b !== a && (this.rm = a, this.g(\"copiesArrayObjects\", b, a));\n      }\n    },\n    copiesKey: {\n      get: function get() {\n        return this.um;\n      },\n      set: function set(a) {\n        var b = this.um;\n        b !== a && (this.um = a, this.g(\"copiesKey\", b, a));\n      }\n    },\n    afterCopyFunction: {\n      get: function get() {\n        return this.fm;\n      },\n      set: function set(a) {\n        var b = this.fm;\n        b !== a && (this.fm = a, this.g(\"afterCopyFunction\", b, a));\n      }\n    },\n    nodeCategoryProperty: {\n      get: function get() {\n        return this.gj;\n      },\n      set: function set(a) {\n        var b = this.gj;\n        b !== a && (this.gj = a, this.g(\"nodeCategoryProperty\", b, a));\n      }\n    },\n    type: {\n      get: function get() {\n        return \"Model\";\n      }\n    }\n  });\n  Z.prototype.setCategoryForNodeData = Z.prototype.Rl;\n  Z.prototype.getCategoryForNodeData = Z.prototype.uo;\n  Z.prototype.removeArrayItem = Z.prototype.Xu;\n  Z.prototype.insertArrayItem = Z.prototype.Qr;\n  Z.prototype.addArrayItem = Z.prototype.iy;\n  Z.prototype.assignAllDataProperties = Z.prototype.ho;\n  Z.prototype.set = Z.prototype.set;\n  Z.prototype.clearUnresolvedReferences = Z.prototype.xy;\n  Z.prototype.mergeNodeDataArray = Z.prototype.Hz;\n  Z.prototype.removeNodeDataCollection = Z.prototype.Uz;\n  Z.prototype.removeNodeData = Z.prototype.Kl;\n  Z.prototype.addNodeDataCollection = Z.prototype.my;\n  Z.prototype.addNodeData = Z.prototype.lf;\n  Z.prototype.makeNodeDataKeyUnique = Z.prototype.Mu;\n  Z.prototype.findNodeDataForKey = Z.prototype.dc;\n  Z.prototype.containsNodeData = Z.prototype.lb;\n  Z.prototype.setKeyForNodeData = Z.prototype.Sl;\n  Z.prototype.getKeyForNodeData = Z.prototype.ua;\n  Z.prototype.updateTargetBindings = Z.prototype.Ka;\n  Z.prototype.commit = Z.prototype.commit;\n  Z.prototype.rollbackTransaction = Z.prototype.Bf;\n  Z.prototype.commitTransaction = Z.prototype.eb;\n  Z.prototype.startTransaction = Z.prototype.Da;\n  Z.prototype.raiseDataChanged = Z.prototype.fs;\n  Z.prototype.raiseChanged = Z.prototype.g;\n  Z.prototype.raiseChangedEvent = Z.prototype.bb;\n  Z.prototype.removeChangedListener = Z.prototype.ak;\n  Z.prototype.addChangedListener = Z.prototype.Ug;\n  Z.prototype.writeJsonValue = Z.prototype.bm;\n  Z.prototype.replaceJsonObjects = Z.prototype.Ll;\n  Z.prototype.applyIncrementalJSON = Z.prototype.qy;\n  Z.prototype.applyIncrementalJson = Z.prototype.Dw;\n  Z.prototype.toJSON = Z.prototype.toJSON;\n  Z.prototype.toJson = Z.prototype.Qo;\n  Z.prototype.toIncrementalJSON = Z.prototype.fA;\n  Z.prototype.toIncrementalJson = Z.prototype.Jx;\n  Z.prototype.toIncrementalData = Z.prototype.eA;\n  Z.prototype.clear = Z.prototype.clear;\n  var wr = !1,\n      xr = {};\n  Z.className = \"Model\";\n\n  Z.fromJSON = Z.fromJson = function (a, b) {\n    void 0 === b && (b = null);\n    var c = null;\n    if (\"string\" === typeof a) try {\n      c = x.JSON.parse(a);\n    } catch (f) {} else \"object\" === typeof a ? c = a : C(\"Unable to construct a Model from: \" + a);\n\n    if (null === b) {\n      a = null;\n      var d = c[\"class\"];\n      if (\"string\" === typeof d) try {\n        var e = null;\n        0 === d.indexOf(\"go.\") ? (d = d.substr(3), e = sr(d)) : (e = sr(d), null === e && (e = x[d]));\n        \"function\" === typeof e && (a = new e());\n      } catch (f) {}\n      null === a || a instanceof Z ? b = a : C(\"Unable to construct a Model of declared class: \" + c[\"class\"]);\n    }\n\n    null === b && (b = Z.constructGraphLinksModel());\n    b.Io(c);\n    b.Uu(c);\n    return b;\n  };\n\n  Z.safePropertyValue = nn;\n  Z.safePropertySet = Nj;\n  xr.Brush = ml;\n  xr.ChangedEvent = ce;\n  xr.Geometry = O;\n  xr.Margin = ec;\n  xr.Panel = W;\n  xr.Point = I;\n  xr.Rect = M;\n  xr.Size = K;\n  xr.Spot = N;\n  xr.Transaction = he;\n  xr.UndoManager = ie;\n\n  function wi(a, b, c, d) {\n    Ra(this);\n    this._isFrozen = !1;\n    void 0 === a && (a = \"\");\n    void 0 === b && (b = a);\n    void 0 === c && (c = null);\n    this.j = -1;\n    this.sd = null;\n    this.ml = a;\n    this.ll = this.Wn = 0;\n    this.Zq = null;\n    this.cn = !1;\n    this.hl = b;\n    this.qm = c;\n    void 0 === d ? (this.Uk = yr, this.jk = null) : (this.Uk = fn, this.jk = d);\n    this.Vs = new G();\n  }\n\n  wi.prototype.copy = function () {\n    var a = new wi();\n    a.ml = this.ml;\n    a.Wn = this.Wn;\n    a.ll = this.ll;\n    a.Zq = this.Zq;\n    a.cn = this.cn;\n    a.hl = this.hl;\n    a.qm = this.qm;\n    a.Uk = this.Uk;\n    a.jk = this.jk;\n    return a;\n  };\n\n  t = wi.prototype;\n\n  t.ob = function (a) {\n    a.classType === wi && (this.mode = a);\n  };\n\n  t.toString = function () {\n    return \"Binding(\" + this.targetProperty + \":\" + this.sourceProperty + (-1 !== this.ti ? \" \" + this.ti : \"\") + \" \" + this.mode.name + \")\";\n  };\n\n  t.freeze = function () {\n    this._isFrozen = !0;\n    return this;\n  };\n\n  t.ja = function () {\n    this._isFrozen = !1;\n    return this;\n  };\n\n  t.px = function (a) {\n    void 0 === a && (a = null);\n    this.mode = fn;\n    this.backConverter = a;\n    return this;\n  };\n\n  t.Fo = function (a) {\n    void 0 === a && (a = \"\");\n    this.sourceName = a;\n    this.isToModel = !1;\n    return this;\n  };\n\n  t.Kz = function () {\n    this.sourceName = null;\n    this.isToModel = !0;\n    return this;\n  };\n\n  function fl(a, b, c) {\n    a = a.sourceName;\n    return null === a || \"\" === a ? b : \"/\" === a ? c.part : \".\" === a ? c : \"..\" === a ? c.panel : b.fb(a);\n  }\n\n  t.pv = function (a, b, c) {\n    var d = this.hl;\n\n    if (void 0 === c || \"\" === d || d === c) {\n      c = this.ml;\n      var e = this.qm;\n      if (null === e && \"\" === c) xa(\"Binding error: target property is the empty string: \" + this.toString());else {\n        var f = b;\n        \"\" !== d && (f = nn(b, d));\n        if (void 0 !== f) if (null === e) \"\" !== c && Nj(a, c, f);else try {\n          if (\"\" !== c) {\n            var g = e(f, a);\n            Nj(a, c, g);\n          } else e(f, a);\n        } catch (h) {}\n      }\n    }\n  };\n\n  t.Vo = function (a, b, c, d) {\n    if (this.Uk === fn) {\n      var e = this.ml;\n\n      if (void 0 === c || e === c) {\n        c = this.hl;\n        var f = this.jk,\n            g = a;\n        \"\" !== e && (g = nn(a, e));\n        if (void 0 !== g && !this.Vs.contains(a)) try {\n          this.Vs.add(a);\n          var h = null !== d ? d.diagram : null,\n              k = null !== h ? h.model : null;\n          if (null === f) {\n            if (\"\" !== c) null !== k ? k.setDataProperty(b, c, g) : Nj(b, c, g);else {\n              if (null !== k && null !== d && 0 <= d.itemIndex && null !== d.panel && Array.isArray(d.panel.itemArray)) {\n                var l = d.itemIndex,\n                    m = d.panel.itemArray;\n                k.Xu(m, l);\n                k.Qr(m, l, g);\n              }\n            }\n          } else try {\n            if (\"\" !== c) {\n              var n = f(g, b, k);\n              null !== k ? k.setDataProperty(b, c, n) : Nj(b, c, n);\n            } else {\n              var p = f(g, b, k);\n\n              if (void 0 !== p && null !== k && null !== d && 0 <= d.itemIndex && null !== d.panel && Array.isArray(d.panel.itemArray)) {\n                var r = d.itemIndex,\n                    q = d.panel.itemArray;\n                k.Xu(q, r);\n                k.Qr(q, r, p);\n              }\n            }\n          } catch (u) {}\n        } finally {\n          this.Vs.remove(a);\n        }\n      }\n    }\n  };\n\n  ma.Object.defineProperties(wi.prototype, {\n    ti: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this);\n        this.j = a;\n      }\n    },\n    targetProperty: {\n      get: function get() {\n        return this.ml;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this);\n        this.ml = a;\n      }\n    },\n    sourceName: {\n      get: function get() {\n        return this.Zq;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this);\n        this.Zq = a;\n        null !== a && (this.cn = !1);\n      }\n    },\n    isToModel: {\n      get: function get() {\n        return this.cn;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this);\n        this.cn = a;\n      }\n    },\n    sourceProperty: {\n      get: function get() {\n        return this.hl;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this);\n        this.hl = a;\n      }\n    },\n    converter: {\n      get: function get() {\n        return this.qm;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this);\n        this.qm = a;\n      }\n    },\n    backConverter: {\n      get: function get() {\n        return this.jk;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this);\n        this.jk = a;\n      }\n    },\n    mode: {\n      get: function get() {\n        return this.Uk;\n      },\n      set: function set(a) {\n        this._isFrozen && va(this);\n        this.Uk = a;\n      }\n    }\n  });\n  wi.prototype.updateSource = wi.prototype.Vo;\n  wi.prototype.updateTarget = wi.prototype.pv;\n  wi.prototype.ofModel = wi.prototype.Kz;\n  wi.prototype.ofObject = wi.prototype.Fo;\n  wi.prototype.makeTwoWay = wi.prototype.px;\n  var Ik = \"Binding\",\n      yr = new D(wi, \"OneWay\", 1),\n      fn = new D(wi, \"TwoWay\", 2);\n  wi.className = \"Binding\";\n\n  wi.parseEnum = function (a, b) {\n    return function (c) {\n      c = Sa(a, c);\n      return null === c ? b : c;\n    };\n  };\n\n  wi.toString = Ia;\n  wi.OneWay = yr;\n  wi.TwoWay = fn;\n\n  function zr(a, b, c) {\n    Z.call(this);\n    this.zv = ',\\n  \"insertedLinkKeys\": ';\n    this.Ox = ',\\n  \"modifiedLinkData\": ';\n    this.Bv = ',\\n  \"removedLinkKeys\": ';\n    this.ed = [];\n    this.Rf = new G();\n    this.rb = new pb();\n    this.Bh = \"\";\n    this.Li = this.nk = this.Sk = null;\n    this.Ze = \"from\";\n    this.$e = \"to\";\n    this.aj = this.$i = \"\";\n    this.Zi = \"category\";\n    this.ce = \"\";\n    this.Yk = \"isGroup\";\n    this.ye = \"group\";\n    this.tm = !1;\n    void 0 !== b && (this.linkDataArray = b);\n    void 0 !== a && (za(a) ? this.nodeDataArray = a : Object.assign(this, a));\n    c && Object.assign(this, c);\n  }\n\n  la(zr, Z);\n  zr.constructGraphLinksModel = Z.constructGraphLinksModel;\n\n  zr.prototype.cloneProtected = function (a) {\n    Z.prototype.cloneProtected.call(this, a);\n    a.Bh = this.Bh;\n    a.Sk = this.Sk;\n    a.nk = this.nk;\n    a.Ze = this.Ze;\n    a.$e = this.$e;\n    a.$i = this.$i;\n    a.aj = this.aj;\n    a.Zi = this.Zi;\n    a.ce = this.ce;\n    a.Yk = this.Yk;\n    a.ye = this.ye;\n    a.tm = this.tm;\n  };\n\n  t = zr.prototype;\n\n  t.clear = function () {\n    Z.prototype.clear.call(this);\n    this.ed = [];\n    this.rb.clear();\n    this.Rf.clear();\n  };\n\n  t.toString = function (a) {\n    void 0 === a && (a = 0);\n    if (2 <= a) return this.Qo();\n    var b = (\"\" !== this.name ? this.name : \"\") + \" GraphLinksModel\";\n\n    if (0 < a) {\n      b += \"\\n node data:\";\n      a = this.nodeDataArray;\n      var c = a.length,\n          d;\n\n      for (d = 0; d < c; d++) {\n        var e = a[d];\n        b += \" \" + this.ua(e) + \":\" + Ia(e);\n      }\n\n      b += \"\\n link data:\";\n      a = this.linkDataArray;\n      c = a.length;\n\n      for (d = 0; d < c; d++) {\n        e = a[d], b += \" \" + Vq(this, e, !0) + \"--\\x3e\" + Vq(this, e, !1);\n      }\n    }\n\n    return b;\n  };\n\n  t.uv = function (a, b) {\n    \"\" === this.linkKeyProperty && C(\"GraphLinksModel.linkKeyProperty must not be an empty string for .toIncrementalData() to succeed.\");\n    var c = Z.prototype.uv.call(this, a, b),\n        d = this,\n        e = new G(),\n        f = new G(),\n        g = new G(),\n        h = this.kh;\n    a.changes.each(function (a) {\n      a.model === d && (\"linkDataArray\" === a.modelChange ? a.change === fe ? e.add(a.newValue) : a.change === ge && g.add(a.oldValue) : d.Cc(a.object) ? f.add(a.object) : null !== a.object && (null !== a.object && h && h.contains(a.object) ? h.get(a.object).each(function (a) {\n        d.Cc(a) && f.add(a);\n      }) : a.object instanceof Z || d.lb(a.object) || Ar(d, a.object).each(function (a) {\n        f.add(a);\n      })));\n    });\n    var k = this.Xk;\n    k.clear();\n    e.each(function (a) {\n      k.add(d.uc(a));\n      b || f.add(a);\n    });\n    var l = this.Zk;\n    l.clear();\n    g.each(function (a) {\n      l.add(d.uc(a));\n      b && f.add(a);\n    });\n    a = d.cloneDeep(f.Ea());\n    0 < k.count && (null === c && (c = {}), b ? c.removedLinkKeys = k.Ea() : c.insertedLinkKeys = k.Ea());\n    0 < a.length && (null === c && (c = {}), c.modifiedLinkData = a);\n    0 < l.count && (null === c && (c = {}), b ? c.insertedLinkKeys = l.Ea() : c.removedLinkKeys = l.Ea());\n    l.clear();\n    k.clear();\n    return c;\n  };\n\n  t.am = function () {\n    var a = Z.prototype.am.call(this),\n        b = \"\";\n    \"category\" !== this.linkCategoryProperty && \"string\" === typeof this.linkCategoryProperty && (b += ',\\n  \"linkCategoryProperty\": ' + this.quote(this.linkCategoryProperty));\n    \"\" !== this.linkKeyProperty && \"string\" === typeof this.linkKeyProperty && (b += ',\\n  \"linkKeyProperty\": ' + this.quote(this.linkKeyProperty));\n    \"from\" !== this.linkFromKeyProperty && \"string\" === typeof this.linkFromKeyProperty && (b += ',\\n  \"linkFromKeyProperty\": ' + this.quote(this.linkFromKeyProperty));\n    \"to\" !== this.linkToKeyProperty && \"string\" === typeof this.linkToKeyProperty && (b += ',\\n  \"linkToKeyProperty\": ' + this.quote(this.linkToKeyProperty));\n    \"\" !== this.linkFromPortIdProperty && \"string\" === typeof this.linkFromPortIdProperty && (b += ',\\n  \"linkFromPortIdProperty\": ' + this.quote(this.linkFromPortIdProperty));\n    \"\" !== this.linkToPortIdProperty && \"string\" === typeof this.linkToPortIdProperty && (b += ',\\n  \"linkToPortIdProperty\": ' + this.quote(this.linkToPortIdProperty));\n    \"\" !== this.linkLabelKeysProperty && \"string\" === typeof this.linkLabelKeysProperty && (b += ',\\n  \"linkLabelKeysProperty\": ' + this.quote(this.linkLabelKeysProperty));\n    \"isGroup\" !== this.nodeIsGroupProperty && \"string\" === typeof this.nodeIsGroupProperty && (b += ',\\n  \"nodeIsGroupProperty\": ' + this.quote(this.nodeIsGroupProperty));\n    \"group\" !== this.nodeGroupKeyProperty && \"string\" === typeof this.nodeGroupKeyProperty && (b += ',\\n  \"nodeGroupKeyProperty\": ' + this.quote(this.nodeGroupKeyProperty));\n    return a + b;\n  };\n\n  t.Io = function (a) {\n    Z.prototype.Io.call(this, a);\n    a.linkKeyProperty && (this.linkKeyProperty = a.linkKeyProperty);\n    a.linkFromKeyProperty && (this.linkFromKeyProperty = a.linkFromKeyProperty);\n    a.linkToKeyProperty && (this.linkToKeyProperty = a.linkToKeyProperty);\n    a.linkFromPortIdProperty && (this.linkFromPortIdProperty = a.linkFromPortIdProperty);\n    a.linkToPortIdProperty && (this.linkToPortIdProperty = a.linkToPortIdProperty);\n    a.linkCategoryProperty && (this.linkCategoryProperty = a.linkCategoryProperty);\n    a.linkLabelKeysProperty && (this.linkLabelKeysProperty = a.linkLabelKeysProperty);\n    a.nodeIsGroupProperty && (this.nodeIsGroupProperty = a.nodeIsGroupProperty);\n    a.nodeGroupKeyProperty && (this.nodeGroupKeyProperty = a.nodeGroupKeyProperty);\n  };\n\n  t.vv = function () {\n    var a = Z.prototype.vv.call(this),\n        b = ',\\n  \"linkDataArray\": ' + mr(this, this.linkDataArray, !0);\n    return a + b;\n  };\n\n  t.Uu = function (a) {\n    Z.prototype.Uu.call(this, a);\n    a = a.linkDataArray;\n    Array.isArray(a) && (this.Ll(a), this.linkDataArray = a);\n  };\n\n  function Ar(a, b) {\n    for (var c = new G(), d = 0; d < a.linkDataArray.length; d++) {\n      var e = a.linkDataArray[d];\n      nr(a, b, e, e, c);\n    }\n\n    return c;\n  }\n\n  t.tv = function (a, b) {\n    \"\" === this.linkKeyProperty && C(\"GraphLinksModel.linkKeyProperty must not be an empty string for .toIncrementalJson() to succeed.\");\n    var c = Z.prototype.tv.call(this, a, b),\n        d = this,\n        e = new G(),\n        f = new G(),\n        g = new G(),\n        h = this.kh;\n    a.changes.each(function (a) {\n      a.model === d && (\"linkDataArray\" === a.modelChange ? a.change === fe ? e.add(a.newValue) : a.change === ge && g.add(a.oldValue) : d.Cc(a.object) ? f.add(a.object) : null !== a.object && (null !== a.object && h && h.contains(a.object) ? h.get(a.object).each(function (a) {\n        d.Cc(a) && f.add(a);\n      }) : a.object instanceof Z || d.lb(a.object) || Ar(d, a.object).each(function (a) {\n        f.add(a);\n      })));\n    });\n    var k = this.Xk;\n    k.clear();\n    e.each(function (a) {\n      k.add(d.uc(a));\n      b || f.add(a);\n    });\n    var l = this.Zk;\n    l.clear();\n    g.each(function (a) {\n      l.add(d.uc(a));\n      b && f.add(a);\n    });\n    a = c;\n    0 < k.count && (a += (b ? this.Bv : this.zv) + mr(this, k.Ea(), !0));\n    0 < f.count && (a += this.Ox + mr(this, f.Ea(), !0));\n    0 < l.count && (a += (b ? this.zv : this.Bv) + mr(this, l.Ea(), !0));\n    l.clear();\n    k.clear();\n    return a;\n  };\n\n  t.Ho = function (a) {\n    (void 0 !== a.linkCategoryProperty && a.linkCategoryProperty !== this.linkCategoryProperty || void 0 !== a.linkKeyProperty && a.linkKeyProperty !== this.linkKeyProperty || void 0 !== a.linkFromKeyProperty && a.linkFromKeyProperty !== this.linkFromKeyProperty || void 0 !== a.linkToKeyProperty && a.linkToKeyProperty !== this.linkToKeyProperty || void 0 !== a.linkFromPortIdProperty && a.linkFromPortIdProperty !== this.linkFromPortIdProperty || void 0 !== a.linkToPortIdProperty && a.linkToPortIdProperty !== this.linkToPortIdProperty || void 0 !== a.linkLabelKeysProperty && a.linkLabelKeysProperty !== this.linkLabelKeysProperty || void 0 !== a.nodeIsGroupProperty && a.nodeIsGroupProperty !== this.nodeIsGroupProperty || void 0 !== a.nodeGroupKeyProperty && a.nodeGroupKeyProperty !== this.nodeGroupKeyProperty) && C(\"applyIncrementalJson cannot change Model properties\");\n    Z.prototype.Ho.call(this, a);\n    var b = a.insertedLinkKeys;\n    if (Array.isArray(b)) for (var c = b.length, d = 0; d < c; d++) {\n      var e = b[d],\n          f = this.Zg(e);\n      null === f && (f = this.no({}), this.ks(f, e), this.Yh(f));\n    }\n    b = a.modifiedLinkData;\n    if (Array.isArray(b)) for (c = b.length, d = 0; d < c; d++) {\n      if (e = b[d], f = this.uc(e), f = this.Zg(f), null !== f) {\n        for (var g in e) {\n          \"__gohashid\" !== g && g !== this.linkKeyProperty && this.setDataProperty(f, g, e[g]);\n        }\n\n        Br(this, e, f);\n      }\n    }\n    a = a.removedLinkKeys;\n    if (Array.isArray(a)) for (g = a.length, b = 0; b < g; b++) {\n      c = this.Zg(a[b]), null !== c && this.Jl(c);\n    }\n  };\n\n  zr.prototype.changeState = function (a, b) {\n    if (null !== a && a.model === this) {\n      if (a.change === de) {\n        var c = a.object,\n            d = a.propertyName;\n\n        if (d === this.linkKeyProperty && this.Cc(c)) {\n          var e = a.I(b);\n          b = a.I(!b);\n          void 0 !== b && this.rb.remove(b);\n          void 0 !== e && this.rb.add(e, c);\n          Nj(c, d, e);\n          return;\n        }\n      } else if (a.change === fe) {\n        c = a.newParam;\n\n        if (\"linkDataArray\" === a.modelChange) {\n          a = a.newValue;\n          ya(a) && \"number\" === typeof c && (d = this.uc(a), b ? (this.Rf.remove(a), this.ed[c] === a && this.ed.splice(c, 1), void 0 !== d && this.rb.remove(d)) : (this.Rf.add(a), this.ed[c] !== a && this.ed.splice(c, 0, a), void 0 !== d && this.rb.add(d, a)));\n          return;\n        }\n\n        if (\"linkLabelKeys\" === a.modelChange) {\n          d = this.vf(a.object);\n          Array.isArray(d) && \"number\" === typeof c && (b ? (c = d.indexOf(a.newValue), 0 <= c && d.splice(c, 1)) : 0 > d.indexOf(a.newValue) && d.splice(c, 0, a.newValue));\n          return;\n        }\n      } else if (a.change === ge) {\n        c = a.oldParam;\n\n        if (\"linkDataArray\" === a.modelChange) {\n          a = a.oldValue;\n          ya(a) && \"number\" === typeof c && (d = this.uc(a), b ? (this.Rf.add(a), this.ed[c] !== a && this.ed.splice(c, 0, a), void 0 !== d && this.rb.add(d, a)) : (this.Rf.remove(a), this.ed[c] === a && this.ed.splice(c, 1), void 0 !== d && this.rb.remove(d)));\n          return;\n        }\n\n        if (\"linkLabelKeys\" === a.modelChange) {\n          d = this.vf(a.object);\n          Array.isArray(d) && \"number\" === typeof c && (b ? 0 > d.indexOf(a.newValue) && d.splice(c, 0, a.newValue) : (c = d.indexOf(a.newValue), 0 <= c && d.splice(c, 1)));\n          return;\n        }\n      }\n\n      Z.prototype.changeState.call(this, a, b);\n    }\n  };\n\n  t = zr.prototype;\n\n  t.Dl = function (a) {\n    if (void 0 !== a) {\n      var b = this.Li;\n\n      if (null !== b) {\n        var c = this.dc(a);\n        null === c && (c = this.copyNodeData(b), Nj(c, this.nodeKeyProperty, a), this.lf(c));\n      }\n\n      return a;\n    }\n  };\n\n  t.$w = function (a) {\n    return Vq(this, a, !0);\n  };\n\n  t.cv = function (a, b) {\n    cr(this, a, b, !0);\n  };\n\n  t.ex = function (a) {\n    return Vq(this, a, !1);\n  };\n\n  t.gv = function (a, b) {\n    cr(this, a, b, !1);\n  };\n\n  function Vq(a, b, c) {\n    if (null !== b && (a = c ? a.Ze : a.$e, \"\" !== a && (a = nn(b, a), void 0 !== a))) {\n      if (Xq(a)) return a;\n      C((c ? \"FromKey\" : \"ToKey\") + \" value for link data \" + b + \" is not a number or a string: \" + a);\n    }\n  }\n\n  function cr(a, b, c, d) {\n    null === c && (c = void 0);\n\n    if (null !== b) {\n      var e = d ? a.Ze : a.$e;\n      if (\"\" !== e) if (c = a.Dl(c), a.Cc(b)) {\n        var f = nn(b, e);\n        f !== c && (ar(a, f, b), Nj(b, e, c), null === a.dc(c) && br(a, c, b), tr(a, d ? \"linkFromKey\" : \"linkToKey\", de, e, b, f, c), \"string\" === typeof e && a.Ka(b, e));\n      } else Nj(b, e, c);\n    }\n  }\n\n  t.ax = function (a) {\n    return Uq(this, a, !0);\n  };\n\n  t.dv = function (a, b) {\n    dr(this, a, b, !0);\n  };\n\n  t.gx = function (a) {\n    return Uq(this, a, !1);\n  };\n\n  t.hv = function (a, b) {\n    dr(this, a, b, !1);\n  };\n\n  function Uq(a, b, c) {\n    if (null === b) return \"\";\n    a = c ? a.$i : a.aj;\n    if (\"\" === a) return \"\";\n    b = nn(b, a);\n    return void 0 === b ? \"\" : b;\n  }\n\n  function dr(a, b, c, d) {\n    if (null !== b) {\n      var e = d ? a.$i : a.aj;\n      if (\"\" !== e) if (a.Cc(b)) {\n        var f = nn(b, e);\n        void 0 === f && (f = \"\");\n        f !== c && (Nj(b, e, c), tr(a, d ? \"linkFromPortId\" : \"linkToPortId\", de, e, b, f, c), \"string\" === typeof e && a.Ka(b, e));\n      } else Nj(b, e, c);\n    }\n  }\n\n  t.vf = function (a) {\n    if (null === a) return Cr;\n    var b = this.ce;\n    if (\"\" === b) return Cr;\n    a = nn(a, b);\n    return void 0 === a ? Cr : a;\n  };\n\n  t.ls = function (a, b) {\n    if (null !== a) {\n      var c = this.ce;\n      if (\"\" !== c) if (this.Cc(a)) {\n        var d = nn(a, c);\n        void 0 === d && (d = Cr);\n\n        if (d !== b) {\n          if (Array.isArray(d)) for (var e = d.length, f = 0; f < e; f++) {\n            ar(this, d[f], a);\n          }\n          Nj(a, c, b);\n          e = b.length;\n\n          for (f = 0; f < e; f++) {\n            var g = b[f];\n            null === this.dc(g) && br(this, g, a);\n          }\n\n          tr(this, \"linkLabelKeys\", de, c, a, d, b);\n          \"string\" === typeof c && this.Ka(a, c);\n        }\n      } else Nj(a, c, b);\n    }\n  };\n\n  t.hu = function (a, b) {\n    if (null !== b && void 0 !== b && null !== a) {\n      var c = this.ce;\n\n      if (\"\" !== c) {\n        var d = nn(a, c);\n        if (void 0 === d) c = [], c.push(b), this.ls(a, c);else if (Array.isArray(d)) {\n          var e = d.indexOf(b);\n          0 <= e || (e = d.length, d.push(b), this.Cc(a) && (null === this.dc(b) && br(this, b, a), tr(this, \"linkLabelKeys\", fe, c, a, null, b, null, e)));\n        } else C(c + \" property is not an Array; cannot addLabelKeyForLinkData: \" + a);\n      }\n    }\n  };\n\n  t.xx = function (a, b) {\n    if (null !== b && void 0 !== b && null !== a) {\n      var c = this.ce;\n\n      if (\"\" !== c) {\n        var d = nn(a, c);\n\n        if (Array.isArray(d)) {\n          var e = d.indexOf(b);\n          0 > e || (d.splice(e, 1), this.Cc(a) && (ar(this, b, a), tr(this, \"linkLabelKeys\", ge, c, a, b, null, e, null)));\n        } else void 0 !== d && C(c + \" property is not an Array; cannot removeLabelKeyforLinkData: \" + a);\n      }\n    }\n  };\n\n  t.uc = function (a) {\n    if (null !== a) {\n      var b = this.Bh;\n\n      if (\"\" !== b && (b = nn(a, b), void 0 !== b)) {\n        if (Xq(b)) return b;\n        C(\"Key value for link data \" + a + \" is not a number or a string: \" + b);\n      }\n    }\n  };\n\n  t.ks = function (a, b) {\n    if (null !== a) {\n      var c = this.Bh;\n      if (\"\" !== c) if (this.Cc(a)) {\n        var d = nn(a, c);\n        d !== b && null === this.Zg(b) && (Nj(a, c, b), void 0 !== d && this.rb.remove(d), this.rb.add(b, a), tr(this, \"linkKey\", de, c, a, d, b), \"string\" === typeof c && this.Ka(a, c));\n      } else Nj(a, c, b);\n    }\n  };\n\n  t.Zg = function (a) {\n    null === a && C(\"GraphLinksModel.findLinkDataForKey:key must not be null\");\n    return void 0 !== a && Xq(a) ? this.rb.I(a) : null;\n  };\n\n  t.$r = function (a) {\n    if (null !== a) {\n      var b = this.Bh;\n\n      if (\"\" !== b) {\n        var c = this.uc(a);\n\n        if (void 0 === c || this.rb.contains(c)) {\n          var d = this.Sk;\n\n          if (null !== d && (c = d(this, a), void 0 !== c && null !== c && !this.rb.contains(c))) {\n            Nj(a, b, c);\n            return;\n          }\n\n          if (\"string\" === typeof c) {\n            for (d = 2; this.rb.contains(c + d);) {\n              d++;\n            }\n\n            Nj(a, b, c + d);\n          } else if (void 0 === c || \"number\" === typeof c) {\n            for (c = -this.rb.count - 1; this.rb.contains(c);) {\n              c--;\n            }\n\n            Nj(a, b, c);\n          }\n        }\n      }\n    }\n  };\n\n  t.Cc = function (a) {\n    return null === a ? !1 : this.Rf.contains(a);\n  };\n\n  t.Yh = function (a) {\n    null !== a && (gb(a), this.Cc(a) || Zq(this, a, !0));\n  };\n\n  function Zq(a, b, c) {\n    if (\"\" !== a.linkKeyProperty) {\n      var d = a.uc(b);\n      if (void 0 !== d && a.rb.I(d) === b) return;\n      a.$r(b);\n      d = a.uc(b);\n      void 0 === d && C(\"GraphLinksModel.makeLinkDataKeyUnique failed on \" + b + \". Data not added to model.\");\n      a.rb.add(d, b);\n    }\n\n    a.Rf.add(b);\n    d = null;\n    c && (d = a.ed.length, a.ed.splice(d, 0, b));\n    tr(a, \"linkDataArray\", fe, \"linkDataArray\", a, null, b, null, d);\n    Dr(a, b);\n  }\n\n  t.ly = function (a) {\n    if (Array.isArray(a)) for (var b = a.length, c = 0; c < b; c++) {\n      this.Yh(a[c]);\n    } else for (a = a.iterator; a.next();) {\n      this.Yh(a.value);\n    }\n  };\n\n  t.Jl = function (a) {\n    null !== a && Yq(this, a, !0);\n  };\n\n  function Yq(a, b, c) {\n    a.Rf.remove(b);\n    var d = a.uc(b);\n    void 0 !== d && a.rb.remove(d);\n    d = null;\n\n    if (c) {\n      d = a.ed.indexOf(b);\n      if (0 > d) return;\n      a.ed.splice(d, 1);\n    }\n\n    tr(a, \"linkDataArray\", ge, \"linkDataArray\", a, b, null, d, null);\n    c = Vq(a, b, !0);\n    ar(a, c, b);\n    c = Vq(a, b, !1);\n    ar(a, c, b);\n    d = a.vf(b);\n    if (Array.isArray(d)) for (var e = d.length, f = 0; f < e; f++) {\n      c = d[f], ar(a, c, b);\n    }\n  }\n\n  t.Sz = function (a) {\n    if (Array.isArray(a)) for (var b = a.length, c = 0; c < b; c++) {\n      this.Jl(a[c]);\n    } else for (a = a.iterator; a.next();) {\n      this.Jl(a.value);\n    }\n  };\n\n  t.Gz = function (a) {\n    \"\" === this.linkKeyProperty && C(\"GraphLinksModel.linkKeyProperty must not be an empty string for .mergeLinkDataArray() to succeed.\");\n\n    if (a !== this.linkDataArray && za(a)) {\n      var b = this.Zk;\n      b.clear();\n      b.addAll(this.rb.iteratorKeys);\n      var c = this.Xk;\n      c.clear();\n\n      for (var d = a.length, e = 0; e < d; e++) {\n        var f = a[e],\n            g = this.uc(f);\n\n        if (void 0 !== g) {\n          c.add(g);\n          var h = this.Zg(g);\n          h !== f && (null !== h ? (this.ho(h, f), Br(this, f, h)) : (f = this.cloneDeep(f), this.ks(f, g), this.Yh(f)));\n        } else g = this.cloneDeep(f), this.Yh(g), c.add(this.uc(g));\n      }\n\n      for (a = b.iterator; a.next();) {\n        d = a.value, c.contains(d) || (d = this.Zg(d)) && this.Jl(d);\n      }\n\n      b.clear();\n      c.clear();\n    }\n  };\n\n  function Dr(a, b) {\n    var c = Vq(a, b, !0);\n    c = a.Dl(c);\n    null === a.dc(c) && br(a, c, b);\n    c = Vq(a, b, !1);\n    c = a.Dl(c);\n    null === a.dc(c) && br(a, c, b);\n    var d = a.vf(b);\n    if (Array.isArray(d)) for (var e = d.length, f = 0; f < e; f++) {\n      c = d[f], null === a.dc(c) && br(a, c, b);\n    }\n  }\n\n  t.no = function (a) {\n    if (null === a) return null;\n    var b = this.nk;\n    a = null !== b ? b(a, this) : vr(this, a, !0);\n    ya(a) && (Ra(a), \"\" !== this.Ze && Nj(a, this.Ze, void 0), \"\" !== this.$e && Nj(a, this.$e, void 0), \"\" !== this.ce && Nj(a, this.ce, []));\n    return a;\n  };\n\n  t.Ku = function (a) {\n    if (null === a) return !1;\n    var b = this.Yk;\n    return \"\" === b ? !1 : nn(a, b) ? !0 : !1;\n  };\n\n  t.ah = function (a) {\n    if (null !== a) {\n      var b = this.ye;\n\n      if (\"\" !== b && (b = nn(a, b), void 0 !== b)) {\n        if (Xq(b)) return b;\n        C(\"GroupKey value for node data \" + a + \" is not a number or a string: \" + b);\n      }\n    }\n  };\n\n  t.Po = function (a, b) {\n    null === b && (b = void 0);\n\n    if (null !== a) {\n      var c = this.ye;\n      if (\"\" !== c) if (this.lb(a)) {\n        var d = nn(a, c);\n        d !== b && (ar(this, d, a), Nj(a, c, b), null === this.dc(b) && br(this, b, a), tr(this, \"nodeGroupKey\", de, c, a, d, b), \"string\" === typeof c && this.Ka(a, c));\n      } else Nj(a, c, b);\n    }\n  };\n\n  zr.prototype.copyNodeData = function (a) {\n    if (null === a) return null;\n    a = Z.prototype.copyNodeData.call(this, a);\n    this.Cj || \"\" === this.ye || void 0 === nn(a, this.ye) || Nj(a, this.ye, void 0);\n    return a;\n  };\n\n  zr.prototype.setDataProperty = function (a, b, c) {\n    if (this.lb(a)) {\n      if (b === this.nodeKeyProperty) {\n        this.Sl(a, c);\n        return;\n      }\n\n      if (b === this.nodeCategoryProperty) {\n        this.Rl(a, c);\n        return;\n      }\n\n      if (b === this.nodeGroupKeyProperty) {\n        this.Po(a, c);\n        return;\n      }\n    } else if (this.Cc(a)) {\n      if (b === this.linkFromKeyProperty) {\n        cr(this, a, c, !0);\n        return;\n      }\n\n      if (b === this.linkToKeyProperty) {\n        cr(this, a, c, !1);\n        return;\n      }\n\n      if (b === this.linkFromPortIdProperty) {\n        dr(this, a, c, !0);\n        return;\n      }\n\n      if (b === this.linkToPortIdProperty) {\n        dr(this, a, c, !1);\n        return;\n      }\n\n      if (b === this.linkKeyProperty) {\n        this.ks(a, c);\n        return;\n      }\n\n      if (b === this.linkCategoryProperty) {\n        this.Oo(a, c);\n        return;\n      }\n\n      if (b === this.linkLabelKeysProperty) {\n        this.ls(a, c);\n        return;\n      }\n    }\n\n    var d = nn(a, b);\n    d !== c && (Nj(a, b, c), this.fs(a, b, d, c));\n  };\n\n  t = zr.prototype;\n\n  t.ho = function (a, b) {\n    if (b) {\n      var c = this.lb(a),\n          d = this.Cc(a),\n          e;\n\n      for (e in b) {\n        \"__gohashid\" === e || c && e === this.nodeKeyProperty || c && e === this.nodeIsGroupProperty && nn(a, e) === b[e] || d && e === this.linkKeyProperty || this.setDataProperty(a, e, b[e]);\n      }\n    }\n  };\n\n  t.Mo = function (a, b) {\n    Z.prototype.Mo.call(this, a, b);\n\n    for (var c = this.kb.iterator; c.next();) {\n      this.Zu(c.value, a, b);\n    }\n\n    for (c = this.Rf.iterator; c.next();) {\n      var d = c.value,\n          e = a,\n          f = b;\n\n      if (Vq(this, d, !0) === e) {\n        var g = this.Ze;\n        Nj(d, g, f);\n        tr(this, \"linkFromKey\", de, g, d, e, f);\n        \"string\" === typeof g && this.Ka(d, g);\n      }\n\n      Vq(this, d, !1) === e && (g = this.$e, Nj(d, g, f), tr(this, \"linkToKey\", de, g, d, e, f), \"string\" === typeof g && this.Ka(d, g));\n      g = this.vf(d);\n      if (Array.isArray(g)) for (var h = g.length, k = this.ce, l = 0; l < h; l++) {\n        g[l] === e && (g[l] = f, tr(this, \"linkLabelKeys\", fe, k, d, e, f, l, l));\n      }\n    }\n  };\n\n  t.Zu = function (a, b, c) {\n    if (this.ah(a) === b) {\n      var d = this.ye;\n      Nj(a, d, c);\n      tr(this, \"nodeGroupKey\", de, d, a, b, c);\n      \"string\" === typeof d && this.Ka(a, d);\n    }\n  };\n\n  t.ov = function () {\n    Z.prototype.ov.call(this);\n\n    for (var a = this.linkDataArray, b = a.length, c = 0; c < b; c++) {\n      Dr(this, a[c]);\n    }\n  };\n\n  t.Nl = function (a) {\n    Z.prototype.Nl.call(this, a);\n    a = this.ua(a);\n    var b = $q(this, a);\n\n    if (null !== b) {\n      var c = Ea();\n\n      for (b = b.iterator; b.next();) {\n        var d = b.value;\n\n        if (this.lb(d)) {\n          if (this.ah(d) === a) {\n            var e = this.ye;\n            tr(this, \"nodeGroupKey\", de, e, d, a, a);\n            \"string\" === typeof e && this.Ka(d, e);\n            c.push(d);\n          }\n        } else if (Vq(this, d, !0) === a && (e = this.Ze, tr(this, \"linkFromKey\", de, e, d, a, a), \"string\" === typeof e && this.Ka(d, e), c.push(d)), Vq(this, d, !1) === a && (e = this.$e, tr(this, \"linkToKey\", de, e, d, a, a), \"string\" === typeof e && this.Ka(d, e), c.push(d)), e = this.vf(d), Array.isArray(e)) for (var f = e.length, g = this.ce, h = 0; h < f; h++) {\n          e[h] === a && (tr(this, \"linkLabelKeys\", fe, g, d, a, a, h, h), c.push(d));\n        }\n      }\n\n      for (b = 0; b < c.length; b++) {\n        ar(this, a, c[b]);\n      }\n\n      Ga(c);\n    }\n  };\n\n  t.Ml = function (a) {\n    Z.prototype.Ml.call(this, a);\n    var b = this.ah(a);\n    null === this.dc(b) && br(this, b, a);\n  };\n\n  t.To = function (a) {\n    Z.prototype.To.call(this, a);\n    var b = this.ah(a);\n    ar(this, b, a);\n  };\n\n  t.Mr = function (a) {\n    if (null === a) return \"\";\n    var b = this.Zi;\n    if (\"\" === b) return \"\";\n    b = nn(a, b);\n    if (void 0 === b) return \"\";\n    if (\"string\" === typeof b) return b;\n    C(\"getCategoryForLinkData found a non-string category for \" + a + \": \" + b);\n  };\n\n  zr.prototype.getLinkCategoryForData = function (a) {\n    return this.Mr(a);\n  };\n\n  zr.prototype.Oo = function (a, b) {\n    if (null !== a) {\n      var c = this.Zi;\n      if (\"\" !== c) if (this.Cc(a)) {\n        var d = nn(a, c);\n        void 0 === d && (d = \"\");\n        d !== b && (Nj(a, c, b), tr(this, \"linkCategory\", de, c, a, d, b), \"string\" === typeof c && this.Ka(a, c));\n      } else Nj(a, c, b);\n    }\n  };\n\n  zr.prototype.setLinkCategoryForData = function (a, b) {\n    this.Oo(a, b);\n  };\n\n  t = zr.prototype;\n\n  t.Tl = function (a, b) {\n    Z.prototype.Tl.call(this, a, b);\n    this.Po(b, this.ah(a));\n  };\n\n  function Br(a, b, c) {\n    a.Oo(c, a.Mr(b));\n    a.cv(c, a.$w(b));\n    a.gv(c, a.ex(b));\n    a.ls(c, a.vf(b));\n    a.dv(c, a.ax(b));\n    a.hv(c, a.gx(b));\n  }\n\n  t.Nj = function () {\n    return !0;\n  };\n\n  t.ki = function () {\n    return !0;\n  };\n\n  t.Vr = function () {\n    return !0;\n  };\n\n  t.Oj = function () {\n    return !0;\n  };\n\n  ma.Object.defineProperties(zr.prototype, {\n    archetypeNodeData: {\n      get: function get() {\n        return this.Li;\n      },\n      set: function set(a) {\n        var b = this.Li;\n        b !== a && (this.Li = a, this.g(\"archetypeNodeData\", b, a));\n      }\n    },\n    linkFromKeyProperty: {\n      get: function get() {\n        return this.Ze;\n      },\n      set: function set(a) {\n        var b = this.Ze;\n        b !== a && (this.Ze = a, this.g(\"linkFromKeyProperty\", b, a));\n      }\n    },\n    linkToKeyProperty: {\n      get: function get() {\n        return this.$e;\n      },\n      set: function set(a) {\n        var b = this.$e;\n        b !== a && (this.$e = a, this.g(\"linkToKeyProperty\", b, a));\n      }\n    },\n    linkFromPortIdProperty: {\n      get: function get() {\n        return this.$i;\n      },\n      set: function set(a) {\n        var b = this.$i;\n        b !== a && (this.$i = a, this.g(\"linkFromPortIdProperty\", b, a));\n      }\n    },\n    linkToPortIdProperty: {\n      get: function get() {\n        return this.aj;\n      },\n      set: function set(a) {\n        var b = this.aj;\n        b !== a && (this.aj = a, this.g(\"linkToPortIdProperty\", b, a));\n      }\n    },\n    linkLabelKeysProperty: {\n      get: function get() {\n        return this.ce;\n      },\n      set: function set(a) {\n        var b = this.ce;\n        b !== a && (this.ce = a, this.g(\"linkLabelKeysProperty\", b, a));\n      }\n    },\n    linkDataArray: {\n      get: function get() {\n        return this.ed;\n      },\n      set: function set(a) {\n        var b = this.ed;\n\n        if (b !== a) {\n          this.rb.clear();\n\n          for (var c = a.length, d = 0; d < c; d++) {\n            var e = a[d];\n            ya(e) || C(\"GraphLinksModel.linkDataArray must only contain Objects, not: \" + e);\n            gb(e);\n          }\n\n          this.ed = a;\n\n          if (\"\" !== this.linkKeyProperty) {\n            d = new E();\n\n            for (e = 0; e < c; e++) {\n              var f = a[e],\n                  g = this.uc(f);\n              void 0 === g ? d.add(f) : null !== this.rb.I(g) ? d.add(f) : this.rb.add(g, f);\n            }\n\n            for (d = d.iterator; d.next();) {\n              e = d.value, this.$r(e), f = this.uc(e), void 0 !== f && this.rb.add(f, e);\n            }\n          }\n\n          d = new G();\n\n          for (e = 0; e < c; e++) {\n            d.add(a[e]);\n          }\n\n          this.Rf = d;\n          tr(this, \"linkDataArray\", de, \"linkDataArray\", this, b, a);\n\n          for (b = 0; b < c; b++) {\n            Dr(this, a[b]);\n          }\n        }\n      }\n    },\n    linkKeyProperty: {\n      get: function get() {\n        return this.Bh;\n      },\n      set: function set(a) {\n        var b = this.Bh;\n\n        if (b !== a) {\n          this.Bh = a;\n          this.rb.clear();\n\n          for (var c = this.linkDataArray.length, d = 0; d < c; d++) {\n            var e = this.linkDataArray[d],\n                f = this.uc(e);\n            void 0 === f && (this.$r(e), f = this.uc(e));\n            void 0 !== f && this.rb.add(f, e);\n          }\n\n          this.g(\"linkKeyProperty\", b, a);\n        }\n      }\n    },\n    makeUniqueLinkKeyFunction: {\n      get: function get() {\n        return this.Sk;\n      },\n      set: function set(a) {\n        var b = this.Sk;\n        b !== a && (this.Sk = a, this.g(\"makeUniqueLinkKeyFunction\", b, a));\n      }\n    },\n    copyLinkDataFunction: {\n      get: function get() {\n        return this.nk;\n      },\n      set: function set(a) {\n        var b = this.nk;\n        b !== a && (this.nk = a, this.g(\"copyLinkDataFunction\", b, a));\n      }\n    },\n    nodeIsGroupProperty: {\n      get: function get() {\n        return this.Yk;\n      },\n      set: function set(a) {\n        var b = this.Yk;\n        b !== a && (this.Yk = a, this.g(\"nodeIsGroupProperty\", b, a));\n      }\n    },\n    nodeGroupKeyProperty: {\n      get: function get() {\n        return this.ye;\n      },\n      set: function set(a) {\n        var b = this.ye;\n        b !== a && (this.ye = a, this.g(\"nodeGroupKeyProperty\", b, a));\n      }\n    },\n    Cj: {\n      get: function get() {\n        return this.tm;\n      },\n      set: function set(a) {\n        this.tm !== a && (this.tm = a);\n      }\n    },\n    linkCategoryProperty: {\n      get: function get() {\n        return this.Zi;\n      },\n      set: function set(a) {\n        var b = this.Zi;\n        b !== a && (this.Zi = a, this.g(\"linkCategoryProperty\", b, a));\n      }\n    },\n    type: {\n      get: function get() {\n        return \"GraphLinksModel\";\n      }\n    }\n  });\n  zr.prototype.setCategoryForLinkData = zr.prototype.Oo;\n  zr.prototype.getCategoryForLinkData = zr.prototype.Mr;\n  zr.prototype.assignAllDataProperties = zr.prototype.ho;\n  zr.prototype.setGroupKeyForNodeData = zr.prototype.Po;\n  zr.prototype.getGroupKeyForNodeData = zr.prototype.ah;\n  zr.prototype.isGroupForNodeData = zr.prototype.Ku;\n  zr.prototype.copyLinkData = zr.prototype.no;\n  zr.prototype.mergeLinkDataArray = zr.prototype.Gz;\n  zr.prototype.removeLinkDataCollection = zr.prototype.Sz;\n  zr.prototype.removeLinkData = zr.prototype.Jl;\n  zr.prototype.addLinkDataCollection = zr.prototype.ly;\n  zr.prototype.addLinkData = zr.prototype.Yh;\n  zr.prototype.containsLinkData = zr.prototype.Cc;\n  zr.prototype.makeLinkDataKeyUnique = zr.prototype.$r;\n  zr.prototype.findLinkDataForKey = zr.prototype.Zg;\n  zr.prototype.setKeyForLinkData = zr.prototype.ks;\n  zr.prototype.getKeyForLinkData = zr.prototype.uc;\n  zr.prototype.removeLabelKeyForLinkData = zr.prototype.xx;\n  zr.prototype.addLabelKeyForLinkData = zr.prototype.hu;\n  zr.prototype.setLabelKeysForLinkData = zr.prototype.ls;\n  zr.prototype.getLabelKeysForLinkData = zr.prototype.vf;\n  zr.prototype.setToPortIdForLinkData = zr.prototype.hv;\n  zr.prototype.getToPortIdForLinkData = zr.prototype.gx;\n  zr.prototype.setFromPortIdForLinkData = zr.prototype.dv;\n  zr.prototype.getFromPortIdForLinkData = zr.prototype.ax;\n  zr.prototype.setToKeyForLinkData = zr.prototype.gv;\n  zr.prototype.getToKeyForLinkData = zr.prototype.ex;\n  zr.prototype.setFromKeyForLinkData = zr.prototype.cv;\n  zr.prototype.getFromKeyForLinkData = zr.prototype.$w;\n  zr.prototype.clear = zr.prototype.clear;\n  var Cr = Object.freeze([]);\n  zr.className = \"GraphLinksModel\";\n  xr.GraphLinksModel = zr;\n\n  Z.constructGraphLinksModel = Z.constructGraphLinksModel = function () {\n    return new zr();\n  };\n\n  Z.initDiagramModel = oi = function oi() {\n    return new zr();\n  };\n\n  function Er(a, b) {\n    Z.call(this);\n    this.ze = \"parent\";\n    this.vm = !1;\n    this.ij = \"parentLinkCategory\";\n    void 0 !== a && (za(a) ? this.nodeDataArray = a : Object.assign(this, a));\n    b && Object.assign(this, b);\n  }\n\n  la(Er, Z);\n  Er.constructGraphLinksModel = Z.constructGraphLinksModel;\n\n  Er.prototype.cloneProtected = function (a) {\n    Z.prototype.cloneProtected.call(this, a);\n    a.ze = this.ze;\n    a.vm = this.vm;\n    a.ij = this.ij;\n  };\n\n  t = Er.prototype;\n\n  t.toString = function (a) {\n    void 0 === a && (a = 0);\n    if (2 <= a) return this.Qo();\n    var b = (\"\" !== this.name ? this.name : \"\") + \" TreeModel\";\n\n    if (0 < a) {\n      b += \"\\n node data:\";\n      a = this.nodeDataArray;\n\n      for (var c = a.length, d = 0; d < c; d++) {\n        var e = a[d];\n        b += \" \" + this.ua(e) + \":\" + Ia(e);\n      }\n    }\n\n    return b;\n  };\n\n  t.am = function () {\n    var a = Z.prototype.am.call(this),\n        b = \"\";\n    \"parent\" !== this.nodeParentKeyProperty && \"string\" === typeof this.nodeParentKeyProperty && (b += ',\\n  \"nodeParentKeyProperty\": ' + this.quote(this.nodeParentKeyProperty));\n    return a + b;\n  };\n\n  t.Io = function (a) {\n    Z.prototype.Io.call(this, a);\n    a.nodeParentKeyProperty && (this.nodeParentKeyProperty = a.nodeParentKeyProperty);\n  };\n\n  t.Ho = function (a) {\n    void 0 !== a.nodeParentKeyProperty && a.nodeParentKeyProperty !== this.nodeParentKeyProperty && C(\"applyIncrementalJson cannot change Model properties\");\n    Z.prototype.Ho.call(this, a);\n  };\n\n  t.Dl = function (a) {\n    return a;\n  };\n\n  t.bh = function (a) {\n    if (null !== a) {\n      var b = this.ze;\n\n      if (\"\" !== b && (b = nn(a, b), void 0 !== b)) {\n        if (Xq(b)) return b;\n        C(\"ParentKey value for node data \" + a + \" is not a number or a string: \" + b);\n      }\n    }\n  };\n\n  t.ie = function (a, b) {\n    null === b && (b = void 0);\n\n    if (null !== a) {\n      var c = this.ze;\n      if (\"\" !== c) if (b = this.Dl(b), this.lb(a)) {\n        var d = nn(a, c);\n        d !== b && (ar(this, d, a), Nj(a, c, b), null === this.dc(b) && br(this, b, a), tr(this, \"nodeParentKey\", de, c, a, d, b), \"string\" === typeof c && this.Ka(a, c));\n      } else Nj(a, c, b);\n    }\n  };\n\n  t.Pr = function (a) {\n    if (null === a) return \"\";\n    var b = this.ij;\n    if (\"\" === b) return \"\";\n    b = nn(a, b);\n    if (void 0 === b) return \"\";\n    if (\"string\" === typeof b) return b;\n    C(\"getParentLinkCategoryForNodeData found a non-string category for \" + a + \": \" + b);\n    return \"\";\n  };\n\n  Er.prototype.getLinkCategoryForData = function (a) {\n    return this.Pr(a);\n  };\n\n  Er.prototype.ms = function (a, b) {\n    if (null !== a) {\n      var c = this.ij;\n      if (\"\" !== c) if (this.lb(a)) {\n        var d = nn(a, c);\n        void 0 === d && (d = \"\");\n        d !== b && (Nj(a, c, b), tr(this, \"parentLinkCategory\", de, c, a, d, b), \"string\" === typeof c && this.Ka(a, c));\n      } else Nj(a, c, b);\n    }\n  };\n\n  Er.prototype.setLinkCategoryForData = function (a, b) {\n    this.ms(a, b);\n  };\n\n  Er.prototype.copyNodeData = function (a) {\n    if (null === a) return null;\n    a = Z.prototype.copyNodeData.call(this, a);\n    this.Dj || \"\" === this.ze || void 0 === nn(a, this.ze) || Nj(a, this.ze, void 0);\n    return a;\n  };\n\n  Er.prototype.setDataProperty = function (a, b, c) {\n    if (this.lb(a)) {\n      if (b === this.nodeKeyProperty) {\n        this.Sl(a, c);\n        return;\n      }\n\n      if (b === this.nodeCategoryProperty) {\n        this.Rl(a, c);\n        return;\n      }\n\n      if (b === this.nodeParentKeyProperty) {\n        this.ie(a, c);\n        return;\n      }\n    }\n\n    var d = nn(a, b);\n    d !== c && (Nj(a, b, c), this.fs(a, b, d, c));\n  };\n\n  t = Er.prototype;\n\n  t.Mo = function (a, b) {\n    Z.prototype.Mo.call(this, a, b);\n\n    for (var c = this.kb.iterator; c.next();) {\n      this.Zu(c.value, a, b);\n    }\n  };\n\n  t.Zu = function (a, b, c) {\n    if (this.bh(a) === b) {\n      var d = this.ze;\n      Nj(a, d, c);\n      tr(this, \"nodeParentKey\", de, d, a, b, c);\n      \"string\" === typeof d && this.Ka(a, d);\n    }\n  };\n\n  t.Nl = function (a) {\n    Z.prototype.Nl.call(this, a);\n    a = this.ua(a);\n    var b = $q(this, a);\n\n    if (null !== b) {\n      var c = Ea();\n\n      for (b = b.iterator; b.next();) {\n        var d = b.value;\n\n        if (this.lb(d) && this.bh(d) === a) {\n          var e = this.ze;\n          tr(this, \"nodeParentKey\", de, e, d, a, a);\n          \"string\" === typeof e && this.Ka(d, e);\n          c.push(d);\n        }\n      }\n\n      for (b = 0; b < c.length; b++) {\n        ar(this, a, c[b]);\n      }\n\n      Ga(c);\n    }\n  };\n\n  t.Ml = function (a) {\n    Z.prototype.Ml.call(this, a);\n    var b = this.bh(a);\n    b = this.Dl(b);\n    null === this.dc(b) && br(this, b, a);\n  };\n\n  t.To = function (a) {\n    Z.prototype.To.call(this, a);\n    var b = this.bh(a);\n    ar(this, b, a);\n  };\n\n  t.Tl = function (a, b) {\n    Z.prototype.Tl.call(this, a, b);\n    this.ms(b, this.Pr(a));\n    this.ie(b, this.bh(a));\n  };\n\n  t.Bl = function () {\n    return !0;\n  };\n\n  t.Vr = function () {\n    return !0;\n  };\n\n  ma.Object.defineProperties(Er.prototype, {\n    nodeParentKeyProperty: {\n      get: function get() {\n        return this.ze;\n      },\n      set: function set(a) {\n        var b = this.ze;\n        b !== a && (this.ze = a, this.g(\"nodeParentKeyProperty\", b, a));\n      }\n    },\n    Dj: {\n      get: function get() {\n        return this.vm;\n      },\n      set: function set(a) {\n        this.vm !== a && (this.vm = a);\n      }\n    },\n    parentLinkCategoryProperty: {\n      get: function get() {\n        return this.ij;\n      },\n      set: function set(a) {\n        var b = this.ij;\n        b !== a && (this.ij = a, this.g(\"parentLinkCategoryProperty\", b, a));\n      }\n    },\n    linkCategoryProperty: {\n      get: function get() {\n        return this.parentLinkCategoryProperty;\n      },\n      set: function set(a) {\n        this.parentLinkCategoryProperty = a;\n      }\n    },\n    type: {\n      get: function get() {\n        return \"TreeModel\";\n      }\n    }\n  });\n  Er.prototype.setParentLinkCategoryForNodeData = Er.prototype.ms;\n  Er.prototype.getParentLinkCategoryForNodeData = Er.prototype.Pr;\n  Er.prototype.setParentKeyForNodeData = Er.prototype.ie;\n  Er.prototype.getParentKeyForNodeData = Er.prototype.bh;\n  Er.className = \"TreeModel\";\n  xr.TreeModel = Er;\n\n  function Fr(a) {\n    qi.call(this);\n    this.Qv = this.Hm = this.hc = 0;\n    this.zp = 360;\n    this.Pv = Gr;\n    this.Ni = 0;\n    this.Dv = new I();\n    this.mp = this.ee = 0;\n    this.wr = new Hr();\n    this.Is = this.hj = 0;\n    this.Zx = 600;\n    this.In = NaN;\n    this.km = 1;\n    this.Un = 0;\n    this.jl = 360;\n    this.Nb = Gr;\n    this.L = Ir;\n    this.fd = Jr;\n    this.Zc = yq;\n    this.gf = 6;\n    this.un = Kr;\n    a && Object.assign(this, a);\n  }\n\n  la(Fr, qi);\n\n  Fr.prototype.cloneProtected = function (a) {\n    qi.prototype.cloneProtected.call(this, a);\n    a.In = this.In;\n    a.km = this.km;\n    a.Un = this.Un;\n    a.jl = this.jl;\n    a.Nb = this.Nb;\n    a.L = this.L;\n    a.fd = this.fd;\n    a.Zc = this.Zc;\n    a.gf = this.gf;\n    a.un = this.un;\n  };\n\n  Fr.prototype.ob = function (a) {\n    if (a.classType === Fr) {\n      if (a === Lr || a === Mr || a === Nr || a === Or || a === Jr) this.sorting = a;else if (a === Pr || a === Qr || a === Ir || a === Rr) this.direction = a;else if (a === Sr || a === Tr || a === Gr || a === Ur) this.arrangement = a;else {\n        if (a === Vr || a === Kr) this.nodeDiameterFormula = a;\n      }\n    } else qi.prototype.ob.call(this, a);\n  };\n\n  Fr.prototype.createNetwork = function () {\n    return new Wr(this);\n  };\n\n  Fr.prototype.doLayout = function (a) {\n    null === this.network && (this.network = this.makeNetwork(a));\n    this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);\n    a = this.network.vertexes;\n    if (1 >= a.count) 1 === a.count && (a = a.first(), a.centerX = 0, a.centerY = 0);else {\n      var b = new E();\n      b.addAll(a.iterator);\n      a = new E();\n      var c = new E();\n      var d = this.sort(b);\n      var e,\n          f,\n          g = this.mp;\n      var h = this.arrangement;\n      var k = this.nodeDiameterFormula;\n      var l = this.radius;\n      if (!isFinite(l) || 0 >= l) l = NaN;\n      var m = this.aspectRatio;\n      if (!isFinite(m) || 0 >= m) m = 1;\n      var n = this.startAngle;\n      isFinite(n) || (n = 0);\n      var p = this.sweepAngle;\n      if (!isFinite(p) || 360 < p || 1 > p) p = 360;\n      b = this.spacing;\n      isFinite(b) || (b = NaN);\n      h === Ur && k === Vr ? h = Gr : h === Ur && k !== Vr && (h = this.arrangement);\n\n      if ((this.direction === Pr || this.direction === Qr) && this.sorting !== Jr) {\n        for (k = 0; !(k >= d.length); k += 2) {\n          a.add(d.K(k));\n          if (k + 1 >= d.length) break;\n          c.add(d.K(k + 1));\n        }\n\n        this.direction === Pr ? (this.arrangement === Ur && a.reverse(), d = new E(), d.addAll(a), d.addAll(c)) : (this.arrangement === Ur && c.reverse(), d = new E(), d.addAll(c), d.addAll(a));\n      }\n\n      k = d.length;\n\n      for (var r = f = e = 0; r < d.length; r++) {\n        var q = n + p * f * (this.direction === Ir ? 1 : -1) / k,\n            u = d.K(r).diameter;\n        isNaN(u) && (u = Xr(d.K(r), q));\n        360 > p && (0 === r || r === d.length - 1) && (u /= 2);\n        e += u;\n        f++;\n      }\n\n      if (isNaN(l) || h === Ur) {\n        isNaN(b) && (b = 6);\n\n        if (h !== Gr && h !== Ur) {\n          f = -Infinity;\n\n          for (g = 0; g < k; g++) {\n            r = d.K(g), e = d.K(g === k - 1 ? 0 : g + 1), isNaN(r.diameter) && Xr(r, 0), isNaN(e.diameter) && Xr(e, 0), f = Math.max(f, (r.diameter + e.diameter) / 2);\n          }\n\n          g = f + b;\n          h === Sr ? l = (f + b) / (2 * Math.PI / k) : l = Yr(this, g * (360 <= p ? k : k - 1), m, n * Math.PI / 180, p * Math.PI / 180);\n        } else l = Yr(this, e + (360 <= p ? k : k - 1) * (h !== Ur ? b : 1.6 * b), m, n * Math.PI / 180, p * Math.PI / 180);\n\n        f = l * m;\n      } else if (f = l * m, r = Zr(this, l, f, n * Math.PI / 180, p * Math.PI / 180), isNaN(b)) {\n        if (h === Gr || h === Ur) b = (r - e) / (360 <= p ? k : k - 1);\n      } else if (h === Gr || h === Ur) r = (r - e) / (360 <= p ? k : k - 1), r < b ? (l = Yr(this, e + b * (360 <= p ? k : k - 1), m, n * Math.PI / 180, p * Math.PI / 180), f = l * m) : b = r;else {\n        g = -Infinity;\n\n        for (e = 0; e < k; e++) {\n          q = d.K(e), u = d.K(e === k - 1 ? 0 : e + 1), isNaN(q.diameter) && Xr(q, 0), isNaN(u.diameter) && Xr(u, 0), g = Math.max(g, (q.diameter + u.diameter) / 2);\n        }\n\n        g += b;\n        e = Yr(this, g * (360 <= p ? k : k - 1), m, n * Math.PI / 180, p * Math.PI / 180);\n        e > l ? (l = e, f = l * m) : g = r / (360 <= p ? k : k - 1);\n      }\n\n      this.Pv = h;\n      this.hc = l;\n      this.Hm = m;\n      this.Qv = n;\n      this.zp = p;\n      this.Ni = b;\n      this.ee = f;\n      this.mp = g;\n      b = d;\n      d = this.Pv;\n      h = this.hc;\n      l = this.Qv;\n      m = this.zp;\n      n = this.Ni;\n      p = this.ee;\n      k = this.mp;\n      if (this.direction !== Pr && this.direction !== Qr || d !== Ur) {\n        if (this.direction === Pr || this.direction === Qr) {\n          g = 0;\n\n          switch (d) {\n            case Tr:\n              g = 180 * $r(this, h, p, l, k) / Math.PI;\n              break;\n\n            case Gr:\n              k = b = 0;\n              g = a.first();\n              null !== g && (b = Xr(g, Math.PI / 2));\n              g = c.first();\n              null !== g && (k = Xr(g, Math.PI / 2));\n              g = 180 * $r(this, h, p, l, n + (b + k) / 2) / Math.PI;\n              break;\n\n            case Sr:\n              g = m / b.length;\n          }\n\n          if (this.direction === Pr) {\n            switch (d) {\n              case Tr:\n                as(this, a, l, Rr);\n                break;\n\n              case Gr:\n                bs(this, a, l, Rr);\n                break;\n\n              case Sr:\n                cs(this, a, m / 2, l, Rr);\n            }\n\n            switch (d) {\n              case Tr:\n                as(this, c, l + g, Ir);\n                break;\n\n              case Gr:\n                bs(this, c, l + g, Ir);\n                break;\n\n              case Sr:\n                cs(this, c, m / 2, l + g, Ir);\n            }\n          } else {\n            switch (d) {\n              case Tr:\n                as(this, c, l, Rr);\n                break;\n\n              case Gr:\n                bs(this, c, l, Rr);\n                break;\n\n              case Sr:\n                cs(this, c, m / 2, l, Rr);\n            }\n\n            switch (d) {\n              case Tr:\n                as(this, a, l + g, Ir);\n                break;\n\n              case Gr:\n                bs(this, a, l + g, Ir);\n                break;\n\n              case Sr:\n                cs(this, a, m / 2, l + g, Ir);\n            }\n          }\n        } else switch (d) {\n          case Tr:\n            as(this, b, l, this.direction);\n            break;\n\n          case Gr:\n            bs(this, b, l, this.direction);\n            break;\n\n          case Sr:\n            cs(this, b, m, l, this.direction);\n            break;\n\n          case Ur:\n            ds(this, b, m, l, this.direction);\n        }\n      } else ds(this, b, m, l - m / 2, Ir);\n    }\n    this.updateParts();\n    this.network = null;\n    this.isValidLayout = !0;\n  };\n\n  function cs(a, b, c, d, e) {\n    var f = a.zp,\n        g = a.hc;\n    a = a.ee;\n    d = d * Math.PI / 180;\n    c = c * Math.PI / 180;\n\n    for (var h = b.length, k = 0; k < h; k++) {\n      var l = d + (e === Ir ? k * c / (360 <= f ? h : h - 1) : -(k * c) / h),\n          m = b.K(k),\n          n = g * Math.tan(l) / a;\n      n = Math.sqrt((g * g + a * a * n * n) / (1 + n * n));\n      m.centerX = n * Math.cos(l);\n      m.centerY = n * Math.sin(l);\n      m.actualAngle = 180 * l / Math.PI;\n    }\n  }\n\n  function bs(a, b, c, d) {\n    var e = a.hc,\n        f = a.ee,\n        g = a.Ni;\n    c = c * Math.PI / 180;\n\n    for (var h = b.length, k = 0; k < h; k++) {\n      var l = b.K(k),\n          m = b.K(k === h - 1 ? 0 : k + 1),\n          n = f * Math.sin(c);\n      l.centerX = e * Math.cos(c);\n      l.centerY = n;\n      l.actualAngle = 180 * c / Math.PI;\n      isNaN(l.diameter) && Xr(l, 0);\n      isNaN(m.diameter) && Xr(m, 0);\n      l = $r(a, e, f, d === Ir ? c : -c, (l.diameter + m.diameter) / 2 + g);\n      c += d === Ir ? l : -l;\n    }\n  }\n\n  function as(a, b, c, d) {\n    var e = a.hc,\n        f = a.ee,\n        g = a.mp;\n    c = c * Math.PI / 180;\n\n    for (var h = b.length, k = 0; k < h; k++) {\n      var l = b.K(k);\n      l.centerX = e * Math.cos(c);\n      l.centerY = f * Math.sin(c);\n      l.actualAngle = 180 * c / Math.PI;\n      l = $r(a, e, f, d === Ir ? c : -c, g);\n      c += d === Ir ? l : -l;\n    }\n  }\n\n  function ds(a, b, c, d, e) {\n    var f = a.zp;\n    a.hj = 0;\n    a.wr = new Hr();\n\n    if (360 > c) {\n      for (f = d + (e === Ir ? f : -f); 0 > f;) {\n        f += 360;\n      }\n\n      f %= 360;\n      180 < f && (f -= 360);\n      f *= Math.PI / 180;\n      a.Is = f;\n      es(a, b, c, d, e);\n    } else fs(a, b, c, d, e);\n\n    a.wr.commit(b);\n  }\n\n  function fs(a, b, c, d, e) {\n    var f = a.hc,\n        g = a.Ni,\n        h = a.Hm,\n        k = f * Math.cos(d * Math.PI / 180),\n        l = a.ee * Math.sin(d * Math.PI / 180),\n        m = b.Ea();\n    if (3 === m.length) m[0].centerX = f, m[0].centerY = 0, m[1].centerX = m[0].centerX - m[0].width / 2 - m[1].width / 2 - g, m[1].y = m[0].y, m[2].centerX = (m[0].centerX + m[1].centerX) / 2, m[2].y = m[0].y - m[2].height - g;else if (4 === m.length) m[0].centerX = f, m[0].centerY = 0, m[2].centerX = -m[0].centerX, m[2].centerY = m[0].centerY, m[1].centerX = 0, m[1].y = Math.min(m[0].y, m[2].y) - m[1].height - g, m[3].centerX = 0, m[3].y = Math.max(m[0].y + m[0].height + g, m[2].y + m[2].height + g);else {\n      f = I.alloc();\n\n      for (var n = 0; n < m.length; n++) {\n        m[n].centerX = k;\n        m[n].centerY = l;\n        if (n >= m.length - 1) break;\n        gs(a, k, l, m, n, e, f) || hs(a, k, l, m, n, e, f);\n        k = f.x;\n        l = f.y;\n      }\n\n      I.free(f);\n      a.hj++;\n\n      if (!(23 < a.hj)) {\n        k = m[0].centerX;\n        l = m[0].centerY;\n        f = m[m.length - 1].centerX;\n        n = m[m.length - 1].centerY;\n        var p = Math.abs(k - f) - ((m[0].width + m[m.length - 1].width) / 2 + g),\n            r = Math.abs(l - n) - ((m[0].height + m[m.length - 1].height) / 2 + g);\n        g = 0;\n        1 > Math.abs(r) ? Math.abs(k - f) < (m[0].width + m[m.length - 1].width) / 2 && (g = 0) : g = 0 < r ? r : 1 > Math.abs(p) ? 0 : p;\n        k = Math.abs(f) > Math.abs(n) ? 0 < f !== l > n : 0 < n !== k < f;\n        if (k = e === Ir ? k : !k) g = -Math.abs(g), g = Math.min(g, -m[m.length - 1].width), g = Math.min(g, -m[m.length - 1].height);\n        a.wr.compare(g, m);\n        1 < Math.abs(g) && (a.hc = 8 > a.hj ? a.hc - g / (2 * Math.PI) : 5 > m.length && 10 < g ? a.hc / 2 : a.hc - (0 < g ? 1.7 : -2.3), a.ee = a.hc * h, fs(a, b, c, d, e));\n      }\n    }\n  }\n\n  function es(a, b, c, d, e) {\n    for (var f = a.hc, g = a.ee, h = a.Hm, k = f * Math.cos(d * Math.PI / 180), l = g * Math.sin(d * Math.PI / 180), m = I.alloc(), n = b.Ea(), p = 0; p < n.length; p++) {\n      n[p].centerX = k;\n      n[p].centerY = l;\n      if (p >= n.length - 1) break;\n      gs(a, k, l, n, p, e, m) || hs(a, k, l, n, p, e, m);\n      k = m.x;\n      l = m.y;\n    }\n\n    I.free(m);\n    a.hj++;\n\n    if (!(23 < a.hj)) {\n      k = Math.atan2(l, k);\n      k = e === Ir ? a.Is - k : k - a.Is;\n      k = Math.abs(k) < Math.abs(k - 2 * Math.PI) ? k : k - 2 * Math.PI;\n      f = k * (f + g) / 2;\n      g = a.wr;\n      if (Math.abs(f) < Math.abs(g.xl)) for (g.xl = f, g.bk = [], g.cm = [], k = 0; k < n.length; k++) {\n        g.bk[k] = n[k].bounds.x, g.cm[k] = n[k].bounds.y;\n      }\n      1 < Math.abs(f) && (a.hc = 8 > a.hj ? a.hc - f / (2 * Math.PI) : a.hc - (0 < f ? 1.7 : -2.3), a.ee = a.hc * h, es(a, b, c, d, e));\n    }\n  }\n\n  function gs(a, b, c, d, e, f, g) {\n    var h = a.hc,\n        k = a.ee,\n        l = 0;\n    a = (d[e].width + d[e + 1].width) / 2 + a.Ni;\n    var m = !1;\n\n    if (0 <= c !== (f === Ir)) {\n      if (f = b + a, f > h) {\n        f = b - a;\n        if (f < -h) return g.x = f, g.y = l, !1;\n        m = !0;\n      }\n    } else if (f = b - a, f < -h) {\n      f = b + a;\n      if (f > h) return g.x = f, g.y = l, !1;\n      m = !0;\n    }\n\n    l = Math.sqrt(1 - Math.min(1, f * f / (h * h))) * k;\n    0 > c !== m && (l = -l);\n    if (Math.abs(c - l) > (d[e].height + d[e + 1].height) / 2) return g.x = f, g.y = l, !1;\n    g.x = f;\n    g.y = l;\n    return !0;\n  }\n\n  function hs(a, b, c, d, e, f, g) {\n    var h = a.hc,\n        k = a.ee,\n        l = 0;\n    a = (d[e].height + d[e + 1].height) / 2 + a.Ni;\n    d = !1;\n\n    if (0 <= b !== (f === Ir)) {\n      if (f = c - a, f < -k) {\n        f = c + a;\n\n        if (f > k) {\n          g.x = l;\n          g.y = f;\n          return;\n        }\n\n        d = !0;\n      }\n    } else if (f = c + a, f > k) {\n      f = c - a;\n\n      if (f < -k) {\n        g.x = l;\n        g.y = f;\n        return;\n      }\n\n      d = !0;\n    }\n\n    l = Math.sqrt(1 - Math.min(1, f * f / (k * k))) * h;\n    0 > b !== d && (l = -l);\n    g.x = l;\n    g.y = f;\n  }\n\n  Fr.prototype.commitLayout = function () {\n    this.commitNodes();\n    this.isRouting && this.commitLinks();\n  };\n\n  Fr.prototype.commitNodes = function () {\n    var a = null !== this.group && null !== this.group.placeholder && this.group.isSubGraphExpanded,\n        b = a ? this.group.location.copy() : null,\n        c = this.actualCenter;\n    a ? c = new I(0, 0) : (c.x = this.arrangementOrigin.x + this.hc, c.y = this.arrangementOrigin.y + this.ee);\n\n    for (var d = this.network.vertexes.iterator; d.next();) {\n      var e = d.value;\n      e.x += c.x;\n      e.y += c.y;\n      e.commit();\n    }\n\n    a && (this.group.Za(), a = this.group.position.copy(), c = this.group.location.copy(), b = b.je(c.je(a)), this.group.move(b), this.Dv = b.je(a));\n  };\n\n  Fr.prototype.commitLinks = function () {\n    for (var a = this.network.edges.iterator; a.next();) {\n      a.value.commit();\n    }\n  };\n\n  function Zr(a, b, c, d, e) {\n    var f = a.Zx;\n    if (.001 > Math.abs(a.Hm - 1)) return void 0 !== d && void 0 !== e ? e * b : 2 * Math.PI * b;\n    a = b > c ? Math.sqrt(b * b - c * c) / b : Math.sqrt(c * c - b * b) / c;\n    var g = 0;\n    var h = void 0 !== d && void 0 !== e ? e / (f + 1) : Math.PI / (2 * (f + 1));\n\n    for (var k = 0, l = 0; l <= f; l++) {\n      void 0 !== d && void 0 !== e ? k = d + l * e / f : k = l * Math.PI / (2 * f);\n      var m = Math.sin(k);\n      g += Math.sqrt(1 - a * a * m * m) * h;\n    }\n\n    return void 0 !== d && void 0 !== e ? (b > c ? b : c) * g : 4 * (b > c ? b : c) * g;\n  }\n\n  function Yr(a, b, c, d, e) {\n    return b / (void 0 !== d && void 0 !== e ? Zr(a, 1, c, d, e) : Zr(a, 1, c));\n  }\n\n  function $r(a, b, c, d, e) {\n    if (.001 > Math.abs(a.Hm - 1)) return e / b;\n    var f = b > c ? Math.sqrt(b * b - c * c) / b : Math.sqrt(c * c - b * b) / c,\n        g = 0;\n    a = 2 * Math.PI / (700 * a.network.vertexes.count);\n    b > c && (d += Math.PI / 2);\n\n    for (var h = 0;; h++) {\n      var k = Math.sin(d + h * a);\n      g += (b > c ? b : c) * Math.sqrt(1 - f * f * k * k) * a;\n      if (g >= e) return h * a;\n    }\n  }\n\n  Fr.prototype.sort = function (a) {\n    switch (this.sorting) {\n      case Nr:\n        break;\n\n      case Or:\n        a.reverse();\n        break;\n\n      case Lr:\n        a.sort(this.comparer);\n        break;\n\n      case Mr:\n        a.sort(this.comparer);\n        a.reverse();\n        break;\n\n      case Jr:\n        return this.Vj(is(a));\n\n      default:\n        C(\"Invalid sorting type.\");\n    }\n\n    return a;\n  };\n\n  function is(a) {\n    for (var b = [], c = 0; c < a.length; c++) {\n      b.push(0);\n    }\n\n    c = new E();\n\n    for (var d = 0; d < a.length; d++) {\n      var e = -1,\n          f = -1;\n      if (0 === d) for (var g = 0; g < a.length; g++) {\n        var h = a.K(g).edgesCount;\n        h > e && (e = h, f = g);\n      } else for (g = 0; g < a.length; g++) {\n        h = b[g], h > e && (e = h, f = g);\n      }\n      c.add(a.K(f));\n      b[f] = -1;\n      f = a.K(f);\n\n      for (g = f.sourceEdges; g.next();) {\n        e = a.indexOf(g.value.fromVertex), 0 > e || 0 <= b[e] && b[e]++;\n      }\n\n      for (f = f.destinationEdges; f.next();) {\n        e = a.indexOf(f.value.toVertex), 0 > e || 0 <= b[e] && b[e]++;\n      }\n    }\n\n    return c;\n  }\n\n  Fr.prototype.Vj = function (a) {\n    for (var b = [], c = 0; c < a.length; c++) {\n      var d = a.K(c);\n      b[c] = [];\n\n      for (var e, f = d.destinationEdges; f.next();) {\n        e = a.indexOf(f.value.toVertex), e !== c && 0 > b[c].indexOf(e) && b[c].push(e);\n      }\n\n      for (d = d.sourceEdges; d.next();) {\n        e = a.indexOf(d.value.fromVertex), e !== c && 0 > b[c].indexOf(e) && b[c].push(e);\n      }\n    }\n\n    f = [];\n\n    for (c = 0; c < b.length; c++) {\n      f[c] = 0;\n    }\n\n    c = [];\n    var g = [],\n        h = [];\n    d = [];\n    e = new E();\n\n    for (var k = 0, l = 0; l < b.length; l++) {\n      var m = b[l].length;\n      if (1 === m) d.push(l);else if (0 === m) e.add(a.K(l));else {\n        if (0 === k) c.push(l);else {\n          for (var n = m = Infinity, p = -1, r = [], q = 0; q < c.length; q++) {\n            0 > b[c[q]].indexOf(c[q === c.length - 1 ? 0 : q + 1]) && r.push(q === c.length - 1 ? 0 : q + 1);\n          }\n\n          if (0 === r.length) for (q = 0; q < c.length; q++) {\n            r.push(q);\n          }\n\n          for (q = 0; q < r.length; q++) {\n            for (var u = r[q], w = b[l], v = 0, z = 0; z < g.length; z++) {\n              var y = f[g[z]],\n                  A = f[h[z]];\n\n              if (y < A) {\n                var B = y;\n                y = A;\n              } else B = A;\n\n              if (B < u && u <= y) for (A = 0; A < w.length; A++) {\n                var F = w[A];\n                0 > c.indexOf(F) || B < f[F] && f[F] < y || B === f[F] || y === f[F] || v++;\n              } else for (A = 0; A < w.length; A++) {\n                F = w[A], 0 > c.indexOf(F) || B < f[F] && f[F] < y && B !== f[F] && y !== f[F] && v++;\n              }\n            }\n\n            w = v;\n\n            for (z = v = 0; z < b[l].length; z++) {\n              B = c.indexOf(b[l][z]), 0 <= B && (B = Math.abs(u - (B >= u ? B + 1 : B)), v += B < c.length + 1 - B ? B : c.length + 1 - B);\n            }\n\n            for (z = 0; z < g.length; z++) {\n              B = f[g[z]], y = f[h[z]], B >= u && B++, y >= u && y++, B > y && (A = y, y = B, B = A), y - B < (c.length + 2) / 2 === (B < u && u <= y) && v++;\n            }\n\n            if (w < m || w === m && v < n) m = w, n = v, p = u;\n          }\n\n          c.splice(p, 0, l);\n\n          for (m = 0; m < c.length; m++) {\n            f[c[m]] = m;\n          }\n\n          for (m = 0; m < b[l].length; m++) {\n            n = b[l][m], 0 <= c.indexOf(n) && (g.push(l), h.push(n));\n          }\n        }\n        k++;\n      }\n    }\n\n    for (g = c.length;;) {\n      f = !0;\n\n      for (h = 0; h < d.length; h++) {\n        if (k = d[h], l = b[k][0], m = c.indexOf(l), 0 <= m) {\n          for (p = n = 0; p < b[l].length; p++) {\n            r = c.indexOf(b[l][p]), 0 > r || r === m || (q = r > m ? r - m : m - r, n += r < m !== q > g - q ? 1 : -1);\n          }\n\n          c.splice(0 > n ? m : m + 1, 0, k);\n          d.splice(h, 1);\n          h--;\n        } else f = !1;\n      }\n\n      if (f) break;else c.push(d[0]), d.splice(0, 1);\n    }\n\n    for (b = 0; b < c.length; b++) {\n      e.add(a.K(c[b]));\n    }\n\n    return e;\n  };\n\n  ma.Object.defineProperties(Fr.prototype, {\n    radius: {\n      get: function get() {\n        return this.In;\n      },\n      set: function set(a) {\n        this.In !== a && (0 < a || isNaN(a)) && (this.In = a, this.D());\n      }\n    },\n    aspectRatio: {\n      get: function get() {\n        return this.km;\n      },\n      set: function set(a) {\n        this.km !== a && 0 < a && (this.km = a, this.D());\n      }\n    },\n    startAngle: {\n      get: function get() {\n        return this.Un;\n      },\n      set: function set(a) {\n        this.Un !== a && (this.Un = a, this.D());\n      }\n    },\n    sweepAngle: {\n      get: function get() {\n        return this.jl;\n      },\n      set: function set(a) {\n        this.jl !== a && (0 < a && 360 >= a ? this.jl = a : this.jl = 360, this.D());\n      }\n    },\n    arrangement: {\n      get: function get() {\n        return this.Nb;\n      },\n      set: function set(a) {\n        this.Nb === a || a !== Ur && a !== Gr && a !== Tr && a !== Sr || (this.Nb = a, this.D());\n      }\n    },\n    direction: {\n      get: function get() {\n        return this.L;\n      },\n      set: function set(a) {\n        this.L === a || a !== Ir && a !== Rr && a !== Pr && a !== Qr || (this.L = a, this.D());\n      }\n    },\n    sorting: {\n      get: function get() {\n        return this.fd;\n      },\n      set: function set(a) {\n        this.fd === a || a !== Nr && a !== Or && a !== Lr && !Mr && a !== Jr || (this.fd = a, this.D());\n      }\n    },\n    comparer: {\n      get: function get() {\n        return this.Zc;\n      },\n      set: function set(a) {\n        this.Zc !== a && (this.Zc = a, this.D());\n      }\n    },\n    spacing: {\n      get: function get() {\n        return this.gf;\n      },\n      set: function set(a) {\n        this.gf !== a && (this.gf = a, this.D());\n      }\n    },\n    nodeDiameterFormula: {\n      get: function get() {\n        return this.un;\n      },\n      set: function set(a) {\n        this.un === a || a !== Kr && a !== Vr || (this.un = a, this.D());\n      }\n    },\n    actualXRadius: {\n      get: function get() {\n        return this.hc;\n      }\n    },\n    actualYRadius: {\n      get: function get() {\n        return this.ee;\n      }\n    },\n    actualSpacing: {\n      get: function get() {\n        return this.Ni;\n      }\n    },\n    actualCenter: {\n      get: function get() {\n        return this.Dv;\n      }\n    }\n  });\n  var Gr = new D(Fr, \"ConstantSpacing\", 0),\n      Tr = new D(Fr, \"ConstantDistance\", 1),\n      Sr = new D(Fr, \"ConstantAngle\", 2),\n      Ur = new D(Fr, \"Packed\", 3),\n      Ir = new D(Fr, \"Clockwise\", 4),\n      Rr = new D(Fr, \"Counterclockwise\", 5),\n      Pr = new D(Fr, \"BidirectionalLeft\", 6),\n      Qr = new D(Fr, \"BidirectionalRight\", 7),\n      Nr = new D(Fr, \"Forwards\", 8),\n      Or = new D(Fr, \"Reverse\", 9),\n      Lr = new D(Fr, \"Ascending\", 10),\n      Mr = new D(Fr, \"Descending\", 11),\n      Jr = new D(Fr, \"Optimized\", 12),\n      Kr = new D(Fr, \"Pythagorean\", 13),\n      Vr = new D(Fr, \"Circular\", 14);\n  Fr.className = \"CircularLayout\";\n  Fr.ConstantSpacing = Gr;\n  Fr.ConstantDistance = Tr;\n  Fr.ConstantAngle = Sr;\n  Fr.Packed = Ur;\n  Fr.Clockwise = Ir;\n  Fr.Counterclockwise = Rr;\n  Fr.BidirectionalLeft = Pr;\n  Fr.BidirectionalRight = Qr;\n  Fr.Forwards = Nr;\n  Fr.Reverse = Or;\n  Fr.Ascending = Lr;\n  Fr.Descending = Mr;\n  Fr.Optimized = Jr;\n  Fr.Pythagorean = Kr;\n  Fr.Circular = Vr;\n\n  function Hr() {\n    this.xl = -Infinity;\n    this.cm = this.bk = null;\n  }\n\n  Hr.prototype.compare = function (a, b) {\n    if (0 < a && 0 > this.xl || Math.abs(a) < Math.abs(this.xl) && !(0 > a && 0 < this.xl)) for (this.xl = a, this.bk = [], this.cm = [], a = 0; a < b.length; a++) {\n      this.bk[a] = b[a].bounds.x, this.cm[a] = b[a].bounds.y;\n    }\n  };\n\n  Hr.prototype.commit = function (a) {\n    if (null !== this.bk && null !== this.cm) for (var b = 0; b < this.bk.length; b++) {\n      var c = a.K(b);\n      c.x = this.bk[b];\n      c.y = this.cm[b];\n    }\n  };\n\n  Hr.className = \"VertexArrangement\";\n\n  function Wr(a) {\n    dq.call(this, a);\n  }\n\n  la(Wr, dq);\n\n  Wr.prototype.createVertex = function () {\n    return new js(this);\n  };\n\n  Wr.prototype.createEdge = function () {\n    return new ks(this);\n  };\n\n  Wr.className = \"CircularNetwork\";\n\n  function js(a) {\n    rq.call(this, a);\n    this.u = this.Mi = NaN;\n  }\n\n  la(js, rq);\n\n  function Xr(a, b) {\n    var c = a.network;\n    if (null === c) return NaN;\n    c = c.layout;\n    if (null === c) return NaN;\n    if (c.arrangement === Ur) {\n      if (c.nodeDiameterFormula === Vr) a.Mi = Math.max(a.width, a.height);else {\n        c = Math.abs(Math.sin(b));\n        b = Math.abs(Math.cos(b));\n        if (0 === c) return a.width;\n        if (0 === b) return a.height;\n        a.Mi = Math.min(a.height / c, a.width / b);\n      }\n    } else a.Mi = c.nodeDiameterFormula === Vr ? Math.max(a.width, a.height) : Math.sqrt(a.width * a.width + a.height * a.height);\n    return a.Mi;\n  }\n\n  ma.Object.defineProperties(js.prototype, {\n    diameter: {\n      get: function get() {\n        return this.Mi;\n      },\n      set: function set(a) {\n        this.Mi !== a && (this.Mi = a);\n      }\n    },\n    actualAngle: {\n      get: function get() {\n        return this.u;\n      },\n      set: function set(a) {\n        this.u !== a && (this.u = a);\n      }\n    }\n  });\n  js.className = \"CircularVertex\";\n\n  function ks(a) {\n    sq.call(this, a);\n  }\n\n  la(ks, sq);\n  ks.className = \"CircularEdge\";\n\n  function ls(a) {\n    qi.call(this);\n    this.Sg = null;\n    this.gn = 0;\n    this.Td = new K(100, 100).freeze();\n    this.jm = !1;\n    this.ff = !0;\n    this.od = !1;\n    this.Tk = 100;\n    this.Im = 1;\n    this.Pf = 1E3;\n    this.pn = 10;\n    this.Jn = Math;\n    this.vk = .05;\n    this.uk = 50;\n    this.sk = 150;\n    this.tk = 0;\n    this.Dm = 10;\n    this.Cm = 5;\n    a && Object.assign(this, a);\n  }\n\n  la(ls, qi);\n\n  ls.prototype.cloneProtected = function (a) {\n    qi.prototype.cloneProtected.call(this, a);\n    a.Td.assign(this.Td);\n    a.jm = this.jm;\n    a.ff = this.ff;\n    a.od = this.od;\n    a.Tk = this.Tk;\n    a.Im = this.Im;\n    a.Pf = this.Pf;\n    a.pn = this.pn;\n    a.Jn = this.Jn;\n    a.vk = this.vk;\n    a.uk = this.uk;\n    a.sk = this.sk;\n    a.tk = this.tk;\n    a.Dm = this.Dm;\n    a.Cm = this.Cm;\n  };\n\n  ls.prototype.serializeLayoutProperties = function (a, b) {\n    qi.prototype.serializeLayoutProperties.call(this, a, b);\n    a.arrangementSpacing = {\n      width: this.arrangementSpacing.width,\n      height: this.arrangementSpacing.height\n    };\n    a.arrangesToOrigin = this.arrangesToOrigin;\n    a.setsPortSpots = this.setsPortSpots;\n    a.comments = this.comments;\n    a.maxIterations = this.maxIterations;\n    a.epsilonDistance = this.epsilonDistance;\n    a.infinityDistance = this.infinityDistance;\n    a.moveLimit = this.moveLimit;\n    a.defaultSpringStiffness = this.defaultSpringStiffness;\n    a.defaultSpringLength = this.defaultSpringLength;\n    a.defaultElectricalCharge = this.defaultElectricalCharge;\n    a.defaultGravitationalMass = this.defaultGravitationalMass;\n    a.defaultCommentSpringLength = this.defaultCommentSpringLength;\n    a.defaultCommentElectricalCharge = this.defaultCommentElectricalCharge;\n  };\n\n  ls.prototype.deserializeLayoutProperties = function (a, b, c, d, e) {\n    qi.prototype.deserializeLayoutProperties.call(this, a, b, c, d, e);\n    this.arrangementSpacing = new K(a.arrangementSpacing.width, a.arrangementSpacing.height);\n    this.arrangesToOrigin = a.arrangesToOrigin;\n    this.setsPortSpots = a.setsPortSpots;\n    this.comments = a.comments;\n    this.maxIterations = a.maxIterations;\n    this.epsilonDistance = a.epsilonDistance;\n    this.infinityDistance = a.infinityDistance;\n    this.moveLimit = a.moveLimit;\n    this.defaultSpringStiffness = a.defaultSpringStiffness;\n    this.defaultSpringLength = a.defaultSpringLength;\n    this.defaultElectricalCharge = a.defaultElectricalCharge;\n    this.defaultGravitationalMass = a.defaultGravitationalMass;\n    this.defaultCommentSpringLength = a.defaultCommentSpringLength;\n    this.defaultCommentElectricalCharge = a.defaultCommentElectricalCharge;\n  };\n\n  ls.prototype.createNetwork = function () {\n    return new ms(this);\n  };\n\n  ls.prototype.doLayout = function (a) {\n    null === this.network && (this.network = this.makeNetwork(a));\n\n    if (!this.qv()) {\n      a = this.maxIterations;\n\n      if (0 < this.network.vertexes.count) {\n        this.network.oo();\n\n        for (var b = this.network.vertexes.iterator; b.next();) {\n          var c = b.value;\n          c.charge = this.electricalCharge(c);\n          c.mass = this.gravitationalMass(c);\n        }\n\n        for (b = this.network.edges.iterator; b.next();) {\n          c = b.value, c.stiffness = this.springStiffness(c), c.length = this.springLength(c);\n        }\n\n        this.ju();\n        this.gn = 0;\n\n        if (this.needsClusterLayout()) {\n          b = this.network;\n          c = b.Ix();\n\n          for (var d = c.iterator; d.next();) {\n            this.network = d.value;\n\n            for (var e = this.network.vertexes.iterator; e.next();) {\n              var f = e.value;\n              f.Nd = f.vertexes.count;\n              f.hh = 1;\n              f.Bj = null;\n              f.Ke = null;\n            }\n\n            ns(this, 0, a);\n          }\n\n          this.network = b;\n          var g = d = c.iterator;\n          d = this.arrangementSpacing;\n          var h = g.count,\n              k = !0;\n          f = e = 0;\n\n          for (var l = Ea(), m = 0; m < h + b.vertexes.count + 2; m++) {\n            l[m] = null;\n          }\n\n          h = 0;\n          g.reset();\n\n          for (var n = M.alloc(); g.next();) {\n            if (m = g.value, this.computeBounds(m, n), k) k = !1, e = n.x + n.width / 2, f = n.y + n.height / 2, l[0] = new I(n.x + n.width + d.width, n.y), l[1] = new I(n.x, n.y + n.height + d.height), h = 2;else {\n              var p = os(l, h, e, f, n.width, n.height, d),\n                  r = l[p],\n                  q = new I(r.x + n.width + d.width, r.y),\n                  u = new I(r.x, r.y + n.height + d.height);\n              p + 1 < h && l.splice(p + 1, 0, null);\n              l[p] = q;\n              l[p + 1] = u;\n              h++;\n              p = r.x - n.x;\n              r = r.y - n.y;\n\n              for (m = m.vertexes.iterator; m.next();) {\n                q = m.value, q.centerX += p, q.centerY += r;\n              }\n            }\n          }\n\n          M.free(n);\n\n          for (m = b.vertexes.iterator; m.next();) {\n            g = m.value, p = g.bounds, 2 > h ? (e = p.x + p.width / 2, f = p.y + p.height / 2, l[0] = new I(p.x + p.width + d.width, p.y), l[1] = new I(p.x, p.y + p.height + d.height), h = 2) : (k = os(l, h, e, f, p.width, p.height, d), n = l[k], r = new I(n.x + p.width + d.width, n.y), p = new I(n.x, n.y + p.height + d.height), k + 1 < h && l.splice(k + 1, 0, null), l[k] = r, l[k + 1] = p, h++, g.centerX = n.x + g.width / 2, g.centerY = n.y + g.height / 2);\n          }\n\n          Ga(l);\n\n          for (d = c.iterator; d.next();) {\n            c = d.value;\n\n            for (e = c.vertexes.iterator; e.next();) {\n              b.fg(e.value);\n            }\n\n            for (c = c.edges.iterator; c.next();) {\n              b.ol(c.value);\n            }\n          }\n        }\n\n        ps(this, a);\n        this.updateParts();\n      }\n\n      this.Tk = a;\n      this.network = null;\n      this.isValidLayout = !0;\n    }\n  };\n\n  ls.prototype.needsClusterLayout = function () {\n    if (3 > this.network.vertexes.count) return !1;\n\n    for (var a = 0, b = 0, c = this.network.vertexes.first().bounds, d = this.network.vertexes.iterator; d.next();) {\n      if (d.value.bounds.Sc(c) && (a++, 2 < a)) return !0;\n      if (10 < b) break;\n      b++;\n    }\n\n    return !1;\n  };\n\n  ls.prototype.computeBounds = function (a, b) {\n    var c = !0;\n\n    for (a = a.vertexes.iterator; a.next();) {\n      var d = a.value;\n      c ? (c = !1, b.set(d.bounds)) : b.Xc(d.bounds);\n    }\n\n    return b;\n  };\n\n  function ns(a, b, c) {\n    if (qs(a, b)) {\n      var d = a.Pf;\n      a.Pf *= 1 + 1 / (b + 1);\n      var e = rs(a, b),\n          f = Math.max(0, Math.max(Math.min(a.network.vertexes.count, c * (b + 1) / 11), 10));\n      a.maxIterations += f;\n      ns(a, b + 1, c);\n      ps(a, f);\n      ss(a, e);\n      b = e.vertexes.Ea();\n      b.sort(function (a, b) {\n        return null === a || null === b || a === b ? 0 : b.Nd - a.Nd;\n      });\n\n      for (c = 0; c < b.length; c++) {\n        ts(a, b[c]);\n      }\n\n      a.Pf = d;\n    }\n  }\n\n  function qs(a, b) {\n    if (10 < b || 3 > a.network.vertexes.count) return !1;\n    a.Sg = a.network.vertexes.Ea();\n    a = a.Sg;\n    a.sort(function (a, b) {\n      return null === a || null === b || a === b ? 0 : b.Nd - a.Nd;\n    });\n\n    for (b = a.length - 1; 0 <= b && 1 >= a[b].Nd;) {\n      b--;\n    }\n\n    return 1 < a.length - b;\n  }\n\n  function rs(a, b) {\n    for (var c = a.network, d = new ms(a), e = 0; e < a.Sg.length; e++) {\n      var f = a.Sg[e];\n\n      if (1 < f.Nd) {\n        d.fg(f);\n        var g = new us();\n        g.ts = f.Nd;\n        g.us = f.width;\n        g.ss = f.height;\n        g.wv = f.focus.x;\n        g.xv = f.focus.y;\n        null === f.Ke && (f.Ke = new E());\n        f.Ke.add(g);\n        f.av = f.Ke.count - 1;\n      } else break;\n    }\n\n    for (f = c.edges.iterator; f.next();) {\n      var h = f.value;\n      e = h.fromVertex;\n      g = h.toVertex;\n      e.network === d && g.network === d ? d.ol(h) : e.network === d ? (h = e.Bj, null === h && (h = new E(), e.Bj = h), h.add(g), e.Nd--, e.hh += g.hh) : g.network === d && (h = g.Bj, null === h && (h = new E(), g.Bj = h), h.add(e), g.Nd--, g.hh += e.hh);\n    }\n\n    for (e = d.edges.iterator; e.next();) {\n      f = e.value, f.length *= Math.max(1, J.sqrt((f.fromVertex.hh + f.toVertex.hh) / (4 * b + 1)));\n    }\n\n    for (b = d.vertexes.iterator; b.next();) {\n      e = b.value;\n      var k = e.Bj;\n\n      if (null !== k && 0 < k.count && (g = e.Ke.K(e.Ke.count - 1).ts - e.Nd, !(0 >= g))) {\n        for (var l = h = 0, m = k.count - g; m < k.count; m++) {\n          var n = k.K(m),\n              p = null;\n\n          for (f = n.edges.iterator; f.next();) {\n            var r = f.value;\n\n            if (r.bx(n) === e) {\n              p = r;\n              break;\n            }\n          }\n\n          null !== p && (l += p.length, h += n.width * n.height);\n        }\n\n        f = e.centerX;\n        k = e.centerY;\n        m = e.width;\n        n = e.height;\n        p = e.focus;\n        r = m * n;\n        1 > r && (r = 1);\n        h = J.sqrt((h + r + l * l * 4 / (g * g)) / r);\n        g = (h - 1) * m / 2;\n        h = (h - 1) * n / 2;\n        e.bounds = new M(f - p.x - g, k - p.y - h, m + 2 * g, n + 2 * h);\n        e.focus = new I(p.x + g, p.y + h);\n      }\n    }\n\n    a.network = d;\n    return c;\n  }\n\n  function ss(a, b) {\n    for (var c = a.network.vertexes.iterator; c.next();) {\n      var d = c.value;\n      d.network = b;\n\n      if (null !== d.Ke) {\n        var e = d.Ke.K(d.av);\n        d.Nd = e.ts;\n        var f = e.wv,\n            g = e.xv;\n        d.bounds = new M(d.centerX - f, d.centerY - g, e.us, e.ss);\n        d.focus = new I(f, g);\n        d.av--;\n      }\n    }\n\n    for (c = a.network.edges.iterator; c.next();) {\n      c.value.network = b;\n    }\n\n    a.network = b;\n  }\n\n  function ts(a, b) {\n    var c = b.Bj;\n\n    if (null !== c && 0 !== c.count) {\n      var d = b.centerX,\n          e = b.centerY,\n          f = b.width,\n          g = b.height;\n      null !== b.Ke && 0 < b.Ke.count && (g = b.Ke.K(0), f = g.us, g = g.ss);\n      f = J.sqrt(f * f + g * g) / 2;\n\n      for (var h = !1, k = g = 0, l = 0, m = b.vertexes.iterator; m.next();) {\n        var n = m.value;\n        1 >= n.Nd ? k++ : (h = !0, l++, g += Math.atan2(b.centerY - n.centerY, b.centerX - n.centerX));\n      }\n\n      if (0 !== k) for (0 < l && (g /= l), l = b = 0, b = h ? 2 * Math.PI / (k + 1) : 2 * Math.PI / k, 0 === k % 2 && (l = b / 2), 1 < c.count && c.sort(function (a, b) {\n        return null === a || null === b || a === b ? 0 : b.width * b.height - a.width * a.height;\n      }), h = 0 === k % 2 ? 0 : 1, c = c.iterator; c.next();) {\n        if (k = c.value, !(1 < k.Nd || a.isFixed(k))) {\n          m = null;\n\n          for (n = k.edges.iterator; n.next();) {\n            m = n.value;\n            break;\n          }\n\n          n = k.width;\n          var p = k.height;\n          n = J.sqrt(n * n + p * p) / 2;\n          m = f + m.length + n;\n          n = g + (b * (h / 2 >> 1) + l) * (0 === h % 2 ? 1 : -1);\n          k.centerX = d + m * Math.cos(n);\n          k.centerY = e + m * Math.sin(n);\n          h++;\n        }\n      }\n    }\n  }\n\n  function os(a, b, c, d, e, f, g) {\n    var h = 9E19,\n        k = -1,\n        l = 0;\n\n    a: for (; l < b; l++) {\n      var m = a[l],\n          n = m.x - c,\n          p = m.y - d;\n      n = n * n + p * p;\n\n      if (n < h) {\n        for (p = l - 1; 0 <= p; p--) {\n          if (a[p].y > m.y && a[p].x - m.x < e + g.width) continue a;\n        }\n\n        for (p = l + 1; p < b; p++) {\n          if (a[p].x > m.x && a[p].y - m.y < f + g.height) continue a;\n        }\n\n        k = l;\n        h = n;\n      }\n    }\n\n    return k;\n  }\n\n  ls.prototype.ju = function () {\n    if (this.comments) for (var a = this.network.vertexes.iterator; a.next();) {\n      this.addComments(a.value);\n    }\n  };\n\n  ls.prototype.addComments = function (a) {\n    var b = a.node;\n    if (null !== b) for (b = b.wu(); b.next();) {\n      var c = b.value;\n\n      if (\"Comment\" === c.category && c.isVisible()) {\n        var d = this.network.ei(c);\n        null === d && (d = this.network.yj(c));\n        d.charge = this.defaultCommentElectricalCharge;\n        c = null;\n\n        for (var e = d.destinationEdges; e.next();) {\n          var f = e.value;\n\n          if (f.toVertex === a) {\n            c = f;\n            break;\n          }\n        }\n\n        if (null === c) for (e = d.sourceEdges; e.next();) {\n          if (f = e.value, f.fromVertex === a) {\n            c = f;\n            break;\n          }\n        }\n        null === c && (c = this.network.Qj(a, d, null));\n        c.length = this.defaultCommentSpringLength;\n      }\n    }\n  };\n\n  function vs(a, b) {\n    var c = a.bounds,\n        d = c.x;\n    a = c.y;\n    var e = c.width;\n    c = c.height;\n    var f = b.bounds,\n        g = f.x;\n    b = f.y;\n    var h = f.width;\n    f = f.height;\n    return d + e < g ? a > b + f ? (c = d + e - g, a = a - b - f, J.sqrt(c * c + a * a)) : a + c < b ? (d = d + e - g, a = a + c - b, J.sqrt(d * d + a * a)) : g - (d + e) : d > g + h ? a > b + f ? (c = d - g - h, a = a - b - f, J.sqrt(c * c + a * a)) : a + c < b ? (d = d - g - h, a = a + c - b, J.sqrt(d * d + a * a)) : d - (g + h) : a > b + f ? a - (b + f) : a + c < b ? b - (a + c) : .1;\n  }\n\n  function ps(a, b) {\n    a.Sg = null;\n\n    for (b = a.gn + b; a.gn < b && (a.gn++, ws(a));) {\n      ;\n    }\n\n    a.Sg = null;\n  }\n\n  function ws(a) {\n    null === a.Sg && (a.Sg = a.network.vertexes.Ea());\n    var b = a.Sg;\n    if (0 >= b.length) return !1;\n    var c = b[0];\n    c.forceX = 0;\n    c.forceY = 0;\n\n    for (var d = c.centerX, e = d, f = c = c.centerY, g = 1; g < b.length; g++) {\n      var h = b[g];\n      h.forceX = 0;\n      h.forceY = 0;\n      var k = h.centerX;\n      h = h.centerY;\n      d = Math.min(d, k);\n      e = Math.max(e, k);\n      c = Math.min(c, h);\n      f = Math.max(f, h);\n    }\n\n    (e = e - d > f - c) ? b.sort(function (a, b) {\n      return null === a || null === b || a === b ? 0 : a.centerX - b.centerX;\n    }) : b.sort(function (a, b) {\n      return null === a || null === b || a === b ? 0 : a.centerY - b.centerY;\n    });\n    c = a.Pf;\n    var l = d = h = 0;\n\n    for (f = 0; f < b.length; f++) {\n      g = b[f];\n      d = g.bounds;\n      h = g.focus;\n      k = d.x + h.x;\n      var m = d.y + h.y;\n      d = g.charge * a.electricalFieldX(k, m);\n      l = g.charge * a.electricalFieldY(k, m);\n      d += g.mass * a.gravitationalFieldX(k, m);\n      l += g.mass * a.gravitationalFieldY(k, m);\n      g.forceX += d;\n      g.forceY += l;\n\n      for (var n = f + 1; n < b.length; n++) {\n        var p = b[n];\n\n        if (p !== g) {\n          d = p.bounds;\n          h = p.focus;\n          l = d.x + h.x;\n          var r = d.y + h.y;\n\n          if (k - l > c || l - k > c) {\n            if (e) break;\n          } else if (m - r > c || r - m > c) {\n            if (!e) break;\n          } else {\n            var q = vs(g, p);\n            1 > q ? (d = a.randomNumberGenerator, null === d && (a.randomNumberGenerator = d = new xs()), q = d.random(), h = d.random(), k > l ? (d = Math.abs(p.bounds.right - g.bounds.x), d = (1 + d) * q) : k < l ? (d = Math.abs(p.bounds.x - g.bounds.right), d = -(1 + d) * q) : (d = Math.max(p.width, g.width), d = (1 + d) * q - d / 2), m > r ? (l = Math.abs(p.bounds.bottom - g.bounds.y), l = (1 + l) * h) : k < l ? (l = Math.abs(p.bounds.y - g.bounds.bottom), l = -(1 + l) * h) : (l = Math.max(p.height, g.height), l = (1 + l) * h - l / 2)) : (h = -(g.charge * p.charge) / (q * q), d = (l - k) / q * h, l = (r - m) / q * h);\n            g.forceX += d;\n            g.forceY += l;\n            p.forceX -= d;\n            p.forceY -= l;\n          }\n        }\n      }\n    }\n\n    for (e = a.network.edges.iterator; e.next();) {\n      h = e.value, c = h.fromVertex, f = h.toVertex, g = c.bounds, k = c.focus, d = g.x + k.x, g = g.y + k.y, m = f.bounds, n = f.focus, k = m.x + n.x, m = m.y + n.y, n = vs(c, f), 1 > n ? (n = a.randomNumberGenerator, null === n && (a.randomNumberGenerator = n = new xs()), h = n.random(), n = n.random(), d = (d > k ? 1 : -1) * (1 + (f.width > c.width ? f.width : c.width)) * h, l = (g > m ? 1 : -1) * (1 + (f.height > c.height ? f.height : c.height)) * n) : (h = h.stiffness * (n - h.length), d = (k - d) / n * h, l = (m - g) / n * h), c.forceX += d, c.forceY += l, f.forceX -= d, f.forceY -= l;\n    }\n\n    for (e = d = 0; e < b.length; e++) {\n      c = b[e], a.isFixed(c) ? a.moveFixedVertex(c) : d = Math.max(d, a.moveVertex(c) || 0);\n    }\n\n    return d > a.epsilonDistance * a.epsilonDistance;\n  }\n\n  ls.prototype.moveVertex = function (a) {\n    var b = a.forceX,\n        c = a.forceY,\n        d = this.moveLimit;\n    b < -d ? b = -d : b > d && (b = d);\n    c < -d ? c = -d : c > d && (c = d);\n    a.centerX += b;\n    a.centerY += c;\n    return b * b + c * c;\n  };\n\n  ls.prototype.moveFixedVertex = function () {};\n\n  ls.prototype.commitLayout = function () {\n    this.ev();\n    this.commitNodes();\n    this.isRouting && this.commitLinks();\n  };\n\n  ls.prototype.ev = function () {\n    if (this.setsPortSpots) for (var a = this.network.edges.iterator; a.next();) {\n      var b = a.value.link;\n      null !== b && (b.fromSpot = Wc, b.toSpot = Wc);\n    }\n  };\n\n  ls.prototype.commitNodes = function () {\n    var a = 0,\n        b = 0;\n\n    if (this.arrangesToOrigin) {\n      var c = M.alloc();\n      this.computeBounds(this.network, c);\n      b = this.arrangementOrigin;\n      a = b.x - c.x;\n      b = b.y - c.y;\n      M.free(c);\n    }\n\n    c = M.alloc();\n\n    for (var d = this.network.vertexes.iterator; d.next();) {\n      var e = d.value;\n      if (0 !== a || 0 !== b) c.assign(e.bounds), c.x += a, c.y += b, e.bounds = c;\n      e.commit();\n    }\n\n    M.free(c);\n  };\n\n  ls.prototype.commitLinks = function () {\n    for (var a = this.network.edges.iterator; a.next();) {\n      a.value.commit();\n    }\n  };\n\n  ls.prototype.springStiffness = function (a) {\n    a = a.stiffness;\n    return isNaN(a) ? this.vk : a;\n  };\n\n  ls.prototype.springLength = function (a) {\n    a = a.length;\n    return isNaN(a) ? this.uk : a;\n  };\n\n  ls.prototype.electricalCharge = function (a) {\n    a = a.charge;\n    return isNaN(a) ? this.sk : a;\n  };\n\n  ls.prototype.electricalFieldX = function () {\n    return 0;\n  };\n\n  ls.prototype.electricalFieldY = function () {\n    return 0;\n  };\n\n  ls.prototype.gravitationalMass = function (a) {\n    a = a.mass;\n    return isNaN(a) ? this.tk : a;\n  };\n\n  ls.prototype.gravitationalFieldX = function () {\n    return 0;\n  };\n\n  ls.prototype.gravitationalFieldY = function () {\n    return 0;\n  };\n\n  ls.prototype.isFixed = function (a) {\n    return a.isFixed;\n  };\n\n  ma.Object.defineProperties(ls.prototype, {\n    currentIteration: {\n      get: function get() {\n        return this.gn;\n      }\n    },\n    arrangementSpacing: {\n      get: function get() {\n        return this.Td;\n      },\n      set: function set(a) {\n        this.Td.C(a) || (this.Td.assign(a), this.D());\n      }\n    },\n    arrangesToOrigin: {\n      get: function get() {\n        return this.jm;\n      },\n      set: function set(a) {\n        this.jm !== a && (this.jm = a, this.D());\n      }\n    },\n    setsPortSpots: {\n      get: function get() {\n        return this.ff;\n      },\n      set: function set(a) {\n        this.ff !== a && (this.ff = a, this.D());\n      }\n    },\n    comments: {\n      get: function get() {\n        return this.od;\n      },\n      set: function set(a) {\n        this.od !== a && (this.od = a, this.D());\n      }\n    },\n    maxIterations: {\n      get: function get() {\n        return this.Tk;\n      },\n      set: function set(a) {\n        this.Tk !== a && 0 <= a && (this.Tk = a, this.D());\n      }\n    },\n    epsilonDistance: {\n      get: function get() {\n        return this.Im;\n      },\n      set: function set(a) {\n        this.Im !== a && 0 < a && (this.Im = a, this.D());\n      }\n    },\n    infinityDistance: {\n      get: function get() {\n        return this.Pf;\n      },\n      set: function set(a) {\n        this.Pf !== a && 1 < a && (this.Pf = a, this.D());\n      }\n    },\n    moveLimit: {\n      get: function get() {\n        return this.pn;\n      },\n      set: function set(a) {\n        this.pn !== a && 1 < a && (this.pn = a, this.D());\n      }\n    },\n    randomNumberGenerator: {\n      get: function get() {\n        return this.Jn;\n      },\n      set: function set(a) {\n        this.Jn !== a && (null !== a && \"function\" !== typeof a.random && C('ForceDirectedLayout.randomNumberGenerator must have a \"random()\" function on it: ' + a), this.Jn = a);\n      }\n    },\n    defaultSpringStiffness: {\n      get: function get() {\n        return this.vk;\n      },\n      set: function set(a) {\n        this.vk !== a && (this.vk = a, this.D());\n      }\n    },\n    defaultSpringLength: {\n      get: function get() {\n        return this.uk;\n      },\n      set: function set(a) {\n        this.uk !== a && (this.uk = a, this.D());\n      }\n    },\n    defaultElectricalCharge: {\n      get: function get() {\n        return this.sk;\n      },\n      set: function set(a) {\n        this.sk !== a && (this.sk = a, this.D());\n      }\n    },\n    defaultGravitationalMass: {\n      get: function get() {\n        return this.tk;\n      },\n      set: function set(a) {\n        this.tk !== a && (this.tk = a, this.D());\n      }\n    },\n    defaultCommentSpringLength: {\n      get: function get() {\n        return this.Dm;\n      },\n      set: function set(a) {\n        this.Dm !== a && (this.Dm = a, this.D());\n      }\n    },\n    defaultCommentElectricalCharge: {\n      get: function get() {\n        return this.Cm;\n      },\n      set: function set(a) {\n        this.Cm !== a && (this.Cm = a, this.D());\n      }\n    }\n  });\n  ls.className = \"ForceDirectedLayout\";\n\n  function us() {\n    this.xv = this.wv = this.ss = this.us = this.ts = 0;\n  }\n\n  us.className = \"ForceDirectedSubnet\";\n\n  function ms(a) {\n    dq.call(this, a);\n  }\n\n  la(ms, dq);\n\n  ms.prototype.createVertex = function () {\n    return new ys(this);\n  };\n\n  ms.prototype.createEdge = function () {\n    return new zs(this);\n  };\n\n  ms.className = \"ForceDirectedNetwork\";\n\n  function ys(a) {\n    rq.call(this, a);\n    this.ga = !1;\n    this.Ga = this.u = NaN;\n    this.hh = this.Nd = this.W = this.F = 0;\n    this.Ke = this.Bj = null;\n    this.av = 0;\n  }\n\n  la(ys, rq);\n\n  ys.prototype.serializeVertexProperties = function (a, b) {\n    rq.prototype.serializeVertexProperties.call(this, a, b);\n    a.isFixed = this.isFixed;\n    a.charge = this.charge;\n    a.mass = this.mass;\n  };\n\n  ys.prototype.deserializeVertexProperties = function (a, b, c, d) {\n    rq.prototype.deserializeVertexProperties.call(this, a, b, c, d);\n    this.isFixed = a.isFixed;\n    this.charge = a.charge;\n    this.mass = a.mass;\n  };\n\n  ma.Object.defineProperties(ys.prototype, {\n    isFixed: {\n      get: function get() {\n        return this.ga;\n      },\n      set: function set(a) {\n        this.ga !== a && (this.ga = a);\n      }\n    },\n    charge: {\n      get: function get() {\n        return this.u;\n      },\n      set: function set(a) {\n        this.u !== a && (this.u = a);\n      }\n    },\n    mass: {\n      get: function get() {\n        return this.Ga;\n      },\n      set: function set(a) {\n        this.Ga !== a && (this.Ga = a);\n      }\n    },\n    forceX: {\n      get: function get() {\n        return this.F;\n      },\n      set: function set(a) {\n        this.F !== a && (this.F = a);\n      }\n    },\n    forceY: {\n      get: function get() {\n        return this.W;\n      },\n      set: function set(a) {\n        this.W !== a && (this.W = a);\n      }\n    }\n  });\n  ys.className = \"ForceDirectedVertex\";\n\n  function zs(a) {\n    sq.call(this, a);\n    this.j = this.m = NaN;\n  }\n\n  la(zs, sq);\n\n  zs.prototype.serializeEdgeProperties = function (a, b) {\n    sq.prototype.serializeEdgeProperties.call(this, a, b);\n    a.stiffness = this.stiffness;\n    a.length = this.length;\n  };\n\n  zs.prototype.deserializeEdgeProperties = function (a, b, c, d) {\n    sq.prototype.deserializeEdgeProperties.call(this, a, b, c, d);\n    this.stiffness = a.stiffness;\n    this.length = a.length;\n  };\n\n  ma.Object.defineProperties(zs.prototype, {\n    stiffness: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        this.m !== a && (this.m = a);\n      }\n    },\n    length: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        this.j !== a && (this.j = a);\n      }\n    }\n  });\n  zs.className = \"ForceDirectedEdge\";\n\n  function xs() {\n    var a = 0;\n    void 0 === a && (a = 42);\n    this.seed = a;\n    this.Kx = 48271;\n    this.Mx = 2147483647;\n    this.Q = 44488.07041494893;\n    this.Nx = 3399;\n    this.Lx = 1 / 2147483647;\n    this.random();\n  }\n\n  xs.prototype.random = function () {\n    var a = this.seed % this.Q * this.Kx - this.seed / this.Q * this.Nx;\n    0 < a ? this.seed = a : this.seed = a + this.Mx;\n    return this.seed * this.Lx;\n  };\n\n  xs.className = \"RandomNumberGenerator\";\n\n  function As(a) {\n    qi.call(this);\n    this.gc = this.be = 25;\n    this.L = 0;\n    this.rk = Bs;\n    this.Ok = Cs;\n    this.Fk = Ds;\n    this.Xi = 4;\n    this.ek = Es;\n    this.Tf = 15;\n    this.ff = !0;\n    this.jn = 4;\n    this.Ja = this.Dh = this.wa = -1;\n    this.zc = this.Bg = 0;\n    this.Qa = this.Bd = this.Cd = this.ae = this.Hb = null;\n    this.Cg = 0;\n    this.qn = this.fj = null;\n    this.Lc = 0;\n    this.rn = null;\n    this.Yc = new I();\n    this.we = [];\n    this.we.length = 100;\n    a && Object.assign(this, a);\n  }\n\n  la(As, qi);\n\n  As.prototype.cloneProtected = function (a) {\n    qi.prototype.cloneProtected.call(this, a);\n    a.be = this.be;\n    a.gc = this.gc;\n    a.L = this.L;\n    a.rk = this.rk;\n    a.Ok = this.Ok;\n    a.Fk = this.Fk;\n    a.Xi = this.Xi;\n    a.ek = this.ek;\n    a.Tf = this.Tf;\n    a.ff = this.ff;\n    a.jn = this.jn;\n  };\n\n  As.prototype.serializeLayoutProperties = function (a, b) {\n    qi.prototype.serializeLayoutProperties.call(this, a, b);\n    a.layerSpacing = this.layerSpacing;\n    a.columnSpacing = this.columnSpacing;\n    a.direction = this.direction;\n    a.cycleRemoveOption = this.cycleRemoveOption.name;\n    a.layeringOption = this.layeringOption.name;\n    a.initializeOption = this.initializeOption.name;\n    a.iterations = this.iterations;\n    a.aggressiveOption = this.aggressiveOption.name;\n    a.packOption = this.packOption;\n    a.setsPortSpots = this.setsPortSpots;\n    a.linkSpacing = this.linkSpacing;\n    a.wa = this.wa;\n    a.Dh = this.Dh;\n    a.Ja = this.Ja;\n    a.Bg = this.Bg;\n    a.zc = this.zc;\n    a.Hb = this.Hb;\n    a.Cg = this.Cg;\n    a.Lc = this.Lc;\n    a.Yc = {\n      x: this.Yc.x,\n      y: this.Yc.y\n    };\n  };\n\n  As.prototype.deserializeLayoutProperties = function (a, b, c, d, e) {\n    qi.prototype.deserializeLayoutProperties.call(this, a, b, c, d, e);\n    this.layerSpacing = a.layerSpacing;\n    this.columnSpacing = a.columnSpacing;\n    this.direction = a.direction;\n    this.cycleRemoveOption = Sa(As, a.cycleRemoveOption);\n    this.layeringOption = Sa(As, a.layeringOption);\n    this.initializeOption = Sa(As, a.initializeOption);\n    this.iterations = a.iterations;\n    this.aggressiveOption = Sa(As, a.aggressiveOption);\n    this.packOption = a.packOption;\n    this.setsPortSpots = a.setsPortSpots;\n    this.linkSpacing = a.linkSpacing;\n    this.wa = a.wa;\n    this.Dh = a.Dh;\n    this.Ja = a.Ja;\n    this.Bg = a.Bg;\n    this.zc = a.zc;\n    this.Hb = a.Hb;\n    this.Cg = a.Cg;\n    this.Lc = a.Lc;\n    this.Yc = new I(this.Yc.x, this.Yc.y);\n    e && !d && e.edges.each(function (a) {\n      if (!a.link && a.fromVertex && a.toVertex && (null === a.fromVertex.node || null === a.toVertex.node)) {\n        for (var b = a.fromVertex; null !== b && null === b.node && 0 < b.wd.count;) {\n          var c = b.wd.K(0);\n\n          if (c.link) {\n            a.link = c.link;\n            break;\n          }\n\n          b = c.fromVertex;\n        }\n\n        if (!a.link) {\n          for (c = a.toVertex; null !== c && null === c.node && 0 < c.Jd.count;) {\n            var d = c.Jd.K(0);\n\n            if (d.link) {\n              a.link = d.link;\n              break;\n            }\n\n            c = d.toVertex;\n          }\n\n          if (!a.link) for (c = c.wd.iterator; c.next();) {\n            if (d = c.value, d.link && d.fromVertex === b) {\n              a.link = d.link;\n              break;\n            }\n          }\n        }\n      }\n    });\n  };\n\n  As.prototype.ob = function (a) {\n    a.classType === As ? 0 === a.name.indexOf(\"Aggressive\") ? this.aggressiveOption = a : 0 === a.name.indexOf(\"Cycle\") ? this.cycleRemoveOption = a : 0 === a.name.indexOf(\"Init\") ? this.initializeOption = a : 0 === a.name.indexOf(\"Layer\") ? this.layeringOption = a : C(\"Unknown enum value: \" + a) : qi.prototype.ob.call(this, a);\n  };\n\n  As.prototype.createNetwork = function () {\n    return new Fs(this);\n  };\n\n  As.prototype.doLayout = function (a) {\n    null === this.network && (this.network = this.makeNetwork(a));\n    this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);\n    this.Dh = -1;\n    this.zc = this.Bg = 0;\n    this.rn = this.qn = this.fj = null;\n\n    for (a = 0; a < this.we.length; a++) {\n      this.we[a] = null;\n    }\n\n    if (0 < this.network.vertexes.count) {\n      this.network.oo();\n      if (this.qv()) return;\n      this.cycleRemoveOption !== Gs && this.removeCycles();\n\n      for (a = this.network.vertexes.iterator; a.next();) {\n        a.value.layer = -1;\n      }\n\n      this.wa = -1;\n      this.assignLayers();\n\n      for (a.reset(); a.next();) {\n        this.wa = Math.max(this.wa, a.value.layer);\n      }\n\n      this.cycleRemoveOption === Gs && this.removeCycles();\n      a = this.network;\n\n      for (var b = [], c = a.edges.iterator; c.next();) {\n        var d = c.value;\n        d.valid = !1;\n        b.push(d);\n      }\n\n      for (c = 0; c < b.length; c++) {\n        d = b[c];\n        var e = d.fromVertex,\n            f = d.toVertex;\n\n        if (!(d.valid || (null === e.node && null === e.data || null === f.node && null === f.data) && e.layer === f.layer)) {\n          var g = 0,\n              h = 0,\n              k = 0,\n              l = 0;\n\n          if (null !== d.link) {\n            h = d.link;\n            if (null === h) continue;\n            var m = e.node;\n            g = f.node;\n            if (null === m || null === g) continue;\n            var n = h.fromNode;\n            k = h.toNode;\n            var p = h.fromPort;\n            h = h.toPort;\n\n            if (d.rev) {\n              l = n;\n              var r = p;\n              n = k;\n              p = h;\n              k = l;\n              h = r;\n            }\n\n            var q = e.focus;\n            l = f.focus;\n            var u = d.rev ? f.bounds : e.bounds;\n            r = I.alloc();\n            m !== n ? u.v() && n.isVisible() ? n.actualBounds.v() ? (Fo(n, p, yc, r), r.x += n.actualBounds.x - u.x, r.y += n.actualBounds.y - u.y) : (Fo(n, p, yc, r), r.v() || r.assign(q)) : r.assign(q) : u.v() ? (Fo(n, p, yc, r), r.v() || r.assign(q)) : r.assign(q);\n            n = d.rev ? e.bounds : f.bounds;\n            m = I.alloc();\n            g !== k ? n.v() && k.isVisible() ? k.actualBounds.v() ? (Fo(k, h, yc, m), m.x += k.actualBounds.x - n.x, m.y += k.actualBounds.y - n.y) : (Fo(k, h, yc, m), m.v() || m.assign(l)) : m.assign(l) : n.v() ? (Fo(k, h, yc, m), m.v() || m.assign(l)) : m.assign(l);\n            90 === this.L || 270 === this.L ? (g = Math.round((r.x - q.x) / this.gc), k = r.x, h = Math.round((m.x - l.x) / this.gc), l = m.x) : (g = Math.round((r.y - q.y) / this.gc), k = r.y, h = Math.round((m.y - l.y) / this.gc), l = m.y);\n            I.free(r);\n            I.free(m);\n            d.portFromColOffset = g;\n            d.portFromPos = k;\n            d.portToColOffset = h;\n            d.portToPos = l;\n          } else d.portFromColOffset = 0, d.portFromPos = 0, d.portToColOffset = 0, d.portToPos = 0;\n\n          r = e.layer;\n          m = f.layer;\n          n = 0;\n          u = d.link;\n\n          if (null !== u) {\n            var w = u.fromPort,\n                v = u.toPort;\n\n            if (null !== w && null !== v) {\n              var z = u.fromNode;\n              p = u.toNode;\n\n              if (null !== z && null !== p) {\n                var y = Hs(this, !0),\n                    A = Hs(this, !1),\n                    B = this.setsPortSpots ? y : u.computeSpot(!0, w);\n                q = this.setsPortSpots ? A : u.computeSpot(!1, v);\n                var F = u.isOrthogonal;\n                B.Uc() && B.xf(A) && q.Uc() && q.xf(y) ? n = 0 : (y = u.getLinkPoint(z, w, B, !0, F, p, v, I.alloc()), A = u.getLinkDirection(z, w, y, B, !0, F, p, v), I.free(y), B.Wr() || A !== Is(this, d, !0) ? this.setsPortSpots && null !== z && 1 === z.ports.count && d.rev && (n += 1) : n += 1, B = u.getLinkPoint(p, v, q, !1, F, z, w, I.alloc()), u = u.getLinkDirection(p, v, B, q, !1, F, z, w), I.free(B), q.Wr() || u !== Is(this, d, !1) ? this.setsPortSpots && null !== p && 1 === p.ports.count && d.rev && (n += 2) : n += 2);\n              }\n            }\n          }\n\n          p = n;\n          n = 1 === p || 3 === p ? !0 : !1;\n          if (p = 2 === p || 3 === p ? !0 : !1) q = a.createVertex(), q.node = null, q.nf = 1, q.layer = r, q.near = e, a.fg(q), e = a.Qj(e, q, d.link), e.valid = !1, e.rev = d.rev, e.portFromColOffset = g, e.portToColOffset = 0, e.portFromPos = k, e.portToPos = 0, e = q;\n          u = 1;\n          n && u--;\n\n          if (r - m > u && 0 < r) {\n            d.valid = !1;\n            q = a.createVertex();\n            q.node = null;\n            q.nf = 2;\n            q.layer = r - 1;\n            a.fg(q);\n            e = a.Qj(e, q, d.link);\n            e.valid = !0;\n            e.rev = d.rev;\n            e.portFromColOffset = p ? 0 : g;\n            e.portToColOffset = 0;\n            e.portFromPos = p ? 0 : k;\n            e.portToPos = 0;\n            e = q;\n\n            for (r--; r - m > u && 0 < r;) {\n              q = a.createVertex(), q.node = null, q.nf = 3, q.layer = r - 1, a.fg(q), e = a.Qj(e, q, d.link), e.valid = !0, e.rev = d.rev, e.portFromColOffset = 0, e.portToColOffset = 0, e.portFromPos = 0, e.portToPos = 0, e = q, r--;\n            }\n\n            e = a.Qj(q, f, d.link);\n            e.valid = !n;\n            n && (q.near = f);\n            e.rev = d.rev;\n            e.portFromColOffset = 0;\n            e.portToColOffset = h;\n            e.portFromPos = 0;\n            e.portToPos = l;\n          } else d.valid = !0;\n        }\n      }\n\n      a = this.Hb = [];\n\n      for (b = 0; b <= this.wa; b++) {\n        a[b] = 0;\n      }\n\n      for (b = this.network.vertexes.iterator; b.next();) {\n        b.value.index = -1;\n      }\n\n      this.initializeIndices();\n      this.Dh = -1;\n\n      for (c = this.zc = this.Bg = 0; c <= this.wa; c++) {\n        a[c] > a[this.zc] && (this.Dh = a[c] - 1, this.zc = c), a[c] < a[this.Bg] && (this.Bg = c);\n      }\n\n      this.rn = [];\n\n      for (c = 0; c < a.length; c++) {\n        this.rn[c] = [];\n      }\n\n      for (b.reset(); b.next();) {\n        a = b.value, this.rn[a.layer][a.index] = a;\n      }\n\n      this.Ja = -1;\n\n      for (a = 0; a <= this.wa; a++) {\n        b = Js(this, a);\n        c = 0;\n        d = this.Hb[a];\n\n        for (f = 0; f < d; f++) {\n          e = b[f], c += this.nodeMinColumnSpace(e, !0), e.column = c, c += 1, c += this.nodeMinColumnSpace(e, !1);\n        }\n\n        this.Ja = Math.max(this.Ja, c - 1);\n        Ks(this, a, b);\n      }\n\n      this.reduceCrossings();\n      this.straightenAndPack();\n      this.updateParts();\n    }\n\n    this.network = null;\n    this.isValidLayout = !0;\n  };\n\n  As.prototype.linkMinLength = function () {\n    return 1;\n  };\n\n  function Ls(a) {\n    var b = a.fromVertex.node || a.fromVertex.data;\n    a = a.toVertex.node || a.toVertex.data;\n    return null === b && null === a ? 8 : null === b || null === a ? 4 : 1;\n  }\n\n  As.prototype.nodeMinLayerSpace = function (a, b) {\n    return null === a.node && null === a.data ? 0 : 90 === this.L || 270 === this.L ? b ? a.focus.y + 10 : a.bounds.height - a.focus.y + 10 : b ? a.focus.x + 10 : a.bounds.width - a.focus.x + 10;\n  };\n\n  As.prototype.nodeMinColumnSpace = function (a, b) {\n    if (null === a.node && null === a.data) return 0;\n    var c = b ? a.Uj : a.Tj;\n    if (null !== c) return c;\n    c = this.L;\n    return 90 === c || 270 === c ? b ? a.Uj = a.focus.x / this.gc + 1 | 0 : a.Tj = (a.bounds.width - a.focus.x) / this.gc + 1 | 0 : b ? a.Uj = a.focus.y / this.gc + 1 | 0 : a.Tj = (a.bounds.height - a.focus.y) / this.gc + 1 | 0;\n  };\n\n  function Ms(a) {\n    null === a.fj && (a.fj = []);\n\n    for (var b = 0, c = a.network.vertexes.iterator; c.next();) {\n      var d = c.value;\n      a.fj[b] = d.layer;\n      b++;\n      a.fj[b] = d.column;\n      b++;\n      a.fj[b] = d.index;\n      b++;\n    }\n\n    return a.fj;\n  }\n\n  function Ns(a, b) {\n    var c = 0;\n\n    for (a = a.network.vertexes.iterator; a.next();) {\n      var d = a.value;\n      d.layer = b[c];\n      c++;\n      d.column = b[c];\n      c++;\n      d.index = b[c];\n      c++;\n    }\n  }\n\n  function Os(a, b, c) {\n    var d = Js(a, b),\n        e = a.Hb[b];\n    if (null === a.qn || a.qn.length < e * e) a.qn = [];\n\n    for (var f = a.qn, g = 0; g < e; g++) {\n      var h = 0,\n          k = d[g],\n          l = k.near;\n      if (null !== l && l.layer === k.layer) if (k = l.index, k > g) for (var m = g + 1; m < k; m++) {\n        var n = d[m];\n        n.near === l && n.nf === l.nf || h++;\n      } else for (m = g - 1; m > k; m--) {\n        n = d[m], n.near === l && n.nf === l.nf || h++;\n      }\n      var p;\n      if (0 <= c) for (k = d[g].sourceEdgesArrayAccess, l = 0; l < k.length; l++) {\n        var r = k[l];\n        if (r.valid && r.fromVertex.layer !== b) for (n = r.fromVertex.index, m = r.portToPos, r = r.portFromPos, p = l + 1; p < k.length; p++) {\n          var q = k[p];\n\n          if (q.valid && q.fromVertex.layer !== b) {\n            var u = q.fromVertex.index;\n            var w = q.portToPos;\n            q = q.portFromPos;\n            m < w && (n > u || n === u && r > q) && h++;\n            w < m && (u > n || u === n && q > r) && h++;\n          }\n        }\n      }\n      if (0 >= c) for (k = d[g].destinationEdgesArrayAccess, l = 0; l < k.length; l++) {\n        if (r = k[l], r.valid && r.toVertex.layer !== b) for (n = r.toVertex.index, m = r.portToPos, r = r.portFromPos, p = l + 1; p < k.length; p++) {\n          q = k[p], q.valid && q.toVertex.layer !== b && (u = q.toVertex.index, w = q.portToPos, q = q.portFromPos, r < q && (n > u || n === u && m > w) && h++, q < r && (u > n || u === n && w > m) && h++);\n        }\n      }\n      f[g * e + g] = h;\n\n      for (k = g + 1; k < e; k++) {\n        var v = 0,\n            z = 0;\n\n        if (0 <= c) {\n          h = d[g].sourceEdgesArrayAccess;\n          var y = d[k].sourceEdgesArrayAccess;\n\n          for (l = 0; l < h.length; l++) {\n            if (r = h[l], r.valid && r.fromVertex.layer !== b) for (n = r.fromVertex.index, r = r.portFromPos, p = 0; p < y.length; p++) {\n              q = y[p], q.valid && q.fromVertex.layer !== b && (u = q.fromVertex.index, q = q.portFromPos, (n < u || n === u && r < q) && z++, (u < n || u === n && q < r) && v++);\n            }\n          }\n        }\n\n        if (0 >= c) for (h = d[g].destinationEdgesArrayAccess, y = d[k].destinationEdgesArrayAccess, l = 0; l < h.length; l++) {\n          if (r = h[l], r.valid && r.toVertex.layer !== b) for (n = r.toVertex.index, m = r.portToPos, p = 0; p < y.length; p++) {\n            q = y[p], q.valid && q.toVertex.layer !== b && (u = q.toVertex.index, w = q.portToPos, (n < u || n === u && m < w) && z++, (u < n || u === n && w < m) && v++);\n          }\n        }\n        f[g * e + k] = v;\n        f[k * e + g] = z;\n      }\n    }\n\n    Ks(a, b, d);\n    return f;\n  }\n\n  As.prototype.countCrossings = function () {\n    for (var a = 0, b = 0; b <= this.wa; b++) {\n      for (var c = Os(this, b, 1), d = this.Hb[b], e = 0; e < d; e++) {\n        for (var f = e; f < d; f++) {\n          a += c[e * d + f];\n        }\n      }\n    }\n\n    return a;\n  };\n\n  function Ps(a) {\n    for (var b = 0, c = 0; c <= a.wa; c++) {\n      for (var d = a, e = c, f = Js(d, e), g = d.Hb[e], h = 0, k = 0; k < g; k++) {\n        var l = f[k].destinationEdgesArrayAccess;\n        if (null !== l) for (var m = 0; m < l.length; m++) {\n          var n = l[m];\n\n          if (n.valid && n.toVertex.layer !== e) {\n            var p = n.fromVertex.column + n.portFromColOffset;\n            var r = n.toVertex.column + n.portToColOffset;\n            h += (Math.abs(p - r) + 1) * Ls(n);\n          }\n        }\n      }\n\n      Ks(d, e, f);\n      b += h;\n    }\n\n    return b;\n  }\n\n  As.prototype.normalize = function () {\n    var a = Infinity;\n    this.Ja = -1;\n\n    for (var b = this.network.vertexes.iterator; b.next();) {\n      var c = b.value;\n      a = Math.min(a, c.column - this.nodeMinColumnSpace(c, !0));\n      this.Ja = Math.max(this.Ja, c.column + this.nodeMinColumnSpace(c, !1));\n    }\n\n    for (b.reset(); b.next();) {\n      b.value.column -= a;\n    }\n\n    this.Ja -= a;\n  };\n\n  function Qs(a, b, c) {\n    for (var d = Js(a, b), e = a.Hb[b], f = [], g = 0; g < e; g++) {\n      var h = d[g],\n          k = null;\n      0 >= c && (k = h.sourceEdgesArrayAccess);\n      var l = null;\n      0 <= c && (l = h.destinationEdgesArrayAccess);\n      var m = 0,\n          n = 0,\n          p = h.near;\n      null !== p && p.layer === h.layer && (m += p.column - 1, n++);\n      if (null !== k) for (p = 0; p < k.length; p++) {\n        h = k[p];\n        var r = h.fromVertex;\n        h.valid && !h.rev && r.layer !== b && (m += r.column, n++);\n      }\n      if (null !== l) for (k = 0; k < l.length; k++) {\n        h = l[k], p = h.toVertex, h.valid && !h.rev && p.layer !== b && (m += p.column, n++);\n      }\n      f[g] = 0 === n ? -1 : m / n;\n    }\n\n    Ks(a, b, d);\n    return f;\n  }\n\n  function Rs(a, b, c) {\n    for (var d = Js(a, b), e = a.Hb[b], f = [], g = 0; g < e; g++) {\n      var h = d[g],\n          k = null;\n      0 >= c && (k = h.sourceEdgesArrayAccess);\n      var l = null;\n      0 <= c && (l = h.destinationEdgesArrayAccess);\n      var m = 0,\n          n = [],\n          p = h.near;\n      null !== p && p.layer === h.layer && (n[m] = p.column - 1, m++);\n      h = void 0;\n      if (null !== k) for (p = 0; p < k.length; p++) {\n        h = k[p];\n        var r = h.fromVertex;\n        h.valid && !h.rev && r.layer !== b && (n[m] = r.column + h.portFromColOffset, m++);\n      }\n      if (null !== l) for (k = 0; k < l.length; k++) {\n        h = l[k], p = h.toVertex, h.valid && !h.rev && p.layer !== b && (n[m] = p.column + h.portToColOffset, m++);\n      }\n      0 === m ? f[g] = -1 : (n.sort(function (a, b) {\n        return a - b;\n      }), l = m >> 1, f[g] = 0 !== (m & 1) ? n[l] : n[l - 1] + n[l] >> 1);\n    }\n\n    Ks(a, b, d);\n    return f;\n  }\n\n  function Ss(a, b, c, d, e, f) {\n    if (b.component === d) {\n      b.component = c;\n      if (e) for (var g = b.destinationEdges; g.next();) {\n        var h = g.value;\n        var k = h.toVertex;\n        var l = b.layer - k.layer;\n        h = a.linkMinLength(h);\n        l === h && Ss(a, k, c, d, e, f);\n      }\n      if (f) for (g = b.sourceEdges; g.next();) {\n        h = g.value, k = h.fromVertex, l = k.layer - b.layer, h = a.linkMinLength(h), l === h && Ss(a, k, c, d, e, f);\n      }\n    }\n  }\n\n  function Ts(a, b, c, d, e, f) {\n    if (b.component === d) {\n      b.component = c;\n      if (e) for (var g = b.destinationEdges; g.next();) {\n        Ts(a, g.value.toVertex, c, d, e, f);\n      }\n      if (f) for (b = b.sourceEdges; b.next();) {\n        Ts(a, b.value.fromVertex, c, d, e, f);\n      }\n    }\n  }\n\n  As.prototype.removeCycles = function () {\n    for (var a = this.network.edges.iterator; a.next();) {\n      a.value.rev = !1;\n    }\n\n    switch (this.rk) {\n      default:\n      case Us:\n        a = this.network;\n        var b = 0,\n            c = a.vertexes.count - 1,\n            d = [];\n        d.length = c + 1;\n\n        for (var e = a.vertexes.iterator; e.next();) {\n          e.value.valid = !0;\n        }\n\n        for (; null !== Vs(a);) {\n          for (e = Ws(a); null !== e;) {\n            d[c] = e, c--, e.valid = !1, e = Ws(a);\n          }\n\n          for (e = Xs(a); null !== e;) {\n            d[b] = e, b++, e.valid = !1, e = Xs(a);\n          }\n\n          e = null;\n\n          for (var f = 0, g = this.network.vertexes.iterator; g.next();) {\n            var h = g.value;\n\n            if (h.valid) {\n              for (var k = 0, l = h.destinationEdges; l.next();) {\n                l.value.toVertex.valid && k++;\n              }\n\n              l = 0;\n\n              for (var m = h.sourceEdges; m.next();) {\n                m.value.fromVertex.valid && l++;\n              }\n\n              if (null === e || f < k - l) e = h, f = k - l;\n            }\n          }\n\n          null !== e && (d[b] = e, b++, e.valid = !1);\n        }\n\n        for (b = 0; b < a.vertexes.count; b++) {\n          d[b].index = b;\n        }\n\n        for (d = a.edges.iterator; d.next();) {\n          b = d.value, b.fromVertex.index > b.toVertex.index && (a.Ol(b), b.rev = !0);\n        }\n\n        break;\n\n      case Bs:\n        for (d = this.network.vertexes.iterator; d.next();) {\n          a = d.value, a.gg = -1, a.finish = -1;\n        }\n\n        for (a = this.network.edges.iterator; a.next();) {\n          a.value.forest = !1;\n        }\n\n        this.Cg = 0;\n\n        for (d.reset(); d.next();) {\n          b = d.value, 0 === b.sourceEdges.count && Ys(this, b);\n        }\n\n        for (d.reset(); d.next();) {\n          b = d.value, -1 === b.gg && Ys(this, b);\n        }\n\n        for (a.reset(); a.next();) {\n          d = a.value, d.forest || (b = d.fromVertex, c = b.finish, e = d.toVertex, f = e.finish, e.gg < b.gg && c < f && (this.network.Ol(d), d.rev = !0));\n        }\n\n        break;\n\n      case Gs:\n        a = this.network;\n        b = a.vertexes.iterator;\n\n        for (d = Infinity; b.next();) {\n          d = Math.min(d, b.value.layer);\n        }\n\n        if (Infinity > d) {\n          if (0 > d) for (b.reset(); b.next();) {\n            b.value.layer -= d;\n          }\n          d = [];\n\n          for (b.reset(); b.next();) {\n            c = b.value, e = d[c.layer], void 0 === e ? d[c.layer] = [c] : e.push(c);\n          }\n\n          for (c = b = 0; c < d.length; c++) {\n            if (e = d[c], !e || 0 === e.length) b++;else if (0 < c) for (f = 0; f < e.length; f++) {\n              e[f].layer -= b;\n            }\n          }\n\n          for (d = a.edges.iterator; d.next();) {\n            b = d.value, b.fromVertex.layer < b.toVertex.layer && (a.Ol(b), b.rev = !0);\n          }\n        }\n\n    }\n  };\n\n  function Vs(a) {\n    for (a = a.vertexes.iterator; a.next();) {\n      var b = a.value;\n      if (b.valid) return b;\n    }\n\n    return null;\n  }\n\n  function Ws(a) {\n    for (a = a.vertexes.iterator; a.next();) {\n      var b = a.value;\n\n      if (b.valid) {\n        for (var c = !0, d = b.destinationEdges; d.next();) {\n          if (d.value.toVertex.valid) {\n            c = !1;\n            break;\n          }\n        }\n\n        if (c) return b;\n      }\n    }\n\n    return null;\n  }\n\n  function Xs(a) {\n    for (a = a.vertexes.iterator; a.next();) {\n      var b = a.value;\n\n      if (b.valid) {\n        for (var c = !0, d = b.sourceEdges; d.next();) {\n          if (d.value.fromVertex.valid) {\n            c = !1;\n            break;\n          }\n        }\n\n        if (c) return b;\n      }\n    }\n\n    return null;\n  }\n\n  function Ys(a, b) {\n    b.gg = a.Cg;\n    a.Cg++;\n\n    for (var c = b.destinationEdges; c.next();) {\n      var d = c.value,\n          e = d.toVertex;\n      -1 === e.gg && (d.forest = !0, Ys(a, e));\n    }\n\n    b.finish = a.Cg;\n    a.Cg++;\n  }\n\n  As.prototype.assignLayers = function () {\n    switch (this.Ok) {\n      case Zs:\n        $s(this);\n        break;\n\n      case at:\n        for (var a, b = this.network.vertexes.iterator; b.next();) {\n          a = bt(this, b.value), this.wa = Math.max(a, this.wa);\n        }\n\n        for (b.reset(); b.next();) {\n          a = b.value, a.layer = this.wa - a.layer;\n        }\n\n        break;\n\n      default:\n      case Cs:\n        $s(this);\n\n        for (b = this.network.vertexes.iterator; b.next();) {\n          b.value.valid = !1;\n        }\n\n        for (b.reset(); b.next();) {\n          a = b.value, 0 === a.sourceEdges.count && ct(this, a);\n        }\n\n        a = Infinity;\n\n        for (b.reset(); b.next();) {\n          a = Math.min(a, b.value.layer);\n        }\n\n        this.wa = -1;\n\n        for (b.reset(); b.next();) {\n          var c = b.value;\n          c.layer -= a;\n          this.wa = Math.max(this.wa, c.layer);\n        }\n\n    }\n  };\n\n  function $s(a) {\n    for (var b = a.network.vertexes.iterator; b.next();) {\n      var c = dt(a, b.value);\n      a.wa = Math.max(c, a.wa);\n    }\n  }\n\n  function dt(a, b) {\n    var c = 0;\n\n    if (-1 === b.layer) {\n      for (var d = b.destinationEdges; d.next();) {\n        var e = d.value,\n            f = e.toVertex;\n        e = a.linkMinLength(e);\n        c = Math.max(c, dt(a, f) + e);\n      }\n\n      b.layer = c;\n    } else c = b.layer;\n\n    return c;\n  }\n\n  function bt(a, b) {\n    var c = 0;\n\n    if (-1 === b.layer) {\n      for (var d = b.sourceEdges; d.next();) {\n        var e = d.value,\n            f = e.fromVertex;\n        e = a.linkMinLength(e);\n        c = Math.max(c, bt(a, f) + e);\n      }\n\n      b.layer = c;\n    } else c = b.layer;\n\n    return c;\n  }\n\n  function ct(a, b) {\n    if (!b.valid) {\n      b.valid = !0;\n\n      for (var c = b.destinationEdges; c.next();) {\n        ct(a, c.value.toVertex);\n      }\n\n      for (c = a.network.vertexes.iterator; c.next();) {\n        c.value.component = -1;\n      }\n\n      for (var d = b.sourceEdgesArrayAccess, e = d.length, f = 0; f < e; f++) {\n        var g = d[f],\n            h = g.fromVertex,\n            k = g.toVertex;\n        g = a.linkMinLength(g);\n        h.layer - k.layer > g && Ss(a, h, 0, -1, !0, !1);\n      }\n\n      for (Ss(a, b, 1, -1, !0, !0); 0 !== b.component;) {\n        f = 0;\n        d = Infinity;\n        h = 0;\n        k = null;\n\n        for (g = a.network.vertexes.iterator; g.next();) {\n          var l = g.value;\n\n          if (1 === l.component) {\n            var m = 0,\n                n = !1,\n                p = l.sourceEdgesArrayAccess;\n            e = p.length;\n\n            for (var r = 0; r < e; r++) {\n              var q = p[r],\n                  u = q.fromVertex;\n              m += 1;\n              1 !== u.component && (f += 1, u = u.layer - l.layer, q = a.linkMinLength(q), d = Math.min(d, u - q));\n            }\n\n            p = l.destinationEdgesArrayAccess;\n            e = p.length;\n\n            for (r = 0; r < e; r++) {\n              q = p[r].toVertex, --m, 1 !== q.component ? --f : n = !0;\n            }\n\n            (null === k || m < h) && !n && (k = l, h = m);\n          }\n        }\n\n        if (0 < f) {\n          for (c.reset(); c.next();) {\n            e = c.value, 1 === e.component && (e.layer += d);\n          }\n\n          b.component = 0;\n        } else k.component = 0;\n      }\n\n      for (c = a.network.vertexes.iterator; c.next();) {\n        c.value.component = -1;\n      }\n\n      for (Ss(a, b, 1, -1, !0, !1); 0 !== b.component;) {\n        d = 0;\n        e = Infinity;\n        f = 0;\n        h = null;\n\n        for (k = a.network.vertexes.iterator; k.next();) {\n          if (g = k.value, 1 === g.component) {\n            l = 0;\n            m = !1;\n            p = g.sourceEdgesArrayAccess;\n            n = p.length;\n\n            for (r = 0; r < n; r++) {\n              q = p[r].fromVertex, l += 1, 1 !== q.component ? d += 1 : m = !0;\n            }\n\n            p = g.destinationEdgesArrayAccess;\n            n = p.length;\n\n            for (r = 0; r < n; r++) {\n              q = p[r], u = q.toVertex, --l, 1 !== u.component && (--d, u = g.layer - u.layer, q = a.linkMinLength(q), e = Math.min(e, u - q));\n            }\n\n            (null === h || l > f) && !m && (h = g, f = l);\n          }\n        }\n\n        if (0 > d) {\n          for (c.reset(); c.next();) {\n            d = c.value, 1 === d.component && (d.layer -= e);\n          }\n\n          b.component = 0;\n        } else h.component = 0;\n      }\n    }\n  }\n\n  function Is(a, b, c) {\n    return 90 === a.L ? c && !b.rev || !c && b.rev ? 270 : 90 : 180 === a.L ? c && !b.rev || !c && b.rev ? 0 : 180 : 270 === a.L ? c && !b.rev || !c && b.rev ? 90 : 270 : c && !b.rev || !c && b.rev ? 180 : 0;\n  }\n\n  As.prototype.initializeIndices = function () {\n    switch (this.Fk) {\n      default:\n      case et:\n        for (var a = this.network.vertexes.iterator; a.next();) {\n          var b = a.value,\n              c = b.layer;\n          b.index = this.Hb[c];\n          this.Hb[c]++;\n        }\n\n        break;\n\n      case Ds:\n        a = this.network.vertexes.iterator;\n\n        for (b = this.wa; 0 <= b; b--) {\n          for (a.reset(); a.next();) {\n            c = a.value, c.layer === b && -1 === c.index && ft(this, c);\n          }\n        }\n\n        break;\n\n      case gt:\n        for (a = this.network.vertexes.iterator, b = 0; b <= this.wa; b++) {\n          for (a.reset(); a.next();) {\n            c = a.value, c.layer === b && -1 === c.index && ht(this, c);\n          }\n        }\n\n    }\n  };\n\n  function ft(a, b) {\n    var c = b.layer;\n    b.index = a.Hb[c];\n    a.Hb[c]++;\n    b = b.destinationEdgesArrayAccess;\n\n    for (c = !0; c;) {\n      c = !1;\n\n      for (var d = 0; d < b.length - 1; d++) {\n        var e = b[d],\n            f = b[d + 1];\n        e.portFromColOffset > f.portFromColOffset && (c = !0, b[d] = f, b[d + 1] = e);\n      }\n    }\n\n    for (c = 0; c < b.length; c++) {\n      d = b[c], d.valid && (d = d.toVertex, -1 === d.index && ft(a, d));\n    }\n  }\n\n  function ht(a, b) {\n    var c = b.layer;\n    b.index = a.Hb[c];\n    a.Hb[c]++;\n    b = b.sourceEdgesArrayAccess;\n\n    for (var d = !0; d;) {\n      for (d = !1, c = 0; c < b.length - 1; c++) {\n        var e = b[c],\n            f = b[c + 1];\n        e.portToColOffset > f.portToColOffset && (d = !0, b[c] = f, b[c + 1] = e);\n      }\n    }\n\n    for (c = 0; c < b.length; c++) {\n      d = b[c], d.valid && (d = d.fromVertex, -1 === d.index && ht(a, d));\n    }\n  }\n\n  As.prototype.reduceCrossings = function () {\n    var a = this.countCrossings(),\n        b = Ms(this),\n        c,\n        d;\n\n    for (c = 0; c < this.Xi; c++) {\n      for (d = 0; d <= this.wa; d++) {\n        it(this, d, 1), jt(this, d, 1);\n      }\n\n      var e = this.countCrossings();\n      e < a && (a = e, b = Ms(this));\n\n      for (d = this.wa; 0 <= d; d--) {\n        it(this, d, -1), jt(this, d, -1);\n      }\n\n      e = this.countCrossings();\n      e < a && (a = e, b = Ms(this));\n    }\n\n    Ns(this, b);\n\n    for (c = 0; c < this.Xi; c++) {\n      for (d = 0; d <= this.wa; d++) {\n        it(this, d, 0), jt(this, d, 0);\n      }\n\n      e = this.countCrossings();\n      e < a && (a = e, b = Ms(this));\n\n      for (d = this.wa; 0 <= d; d--) {\n        it(this, d, 0), jt(this, d, 0);\n      }\n\n      e = this.countCrossings();\n      e < a && (a = e, b = Ms(this));\n    }\n\n    Ns(this, b);\n    var f, g, h;\n\n    switch (this.ek) {\n      case kt:\n        break;\n\n      case lt:\n        for (h = a + 1; (d = this.countCrossings()) < h;) {\n          for (h = d, c = this.wa; 0 <= c; c--) {\n            for (g = 0; g <= c; g++) {\n              for (f = !0; f;) {\n                for (f = !1, d = c; d >= g; d--) {\n                  f = jt(this, d, -1) || f;\n                }\n              }\n\n              e = this.countCrossings();\n              e >= a ? Ns(this, b) : (a = e, b = Ms(this));\n\n              for (f = !0; f;) {\n                for (f = !1, d = c; d >= g; d--) {\n                  f = jt(this, d, 1) || f;\n                }\n              }\n\n              e = this.countCrossings();\n              e >= a ? Ns(this, b) : (a = e, b = Ms(this));\n\n              for (f = !0; f;) {\n                for (f = !1, d = g; d <= c; d++) {\n                  f = jt(this, d, 1) || f;\n                }\n              }\n\n              e >= a ? Ns(this, b) : (a = e, b = Ms(this));\n\n              for (f = !0; f;) {\n                for (f = !1, d = g; d <= c; d++) {\n                  f = jt(this, d, -1) || f;\n                }\n              }\n\n              e >= a ? Ns(this, b) : (a = e, b = Ms(this));\n\n              for (f = !0; f;) {\n                for (f = !1, d = c; d >= g; d--) {\n                  f = jt(this, d, 0) || f;\n                }\n              }\n\n              e >= a ? Ns(this, b) : (a = e, b = Ms(this));\n\n              for (f = !0; f;) {\n                for (f = !1, d = g; d <= c; d++) {\n                  f = jt(this, d, 0) || f;\n                }\n              }\n\n              e >= a ? Ns(this, b) : (a = e, b = Ms(this));\n            }\n          }\n        }\n\n        break;\n\n      default:\n      case Es:\n        for (c = this.wa, g = 0, h = a + 1; (d = this.countCrossings()) < h;) {\n          h = d;\n\n          for (f = !0; f;) {\n            for (f = !1, d = c; d >= g; d--) {\n              f = jt(this, d, -1) || f;\n            }\n          }\n\n          e = this.countCrossings();\n          e >= a ? Ns(this, b) : (a = e, b = Ms(this));\n\n          for (f = !0; f;) {\n            for (f = !1, d = c; d >= g; d--) {\n              f = jt(this, d, 1) || f;\n            }\n          }\n\n          e = this.countCrossings();\n          e >= a ? Ns(this, b) : (a = e, b = Ms(this));\n\n          for (f = !0; f;) {\n            for (f = !1, d = g; d <= c; d++) {\n              f = jt(this, d, 1) || f;\n            }\n          }\n\n          e >= a ? Ns(this, b) : (a = e, b = Ms(this));\n\n          for (f = !0; f;) {\n            for (f = !1, d = g; d <= c; d++) {\n              f = jt(this, d, -1) || f;\n            }\n          }\n\n          e >= a ? Ns(this, b) : (a = e, b = Ms(this));\n\n          for (f = !0; f;) {\n            for (f = !1, d = c; d >= g; d--) {\n              f = jt(this, d, 0) || f;\n            }\n          }\n\n          e >= a ? Ns(this, b) : (a = e, b = Ms(this));\n\n          for (f = !0; f;) {\n            for (f = !1, d = g; d <= c; d++) {\n              f = jt(this, d, 0) || f;\n            }\n          }\n\n          e >= a ? Ns(this, b) : (a = e, b = Ms(this));\n        }\n\n    }\n\n    Ns(this, b);\n  };\n\n  function it(a, b, c) {\n    var d = Js(a, b),\n        e = a.Hb[b],\n        f = Rs(a, b, c),\n        g = Qs(a, b, c);\n\n    for (c = 0; c < e; c++) {\n      -1 === g[c] && (g[c] = d[c].column), -1 === f[c] && (f[c] = d[c].column);\n    }\n\n    for (var h = !0, k; h;) {\n      for (h = !1, c = 0; c < e - 1; c++) {\n        if (f[c + 1] < f[c] || f[c + 1] === f[c] && g[c + 1] < g[c]) h = !0, k = f[c], f[c] = f[c + 1], f[c + 1] = k, k = g[c], g[c] = g[c + 1], g[c + 1] = k, k = d[c], d[c] = d[c + 1], d[c + 1] = k;\n      }\n    }\n\n    for (c = f = 0; c < e; c++) {\n      k = d[c], k.index = c, f += a.nodeMinColumnSpace(k, !0), k.column = f, f += 1, f += a.nodeMinColumnSpace(k, !1);\n    }\n\n    Ks(a, b, d);\n  }\n\n  function jt(a, b, c) {\n    var d = Js(a, b),\n        e = a.Hb[b];\n    c = Os(a, b, c);\n    var f;\n    var g = [];\n\n    for (f = 0; f < e; f++) {\n      g[f] = -1;\n    }\n\n    var h = [];\n\n    for (f = 0; f < e; f++) {\n      h[f] = -1;\n    }\n\n    for (var k = !1, l = !0; l;) {\n      for (l = !1, f = 0; f < e - 1; f++) {\n        var m = c[d[f].index * e + d[f + 1].index],\n            n = c[d[f + 1].index * e + d[f].index],\n            p = 0,\n            r = 0,\n            q = d[f].column,\n            u = d[f + 1].column,\n            w = a.nodeMinColumnSpace(d[f], !0),\n            v = a.nodeMinColumnSpace(d[f], !1),\n            z = a.nodeMinColumnSpace(d[f + 1], !0),\n            y = a.nodeMinColumnSpace(d[f + 1], !1);\n        w = q - w + z;\n        v = u - v + y;\n        var A = d[f].sourceEdges.iterator;\n\n        for (A.reset(); A.next();) {\n          if (z = A.value, y = z.fromVertex, z.valid && y.layer === b) {\n            for (z = 0; d[z] !== y;) {\n              z++;\n            }\n\n            z < f && (p += 2 * (f - z), r += 2 * (f + 1 - z));\n            z === f + 1 && (p += 1);\n            z > f + 1 && (p += 4 * (z - f), r += 4 * (z - (f + 1)));\n          }\n        }\n\n        A = d[f].destinationEdges.iterator;\n\n        for (A.reset(); A.next();) {\n          if (z = A.value, y = z.toVertex, z.valid && y.layer === b) {\n            for (z = 0; d[z] !== y;) {\n              z++;\n            }\n\n            z === f + 1 && (r += 1);\n          }\n        }\n\n        A = d[f + 1].sourceEdges.iterator;\n\n        for (A.reset(); A.next();) {\n          if (z = A.value, y = z.fromVertex, z.valid && y.layer === b) {\n            for (z = 0; d[z] !== y;) {\n              z++;\n            }\n\n            z < f && (p += 2 * (f + 1 - z), r += 2 * (f - z));\n            z === f && (r += 1);\n            z > f + 1 && (p += 4 * (z - (f + 1)), r += 4 * (z - f));\n          }\n        }\n\n        A = d[f + 1].destinationEdges.iterator;\n\n        for (A.reset(); A.next();) {\n          if (z = A.value, y = z.toVertex, z.valid && y.layer === b) {\n            for (z = 0; d[z] !== y;) {\n              z++;\n            }\n\n            z === f && (p += 1);\n          }\n        }\n\n        z = y = 0;\n        A = g[d[f].index];\n        var B = h[d[f].index],\n            F = g[d[f + 1].index],\n            L = h[d[f + 1].index];\n        -1 !== A && (y += Math.abs(A - q), z += Math.abs(A - v));\n        -1 !== B && (y += Math.abs(B - q), z += Math.abs(B - v));\n        -1 !== F && (y += Math.abs(F - u), z += Math.abs(F - w));\n        -1 !== L && (y += Math.abs(L - u), z += Math.abs(L - w));\n        if (r < p - .5 || r === p && n < m - .5 || r === p && n === m && z < y - .5) l = k = !0, d[f].column = v, d[f + 1].column = w, m = d[f], d[f] = d[f + 1], d[f + 1] = m;\n      }\n    }\n\n    for (f = 0; f < e; f++) {\n      d[f].index = f;\n    }\n\n    Ks(a, b, d);\n    return k;\n  }\n\n  As.prototype.straightenAndPack = function () {\n    var a = 0 !== (this.Tf & 1);\n    var b = 0 !== (this.Tf & mt);\n    1E3 < this.network.edges.count && b && (a = !1);\n\n    if (a) {\n      var c = [];\n\n      for (b = 0; b <= this.wa; b++) {\n        c[b] = 0;\n      }\n\n      for (var d, e = this.network.vertexes.iterator; e.next();) {\n        var f = e.value;\n        b = f.layer;\n        d = f.column;\n        f = this.nodeMinColumnSpace(f, !1);\n        c[b] = Math.max(c[b], d + f);\n      }\n\n      for (e.reset(); e.next();) {\n        f = e.value, b = f.layer, d = f.column, f.column = (8 * (this.Ja - c[b]) >> 1) + 8 * d;\n      }\n\n      this.Ja *= 8;\n    }\n\n    if (0 !== (this.Tf & 2)) for (c = !0; c;) {\n      c = !1;\n\n      for (b = this.zc + 1; b <= this.wa; b++) {\n        c = nt(this, b, 1) || c;\n      }\n\n      for (b = this.zc - 1; 0 <= b; b--) {\n        c = nt(this, b, -1) || c;\n      }\n\n      c = nt(this, this.zc, 0) || c;\n    }\n\n    if (0 !== (this.Tf & 4)) {\n      for (b = this.zc + 1; b <= this.wa; b++) {\n        ot(this, b, 1);\n      }\n\n      for (b = this.zc - 1; 0 <= b; b--) {\n        ot(this, b, -1);\n      }\n\n      ot(this, this.zc, 0);\n    }\n\n    a && (pt(this, -1), pt(this, 1));\n    if (0 !== (this.Tf & 2)) for (c = !0; c;) {\n      c = !1;\n      c = nt(this, this.zc, 0) || c;\n\n      for (b = this.zc + 1; b <= this.wa; b++) {\n        c = nt(this, b, 0) || c;\n      }\n\n      for (b = this.zc - 1; 0 <= b; b--) {\n        c = nt(this, b, 0) || c;\n      }\n    }\n  };\n\n  function nt(a, b, c) {\n    for (var d = !1; qt(a, b, c);) {\n      d = !0;\n    }\n\n    return d;\n  }\n\n  function qt(a, b, c) {\n    var d,\n        e = Js(a, b),\n        f = a.Hb[b],\n        g = Qs(a, b, -1);\n    if (0 < c) for (d = 0; d < f; d++) {\n      g[d] = -1;\n    }\n    var h = Qs(a, b, 1);\n    if (0 > c) for (d = 0; d < f; d++) {\n      h[d] = -1;\n    }\n\n    for (var k = !1, l = !0; l;) {\n      for (l = !1, d = 0; d < f; d++) {\n        var m = e[d].column,\n            n = a.nodeMinColumnSpace(e[d], !0),\n            p = a.nodeMinColumnSpace(e[d], !1),\n            r = 0;\n        0 > d - 1 || m - e[d - 1].column - 1 > n + a.nodeMinColumnSpace(e[d - 1], !1) ? r = m - 1 : r = m;\n        n = d + 1 >= f || e[d + 1].column - m - 1 > p + a.nodeMinColumnSpace(e[d + 1], !0) ? m + 1 : m;\n        var q = p = 0,\n            u = 0;\n        if (0 >= c) for (var w = e[d].sourceEdges.iterator; w.next();) {\n          var v = w.value;\n          var z = v.fromVertex;\n\n          if (v.valid && z.layer !== b) {\n            var y = Ls(v);\n            var A = v.portFromColOffset;\n            v = v.portToColOffset;\n            z = z.column;\n            p += (Math.abs(m + v - (z + A)) + 1) * y;\n            q += (Math.abs(r + v - (z + A)) + 1) * y;\n            u += (Math.abs(n + v - (z + A)) + 1) * y;\n          }\n        }\n        if (0 <= c) for (w = e[d].destinationEdges.iterator; w.next();) {\n          v = w.value, z = v.toVertex, v.valid && z.layer !== b && (y = Ls(v), A = v.portFromColOffset, v = v.portToColOffset, z = z.column, p += (Math.abs(m + A - (z + v)) + 1) * y, q += (Math.abs(r + A - (z + v)) + 1) * y, u += (Math.abs(n + A - (z + v)) + 1) * y);\n        }\n        v = A = y = 0;\n        w = g[e[d].index];\n        z = h[e[d].index];\n        -1 !== w && (y += Math.abs(w - m), A += Math.abs(w - r), v += Math.abs(w - n));\n        -1 !== z && (y += Math.abs(z - m), A += Math.abs(z - r), v += Math.abs(z - n));\n        if (q < p || q === p && A < y) l = k = !0, e[d].column = r;else if (u < p || u === p && v < y) l = k = !0, e[d].column = n;\n      }\n    }\n\n    Ks(a, b, e);\n    a.normalize();\n    return k;\n  }\n\n  function ot(a, b, c) {\n    var d = Js(a, b),\n        e = a.Hb[b],\n        f = Rs(a, b, c),\n        g = [];\n\n    for (c = 0; c < e; c++) {\n      g[c] = f[c];\n    }\n\n    for (f = !0; f;) {\n      for (f = !1, c = 0; c < e; c++) {\n        var h = d[c].column,\n            k = a.nodeMinColumnSpace(d[c], !0),\n            l = a.nodeMinColumnSpace(d[c], !1),\n            m = 0;\n        if (-1 === g[c]) {\n          if (0 === c && c === e - 1) m = h;else if (0 === c) {\n            var n = d[c + 1].column;\n            n - h === l + a.nodeMinColumnSpace(d[c + 1], !0) ? m = h - 1 : m = h;\n          } else c === e - 1 ? (n = d[c - 1].column, m = h - n === k + a.nodeMinColumnSpace(d[c - 1], !1) ? h + 1 : h) : (n = d[c - 1].column, k = n + a.nodeMinColumnSpace(d[c - 1], !1) + k + 1, n = d[c + 1].column, l = n - a.nodeMinColumnSpace(d[c + 1], !0) - l - 1, m = (k + l) / 2 | 0);\n        } else 0 === c && c === e - 1 ? m = g[c] : 0 === c ? (n = d[c + 1].column, l = n - a.nodeMinColumnSpace(d[c + 1], !0) - l - 1, m = Math.min(g[c], l)) : c === e - 1 ? (n = d[c - 1].column, k = n + a.nodeMinColumnSpace(d[c - 1], !1) + k + 1, m = Math.max(g[c], k)) : (n = d[c - 1].column, k = n + a.nodeMinColumnSpace(d[c - 1], !1) + k + 1, n = d[c + 1].column, l = n - a.nodeMinColumnSpace(d[c + 1], !0) - l - 1, k < g[c] && g[c] < l ? m = g[c] : k >= g[c] ? m = k : l <= g[c] && (m = l));\n        m !== h && (f = !0, d[c].column = m);\n      }\n    }\n\n    Ks(a, b, d);\n    a.normalize();\n  }\n\n  function rt(a, b) {\n    for (var c = !0, d = a.network.vertexes.iterator; d.next();) {\n      var e = d.value,\n          f = a.nodeMinColumnSpace(e, !0),\n          g = a.nodeMinColumnSpace(e, !1);\n\n      if (e.column - f <= b && e.column + g >= b) {\n        c = !1;\n        break;\n      }\n    }\n\n    a = !1;\n    if (c) for (d.reset(); d.next();) {\n      c = d.value, c.column > b && (--c.column, a = !0);\n    }\n    return a;\n  }\n\n  function st(a, b) {\n    var c = b + 1;\n    var d,\n        e = [],\n        f = [];\n\n    for (d = 0; d <= a.wa; d++) {\n      e[d] = !1, f[d] = !1;\n    }\n\n    for (var g = a.network.vertexes.iterator; g.next();) {\n      d = g.value;\n      var h = d.column - a.nodeMinColumnSpace(d, !0),\n          k = d.column + a.nodeMinColumnSpace(d, !1);\n      h <= b && k >= b && (e[d.layer] = !0);\n      h <= c && k >= c && (f[d.layer] = !0);\n    }\n\n    h = !0;\n    c = !1;\n\n    for (d = 0; d <= a.wa; d++) {\n      h = h && !(e[d] && f[d]);\n    }\n\n    if (h) for (g.reset(); g.next();) {\n      a = g.value, a.column > b && (--a.column, c = !0);\n    }\n    return c;\n  }\n\n  function pt(a, b) {\n    for (var c = 0; c <= a.Ja; c++) {\n      for (; rt(a, c);) {\n        ;\n      }\n    }\n\n    a.normalize();\n\n    for (c = 0; c < a.Ja; c++) {\n      for (; st(a, c);) {\n        ;\n      }\n    }\n\n    a.normalize();\n    var d;\n    if (0 < b) for (c = 0; c <= a.Ja; c++) {\n      var e = Ms(a);\n      var f = Ps(a);\n\n      for (d = f + 1; f < d;) {\n        d = f;\n        tt(a, c, 1);\n        var g = Ps(a);\n        g > f ? Ns(a, e) : g < f && (f = g, e = Ms(a));\n      }\n    }\n    if (0 > b) for (c = a.Ja; 0 <= c; c--) {\n      for (e = Ms(a), f = Ps(a), d = f + 1; f < d;) {\n        d = f, tt(a, c, -1), g = Ps(a), g > f ? Ns(a, e) : g < f && (f = g, e = Ms(a));\n      }\n    }\n    a.normalize();\n  }\n\n  function tt(a, b, c) {\n    a.Lc = 0;\n\n    for (var d = a.network.vertexes.iterator; d.next();) {\n      d.value.component = -1;\n    }\n\n    if (0 < c) for (d.reset(); d.next();) {\n      var e = d.value;\n      e.column - a.nodeMinColumnSpace(e, !0) <= b && (e.component = a.Lc);\n    }\n    if (0 > c) for (d.reset(); d.next();) {\n      e = d.value, e.column + a.nodeMinColumnSpace(e, !1) >= b && (e.component = a.Lc);\n    }\n    a.Lc++;\n\n    for (d.reset(); d.next();) {\n      b = d.value, -1 === b.component && (Ts(a, b, a.Lc, -1, !0, !0), a.Lc++);\n    }\n\n    var f;\n    b = [];\n\n    for (f = 0; f < a.Lc * a.Lc; f++) {\n      b[f] = !1;\n    }\n\n    e = [];\n\n    for (f = 0; f < (a.wa + 1) * (a.Ja + 1); f++) {\n      e[f] = -1;\n    }\n\n    for (d.reset(); d.next();) {\n      f = d.value;\n\n      for (var g = f.layer, h = Math.max(0, f.column - a.nodeMinColumnSpace(f, !0)), k = Math.min(a.Ja, f.column + a.nodeMinColumnSpace(f, !1)); h <= k; h++) {\n        e[g * (a.Ja + 1) + h] = f.component;\n      }\n    }\n\n    for (f = 0; f <= a.wa; f++) {\n      if (0 < c) for (g = 0; g < a.Ja; g++) {\n        -1 !== e[f * (a.Ja + 1) + g] && -1 !== e[f * (a.Ja + 1) + g + 1] && e[f * (a.Ja + 1) + g] !== e[f * (a.Ja + 1) + g + 1] && (b[e[f * (a.Ja + 1) + g] * a.Lc + e[f * (a.Ja + 1) + g + 1]] = !0);\n      }\n      if (0 > c) for (g = a.Ja; 0 < g; g--) {\n        -1 !== e[f * (a.Ja + 1) + g] && -1 !== e[f * (a.Ja + 1) + g - 1] && e[f * (a.Ja + 1) + g] !== e[f * (a.Ja + 1) + g - 1] && (b[e[f * (a.Ja + 1) + g] * a.Lc + e[f * (a.Ja + 1) + g - 1]] = !0);\n      }\n    }\n\n    e = [];\n\n    for (f = 0; f < a.Lc; f++) {\n      e[f] = !0;\n    }\n\n    g = [];\n\n    for (g.push(0); 0 !== g.length;) {\n      if (k = g[g.length - 1], g.pop(), e[k]) for (e[k] = !1, f = 0; f < a.Lc; f++) {\n        b[k * a.Lc + f] && g.splice(0, 0, f);\n      }\n    }\n\n    if (0 < c) for (d.reset(); d.next();) {\n      a = d.value, e[a.component] && --a.column;\n    }\n    if (0 > c) for (d.reset(); d.next();) {\n      c = d.value, e[c.component] && (c.column += 1);\n    }\n  }\n\n  As.prototype.commitLayout = function () {\n    if (this.setsPortSpots) for (var a = Hs(this, !0), b = Hs(this, !1), c = this.network.edges.iterator; c.next();) {\n      var d = c.value.link;\n      null !== d && (d.fromSpot = a, d.toSpot = b);\n    }\n    this.commitNodes();\n    this.nu();\n    this.isRouting && this.commitLinks();\n  };\n\n  function Hs(a, b) {\n    return 270 === a.L ? b ? ad : fd : 90 === a.L ? b ? fd : ad : 180 === a.L ? b ? dd : ed : b ? ed : dd;\n  }\n\n  As.prototype.commitNodes = function () {\n    this.ae = [];\n    this.Cd = [];\n    this.Bd = [];\n    this.Qa = [];\n\n    for (var a = 0; a <= this.wa; a++) {\n      this.ae[a] = 0, this.Cd[a] = 0, this.Bd[a] = 0, this.Qa[a] = 0;\n    }\n\n    for (a = this.network.vertexes.iterator; a.next();) {\n      var b = a.value,\n          c = b.layer;\n      this.ae[c] = Math.max(this.ae[c], this.nodeMinLayerSpace(b, !0));\n      this.Cd[c] = Math.max(this.Cd[c], this.nodeMinLayerSpace(b, !1));\n    }\n\n    b = 0;\n    c = this.be;\n\n    for (var d = 0; d <= this.wa; d++) {\n      var e = c;\n      0 >= this.ae[d] + this.Cd[d] && (e = 0);\n      0 < d && (b += e / 2);\n      90 === this.L || 0 === this.L ? (b += this.Cd[d], this.Bd[d] = b, b += this.ae[d]) : (b += this.ae[d], this.Bd[d] = b, b += this.Cd[d]);\n      d < this.wa && (b += e / 2);\n      this.Qa[d] = b;\n    }\n\n    c = b;\n    b = this.arrangementOrigin;\n\n    for (d = 0; d <= this.wa; d++) {\n      270 === this.L ? this.Bd[d] = b.y + this.Bd[d] : 90 === this.L ? (this.Bd[d] = b.y + c - this.Bd[d], this.Qa[d] = c - this.Qa[d]) : 180 === this.L ? this.Bd[d] = b.x + this.Bd[d] : (this.Bd[d] = b.x + c - this.Bd[d], this.Qa[d] = c - this.Qa[d]);\n    }\n\n    a.reset();\n\n    for (c = d = Infinity; a.next();) {\n      e = a.value;\n      var f = e.layer,\n          g = e.column | 0;\n\n      if (270 === this.L || 90 === this.L) {\n        var h = b.x + this.gc * g;\n        f = this.Bd[f];\n      } else h = this.Bd[f], f = b.y + this.gc * g;\n\n      e.centerX = h;\n      e.centerY = f;\n      d = Math.min(e.x, d);\n      c = Math.min(e.y, c);\n    }\n\n    d = b.x - d;\n    b = b.y - c;\n    this.Yc = new I(d, b);\n\n    for (a.reset(); a.next();) {\n      c = a.value, c.x += d, c.y += b, c.commit();\n    }\n  };\n\n  As.prototype.nu = function () {\n    for (var a = 0, b = this.be, c = 0; c <= this.wa; c++) {\n      a += this.ae[c], a += this.Cd[c];\n    }\n\n    a += this.wa * b;\n    b = [];\n    c = this.gc * this.Ja;\n\n    for (var d = this.maxLayer; 0 <= d; d--) {\n      270 === this.L ? 0 === d ? b.push(new M(0, 0, c, Math.abs(this.Qa[0]))) : b.push(new M(0, this.Qa[d - 1], c, Math.abs(this.Qa[d - 1] - this.Qa[d]))) : 90 === this.L ? 0 === d ? b.push(new M(0, this.Qa[0], c, Math.abs(this.Qa[0] - a))) : b.push(new M(0, this.Qa[d], c, Math.abs(this.Qa[d - 1] - this.Qa[d]))) : 180 === this.L ? 0 === d ? b.push(new M(0, 0, Math.abs(this.Qa[0]), c)) : b.push(new M(this.Qa[d - 1], 0, Math.abs(this.Qa[d - 1] - this.Qa[d]), c)) : 0 === d ? b.push(new M(this.Qa[0], 0, Math.abs(this.Qa[0] - a), c)) : b.push(new M(this.Qa[d], 0, Math.abs(this.Qa[d - 1] - this.Qa[d]), c));\n    }\n\n    this.commitLayers(b, this.Yc);\n  };\n\n  As.prototype.commitLayers = function () {};\n\n  As.prototype.commitLinks = function () {\n    for (var a = this.network.edges.iterator, b; a.next();) {\n      b = a.value.link, null !== b && (b.jh(), b.Aj(), b.pf());\n    }\n\n    for (a.reset(); a.next();) {\n      b = a.value.link, null !== b && b.mg();\n    }\n\n    for (a.reset(); a.next();) {\n      var c = a.value;\n      b = c.link;\n\n      if (null !== b) {\n        b.jh();\n        var d = b,\n            e = d.fromNode,\n            f = d.toNode,\n            g = d.fromPort,\n            h = d.toPort;\n\n        if (null !== e) {\n          var k = e.findVisibleNode();\n          null !== k && k !== e && (e = k, g = k.port);\n        }\n\n        null !== f && (k = f.findVisibleNode(), null !== k && k !== f && (f = k, h = k.port));\n        var l = b.computeSpot(!0, g);\n        k = b.computeSpot(!1, h);\n        var m = c.fromVertex,\n            n = c.toVertex;\n\n        if (c.valid) {\n          if (b.curve === cg && 4 === b.pointsCount) if (m.column === n.column) c = b.getLinkPoint(e, g, l, !0, !1, f, h), g = b.getLinkPoint(f, h, k, !1, !1, e, g), c.v() || c.set(e.actualBounds.center), g.v() || g.set(f.actualBounds.center), b.Aj(), b.mf(c.x, c.y), b.mf((2 * c.x + g.x) / 3, (2 * c.y + g.y) / 3), b.mf((c.x + 2 * g.x) / 3, (c.y + 2 * g.y) / 3), b.mf(g.x, g.y);else {\n            var p = !1,\n                r = !1;\n            null !== g && l === sc && (p = !0);\n            null !== h && k === sc && (r = !0);\n\n            if (p || r) {\n              var q = b.i(0).x;\n              c = b.i(0).y;\n              m = b.i(3).x;\n              d = b.i(3).y;\n\n              if (p) {\n                if (90 === this.L || 270 === this.L) {\n                  p = q;\n                  var u = (c + d) / 2;\n                } else p = (q + m) / 2, u = c;\n\n                b.M(1, p, u);\n                l = b.getLinkPoint(e, g, l, !0, !1, f, h);\n                l.v() || l.set(e.actualBounds.center);\n                b.M(0, l.x, l.y);\n              }\n\n              r && (90 === this.L || 270 === this.L ? (l = m, c = (c + d) / 2) : (l = (q + m) / 2, c = d), b.M(2, l, c), e = b.getLinkPoint(f, h, k, !1, !1, e, g), e.v() || e.set(f.actualBounds.center), b.M(3, e.x, e.y));\n            }\n          }\n          b.pf();\n        } else if (m.layer === n.layer) b.pf();else {\n          p = r = !1;\n          u = this.be;\n          q = b.firstPickIndex + 1;\n\n          if (b.isOrthogonal) {\n            p = !0;\n            var w = b.pointsCount;\n            4 < w && b.points.removeRange(2, w - 3);\n          } else if (b.curve === cg) r = !0, w = b.pointsCount, 4 < w && b.points.removeRange(2, w - 3), 4 === w && (q = 2);else {\n            w = b.pointsCount;\n            var v = l === sc,\n                z = k === sc;\n            2 < w && v && z ? b.points.removeRange(1, w - 2) : 3 < w && v && !z ? b.points.removeRange(1, w - 3) : 3 < w && !v && z ? b.points.removeRange(2, w - 2) : 4 < w && !v && !z && b.points.removeRange(2, w - 3);\n          }\n\n          if (c.rev) {\n            for (; null !== n && m !== n;) {\n              var y = w = null;\n\n              for (v = n.sourceEdges.iterator; v.next() && (z = v.value, z.link !== c.link || (w = z.fromVertex, y = z.toVertex, null !== w.node));) {\n                ;\n              }\n\n              if (null === w) break;\n\n              if (w !== m) {\n                v = b.i(q - 1).x;\n                z = b.i(q - 1).y;\n                var A = w.centerX;\n                var B = w.centerY;\n                if (p) 180 === this.L || 0 === this.L ? q === b.firstPickIndex + 1 ? (b.l(q++, v, z), b.l(q++, v, B)) : (null !== y ? y.centerY : z) !== B && (y = this.Qa[w.layer - 1] + this.Yc.x, b.l(q++, y, z), b.l(q++, y, B)) : q === b.firstPickIndex + 1 ? (b.l(q++, v, z), b.l(q++, A, z)) : (null !== y ? y.centerX : v) !== A && (y = this.Qa[w.layer - 1] + this.Yc.y, b.l(q++, v, y), b.l(q++, A, y));else if (q === b.firstPickIndex + 1) {\n                  y = Math.max(10, this.ae[n.layer]);\n                  var F = Math.max(10, this.Cd[n.layer]);\n                  if (r) 180 === this.L ? A <= n.bounds.x ? (n = n.bounds.x, b.l(q++, n - y, B), b.l(q++, n, B), b.l(q++, n + F, B)) : (b.l(q++, A - y, B), b.l(q++, A, B), b.l(q++, A + F, B)) : 90 === this.L ? B >= n.bounds.bottom ? (n = n.bounds.y + n.bounds.height, b.l(q++, A, n + F), b.l(q++, A, n), b.l(q++, A, n - y)) : (b.l(q++, A, B + F), b.l(q++, A, B), b.l(q++, A, B - y)) : 270 === this.L ? B <= n.bounds.y ? (n = n.bounds.y, b.l(q++, A, n - y), b.l(q++, A, n), b.l(q++, A, n + F)) : (b.l(q++, A, B - y), b.l(q++, A, B), b.l(q++, A, B + F)) : 0 === this.L && (A >= n.bounds.right ? (n = n.bounds.x + n.bounds.width, b.l(q++, n + F, B), b.l(q++, n, B), b.l(q++, n - y, B)) : (b.l(q++, A + F, B), b.l(q++, A, B), b.l(q++, A - y, B)));else {\n                    b.l(q++, v, z);\n                    var L = 0;\n\n                    if (180 === this.L || 0 === this.L) {\n                      if (180 === this.L ? A >= n.bounds.right : A <= n.bounds.x) L = (0 === this.L ? -y : F) / 2;\n                      b.l(q++, v + L, B);\n                    } else {\n                      if (270 === this.L ? B >= n.bounds.bottom : B <= n.bounds.y) L = (90 === this.L ? -y : F) / 2;\n                      b.l(q++, A, z + L);\n                    }\n\n                    b.l(q++, A, B);\n                  }\n                } else y = Math.max(10, this.ae[w.layer]), F = Math.max(10, this.Cd[w.layer]), r ? 180 === this.L ? (b.l(q++, A - y - u, B), b.l(q++, Math.min(A - y + u / 2, A), B), b.l(q++, A, B), b.l(q++, A, B), b.l(q++, Math.max(A + F - u / 2, A), B), b.l(q++, A + F + u, B)) : 90 === this.L ? (b.l(q++, A, B + F + u), b.l(q++, A, Math.max(B + F - u / 2, B)), b.l(q++, A, B), b.l(q++, A, B), b.l(q++, A, Math.min(B - y + u / 2, B)), b.l(q++, A, B - y - u)) : 270 === this.L ? (b.l(q++, A, B - y - u), b.l(q++, A, Math.min(B - y + u / 2, B)), b.l(q++, A, B), b.l(q++, A, B), b.l(q++, A, Math.max(B + F - u / 2, B)), b.l(q++, A, B + F + u)) : (b.l(q++, A + F + u, B), b.l(q++, Math.max(A + F - u / 2, A), B), b.l(q++, A, B), b.l(q++, A, B), b.l(q++, Math.min(A - y + u / 2, A), B), b.l(q++, A - y - u, B)) : b.l(q++, A, B);\n              }\n\n              n = w;\n            }\n\n            if (null === h || l !== sc || p) if (v = b.i(q - 1).x, z = b.i(q - 1).y, A = b.i(q).x, B = b.i(q).y, p) u = this.Cd[m.layer], 180 === this.L || 0 === this.L ? (p = z, p >= m.bounds.y && p <= m.bounds.bottom && (180 === this.L ? A >= m.bounds.x : A <= m.bounds.right) && (n = m.centerX + (180 === this.L ? -u : u), p < m.bounds.y + m.bounds.height / 2 ? p = m.bounds.y - this.gc / 2 : p = m.bounds.bottom + this.gc / 2, b.l(q++, n, z), b.l(q++, n, p)), b.l(q++, A, p)) : (p = v, p >= m.bounds.x && p <= m.bounds.right && (270 === this.L ? B >= m.bounds.y : B <= m.bounds.bottom) && (n = m.centerY + (270 === this.L ? -u : u), p < m.bounds.x + m.bounds.width / 2 ? p = m.bounds.x - this.gc / 2 : p = m.bounds.right + this.gc / 2, b.l(q++, v, n), b.l(q++, p, n)), b.l(q++, p, B)), b.l(q++, A, B);else if (r) y = Math.max(10, this.ae[m.layer]), F = Math.max(10, this.Cd[m.layer]), 180 === this.L && A >= m.bounds.x ? (n = m.bounds.x + m.bounds.width, b.M(q - 2, n, z), b.M(q - 1, n + F, z)) : 90 === this.L && B <= m.bounds.bottom ? (n = m.bounds.y, b.M(q - 2, v, n), b.M(q - 1, v, n - y)) : 270 === this.L && B >= m.bounds.y ? (n = m.bounds.y + m.bounds.height, b.M(q - 2, v, n), b.M(q - 1, v, n + F)) : 0 === this.L && A <= m.bounds.right && (n = m.bounds.x, b.M(q - 2, n, z), b.M(q - 1, n - y, z));else {\n              y = Math.max(10, this.ae[m.layer]);\n              F = Math.max(10, this.Cd[m.layer]);\n              p = 0;\n\n              if (180 === this.L || 0 === this.L) {\n                if (180 === this.L ? A <= m.bounds.x : A >= m.bounds.right) p = (0 === this.L ? F : -y) / 2;\n                b.l(q++, A + p, z);\n              } else {\n                if (270 === this.L ? B <= m.bounds.y : B >= m.bounds.bottom) p = (90 === this.L ? F : -y) / 2;\n                b.l(q++, v, B + p);\n              }\n\n              b.l(q++, A, B);\n            }\n          } else {\n            for (; null !== m && m !== n;) {\n              y = w = null;\n\n              for (m = m.destinationEdges.iterator; m.next() && (v = m.value, v.link !== c.link || (w = v.toVertex, y = v.fromVertex, null !== y.node && (y = null), null !== w.node));) {\n                ;\n              }\n\n              if (null === w) break;\n              w !== n && (v = b.i(q - 1).x, z = b.i(q - 1).y, A = w.centerX, B = w.centerY, p ? 180 === this.L || 0 === this.L ? (null !== y ? y.centerY : z) !== B && (y = this.Qa[w.layer] + this.Yc.x, q === b.firstPickIndex + 1 && (y = 0 === this.L ? Math.max(y, v) : Math.min(y, v)), b.l(q++, y, z), b.l(q++, y, B)) : (null !== y ? y.centerX : v) !== A && (y = this.Qa[w.layer] + this.Yc.y, q === b.firstPickIndex + 1 && (y = 90 === this.L ? Math.max(y, z) : Math.min(y, z)), b.l(q++, v, y), b.l(q++, A, y)) : (y = Math.max(10, this.ae[w.layer]), F = Math.max(10, this.Cd[w.layer]), r ? 180 === this.L ? (b.l(q++, A + F + u, B), b.l(q++, Math.max(A + F - u / 2, A), B), b.l(q++, A, B), b.l(q++, A, B), b.l(q++, Math.min(A - y + u / 2, A), B), b.l(q++, A - y - u, B)) : 90 === this.L ? (b.l(q++, A, B - y - u), b.l(q++, A, Math.min(B - y + u / 2, B)), b.l(q++, A, B), b.l(q++, A, B), b.l(q++, A, Math.max(B + F - u / 2, B)), b.l(q++, A, B + F + u)) : 270 === this.L ? (b.l(q++, A, B + F + u), b.l(q++, A, Math.max(B + F - u / 2, B)), b.l(q++, A, B), b.l(q++, A, B), b.l(q++, A, Math.min(B - y + u / 2, B)), b.l(q++, A, B - y - u)) : (b.l(q++, A - y - u, B), b.l(q++, Math.min(A - y + u / 2, A), B), b.l(q++, A, B), b.l(q++, A, B), b.l(q++, Math.max(A + F - u / 2, A), B), b.l(q++, A + F + u, B)) : 180 === this.L ? (b.l(q++, A + F, B), b.l(q++, A - y, B)) : 90 === this.L ? (b.l(q++, A, B - y), b.l(q++, A, B + F)) : 270 === this.L ? (b.l(q++, A, B + F), b.l(q++, A, B - y)) : (b.l(q++, A - y, B), b.l(q++, A + F, B))));\n              m = w;\n            }\n\n            p && (v = b.i(q - 1).x, z = b.i(q - 1).y, A = b.i(q).x, B = b.i(q).y, 180 === this.L || 0 === this.L ? z !== B && (y = 0 === this.L ? Math.min(Math.max((A + v) / 2, this.Qa[n.layer] + this.Yc.x), A) : Math.max(Math.min((A + v) / 2, this.Qa[n.layer] + this.Yc.x), A), b.l(q++, y, z), b.l(q++, y, B)) : v !== A && (y = 90 === this.L ? Math.min(Math.max((B + z) / 2, this.Qa[n.layer] + this.Yc.y), B) : Math.max(Math.min((B + z) / 2, this.Qa[n.layer] + this.Yc.y), B), b.l(q++, v, y), b.l(q++, A, y)));\n          }\n\n          null !== d && r && (null !== g && (l === sc && (l = b.i(0), d = b.i(2), l.C(d) || b.M(1, (l.x + d.x) / 2, (l.y + d.y) / 2)), l = b.getLinkPoint(e, g, sc, !0, !1, f, h), l.v() || l.set(e.actualBounds.center), b.M(0, l.x, l.y)), null !== h && (k === sc && (k = b.i(b.pointsCount - 1), l = b.i(b.pointsCount - 3), k.C(l) || b.M(b.pointsCount - 2, (k.x + l.x) / 2, (k.y + l.y) / 2)), e = b.getLinkPoint(f, h, sc, !1, !1, e, g), e.v() || e.set(f.actualBounds.center), b.M(b.pointsCount - 1, e.x, e.y)));\n          b.pf();\n          c.commit();\n        }\n      }\n    }\n\n    this.avoidOrthogonalOverlaps();\n  };\n\n  As.prototype.avoidOrthogonalOverlaps = function () {\n    if (!(0 >= this.linkSpacing)) {\n      for (var a = new E(), b = this.network.edges.iterator; b.next();) {\n        var c = b.value.link;\n        null !== c && c.isOrthogonal && !a.contains(c) && a.add(c);\n      }\n\n      if (0 < a.count) if (90 === this.L || 270 === this.L) {\n        b = 0;\n        c = [];\n\n        for (a = a.iterator; a.next();) {\n          var d = a.value;\n          if (null !== d && d.isOrthogonal) for (var e = 2; e < d.pointsCount - 3; e++) {\n            var f = d.i(e);\n            var g = d.i(e + 1);\n\n            if (this.B(f.y, g.y) && !this.B(f.x, g.x)) {\n              var h = new ut();\n              h.layer = Math.floor(f.y / 2);\n              var k = d.i(0),\n                  l = d.i(d.pointsCount - 1);\n              h.first = k.x * k.x + k.y;\n              h.fc = l.x * l.x + l.y;\n              h.ld = Math.min(f.x, g.x);\n              h.Bc = Math.max(f.x, g.x);\n              h.index = e;\n              h.link = d;\n\n              if (e + 2 < d.pointsCount) {\n                k = d.i(e - 1);\n                l = d.i(e + 2);\n                var m = 0;\n                k.y < f.y ? m = l.y < f.y ? 3 : f.x < g.x ? 2 : 1 : k.y > f.y && (m = l.y > f.y ? 0 : g.x < f.x ? 2 : 1);\n                h.j = m;\n              }\n\n              c.push(h);\n            }\n          }\n        }\n\n        if (1 < c.length) for (c.sort(this.Cx), a = 0; a < c.length;) {\n          f = c[a].layer;\n\n          for (d = a + 1; d < c.length && c[d].layer === f;) {\n            d++;\n          }\n\n          if (1 < d - a) for (f = a; f < d;) {\n            g = c[f].Bc;\n\n            for (e = a + 1; e < d && c[e].ld < g;) {\n              g = Math.max(g, c[e].Bc), e++;\n            }\n\n            g = e - f;\n\n            if (1 < g) {\n              this.ri(c, this.js, f, f + g);\n              m = 1;\n              h = c[f].fc;\n\n              for (k = f; k < e; k++) {\n                l = c[k], l.fc !== h && (m++, h = l.fc);\n              }\n\n              this.ri(c, this.Bx, f, f + g);\n              var n = 1;\n              h = c[f].first;\n\n              for (k = f; k < e; k++) {\n                l = c[k], l.first !== h && (n++, h = l.first);\n              }\n\n              k = !0;\n              l = n;\n              m < n ? (k = !1, l = m, h = c[f].fc, this.ri(c, this.js, f, f + g)) : h = c[f].first;\n              m = 0;\n\n              for (n = f; n < e; n++) {\n                var p = c[n];\n                (k ? p.first : p.fc) !== h && (m++, h = k ? p.first : p.fc);\n                var r = p.link;\n                f = r.i(p.index);\n                g = r.i(p.index + 1);\n                var q = this.linkSpacing * (m - (l - 1) / 2);\n                b++;\n                r.jh();\n                r.M(p.index, f.x, f.y + q);\n                r.M(p.index + 1, g.x, g.y + q);\n                r.pf();\n              }\n            }\n\n            f = e;\n          }\n          a = d;\n        }\n      } else {\n        b = 0;\n        c = [];\n\n        for (a = a.iterator; a.next();) {\n          if (d = a.value, null !== d && d.isOrthogonal) for (e = 2; e < d.pointsCount - 3; e++) {\n            f = d.i(e), g = d.i(e + 1), this.B(f.x, g.x) && !this.B(f.y, g.y) && (h = new ut(), h.layer = Math.floor(f.x / 2), k = d.i(0), l = d.i(d.pointsCount - 1), h.first = k.x + k.y * k.y, h.fc = l.x + l.y * l.y, h.ld = Math.min(f.y, g.y), h.Bc = Math.max(f.y, g.y), h.index = e, h.link = d, e + 2 < d.pointsCount && (k = d.i(e - 1), l = d.i(e + 2), m = 0, k.x < f.x ? m = l.x < f.x ? 3 : f.y < g.y ? 2 : 1 : k.x > f.x && (m = l.x > f.x ? 0 : g.y < f.y ? 2 : 1), h.j = m), c.push(h));\n          }\n        }\n\n        if (1 < c.length) for (c.sort(this.Cx), a = 0; a < c.length;) {\n          f = c[a].layer;\n\n          for (d = a + 1; d < c.length && c[d].layer === f;) {\n            d++;\n          }\n\n          if (1 < d - a) for (f = a; f < d;) {\n            g = c[f].Bc;\n\n            for (e = a + 1; e < d && c[e].ld < g;) {\n              g = Math.max(g, c[e].Bc), e++;\n            }\n\n            g = e - f;\n\n            if (1 < g) {\n              this.ri(c, this.js, f, f + g);\n              m = 1;\n              h = c[f].fc;\n\n              for (k = f; k < e; k++) {\n                l = c[k], l.fc !== h && (m++, h = l.fc);\n              }\n\n              this.ri(c, this.Bx, f, f + g);\n              n = 1;\n              h = c[f].first;\n\n              for (k = f; k < e; k++) {\n                l = c[k], l.first !== h && (n++, h = l.first);\n              }\n\n              k = !0;\n              l = n;\n              m < n ? (k = !1, l = m, h = c[f].fc, this.ri(c, this.js, f, f + g)) : h = c[f].first;\n              m = 0;\n\n              for (n = f; n < e; n++) {\n                p = c[n], (k ? p.first : p.fc) !== h && (m++, h = k ? p.first : p.fc), r = p.link, f = r.i(p.index), g = r.i(p.index + 1), q = this.linkSpacing * (m - (l - 1) / 2), b++, r.jh(), r.M(p.index, f.x + q, f.y), r.M(p.index + 1, g.x + q, g.y), r.pf();\n              }\n            }\n\n            f = e;\n          }\n          a = d;\n        }\n      }\n    }\n  };\n\n  t = As.prototype;\n\n  t.Cx = function (a, b) {\n    return a instanceof ut && b instanceof ut && a !== b ? a.layer < b.layer ? -1 : a.layer > b.layer ? 1 : a.ld < b.ld ? -1 : a.ld > b.ld ? 1 : a.Bc < b.Bc ? -1 : a.Bc > b.Bc ? 1 : 0 : 0;\n  };\n\n  t.Bx = function (a, b) {\n    return a instanceof ut && b instanceof ut && a !== b ? a.first < b.first ? -1 : a.first > b.first || a.j < b.j ? 1 : a.j > b.j || a.ld < b.ld ? -1 : a.ld > b.ld ? 1 : a.Bc < b.Bc ? -1 : a.Bc > b.Bc ? 1 : 0 : 0;\n  };\n\n  t.js = function (a, b) {\n    return a instanceof ut && b instanceof ut && a !== b ? a.fc < b.fc ? -1 : a.fc > b.fc || a.j < b.j ? 1 : a.j > b.j || a.ld < b.ld ? -1 : a.ld > b.ld ? 1 : a.Bc < b.Bc ? -1 : a.Bc > b.Bc ? 1 : 0 : 0;\n  };\n\n  t.B = function (a, b) {\n    a -= b;\n    return -1 < a && 1 > a;\n  };\n\n  t.ri = function (a, b, c, d) {\n    var e = a.length,\n        f = d - c;\n    if (!(1 >= f)) if ((0 > c || c >= e - 1) && C(\"not in range 0 <= from < length: \" + c), 2 === f) d = a[c], e = a[c + 1], 0 < b(d, e) && (a[c] = e, a[c + 1] = d);else if (0 === c) {\n      if (d >= e) a.sort(b);else for (c = a.slice(0, d), c.sort(b), b = 0; b < d; b++) {\n        a[b] = c[b];\n      }\n    } else if (d >= e) for (d = a.slice(c), d.sort(b), b = c; b < e; b++) {\n      a[b] = d[b - c];\n    } else for (e = a.slice(c, d), e.sort(b), b = c; b < d; b++) {\n      a[b] = e[b - c];\n    }\n  };\n\n  function Js(a, b) {\n    var c = a.Hb[b];\n\n    if (c >= a.we.length) {\n      var d = [];\n\n      for (var e = 0; e < a.we.length; e++) {\n        d[e] = a.we[e];\n      }\n\n      a.we = d;\n    }\n\n    void 0 === a.we[c] || null === a.we[c] ? d = [] : (d = a.we[c], a.we[c] = null);\n    a = a.rn[b];\n\n    for (b = 0; b < a.length; b++) {\n      c = a[b], d[c.index] = c;\n    }\n\n    return d;\n  }\n\n  function Ks(a, b, c) {\n    a.we[a.Hb[b]] = c;\n  }\n\n  ma.Object.defineProperties(As.prototype, {\n    layerSpacing: {\n      get: function get() {\n        return this.be;\n      },\n      set: function set(a) {\n        this.be !== a && 0 <= a && (this.be = a, this.D());\n      }\n    },\n    columnSpacing: {\n      get: function get() {\n        return this.gc;\n      },\n      set: function set(a) {\n        this.gc !== a && 0 < a && (this.gc = a, this.D());\n      }\n    },\n    direction: {\n      get: function get() {\n        return this.L;\n      },\n      set: function set(a) {\n        this.L !== a && (0 === a || 90 === a || 180 === a || 270 === a ? (this.L = a, this.D()) : C(\"LayeredDigraphLayout.direction must be 0, 90, 180, or 270\"));\n      }\n    },\n    cycleRemoveOption: {\n      get: function get() {\n        return this.rk;\n      },\n      set: function set(a) {\n        this.rk === a || a !== Us && a !== Bs && a !== Gs || (this.rk = a, this.D());\n      }\n    },\n    layeringOption: {\n      get: function get() {\n        return this.Ok;\n      },\n      set: function set(a) {\n        this.Ok === a || a !== Cs && a !== Zs && a !== at || (this.Ok = a, this.D());\n      }\n    },\n    initializeOption: {\n      get: function get() {\n        return this.Fk;\n      },\n      set: function set(a) {\n        this.Fk === a || a !== Ds && a !== gt && a !== et || (this.Fk = a, this.D());\n      }\n    },\n    iterations: {\n      get: function get() {\n        return this.Xi;\n      },\n      set: function set(a) {\n        this.Xi !== a && 0 <= a && (this.Xi = a, this.D());\n      }\n    },\n    aggressiveOption: {\n      get: function get() {\n        return this.ek;\n      },\n      set: function set(a) {\n        this.ek === a || a !== kt && a !== Es && a !== lt || (this.ek = a, this.D());\n      }\n    },\n    packOption: {\n      get: function get() {\n        return this.Tf;\n      },\n      set: function set(a) {\n        this.Tf !== a && 0 <= a && 8 > a && (this.Tf = a, this.D());\n      }\n    },\n    setsPortSpots: {\n      get: function get() {\n        return this.ff;\n      },\n      set: function set(a) {\n        this.ff !== a && (this.ff = a, this.D());\n      }\n    },\n    linkSpacing: {\n      get: function get() {\n        return this.jn;\n      },\n      set: function set(a) {\n        this.jn !== a && 0 <= a && (this.jn = a, this.D());\n      }\n    },\n    maxLayer: {\n      get: function get() {\n        return this.wa;\n      }\n    },\n    maxIndex: {\n      get: function get() {\n        return this.Dh;\n      }\n    },\n    maxColumn: {\n      get: function get() {\n        return this.Ja;\n      }\n    },\n    minIndexLayer: {\n      get: function get() {\n        return this.Bg;\n      }\n    },\n    maxIndexLayer: {\n      get: function get() {\n        return this.zc;\n      }\n    }\n  });\n  var Bs = new D(As, \"CycleDepthFirst\", 0),\n      Us = new D(As, \"CycleGreedy\", 1),\n      Gs = new D(As, \"CycleFromLayers\", 2),\n      Cs = new D(As, \"LayerOptimalLinkLength\", 0),\n      Zs = new D(As, \"LayerLongestPathSink\", 1),\n      at = new D(As, \"LayerLongestPathSource\", 2),\n      Ds = new D(As, \"InitDepthFirstOut\", 0),\n      gt = new D(As, \"InitDepthFirstIn\", 1),\n      et = new D(As, \"InitNaive\", 2),\n      kt = new D(As, \"AggressiveNone\", 0),\n      Es = new D(As, \"AggressiveLess\", 1),\n      lt = new D(As, \"AggressiveMore\", 2),\n      mt = 8;\n  As.className = \"LayeredDigraphLayout\";\n  As.CycleDepthFirst = Bs;\n  As.CycleGreedy = Us;\n  As.CycleFromLayers = Gs;\n  As.LayerOptimalLinkLength = Cs;\n  As.LayerLongestPathSink = Zs;\n  As.LayerLongestPathSource = at;\n  As.InitDepthFirstOut = Ds;\n  As.InitDepthFirstIn = gt;\n  As.InitNaive = et;\n  As.AggressiveNone = kt;\n  As.AggressiveLess = Es;\n  As.AggressiveMore = lt;\n  As.PackNone = 0;\n  As.PackExpand = 1;\n  As.PackStraighten = 2;\n  As.PackMedian = 4;\n  As.PackAll = 15;\n\n  function ut() {\n    this.index = this.Bc = this.ld = this.fc = this.first = this.layer = 0;\n    this.link = null;\n    this.j = 0;\n  }\n\n  ut.className = \"SegInfo\";\n\n  function Fs(a) {\n    dq.call(this, a);\n  }\n\n  la(Fs, dq);\n\n  Fs.prototype.createVertex = function () {\n    return new vt(this);\n  };\n\n  Fs.prototype.createEdge = function () {\n    return new wt(this);\n  };\n\n  Fs.className = \"LayeredDigraphNetwork\";\n\n  function vt(a) {\n    rq.call(this, a);\n    this.Wa = this.rg = this.Ah = -1;\n    this.u = NaN;\n    this.F = null;\n    this.valid = !1;\n    this.finish = this.gg = NaN;\n    this.nf = 0;\n    this.Tj = this.Uj = null;\n  }\n\n  la(vt, rq);\n\n  vt.prototype.serializeVertexProperties = function (a, b) {\n    rq.prototype.serializeVertexProperties.call(this, a, b);\n    a.layer = this.layer;\n    a.column = this.column;\n    a.index = this.index;\n    a.component = this.component;\n    a.near = this.near ? cb(this.near) : null;\n    a.valid = this.valid;\n    a.gg = this.gg;\n    a.finish = this.finish;\n    a.nf = this.nf;\n    a.Uj = this.Uj;\n    a.Tj = this.Tj;\n  };\n\n  vt.prototype.deserializeVertexProperties = function (a, b, c, d) {\n    rq.prototype.deserializeVertexProperties.call(this, a, b, c, d);\n    this.layer = a.layer;\n    this.column = a.column;\n    this.index = a.index;\n    this.component = a.component;\n    if (b = b.get(a.near)) this.near = b;\n    this.valid = a.valid;\n    this.gg = a.gg;\n    this.finish = a.finish;\n    this.nf = a.nf;\n    this.Uj = a.Uj;\n    this.Tj = a.Tj;\n  };\n\n  ma.Object.defineProperties(vt.prototype, {\n    layer: {\n      get: function get() {\n        return this.Ah;\n      },\n      set: function set(a) {\n        this.Ah !== a && (this.Ah = a);\n      }\n    },\n    column: {\n      get: function get() {\n        return this.rg;\n      },\n      set: function set(a) {\n        this.rg !== a && (this.rg = a);\n      }\n    },\n    index: {\n      get: function get() {\n        return this.Wa;\n      },\n      set: function set(a) {\n        this.Wa !== a && (this.Wa = a);\n      }\n    },\n    component: {\n      get: function get() {\n        return this.u;\n      },\n      set: function set(a) {\n        this.u !== a && (this.u = a);\n      }\n    },\n    near: {\n      get: function get() {\n        return this.F;\n      },\n      set: function set(a) {\n        this.F !== a && (this.F = a);\n      }\n    }\n  });\n  vt.className = \"LayeredDigraphVertex\";\n\n  function wt(a) {\n    sq.call(this, a);\n    this.j = this.ga = this.Ga = !1;\n    this.W = this.u = NaN;\n    this.F = this.m = 0;\n  }\n\n  la(wt, sq);\n\n  wt.prototype.serializeEdgeProperties = function (a, b) {\n    sq.prototype.serializeEdgeProperties.call(this, a, b);\n    a.valid = this.valid;\n    a.rev = this.rev;\n    a.forest = this.forest;\n    a.portFromPos = this.portFromPos;\n    a.portToPos = this.portToPos;\n    a.portFromColOffset = this.portFromColOffset;\n    a.portToColOffset = this.portToColOffset;\n  };\n\n  wt.prototype.deserializeEdgeProperties = function (a, b, c, d) {\n    sq.prototype.deserializeEdgeProperties.call(this, a, b, c, d);\n    this.valid = a.valid;\n    this.rev = a.rev;\n    this.forest = a.forest;\n    this.portFromPos = a.portFromPos;\n    this.portToPos = a.portToPos;\n    this.portFromColOffset = a.portFromColOffset;\n    this.portToColOffset = a.portToColOffset;\n  };\n\n  ma.Object.defineProperties(wt.prototype, {\n    fromVertex: {\n      get: function get() {\n        return this.ad;\n      },\n      set: function set(a) {\n        this.ad !== a && (this.ad = a);\n      }\n    },\n    toVertex: {\n      get: function get() {\n        return this.jd;\n      },\n      set: function set(a) {\n        this.jd !== a && (this.jd = a);\n      }\n    },\n    valid: {\n      get: function get() {\n        return this.Ga;\n      },\n      set: function set(a) {\n        this.Ga !== a && (this.Ga = a);\n      }\n    },\n    rev: {\n      get: function get() {\n        return this.ga;\n      },\n      set: function set(a) {\n        this.ga !== a && (this.ga = a);\n      }\n    },\n    forest: {\n      get: function get() {\n        return this.j;\n      },\n      set: function set(a) {\n        this.j !== a && (this.j = a);\n      }\n    },\n    portFromPos: {\n      get: function get() {\n        return this.u;\n      },\n      set: function set(a) {\n        this.u !== a && (this.u = a);\n      }\n    },\n    portToPos: {\n      get: function get() {\n        return this.W;\n      },\n      set: function set(a) {\n        this.W !== a && (this.W = a);\n      }\n    },\n    portFromColOffset: {\n      get: function get() {\n        return this.m;\n      },\n      set: function set(a) {\n        this.m !== a && (this.m = a);\n      }\n    },\n    portToColOffset: {\n      get: function get() {\n        return this.F;\n      },\n      set: function set(a) {\n        this.F !== a && (this.F = a);\n      }\n    }\n  });\n  wt.className = \"LayeredDigraphEdge\";\n\n  function xt(a) {\n    qi.call(this);\n    this.Qb = new G();\n    this.En = yt;\n    this.qd = zt;\n    this.Yn = At;\n    this.aq = Bt;\n    this.Ev = [];\n    this.od = !0;\n    this.Nb = Ct;\n    this.Td = new K(10, 10).freeze();\n    var b = new Dt(this);\n    this.V = new Et(b);\n    this.Y = new Et(b);\n    this.Xt = [];\n    a && Object.assign(this, a);\n  }\n\n  la(xt, qi);\n\n  xt.prototype.cloneProtected = function (a) {\n    qi.prototype.cloneProtected.call(this, a);\n    a.En = this.En;\n    a.Yn = this.Yn;\n    a.aq = this.aq;\n    a.od = this.od;\n    a.Nb = this.Nb;\n    a.Td.assign(this.Td);\n    a.V.copyInheritedPropertiesFrom(this.V);\n    a.Y.copyInheritedPropertiesFrom(this.Y);\n  };\n\n  xt.prototype.ob = function (a) {\n    a.classType === xt ? 0 === a.name.indexOf(\"Alignment\") ? this.alignment = a : 0 === a.name.indexOf(\"Arrangement\") ? this.arrangement = a : 0 === a.name.indexOf(\"Compaction\") ? this.compaction = a : 0 === a.name.indexOf(\"Path\") ? this.path = a : 0 === a.name.indexOf(\"Sorting\") ? this.sorting = a : 0 === a.name.indexOf(\"Style\") ? this.treeStyle = a : C(\"Unknown enum value: \" + a) : qi.prototype.ob.call(this, a);\n  };\n\n  xt.prototype.createNetwork = function () {\n    return new Dt(this);\n  };\n\n  xt.prototype.makeNetwork = function (a) {\n    function b(a) {\n      if (a instanceof V) return !a.isLinkLabel && \"Comment\" !== a.category;\n\n      if (a instanceof T) {\n        var b = a.fromNode;\n        if (null === b || b.isLinkLabel || \"Comment\" === b.category) return !1;\n        a = a.toNode;\n        return null === a || a.isLinkLabel || \"Comment\" === a.category ? !1 : !0;\n      }\n\n      return !1;\n    }\n\n    var c = this.createNetwork();\n    a instanceof Q ? (c.eg(a.nodes, !0, b), c.eg(a.links, !0, b)) : a instanceof qf ? c.eg(a.memberParts, !1, b) : c.eg(a.iterator, !1, b);\n    return c;\n  };\n\n  xt.prototype.doLayout = function (a) {\n    null === this.network && (this.network = this.makeNetwork(a));\n    this.arrangement !== Ft && (this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin));\n    var b = this.diagram;\n    null === b && a instanceof Q && (b = a);\n    this.path === yt && null !== b ? this.qd = b.isTreePathToChildren ? zt : Gt : this.qd = this.path === yt ? zt : this.path;\n\n    if (0 < this.network.vertexes.count) {\n      this.network.oo();\n\n      for (a = this.network.vertexes.iterator; a.next();) {\n        b = a.value, b.initialized = !1, b.level = 0, b.parent = null, b.children = [];\n      }\n\n      if (0 < this.Qb.count) {\n        a = new G();\n\n        for (b = this.Qb.iterator; b.next();) {\n          var c = b.value;\n          c instanceof V ? (c = this.network.ei(c), null !== c && a.add(c)) : c instanceof Et && a.add(c);\n        }\n\n        this.Qb = a;\n      }\n\n      0 === this.Qb.count && this.findRoots();\n\n      for (a = this.Qb.copy().iterator; a.next();) {\n        b = a.value, b.initialized || (b.initialized = !0, Ht(this, b));\n      }\n\n      b = this.network.vertexes;\n\n      for (a = null; a = It(b), 0 < a.count;) {\n        b = Jt(this, a), null !== b && this.Qb.add(b), b.initialized = !0, Ht(this, b), b = a;\n      }\n\n      for (a = this.Qb.iterator; a.next();) {\n        b = a.value, b instanceof Et && Kt(this, b);\n      }\n\n      for (a = this.Qb.iterator; a.next();) {\n        b = a.value, b instanceof Et && Lt(this, b);\n      }\n\n      for (a = this.Qb.iterator; a.next();) {\n        b = a.value, b instanceof Et && Mt(this, b);\n      }\n\n      this.ju();\n\n      if (this.layerStyle === Nt) {\n        a = [];\n\n        for (b = this.network.vertexes.iterator; b.next();) {\n          c = b.value;\n          var d = c.parent;\n          null === d && (d = c);\n          d = 0 === d.angle || 180 === d.angle;\n          var e = a[c.level];\n          void 0 === e && (e = 0);\n          a[c.level] = Math.max(e, d ? c.width : c.height);\n        }\n\n        for (b = 0; b < a.length; b++) {\n          void 0 === a[b] && (a[b] = 0);\n        }\n\n        this.Ev = a;\n\n        for (b = this.network.vertexes.iterator; b.next();) {\n          c = b.value, d = c.parent, null === d && (d = c), 0 === d.angle || 180 === d.angle ? (180 === d.angle && (c.focusX += a[c.level] - c.width), c.width = a[c.level]) : (270 === d.angle && (c.focusY += a[c.level] - c.height), c.height = a[c.level]);\n        }\n      } else if (this.layerStyle === Ot) for (a = this.network.vertexes.iterator; a.next();) {\n        b = a.value;\n        c = 0 === b.angle || 180 === b.angle;\n        d = -1;\n\n        for (e = 0; e < b.children.length; e++) {\n          var f = b.children[e];\n          d = Math.max(d, c ? f.width : f.height);\n        }\n\n        if (0 <= d) for (e = 0; e < b.children.length; e++) {\n          f = b.children[e], c ? (180 === b.angle && (f.focusX += d - f.width), f.width = d) : (270 === b.angle && (f.focusY += d - f.height), f.height = d);\n        }\n      }\n\n      for (a = this.Qb.iterator; a.next();) {\n        b = a.value, b instanceof Et && this.layoutTree(b);\n      }\n\n      this.arrangeTrees();\n      this.updateParts();\n    }\n\n    this.network = null;\n    this.Qb = new G();\n    this.isValidLayout = !0;\n  };\n\n  function It(a) {\n    var b = new G();\n\n    for (a = a.iterator; a.next();) {\n      var c = a.value;\n      c.initialized || b.add(c);\n    }\n\n    return b;\n  }\n\n  xt.prototype.findRoots = function () {\n    for (var a = this.network.vertexes, b = a.iterator; b.next();) {\n      var c = b.value;\n\n      switch (this.qd) {\n        case zt:\n          0 === c.sourceEdges.count && this.Qb.add(c);\n          break;\n\n        case Gt:\n          0 === c.destinationEdges.count && this.Qb.add(c);\n          break;\n\n        default:\n          C(\"Unhandled path value \" + this.qd.toString());\n      }\n    }\n\n    0 === this.Qb.count && (a = Jt(this, a), null !== a && this.Qb.add(a));\n  };\n\n  function Jt(a, b) {\n    var c = 999999,\n        d = null;\n\n    for (b = b.iterator; b.next();) {\n      var e = b.value;\n\n      switch (a.qd) {\n        case zt:\n          e.sourceEdges.count < c && (c = e.sourceEdges.count, d = e);\n          break;\n\n        case Gt:\n          e.destinationEdges.count < c && (c = e.destinationEdges.count, d = e);\n          break;\n\n        default:\n          C(\"Unhandled path value \" + a.qd.toString());\n      }\n    }\n\n    return d;\n  }\n\n  function Ht(a, b) {\n    if (null !== b) {\n      switch (a.qd) {\n        case zt:\n          if (0 < b.destinationEdges.count) {\n            for (var c = new E(), d = b.destinationVertexes; d.next();) {\n              var e = d.value;\n              Pt(a, b, e) && c.add(e);\n            }\n\n            0 < c.count && (b.children = c.Ea());\n          }\n\n          break;\n\n        case Gt:\n          if (0 < b.sourceEdges.count) {\n            c = new E();\n\n            for (d = b.sourceVertexes; d.next();) {\n              e = d.value, Pt(a, b, e) && c.add(e);\n            }\n\n            0 < c.count && (b.children = c.Ea());\n          }\n\n          break;\n\n        default:\n          C(\"Unhandled path value\" + a.qd.toString());\n      }\n\n      c = b.children;\n      d = c.length;\n\n      for (e = 0; e < d; e++) {\n        var f = c[e];\n        f.initialized = !0;\n        f.level = b.level + 1;\n        f.parent = b;\n        a.Qb.remove(f);\n      }\n\n      for (b = 0; b < d; b++) {\n        Ht(a, c[b]);\n      }\n    }\n  }\n\n  function Pt(a, b, c) {\n    if (c.initialized) {\n      if (null === b) var d = !1;else {\n        for (d = b.parent; null !== d && d !== c;) {\n          d = d.parent;\n        }\n\n        d = d === c;\n      }\n      if (d || c.level > b.level) return !1;\n      a.removeChild(c.parent, c);\n    }\n\n    return !0;\n  }\n\n  xt.prototype.removeChild = function (a, b) {\n    if (null !== a && null !== b) {\n      for (var c = a.children, d = 0, e = 0; e < c.length; e++) {\n        c[e] === b && d++;\n      }\n\n      if (0 < d) {\n        d = Array(c.length - d);\n\n        for (var f = e = 0; f < c.length; f++) {\n          c[f] !== b && (d[e++] = c[f]);\n        }\n\n        a.children = d;\n      }\n    }\n  };\n\n  function Kt(a, b) {\n    if (null !== b) {\n      a.initializeTreeVertexValues(b);\n      b.alignment === Qt && a.sortTreeVertexChildren(b);\n\n      for (var c = 0, d = b.childrenCount, e = 0, f = b.children, g = f.length, h = 0; h < g; h++) {\n        var k = f[h];\n        Kt(a, k);\n        c += k.descendantCount + 1;\n        d = Math.max(d, k.maxChildrenCount);\n        e = Math.max(e, k.maxGenerationCount);\n      }\n\n      b.descendantCount = c;\n      b.maxChildrenCount = d;\n      b.maxGenerationCount = 0 < d ? e + 1 : 0;\n    }\n  }\n\n  function Rt(a, b) {\n    switch (a.Yn) {\n      default:\n      case At:\n        return null !== b.parent ? b.parent : a.V;\n\n      case St:\n        return null === b.parent ? a.V : null === b.parent.parent ? a.Y : b.parent;\n\n      case Tt:\n        return null !== b.parent ? null !== b.parent.parent ? b.parent.parent : a.Y : a.V;\n\n      case Ut:\n        var c = !0;\n        if (0 === b.childrenCount) c = !1;else for (var d = b.children, e = d.length, f = 0; f < e; f++) {\n          if (0 < d[f].childrenCount) {\n            c = !1;\n            break;\n          }\n        }\n        return c && null !== b.parent ? a.Y : null !== b.parent ? b.parent : a.V;\n    }\n  }\n\n  xt.prototype.initializeTreeVertexValues = function (a) {\n    a.copyInheritedPropertiesFrom(Rt(this, a));\n\n    if (null !== a.parent && a.parent.alignment === Qt) {\n      for (var b = a.angle, c = a.parent.children, d = 0; d < c.length && a !== c[d];) {\n        d++;\n      }\n\n      0 === d % 2 ? d !== c.length - 1 && (b = 90 === b ? 180 : 180 === b ? 270 : 270 === b ? 180 : 270) : b = 90 === b ? 0 : 180 === b ? 90 : 270 === b ? 0 : 90;\n      a.angle = b;\n    }\n\n    a.initialized = !0;\n  };\n\n  function Lt(a, b) {\n    if (null !== b) {\n      a.assignTreeVertexValues(b);\n      b = b.children;\n\n      for (var c = b.length, d = 0; d < c; d++) {\n        Lt(a, b[d]);\n      }\n    }\n  }\n\n  xt.prototype.assignTreeVertexValues = function () {};\n\n  function Mt(a, b) {\n    if (null !== b) {\n      b.alignment !== Qt && a.sortTreeVertexChildren(b);\n      b = b.children;\n\n      for (var c = b.length, d = 0; d < c; d++) {\n        Mt(a, b[d]);\n      }\n    }\n  }\n\n  xt.prototype.sortTreeVertexChildren = function (a) {\n    switch (a.sorting) {\n      case Vt:\n        break;\n\n      case Wt:\n        a.children.reverse();\n        break;\n\n      case Xt:\n        a.children.sort(a.comparer);\n        break;\n\n      case Yt:\n        a.children.sort(a.comparer);\n        a.children.reverse();\n        break;\n\n      default:\n        C(\"Unhandled sorting value \" + a.sorting.toString());\n    }\n  };\n\n  xt.prototype.ju = function () {\n    if (this.comments) for (var a = this.network.vertexes.iterator; a.next();) {\n      this.addComments(a.value);\n    }\n  };\n\n  xt.prototype.addComments = function (a) {\n    var b = a.angle,\n        c = a.parent,\n        d = 0;\n    var e = !1;\n    null !== c && (d = c.angle, e = c.alignment, e = Zt(e));\n    b = 90 === b || 270 === b;\n    d = 90 === d || 270 === d;\n    c = 0 === a.childrenCount;\n    var f = 0,\n        g = 0,\n        h = 0,\n        k = a.commentSpacing;\n    if (null !== a.node) for (var l = a.node.wu(); l.next();) {\n      var m = l.value;\n      \"Comment\" === m.category && m.canLayout() && (null === a.comments && (a.comments = []), a.comments.push(m), m.Za(), m = m.measuredBounds, b && !c || !e && !d && c || e && d && c ? (f = Math.max(f, m.width), g += m.height + Math.abs(h)) : (f += m.width + Math.abs(h), g = Math.max(g, m.height)), h = k);\n    }\n    null !== a.comments && (b && !c || !e && !d && c || e && d && c ? (f += Math.abs(a.commentMargin), g = Math.max(0, g - a.height)) : (g += Math.abs(a.commentMargin), f = Math.max(0, f - a.width)), e = M.allocAt(0, 0, a.bounds.width + f, a.bounds.height + g), a.bounds = e, M.free(e));\n  };\n\n  function Zt(a) {\n    return a === $t || a === Qt || a === au || a === bu;\n  }\n\n  function cu(a) {\n    return a === $t || a === Qt;\n  }\n\n  function du(a) {\n    var b = a.parent;\n\n    if (null !== b) {\n      var c = b.alignment;\n\n      if (Zt(c)) {\n        if (cu(c)) {\n          b = b.children;\n\n          for (c = 0; c < b.length && a !== b[c];) {\n            c++;\n          }\n\n          return 0 === c % 2;\n        }\n\n        if (c === au) return !0;\n      }\n    }\n\n    return !1;\n  }\n\n  xt.prototype.layoutComments = function (a) {\n    if (null !== a.comments) {\n      var b = a.node.measuredBounds,\n          c = a.parent,\n          d = a.angle,\n          e = 0;\n      var f = !1;\n      null !== c && (e = c.angle, f = c.alignment, f = Zt(f));\n      d = 90 === d || 270 === d;\n      c = 90 === e || 270 === e;\n\n      for (var g = 0 === a.childrenCount, h = du(a), k = 0, l = a.comments, m = l.length, n = I.alloc(), p = 0; p < m; p++) {\n        var r = l[p],\n            q = r.measuredBounds;\n\n        if (d && !g || !f && !c && g || f && c && g) {\n          if (135 < e && !f || c && h) {\n            if (0 <= a.commentMargin) for (n.h(a.bounds.x - a.commentMargin - q.width, a.bounds.y + k), r.move(n), r = r.Kd(); r.next();) {\n              var u = r.value;\n              u.fromSpot = dd;\n              u.toSpot = ed;\n            } else for (n.h(a.bounds.x + 2 * a.focus.x - a.commentMargin, a.bounds.y + k), r.move(n), r = r.Kd(); r.next();) {\n              u = r.value, u.fromSpot = ed, u.toSpot = dd;\n            }\n          } else if (0 <= a.commentMargin) for (n.h(a.bounds.x + 2 * a.focus.x + a.commentMargin, a.bounds.y + k), r.move(n), r = r.Kd(); r.next();) {\n            u = r.value, u.fromSpot = ed, u.toSpot = dd;\n          } else for (n.h(a.bounds.x + a.commentMargin - q.width, a.bounds.y + k), r.move(n), r = r.Kd(); r.next();) {\n            u = r.value, u.fromSpot = dd, u.toSpot = ed;\n          }\n          k = 0 <= a.commentSpacing ? k + (q.height + a.commentSpacing) : k + (a.commentSpacing - q.height);\n        } else {\n          if (135 < e && !f || !c && h) {\n            if (0 <= a.commentMargin) for (n.h(a.bounds.x + k, a.bounds.y - a.commentMargin - q.height), r.move(n), r = r.Kd(); r.next();) {\n              u = r.value, u.fromSpot = ad, u.toSpot = fd;\n            } else for (n.h(a.bounds.x + k, a.bounds.y + 2 * a.focus.y - a.commentMargin), r.move(n), r = r.Kd(); r.next();) {\n              u = r.value, u.fromSpot = fd, u.toSpot = ad;\n            }\n          } else if (0 <= a.commentMargin) for (n.h(a.bounds.x + k, a.bounds.y + 2 * a.focus.y + a.commentMargin), r.move(n), r = r.Kd(); r.next();) {\n            u = r.value, u.fromSpot = fd, u.toSpot = ad;\n          } else for (n.h(a.bounds.x + k, a.bounds.y + a.commentMargin - q.height), r.move(n), r = r.Kd(); r.next();) {\n            u = r.value, u.fromSpot = ad, u.toSpot = fd;\n          }\n          k = 0 <= a.commentSpacing ? k + (q.width + a.commentSpacing) : k + (a.commentSpacing - q.width);\n        }\n      }\n\n      I.free(n);\n      b = k - a.commentSpacing - (d ? b.height : b.width);\n      if (this.qd === zt) for (a = a.destinationEdges; a.next();) {\n        e = a.value.link, null === e || e.isAvoiding || (e.fromEndSegmentLength = 0 < b ? b : NaN);\n      } else for (a = a.sourceEdges; a.next();) {\n        e = a.value.link, null === e || e.isAvoiding || (e.toEndSegmentLength = 0 < b ? b : NaN);\n      }\n    }\n  };\n\n  xt.prototype.layoutTree = function (a) {\n    if (null !== a) {\n      for (var b = a.children, c = b.length, d = 0; d < c; d++) {\n        this.layoutTree(b[d]);\n      }\n\n      switch (a.compaction) {\n        case eu:\n          fu(this, a);\n          break;\n\n        case gu:\n          if (a.alignment === Qt) fu(this, a);else if (0 === a.childrenCount) d = a.parent, c = !1, b = 0, null !== d && (b = d.angle, c = d.alignment, c = Zt(c)), d = du(a), a.S.h(0, 0), a.Ca.h(a.width, a.height), null === a.parent || null === a.comments || (180 !== b && 270 !== b || c) && !d ? a.ka.h(0, 0) : 180 === b && !c || (90 === b || 270 === b) && d ? a.ka.h(a.width - 2 * a.focus.x, 0) : a.ka.h(0, a.height - 2 * a.focus.y), a.Bo = null, a.No = null;else {\n            var e = ju(a);\n            b = 90 === e || 270 === e;\n            var f = 0,\n                g = a.children,\n                h = g.length;\n\n            for (c = 0; c < h; c++) {\n              d = g[c], f = Math.max(f, b ? d.Ca.width : d.Ca.height);\n            }\n\n            var k = a.alignment,\n                l = k === ku,\n                m = Zt(k),\n                n = Math.max(0, a.breadthLimit);\n            c = lu(a);\n            var p = a.nodeSpacing,\n                r = mu(a),\n                q = a.rowSpacing,\n                u = 0;\n            if (k === nu || l || a.Pl || a.Ql && 1 === a.maxGenerationCount) u = Math.max(0, a.rowIndent);\n            d = a.width;\n            var w = a.height,\n                v = 0,\n                z = 0,\n                y = 0,\n                A = null,\n                B = null,\n                F = 0,\n                L = 0,\n                S = 0,\n                R = 0,\n                P = 0,\n                H = 0,\n                da = 0,\n                X = 0;\n            m && !cu(k) && 135 < e && g.reverse();\n            if (cu(k)) if (1 < h) for (var oa = 0; oa < h; oa++) {\n              0 === oa % 2 && oa !== h - 1 && (X = Math.max(X, b ? g[oa].Ca.width : g[oa].Ca.height));\n            } else 1 === h && (X = b ? g[0].Ca.width : g[0].Ca.height);\n\n            if (m) {\n              switch (k) {\n                case $t:\n                  z = 135 > e ? ou(a, g, X, v, z) : pu(a, g, X, v, z);\n                  X = z.x;\n                  v = z.width;\n                  z = z.height;\n                  break;\n\n                case au:\n                  for (A = 0; A < h; A++) {\n                    B = g[A], n = B.Ca, y = 0 === H ? 0 : q, b ? (B.S.h(f - n.width, R + y), v = Math.max(v, n.width), z = Math.max(z, R + y + n.height), R += y + n.height) : (B.S.h(S + y, f - n.height), v = Math.max(v, S + y + n.width), z = Math.max(z, n.height), S += y + n.width), H++;\n                  }\n\n                  break;\n\n                case bu:\n                  for (A = 0; A < h; A++) {\n                    B = g[A], f = B.Ca, n = 0 === H ? 0 : q, b ? (B.S.h(p / 2 + a.focus.x, R + n), v = Math.max(v, f.width), z = Math.max(z, R + n + f.height), R += n + f.height) : (B.S.h(S + n, p / 2 + a.focus.y), v = Math.max(v, S + n + f.width), z = Math.max(z, f.height), S += n + f.width), H++;\n                  }\n\n              }\n\n              A = qu(this, 2);\n              B = qu(this, 2);\n              b ? (A[0].h(0, 0), A[1].h(0, z), B[0].h(v, 0)) : (A[0].h(0, 0), A[1].h(v, 0), B[0].h(0, z));\n              B[1].h(v, z);\n            } else for (oa = 0; oa < h; oa++) {\n              var Ba = g[oa],\n                  db = Ba.Ca;\n\n              if (b) {\n                0 < n && 0 < H && S + p + db.width > n && (S < f && ru(a, k, f - S, 0, da, oa - 1), P++, H = 0, da = oa, y = z, S = 0, R = 135 < e ? -z - q : z + q);\n                su(this, Ba, 0, R);\n                var hb = 0;\n\n                if (0 === H) {\n                  if (A = Ba.Bo, B = Ba.No, F = db.width, L = db.height, null === A || null === B || e !== ju(Ba)) A = qu(this, 2), B = qu(this, 2), A[0].h(0, 0), A[1].h(0, L), B[0].h(F, 0), B[1].h(F, L);\n                } else {\n                  var Fb = Ea();\n                  L = tu(this, a, Ba, A, B, F, L, Fb);\n                  hb = L.x;\n                  A = Fb[0];\n                  B = Fb[1];\n                  F = L.width;\n                  L = L.height;\n                  Ga(Fb);\n                  S < db.width && 0 > hb && (uu(a, -hb, 0, da, oa - 1), vu(A, -hb, 0), vu(B, -hb, 0), hb = 0);\n                }\n\n                Ba.S.h(hb, R);\n                v = Math.max(v, F);\n                z = Math.max(z, y + (0 === P ? 0 : q) + db.height);\n                S = F;\n              } else {\n                0 < n && 0 < H && R + p + db.height > n && (R < f && ru(a, k, 0, f - R, da, oa - 1), P++, H = 0, da = oa, y = v, R = 0, S = 135 < e ? -v - q : v + q);\n                su(this, Ba, S, 0);\n                hb = 0;\n\n                if (0 === H) {\n                  if (A = Ba.Bo, B = Ba.No, F = db.width, L = db.height, null === A || null === B || e !== ju(Ba)) A = qu(this, 2), B = qu(this, 2), A[0].h(0, 0), A[1].h(F, 0), B[0].h(0, L), B[1].h(F, L);\n                } else Fb = Ea(), L = tu(this, a, Ba, A, B, F, L, Fb), hb = L.x, A = Fb[0], B = Fb[1], F = L.width, L = L.height, Ga(Fb), R < db.height && 0 > hb && (uu(a, 0, -hb, da, oa - 1), vu(A, 0, -hb), vu(B, 0, -hb), hb = 0);\n\n                Ba.S.h(S, hb);\n                z = Math.max(z, L);\n                v = Math.max(v, y + (0 === P ? 0 : q) + db.width);\n                R = L;\n              }\n\n              H++;\n            }\n\n            0 < P && (b ? (z += Math.max(0, c), S < v && ru(a, k, v - S, 0, da, h - 1), 0 < u && (l || uu(a, u, 0, 0, h - 1), v += u)) : (v += Math.max(0, c), R < z && ru(a, k, 0, z - R, da, h - 1), 0 < u && (l || uu(a, 0, u, 0, h - 1), z += u)));\n            u = l = 0;\n\n            switch (k) {\n              case wu:\n                b ? l += v / 2 - a.focus.x - r / 2 : u += z / 2 - a.focus.y - r / 2;\n                break;\n\n              case xu:\n                0 < P ? b ? l += v / 2 - a.focus.x - r / 2 : u += z / 2 - a.focus.y - r / 2 : b ? (X = g[0].S.x + g[0].ka.x, l += X + (g[h - 1].S.x + g[h - 1].ka.x + 2 * g[h - 1].focus.x - X) / 2 - a.focus.x - r / 2) : (X = g[0].S.y + g[0].ka.y, u += X + (g[h - 1].S.y + g[h - 1].ka.y + 2 * g[h - 1].focus.y - X) / 2 - a.focus.y - r / 2);\n                break;\n\n              case nu:\n                b ? (l -= r, v += r) : (u -= r, z += r);\n                break;\n\n              case ku:\n                b ? (l += v - a.width + r, v += r) : (u += z - a.height + r, z += r);\n                break;\n\n              case $t:\n                b ? 1 < h ? l += X + p / 2 - a.focus.x : l += g[0].focus.x - a.focus.x + g[0].ka.x : 1 < h ? u += X + p / 2 - a.focus.y : u += g[0].focus.y - a.focus.y + g[0].ka.y;\n                break;\n\n              case au:\n                b ? l += v + p / 2 - a.focus.x : u += z + p / 2 - a.focus.y;\n                break;\n\n              case bu:\n                break;\n\n              default:\n                C(\"Unhandled alignment value \" + k.toString());\n            }\n\n            for (r = 0; r < h; r++) {\n              X = g[r], b ? X.S.h(X.S.x + X.ka.x - l, X.S.y + (135 < e ? (m ? -z : -X.Ca.height) + X.ka.y - c : w + c + X.ka.y)) : X.S.h(X.S.x + (135 < e ? (m ? -v : -X.Ca.width) + X.ka.x - c : d + c + X.ka.x), X.S.y + X.ka.y - u);\n            }\n\n            h = g = 0;\n            m ? b ? (v = yu(a, v, l), 0 > l && (l = 0), 135 < e && (u += z + c), z += w + c, k === bu && (g += p / 2 + a.focus.x), h += w + c) : (135 < e && (l += v + c), v += d + c, z = zu(a, z, u), 0 > u && (u = 0), k === bu && (h += p / 2 + a.focus.y), g += d + c) : b ? (null === a.comments ? d > v && (v = Au(k, d - v, 0), g = v.x, h = v.y, v = d, l = 0) : v = yu(a, v, l), 0 > l && (g -= l, l = 0), 135 < e && (u += z + c), z = Math.max(Math.max(z, w), z + w + c), h += w + c) : (135 < e && (l += v + c), v = Math.max(Math.max(v, d), v + d + c), null === a.comments ? w > z && (z = Au(k, 0, w - z), g = z.x, h = z.y, z = w, u = 0) : z = zu(a, z, u), 0 > u && (h -= u, u = 0), g += d + c);\n            if (0 < P) e = qu(this, 4), P = qu(this, 4), b ? (e[2].h(0, w + c), e[3].h(e[2].x, z), P[2].h(v, e[2].y), P[3].h(P[2].x, e[3].y)) : (e[2].h(d + c, 0), e[3].h(v, e[2].y), P[2].h(e[2].x, z), P[3].h(e[3].x, P[2].y));else {\n              e = qu(this, A.length + 2);\n              P = qu(this, B.length + 2);\n\n              for (k = 0; k < A.length; k++) {\n                m = A[k], e[k + 2].h(m.x + g, m.y + h);\n              }\n\n              for (k = 0; k < B.length; k++) {\n                m = B[k], P[k + 2].h(m.x + g, m.y + h);\n              }\n            }\n            b ? (e[0].h(l, 0), e[1].h(e[0].x, w), e[2].y < e[1].y && (e[2].x > e[0].x ? e[2].assign(e[1]) : e[1].assign(e[2])), e[3].y < e[2].y && (e[3].x > e[0].x ? e[3].assign(e[2]) : e[2].assign(e[3])), P[0].h(l + d, 0), P[1].h(P[0].x, w), P[2].y < P[1].y && (P[2].x < P[0].x ? P[2].assign(P[1]) : P[1].assign(P[2])), P[3].y < P[2].y && (P[3].x < P[0].x ? P[3].assign(P[2]) : P[2].assign(P[3])), e[2].y -= c / 2, P[2].y -= c / 2) : (e[0].h(0, u), e[1].h(d, e[0].y), e[2].x < e[1].x && (e[2].y > e[0].y ? e[2].assign(e[1]) : e[1].assign(e[2])), e[3].x < e[2].x && (e[3].y > e[0].y ? e[3].assign(e[2]) : e[2].assign(e[3])), P[0].h(0, u + w), P[1].h(d, P[0].y), P[2].x < P[1].x && (P[2].y < P[0].y ? P[2].assign(P[1]) : P[1].assign(P[2])), P[3].x < P[2].x && (P[3].y < P[0].y ? P[3].assign(P[2]) : P[2].assign(P[3])), e[2].x -= c / 2, P[2].x -= c / 2);\n            Bu(this, A);\n            Bu(this, B);\n            a.Bo = e;\n            a.No = P;\n            a.ka.h(l, u);\n            a.Ca.h(v, z);\n          }\n          break;\n\n        default:\n          C(\"Unhandled compaction value \" + a.compaction.toString());\n      }\n    }\n  };\n\n  function fu(a, b) {\n    if (0 === b.childrenCount) {\n      var c = !1,\n          d = 0;\n      null !== b.parent && (d = b.parent.angle, c = b.parent.alignment, c = Zt(c));\n      var e = du(b);\n      b.S.h(0, 0);\n      b.Ca.h(b.width, b.height);\n      null === b.parent || null === b.comments || (180 !== d && 270 !== d || c) && !e ? b.ka.h(0, 0) : 180 === d && !c || (90 === d || 270 === d) && e ? b.ka.h(b.width - 2 * b.focus.x, 0) : b.ka.h(0, b.height - 2 * b.focus.y);\n    } else {\n      d = ju(b);\n      c = 90 === d || 270 === d;\n      var f = 0;\n      e = b.children;\n\n      for (var g = e.length, h = 0; h < g; h++) {\n        var k = e[h];\n        f = Math.max(f, c ? k.Ca.width : k.Ca.height);\n      }\n\n      var l = b.alignment,\n          m = l === nu,\n          n = l === ku;\n      h = Zt(l);\n      var p = Math.max(0, b.breadthLimit);\n      k = lu(b);\n      var r = b.nodeSpacing,\n          q = mu(b),\n          u = m || n ? 0 : q / 2,\n          w = b.rowSpacing,\n          v = 0;\n      if (m || n || b.Pl || b.Ql && 1 === b.maxGenerationCount) v = Math.max(0, b.rowIndent);\n      m = b.width;\n      var z = b.height,\n          y = 0,\n          A = 0,\n          B = 0,\n          F = 0,\n          L = 0,\n          S = 0,\n          R = 0,\n          P = 0,\n          H = 0;\n      h && !cu(l) && 135 < d && e.reverse();\n      if (cu(l)) if (1 < g) for (var da = 0; da < g; da++) {\n        var X = e[da],\n            oa = X.Ca;\n        0 === da % 2 && da !== g - 1 && (H = Math.max(H, (c ? oa.width : oa.height) + Cu(X) - r));\n      } else 1 === g && (H = c ? e[0].Ca.width : e[0].Ca.height);\n      if (h) switch (l) {\n        case $t:\n        case Qt:\n          A = 135 > d ? ou(b, e, H, y, A) : pu(b, e, H, y, A);\n          H = A.x;\n          y = A.width;\n          A = A.height;\n          break;\n\n        case au:\n          for (a = 0; a < g; a++) {\n            p = e[a], u = p.Ca, B = 0 === R ? 0 : w, c ? (p.S.h(f - u.width, L + B), y = Math.max(y, u.width), A = Math.max(A, L + B + u.height), L += B + u.height) : (p.S.h(F + B, f - u.height), y = Math.max(y, F + B + u.width), A = Math.max(A, u.height), F += B + u.width), R++;\n          }\n\n          break;\n\n        case bu:\n          for (f = 0; f < g; f++) {\n            a = e[f], p = a.Ca, u = 0 === R ? 0 : w, c ? (a.S.h(r / 2 + b.focus.x, L + u), y = Math.max(y, p.width), A = Math.max(A, L + u + p.height), L += u + p.height) : (a.S.h(F + u, r / 2 + b.focus.y), y = Math.max(y, F + u + p.width), A = Math.max(A, p.height), F += u + p.width), R++;\n          }\n\n      } else for (da = 0; da < g; da++) {\n        X = e[da];\n        oa = X.Ca;\n\n        if (c) {\n          0 < p && 0 < R && F + r + oa.width > p && (F < f && ru(b, l, f - F, 0, P, da - 1), S++, R = 0, P = da, B = A, F = 0, L = 135 < d ? -A - w : A + w);\n          var Ba = 0 === R ? u : r;\n          su(a, X, 0, L);\n          X.S.h(F + Ba, L);\n          y = Math.max(y, F + Ba + oa.width);\n          A = Math.max(A, B + (0 === S ? 0 : w) + oa.height);\n          F += Ba + oa.width;\n        } else 0 < p && 0 < R && L + r + oa.height > p && (L < f && ru(b, l, 0, f - L, P, da - 1), S++, R = 0, P = da, B = y, L = 0, F = 135 < d ? -y - w : y + w), Ba = 0 === R ? u : r, su(a, X, F, 0), X.S.h(F, L + Ba), A = Math.max(A, L + Ba + oa.height), y = Math.max(y, B + (0 === S ? 0 : w) + oa.width), L += Ba + oa.height;\n\n        R++;\n      }\n      0 < S && (c ? (A += Math.max(0, k), F < y && ru(b, l, y - F, 0, P, g - 1), 0 < v && (n || uu(b, v, 0, 0, g - 1), y += v)) : (y += Math.max(0, k), L < A && ru(b, l, 0, A - L, P, g - 1), 0 < v && (n || uu(b, 0, v, 0, g - 1), A += v)));\n      v = n = 0;\n\n      switch (l) {\n        case wu:\n          c ? n += y / 2 - b.focus.x - q / 2 : v += A / 2 - b.focus.y - q / 2;\n          break;\n\n        case xu:\n          0 < S ? c ? n += y / 2 - b.focus.x - q / 2 : v += A / 2 - b.focus.y - q / 2 : c ? (l = e[0].S.x + e[0].ka.x, n += l + (e[g - 1].S.x + e[g - 1].ka.x + 2 * e[g - 1].focus.x - l) / 2 - b.focus.x - q / 2) : (l = e[0].S.y + e[0].ka.y, v += l + (e[g - 1].S.y + e[g - 1].ka.y + 2 * e[g - 1].focus.y - l) / 2 - b.focus.y - q / 2);\n          break;\n\n        case nu:\n          c ? (n -= q, y += q) : (v -= q, A += q);\n          break;\n\n        case ku:\n          c ? (n += y - b.width + q, y += q) : (v += A - b.height + q, A += q);\n          break;\n\n        case $t:\n        case Qt:\n          c ? 1 < g ? n += H + r / 2 - b.focus.x : n += e[0].focus.x - b.focus.x + e[0].ka.x : 1 < g ? v += H + r / 2 - b.focus.y : v += e[0].focus.y - b.focus.y + e[0].ka.y;\n          break;\n\n        case au:\n          c ? n += y + r / 2 - b.focus.x : v += A + r / 2 - b.focus.y;\n          break;\n\n        case bu:\n          break;\n\n        default:\n          C(\"Unhandled alignment value \" + l.toString());\n      }\n\n      for (q = 0; q < g; q++) {\n        l = e[q], c ? l.S.h(l.S.x + l.ka.x - n, l.S.y + (135 < d ? (h ? -A : -l.Ca.height) + l.ka.y - k : z + k + l.ka.y)) : l.S.h(l.S.x + (135 < d ? (h ? -y : -l.Ca.width) + l.ka.x - k : m + k + l.ka.x), l.S.y + l.ka.y - v);\n      }\n\n      c ? (y = yu(b, y, n), 0 > n && (n = 0), 135 < d && (v += A + k), A = Math.max(Math.max(A, z), A + z + k)) : (135 < d && (n += y + k), y = Math.max(Math.max(y, m), y + m + k), A = zu(b, A, v), 0 > v && (v = 0));\n      b.ka.h(n, v);\n      b.Ca.h(y, A);\n    }\n  }\n\n  function ou(a, b, c, d, e) {\n    var f = b.length;\n    if (0 === f) return new M(c, 0, d, e);\n    if (1 === f) return a = b[0], d = a.Ca.width, e = a.Ca.height, new M(c, 0, d, e);\n\n    for (var g = a.nodeSpacing, h = a.rowSpacing, k = 90 === ju(a), l = 0, m = 0, n = 0, p = 0; p < f; p++) {\n      if (!(0 !== p % 2 || 1 < f && p === f - 1)) {\n        var r = b[p],\n            q = r.Ca,\n            u = 0 === l ? 0 : h;\n\n        if (k) {\n          var w = Cu(r) - g;\n          r.S.h(c - (q.width + w), n + u);\n          d = Math.max(d, q.width + w);\n          e = Math.max(e, n + u + q.height);\n          n += u + q.height;\n        } else w = Cu(r) - g, r.S.h(m + u, c - (q.height + w)), e = Math.max(e, q.height + w), d = Math.max(d, m + u + q.width), m += u + q.width;\n\n        l++;\n      }\n    }\n\n    l = 0;\n    r = m;\n    p = n;\n    k ? (m = c + g, n = 0) : (m = 0, n = c + g);\n\n    for (q = 0; q < f; q++) {\n      if (0 !== q % 2) {\n        u = b[q];\n        w = u.Ca;\n        var v = 0 === l ? 0 : h;\n\n        if (k) {\n          var z = Cu(u) - g;\n          u.S.h(m + z, n + v);\n          d = Math.max(d, m + w.width + z);\n          e = Math.max(e, n + v + w.height);\n          n += v + w.height;\n        } else z = Cu(u) - g, u.S.h(m + v, n + z), d = Math.max(d, m + v + w.width), e = Math.max(e, n + w.height + z), m += v + w.width;\n\n        l++;\n      }\n    }\n\n    1 < f && 1 === f % 2 && (b = b[f - 1], f = b.Ca, h = null === b.parent ? 0 : b.parent.rowSpacing, k ? (b.S.h(c + g / 2 - b.focus.x - b.ka.x, e + h), k = c + g / 2 - b.focus.x - b.ka.x, d = Math.max(d, k + f.width), 0 > k && (d -= k), e = Math.max(e, Math.max(p, n) + h + f.height), 0 > b.S.x && (c = Du(a, b.S.x, !1, c, g))) : (b.S.h(d + h, c + g / 2 - b.focus.y - b.ka.y), d = Math.max(d, Math.max(r, m) + h + f.width), n = c + g / 2 - b.focus.y - b.ka.y, e = Math.max(e, n + f.height), 0 > n && (e -= n), 0 > b.S.y && (c = Du(a, b.S.y, !0, c, g))));\n    return new M(c, 0, d, e);\n  }\n\n  function pu(a, b, c, d, e) {\n    var f = b.length;\n    if (0 === f) return new M(c, 0, d, e);\n    if (1 === f) return b = b[0], d = b.Ca.width, e = b.Ca.height, new M(c, 0, d, e);\n\n    for (var g = a.nodeSpacing, h = a.rowSpacing, k = 270 === ju(a), l = 0, m = 0, n = 0, p = 0; p < f; p++) {\n      if (!(0 !== p % 2 || 1 < f && p === f - 1)) {\n        var r = b[p],\n            q = r.Ca,\n            u = 0 === l ? 0 : h;\n\n        if (k) {\n          var w = Cu(r) - g;\n          n -= u + q.height;\n          r.S.h(c - (q.width + w), n);\n          d = Math.max(d, q.width + w);\n          e = Math.max(e, Math.abs(n));\n        } else w = Cu(r) - g, m -= u + q.width, r.S.h(m, c - (q.height + w)), e = Math.max(e, q.height + w), d = Math.max(d, Math.abs(m));\n\n        l++;\n      }\n    }\n\n    l = 0;\n    r = m;\n    p = n;\n    k ? (m = c + g, n = 0) : (m = 0, n = c + g);\n\n    for (q = 0; q < f; q++) {\n      if (0 !== q % 2) {\n        u = b[q];\n        w = u.Ca;\n        var v = 0 === l ? 0 : h;\n\n        if (k) {\n          var z = Cu(u) - g;\n          n -= v + w.height;\n          u.S.h(m + z, n);\n          d = Math.max(d, m + w.width + z);\n          e = Math.max(e, Math.abs(n));\n        } else z = Cu(u) - g, m -= v + w.width, u.S.h(m, n + z), e = Math.max(e, n + w.height + z), d = Math.max(d, Math.abs(m));\n\n        l++;\n      }\n    }\n\n    1 < f && 1 === f % 2 && (h = b[f - 1], l = h.Ca, q = null === h.parent ? 0 : h.parent.rowSpacing, k ? (h.S.h(c + g / 2 - h.focus.x - h.ka.x, -e - l.height - q), m = c + g / 2 - h.focus.x - h.ka.x, d = Math.max(d, m + l.width), 0 > m && (d -= m), e = Math.max(e, Math.abs(Math.min(p, n)) + q + l.height), 0 > h.S.x && (c = Du(a, h.S.x, !1, c, g))) : (h.S.h(-d - l.width - q, c + g / 2 - h.focus.y - h.ka.y), d = Math.max(d, Math.abs(Math.min(r, m)) + q + l.width), n = c + g / 2 - h.focus.y - h.ka.y, e = Math.max(e, n + l.height), 0 > n && (e -= n), 0 > h.S.y && (c = Du(a, h.S.y, !0, c, g))));\n\n    for (a = 0; a < f; a++) {\n      g = b[a], k ? g.S.h(g.S.x, g.S.y + e) : g.S.h(g.S.x + d, g.S.y);\n    }\n\n    return new M(c, 0, d, e);\n  }\n\n  function Cu(a) {\n    return null === a.parent ? 0 : a.parent.nodeSpacing;\n  }\n\n  function Du(a, b, c, d, e) {\n    a = a.children;\n\n    for (var f = a.length, g = 0; g < f; g++) {\n      c ? a[g].S.h(a[g].S.x, a[g].S.y - b) : a[g].S.h(a[g].S.x - b, a[g].S.y);\n    }\n\n    b = a[f - 1];\n    return Math.max(d, c ? b.ka.y + b.focus.y - e / 2 : b.ka.x + b.focus.x - e / 2);\n  }\n\n  function yu(a, b, c) {\n    switch (a.alignment) {\n      case xu:\n      case wu:\n        return c + a.width > b && (b = c + a.width), 0 > c && (b -= c), b;\n\n      case nu:\n        return a.width > b ? a.width : b;\n\n      case ku:\n        return 2 * a.focus.x > b ? a.width : b + a.width - 2 * a.focus.x;\n\n      case $t:\n      case Qt:\n        return Math.max(a.width, Math.max(b, c + a.width) - Math.min(0, c));\n\n      case au:\n        return a.width - a.focus.x + a.nodeSpacing / 2 + b;\n\n      case bu:\n        return Math.max(a.width, a.focus.x + a.nodeSpacing / 2 + b);\n\n      default:\n        return b;\n    }\n  }\n\n  function zu(a, b, c) {\n    switch (a.alignment) {\n      case xu:\n      case wu:\n        return c + a.height > b && (b = c + a.height), 0 > c && (b -= c), b;\n\n      case nu:\n        return a.height > b ? a.height : b;\n\n      case ku:\n        return 2 * a.focus.y > b ? a.height : b + a.height - 2 * a.focus.y;\n\n      case $t:\n      case Qt:\n        return Math.max(a.height, Math.max(b, c + a.height) - Math.min(0, c));\n\n      case au:\n        return a.height - a.focus.y + a.nodeSpacing / 2 + b;\n\n      case bu:\n        return Math.max(a.height, a.focus.y + a.nodeSpacing / 2 + b);\n\n      default:\n        return b;\n    }\n  }\n\n  function Au(a, b, c) {\n    switch (a) {\n      case wu:\n        b /= 2;\n        c /= 2;\n        break;\n\n      case xu:\n        b /= 2;\n        c /= 2;\n        break;\n\n      case nu:\n        c = b = 0;\n        break;\n\n      case ku:\n        break;\n\n      default:\n        C(\"Unhandled alignment value \" + a.toString());\n    }\n\n    return new I(b, c);\n  }\n\n  function ru(a, b, c, d, e, f) {\n    b = Au(b, c, d);\n    uu(a, b.x, b.y, e, f);\n  }\n\n  function uu(a, b, c, d, e) {\n    if (0 !== b || 0 !== c) for (a = a.children; d <= e; d++) {\n      var f = a[d].S;\n      f.x += b;\n      f.y += c;\n    }\n  }\n\n  function su(a, b, c, d) {\n    var e = b.parent;\n\n    switch (a.qd) {\n      case zt:\n        for (a = b.sourceEdges; a.next();) {\n          b = a.value, b.fromVertex === e && b.relativePoint.h(c, d);\n        }\n\n        break;\n\n      case Gt:\n        for (a = b.destinationEdges; a.next();) {\n          b = a.value, b.toVertex === e && b.relativePoint.h(c, d);\n        }\n\n        break;\n\n      default:\n        C(\"Unhandled path value \" + a.qd.toString());\n    }\n  }\n\n  function vu(a, b, c) {\n    for (var d = 0; d < a.length; d++) {\n      var e = a[d];\n      e.x += b;\n      e.y += c;\n    }\n  }\n\n  function tu(a, b, c, d, e, f, g, h) {\n    var k = ju(b),\n        l = 90 === k || 270 === k,\n        m = b.nodeSpacing;\n    b = d;\n    var n = e;\n    d = f;\n    var p = g,\n        r = c.Bo,\n        q = c.No;\n    g = c.Ca;\n    var u = l ? Math.max(p, g.height) : Math.max(d, g.width);\n    if (null === r || k !== ju(c)) r = qu(a, 2), q = qu(a, 2), l ? (r[0].h(0, 0), r[1].h(0, g.height), q[0].h(g.width, 0), q[1].h(q[0].x, r[1].y)) : (r[0].h(0, 0), r[1].h(g.width, 0), q[0].h(0, g.height), q[1].h(r[1].x, q[0].y));\n\n    if (l) {\n      p = 9999999;\n      if (!(null === n || 2 > n.length || null === r || 2 > r.length)) for (e = c = 0; c < n.length && e < r.length;) {\n        f = n[c];\n        var w = r[e];\n        k = w.x;\n        l = w.y;\n        k += d;\n        var v = f;\n        c + 1 < n.length && (v = n[c + 1]);\n        var z = w;\n        w = z.x;\n        z = z.y;\n        e + 1 < r.length && (z = r[e + 1], w = z.x, z = z.y, w += d);\n        var y = p;\n        f.y === l ? y = k - f.x : f.y > l && f.y < z ? y = k + (f.y - l) / (z - l) * (w - k) - f.x : l > f.y && l < v.y && (y = k - (f.x + (l - f.y) / (v.y - f.y) * (v.x - f.x)));\n        y < p && (p = y);\n        v.y <= f.y ? c++ : z <= l ? e++ : (v.y <= z && c++, z <= v.y && e++);\n      }\n      p = d - p;\n      p += m;\n      c = r;\n      e = p;\n      if (null === b || 2 > b.length || null === c || 2 > c.length) d = null;else {\n        m = qu(a, b.length + c.length);\n\n        for (d = f = k = 0; f < c.length && c[f].y < b[0].y;) {\n          l = c[f++], m[d++].h(l.x + e, l.y);\n        }\n\n        for (; k < b.length;) {\n          l = b[k++], m[d++].h(l.x, l.y);\n        }\n\n        for (k = b[b.length - 1].y; f < c.length && c[f].y <= k;) {\n          f++;\n        }\n\n        for (; f < c.length && c[f].y > k;) {\n          l = c[f++], m[d++].h(l.x + e, l.y);\n        }\n\n        c = qu(a, d);\n\n        for (k = 0; k < d; k++) {\n          c[k].assign(m[k]);\n        }\n\n        Bu(a, m);\n        d = c;\n      }\n      f = q;\n      k = p;\n      if (null === n || 2 > n.length || null === f || 2 > f.length) e = null;else {\n        m = qu(a, n.length + f.length);\n\n        for (e = l = c = 0; c < n.length && n[c].y < f[0].y;) {\n          v = n[c++], m[e++].h(v.x, v.y);\n        }\n\n        for (; l < f.length;) {\n          v = f[l++], m[e++].h(v.x + k, v.y);\n        }\n\n        for (f = f[f.length - 1].y; c < n.length && n[c].y <= f;) {\n          c++;\n        }\n\n        for (; c < n.length && n[c].y > f;) {\n          k = n[c++], m[e++].h(k.x, k.y);\n        }\n\n        f = qu(a, e);\n\n        for (c = 0; c < e; c++) {\n          f[c].assign(m[c]);\n        }\n\n        Bu(a, m);\n        e = f;\n      }\n      f = Math.max(0, p) + g.width;\n      g = u;\n      Bu(a, b);\n      Bu(a, r);\n      Bu(a, n);\n      Bu(a, q);\n      h[0] = d;\n      h[1] = e;\n      return new M(p, 0, f, g);\n    }\n\n    d = 9999999;\n    if (!(null === n || 2 > n.length || null === r || 2 > r.length)) for (e = c = 0; c < n.length && e < r.length;) {\n      f = n[c], w = r[e], k = w.x, l = w.y, l += p, v = f, c + 1 < n.length && (v = n[c + 1]), z = w, w = z.x, z = z.y, e + 1 < r.length && (z = r[e + 1], w = z.x, z = z.y, z += p), y = d, f.x === k ? y = l - f.y : f.x > k && f.x < w ? y = l + (f.x - k) / (w - k) * (z - l) - f.y : k > f.x && k < v.x && (y = l - (f.y + (k - f.x) / (v.x - f.x) * (v.y - f.y))), y < d && (d = y), v.x <= f.x ? c++ : w <= k ? e++ : (v.x <= w && c++, w <= v.x && e++);\n    }\n    p -= d;\n    p += m;\n    c = r;\n    e = p;\n    if (null === b || 2 > b.length || null === c || 2 > c.length) d = null;else {\n      m = qu(a, b.length + c.length);\n\n      for (d = f = k = 0; f < c.length && c[f].x < b[0].x;) {\n        l = c[f++], m[d++].h(l.x, l.y + e);\n      }\n\n      for (; k < b.length;) {\n        l = b[k++], m[d++].h(l.x, l.y);\n      }\n\n      for (k = b[b.length - 1].x; f < c.length && c[f].x <= k;) {\n        f++;\n      }\n\n      for (; f < c.length && c[f].x > k;) {\n        l = c[f++], m[d++].h(l.x, l.y + e);\n      }\n\n      c = qu(a, d);\n\n      for (k = 0; k < d; k++) {\n        c[k].assign(m[k]);\n      }\n\n      Bu(a, m);\n      d = c;\n    }\n    f = q;\n    k = p;\n    if (null === n || 2 > n.length || null === f || 2 > f.length) e = null;else {\n      m = qu(a, n.length + f.length);\n\n      for (e = l = c = 0; c < n.length && n[c].x < f[0].x;) {\n        v = n[c++], m[e++].h(v.x, v.y);\n      }\n\n      for (; l < f.length;) {\n        v = f[l++], m[e++].h(v.x, v.y + k);\n      }\n\n      for (f = f[f.length - 1].x; c < n.length && n[c].x <= f;) {\n        c++;\n      }\n\n      for (; c < n.length && n[c].x > f;) {\n        k = n[c++], m[e++].h(k.x, k.y);\n      }\n\n      f = qu(a, e);\n\n      for (c = 0; c < e; c++) {\n        f[c].assign(m[c]);\n      }\n\n      Bu(a, m);\n      e = f;\n    }\n    f = u;\n    g = Math.max(0, p) + g.height;\n    Bu(a, b);\n    Bu(a, r);\n    Bu(a, n);\n    Bu(a, q);\n    h[0] = d;\n    h[1] = e;\n    return new M(p, 0, f, g);\n  }\n\n  function qu(a, b) {\n    a = a.Xt[b];\n    if (void 0 !== a && (a = a.pop(), void 0 !== a)) return a;\n    a = [];\n\n    for (var c = 0; c < b; c++) {\n      a[c] = new I();\n    }\n\n    return a;\n  }\n\n  function Bu(a, b) {\n    var c = b.length,\n        d = a.Xt[c];\n    void 0 === d && (d = [], a.Xt[c] = d);\n    d.push(b);\n  }\n\n  xt.prototype.arrangeTrees = function () {\n    if (this.Nb === Ft) for (var a = this.Qb.iterator; a.next();) {\n      var b = a.value;\n\n      if (b instanceof Et) {\n        var c = b.node;\n\n        if (null !== c) {\n          var d = c.position;\n          c = d.x;\n          d = d.y;\n          isFinite(c) || (c = 0);\n          isFinite(d) || (d = 0);\n          Eu(this, b, c, d);\n        }\n      }\n    } else {\n      a = [];\n\n      for (b = this.Qb.iterator; b.next();) {\n        c = b.value, c instanceof Et && a.push(c);\n      }\n\n      switch (this.sorting) {\n        case Vt:\n          break;\n\n        case Wt:\n          a.reverse();\n          break;\n\n        case Xt:\n          a.sort(this.comparer);\n          break;\n\n        case Yt:\n          a.sort(this.comparer);\n          a.reverse();\n          break;\n\n        default:\n          C(\"Unhandled sorting value \" + this.sorting.toString());\n      }\n\n      c = this.arrangementOrigin;\n      b = c.x;\n      c = c.y;\n\n      for (d = 0; d < a.length; d++) {\n        var e = a[d];\n        Eu(this, e, b + e.ka.x, c + e.ka.y);\n\n        switch (this.Nb) {\n          case Ct:\n            c += e.Ca.height + this.Td.height;\n            break;\n\n          case Fu:\n            b += e.Ca.width + this.Td.width;\n            break;\n\n          default:\n            C(\"Unhandled arrangement value \" + this.Nb.toString());\n        }\n      }\n    }\n  };\n\n  function Eu(a, b, c, d) {\n    if (null !== b) {\n      b.x = c;\n      b.y = d;\n      b = b.children;\n\n      for (var e = b.length, f = 0; f < e; f++) {\n        var g = b[f];\n        Eu(a, g, c + g.S.x, d + g.S.y);\n      }\n    }\n  }\n\n  xt.prototype.commitLayout = function () {\n    this.ev();\n    this.commitNodes();\n    this.nu();\n    this.isRouting && this.commitLinks();\n  };\n\n  xt.prototype.commitNodes = function () {\n    for (var a = this.network.vertexes.iterator; a.next();) {\n      a.value.commit();\n    }\n\n    for (a.reset(); a.next();) {\n      this.layoutComments(a.value);\n    }\n  };\n\n  xt.prototype.nu = function () {\n    if (this.layerStyle === Nt) {\n      for (var a = this.Ev, b = [], c = null, d = this.network.vertexes.iterator; d.next();) {\n        var e = d.value;\n        null === c ? c = e.bounds.copy() : c.Xc(e.bounds);\n        var f = b[e.level];\n        void 0 === f ? f = lu(e) : f = Math.max(f, lu(e));\n        b[e.level] = f;\n      }\n\n      for (d = 0; d < b.length; d++) {\n        void 0 === b[d] && (b[d] = 0);\n      }\n\n      90 === this.angle || 270 === this.angle ? (c.vc(this.nodeSpacing / 2, this.layerSpacing), d = new I(-this.nodeSpacing / 2, -this.layerSpacing / 2)) : (c.vc(this.layerSpacing, this.nodeSpacing / 2), d = new I(-this.layerSpacing / 2, -this.nodeSpacing / 2));\n      e = [];\n      c = 90 === this.angle || 270 === this.angle ? c.width : c.height;\n      f = 0;\n      if (180 === this.angle || 270 === this.angle) for (var g = 0; g < a.length; g++) {\n        f += a[g] + b[g];\n      }\n\n      for (g = 0; g < a.length; g++) {\n        var h = a[g] + b[g];\n        270 === this.angle ? (f -= h, e.push(new M(0, f, c, h))) : 90 === this.angle ? (e.push(new M(0, f, c, h)), f += h) : 180 === this.angle ? (f -= h, e.push(new M(f, 0, h, c))) : (e.push(new M(f, 0, h, c)), f += h);\n      }\n\n      this.commitLayers(e, d);\n    }\n  };\n\n  xt.prototype.commitLayers = function () {};\n\n  xt.prototype.commitLinks = function () {\n    for (var a = this.network.edges.iterator; a.next();) {\n      a.value.commit();\n    }\n  };\n\n  xt.prototype.ev = function () {\n    for (var a = this.Qb.iterator; a.next();) {\n      var b = a.value;\n      b instanceof Et && Gu(this, b);\n    }\n  };\n\n  function Gu(a, b) {\n    if (null !== b) {\n      a.setPortSpots(b);\n      b = b.children;\n\n      for (var c = b.length, d = 0; d < c; d++) {\n        Gu(a, b[d]);\n      }\n    }\n  }\n\n  xt.prototype.setPortSpots = function (a) {\n    var b = a.alignment;\n\n    if (Zt(b)) {\n      var c = this.qd === zt,\n          d = ju(a);\n\n      switch (d) {\n        case 0:\n          var e = ed;\n          break;\n\n        case 90:\n          e = fd;\n          break;\n\n        case 180:\n          e = dd;\n          break;\n\n        default:\n          e = ad;\n      }\n\n      var f = a.children,\n          g = f.length;\n\n      switch (b) {\n        case $t:\n        case Qt:\n          for (b = 0; b < g; b++) {\n            var h = f[b];\n            h = (c ? h.sourceEdges : h.destinationEdges).first();\n\n            if (null !== h && (h = h.link, null !== h)) {\n              var k = 90 === d || 270 === d ? dd : ad;\n              if (1 === g || b === g - 1 && 1 === g % 2) switch (d) {\n                case 0:\n                  k = dd;\n                  break;\n\n                case 90:\n                  k = ad;\n                  break;\n\n                case 180:\n                  k = ed;\n                  break;\n\n                default:\n                  k = fd;\n              } else 0 === b % 2 && (k = 90 === d || 270 === d ? ed : fd);\n              c ? (a.setsPortSpot && (h.fromSpot = e), a.setsChildPortSpot && (h.toSpot = k)) : (a.setsPortSpot && (h.fromSpot = k), a.setsChildPortSpot && (h.toSpot = e));\n            }\n          }\n\n          break;\n\n        case au:\n          d = 90 === d || 270 === d ? ed : fd;\n\n          for (f = c ? a.destinationEdges : a.sourceEdges; f.next();) {\n            g = f.value.link, null !== g && (c ? (a.setsPortSpot && (g.fromSpot = e), a.setsChildPortSpot && (g.toSpot = d)) : (a.setsPortSpot && (g.fromSpot = d), a.setsChildPortSpot && (g.toSpot = e)));\n          }\n\n          break;\n\n        case bu:\n          for (d = 90 === d || 270 === d ? dd : ad, f = c ? a.destinationEdges : a.sourceEdges; f.next();) {\n            g = f.value.link, null !== g && (c ? (a.setsPortSpot && (g.fromSpot = e), a.setsChildPortSpot && (g.toSpot = d)) : (a.setsPortSpot && (g.fromSpot = d), a.setsChildPortSpot && (g.toSpot = e)));\n          }\n\n      }\n    } else if (c = ju(a), this.qd === zt) for (e = a.destinationEdges; e.next();) {\n      if (d = e.value.link, null !== d) {\n        if (a.setsPortSpot) if (a.portSpot.Sb()) switch (c) {\n          case 0:\n            d.fromSpot = ed;\n            break;\n\n          case 90:\n            d.fromSpot = fd;\n            break;\n\n          case 180:\n            d.fromSpot = dd;\n            break;\n\n          default:\n            d.fromSpot = ad;\n        } else d.fromSpot = a.portSpot;\n        if (a.setsChildPortSpot) if (a.childPortSpot.Sb()) switch (c) {\n          case 0:\n            d.toSpot = dd;\n            break;\n\n          case 90:\n            d.toSpot = ad;\n            break;\n\n          case 180:\n            d.toSpot = ed;\n            break;\n\n          default:\n            d.toSpot = fd;\n        } else d.toSpot = a.childPortSpot;\n      }\n    } else for (e = a.sourceEdges; e.next();) {\n      if (d = e.value.link, null !== d) {\n        if (a.setsPortSpot) if (a.portSpot.Sb()) switch (c) {\n          case 0:\n            d.toSpot = ed;\n            break;\n\n          case 90:\n            d.toSpot = fd;\n            break;\n\n          case 180:\n            d.toSpot = dd;\n            break;\n\n          default:\n            d.toSpot = ad;\n        } else d.toSpot = a.portSpot;\n        if (a.setsChildPortSpot) if (a.childPortSpot.Sb()) switch (c) {\n          case 0:\n            d.fromSpot = dd;\n            break;\n\n          case 90:\n            d.fromSpot = ad;\n            break;\n\n          case 180:\n            d.fromSpot = ed;\n            break;\n\n          default:\n            d.fromSpot = fd;\n        } else d.fromSpot = a.childPortSpot;\n      }\n    }\n  };\n\n  function ju(a) {\n    a = a.angle;\n    return 45 >= a ? 0 : 135 >= a ? 90 : 225 >= a ? 180 : 315 >= a ? 270 : 0;\n  }\n\n  function lu(a) {\n    var b = ju(a);\n    b = 90 === b || 270 === b;\n    var c = a.layerSpacing;\n\n    if (0 < a.layerSpacingParentOverlap) {\n      var d = Math.min(1, a.layerSpacingParentOverlap);\n      c -= b ? a.height * d : a.width * d;\n    }\n\n    c < (b ? -a.height : -a.width) && (c = b ? -a.height : -a.width);\n    return c;\n  }\n\n  function mu(a) {\n    var b = ju(a),\n        c = a.nodeIndent;\n\n    if (0 < a.nodeIndentPastParent) {\n      var d = Math.min(1, a.nodeIndentPastParent);\n      c += 90 === b || 270 === b ? a.width * d : a.height * d;\n    }\n\n    return c = Math.max(0, c);\n  }\n\n  ma.Object.defineProperties(xt.prototype, {\n    roots: {\n      get: function get() {\n        return this.Qb;\n      },\n      set: function set(a) {\n        this.Qb !== a && (this.Qb = a, this.D());\n      }\n    },\n    path: {\n      get: function get() {\n        return this.En;\n      },\n      set: function set(a) {\n        this.En !== a && (this.En = a, this.D());\n      }\n    },\n    treeStyle: {\n      get: function get() {\n        return this.Yn;\n      },\n      set: function set(a) {\n        this.Nb === a || a !== At && a !== Tt && a !== Ut && a !== St || (this.Yn = a, this.D());\n      }\n    },\n    layerStyle: {\n      get: function get() {\n        return this.aq;\n      },\n      set: function set(a) {\n        this.Nb === a || a !== Bt && a !== Ot && a !== Nt || (this.aq = a, this.D());\n      }\n    },\n    comments: {\n      get: function get() {\n        return this.od;\n      },\n      set: function set(a) {\n        this.od !== a && (this.od = a, this.D());\n      }\n    },\n    arrangement: {\n      get: function get() {\n        return this.Nb;\n      },\n      set: function set(a) {\n        this.Nb === a || a !== Ct && a !== Fu && a !== Ft || (this.Nb = a, this.D());\n      }\n    },\n    arrangementSpacing: {\n      get: function get() {\n        return this.Td;\n      },\n      set: function set(a) {\n        this.Td.C(a) || (this.Td.assign(a), this.D());\n      }\n    },\n    rootDefaults: {\n      get: function get() {\n        return this.V;\n      },\n      set: function set(a) {\n        this.V !== a && (this.V = a, this.D());\n      }\n    },\n    alternateDefaults: {\n      get: function get() {\n        return this.Y;\n      },\n      set: function set(a) {\n        this.Y !== a && (this.Y = a, this.D());\n      }\n    },\n    sorting: {\n      get: function get() {\n        return this.V.sorting;\n      },\n      set: function set(a) {\n        this.V.sorting === a || a !== Vt && a !== Wt && a !== Xt && !Yt || (this.V.sorting = a, this.D());\n      }\n    },\n    comparer: {\n      get: function get() {\n        return this.V.comparer;\n      },\n      set: function set(a) {\n        this.V.comparer !== a && (this.V.comparer = a, this.D());\n      }\n    },\n    angle: {\n      get: function get() {\n        return this.V.angle;\n      },\n      set: function set(a) {\n        this.V.angle !== a && (0 === a || 90 === a || 180 === a || 270 === a ? (this.V.angle = a, this.D()) : C(\"TreeLayout.angle must be 0, 90, 180, or 270\"));\n      }\n    },\n    alignment: {\n      get: function get() {\n        return this.V.alignment;\n      },\n      set: function set(a) {\n        this.V.alignment !== a && (this.V.alignment = a, this.D());\n      }\n    },\n    nodeIndent: {\n      get: function get() {\n        return this.V.nodeIndent;\n      },\n      set: function set(a) {\n        this.V.nodeIndent !== a && 0 <= a && (this.V.nodeIndent = a, this.D());\n      }\n    },\n    nodeIndentPastParent: {\n      get: function get() {\n        return this.V.nodeIndentPastParent;\n      },\n      set: function set(a) {\n        this.V.nodeIndentPastParent !== a && 0 <= a && 1 >= a && (this.V.nodeIndentPastParent = a, this.D());\n      }\n    },\n    nodeSpacing: {\n      get: function get() {\n        return this.V.nodeSpacing;\n      },\n      set: function set(a) {\n        this.V.nodeSpacing !== a && (this.V.nodeSpacing = a, this.D());\n      }\n    },\n    layerSpacing: {\n      get: function get() {\n        return this.V.layerSpacing;\n      },\n      set: function set(a) {\n        this.V.layerSpacing !== a && (this.V.layerSpacing = a, this.D());\n      }\n    },\n    layerSpacingParentOverlap: {\n      get: function get() {\n        return this.V.layerSpacingParentOverlap;\n      },\n      set: function set(a) {\n        this.V.layerSpacingParentOverlap !== a && 0 <= a && 1 >= a && (this.V.layerSpacingParentOverlap = a, this.D());\n      }\n    },\n    compaction: {\n      get: function get() {\n        return this.V.compaction;\n      },\n      set: function set(a) {\n        this.V.compaction === a || a !== eu && a !== gu || (this.V.compaction = a, this.D());\n      }\n    },\n    breadthLimit: {\n      get: function get() {\n        return this.V.breadthLimit;\n      },\n      set: function set(a) {\n        this.V.breadthLimit !== a && 0 <= a && (this.V.breadthLimit = a, this.D());\n      }\n    },\n    rowSpacing: {\n      get: function get() {\n        return this.V.rowSpacing;\n      },\n      set: function set(a) {\n        this.V.rowSpacing !== a && (this.V.rowSpacing = a, this.D());\n      }\n    },\n    rowIndent: {\n      get: function get() {\n        return this.V.rowIndent;\n      },\n      set: function set(a) {\n        this.V.rowIndent !== a && 0 <= a && (this.V.rowIndent = a, this.D());\n      }\n    },\n    commentSpacing: {\n      get: function get() {\n        return this.V.commentSpacing;\n      },\n      set: function set(a) {\n        this.V.commentSpacing !== a && (this.V.commentSpacing = a, this.D());\n      }\n    },\n    commentMargin: {\n      get: function get() {\n        return this.V.commentMargin;\n      },\n      set: function set(a) {\n        this.V.commentMargin !== a && (this.V.commentMargin = a, this.D());\n      }\n    },\n    setsPortSpot: {\n      get: function get() {\n        return this.V.setsPortSpot;\n      },\n      set: function set(a) {\n        this.V.setsPortSpot !== a && (this.V.setsPortSpot = a, this.D());\n      }\n    },\n    portSpot: {\n      get: function get() {\n        return this.V.portSpot;\n      },\n      set: function set(a) {\n        this.V.portSpot.C(a) || (this.V.portSpot = a, this.D());\n      }\n    },\n    setsChildPortSpot: {\n      get: function get() {\n        return this.V.setsChildPortSpot;\n      },\n      set: function set(a) {\n        this.V.setsChildPortSpot !== a && (this.V.setsChildPortSpot = a, this.D());\n      }\n    },\n    childPortSpot: {\n      get: function get() {\n        return this.V.childPortSpot;\n      },\n      set: function set(a) {\n        this.V.childPortSpot.C(a) || (this.V.childPortSpot = a, this.D());\n      }\n    },\n    alternateSorting: {\n      get: function get() {\n        return this.Y.sorting;\n      },\n      set: function set(a) {\n        this.Y.sorting === a || a !== Vt && a !== Wt && a !== Xt && !Yt || (this.Y.sorting = a, this.D());\n      }\n    },\n    alternateComparer: {\n      get: function get() {\n        return this.Y.comparer;\n      },\n      set: function set(a) {\n        this.Y.comparer !== a && (this.Y.comparer = a, this.D());\n      }\n    },\n    alternateAngle: {\n      get: function get() {\n        return this.Y.angle;\n      },\n      set: function set(a) {\n        this.Y.angle === a || 0 !== a && 90 !== a && 180 !== a && 270 !== a || (this.Y.angle = a, this.D());\n      }\n    },\n    alternateAlignment: {\n      get: function get() {\n        return this.Y.alignment;\n      },\n      set: function set(a) {\n        this.Y.alignment !== a && (this.Y.alignment = a, this.D());\n      }\n    },\n    alternateNodeIndent: {\n      get: function get() {\n        return this.Y.nodeIndent;\n      },\n      set: function set(a) {\n        this.Y.nodeIndent !== a && 0 <= a && (this.Y.nodeIndent = a, this.D());\n      }\n    },\n    alternateNodeIndentPastParent: {\n      get: function get() {\n        return this.Y.nodeIndentPastParent;\n      },\n      set: function set(a) {\n        this.Y.nodeIndentPastParent !== a && 0 <= a && 1 >= a && (this.Y.nodeIndentPastParent = a, this.D());\n      }\n    },\n    alternateNodeSpacing: {\n      get: function get() {\n        return this.Y.nodeSpacing;\n      },\n      set: function set(a) {\n        this.Y.nodeSpacing !== a && (this.Y.nodeSpacing = a, this.D());\n      }\n    },\n    alternateLayerSpacing: {\n      get: function get() {\n        return this.Y.layerSpacing;\n      },\n      set: function set(a) {\n        this.Y.layerSpacing !== a && (this.Y.layerSpacing = a, this.D());\n      }\n    },\n    alternateLayerSpacingParentOverlap: {\n      get: function get() {\n        return this.Y.layerSpacingParentOverlap;\n      },\n      set: function set(a) {\n        this.Y.layerSpacingParentOverlap !== a && 0 <= a && 1 >= a && (this.Y.layerSpacingParentOverlap = a, this.D());\n      }\n    },\n    alternateCompaction: {\n      get: function get() {\n        return this.Y.compaction;\n      },\n      set: function set(a) {\n        this.Y.compaction === a || a !== eu && a !== gu || (this.Y.compaction = a, this.D());\n      }\n    },\n    alternateBreadthLimit: {\n      get: function get() {\n        return this.Y.breadthLimit;\n      },\n      set: function set(a) {\n        this.Y.breadthLimit !== a && 0 <= a && (this.Y.breadthLimit = a, this.D());\n      }\n    },\n    alternateRowSpacing: {\n      get: function get() {\n        return this.Y.rowSpacing;\n      },\n      set: function set(a) {\n        this.Y.rowSpacing !== a && (this.Y.rowSpacing = a, this.D());\n      }\n    },\n    alternateRowIndent: {\n      get: function get() {\n        return this.Y.rowIndent;\n      },\n      set: function set(a) {\n        this.Y.rowIndent !== a && 0 <= a && (this.Y.rowIndent = a, this.D());\n      }\n    },\n    alternateCommentSpacing: {\n      get: function get() {\n        return this.Y.commentSpacing;\n      },\n      set: function set(a) {\n        this.Y.commentSpacing !== a && (this.Y.commentSpacing = a, this.D());\n      }\n    },\n    alternateCommentMargin: {\n      get: function get() {\n        return this.Y.commentMargin;\n      },\n      set: function set(a) {\n        this.Y.commentMargin !== a && (this.Y.commentMargin = a, this.D());\n      }\n    },\n    alternateSetsPortSpot: {\n      get: function get() {\n        return this.Y.setsPortSpot;\n      },\n      set: function set(a) {\n        this.Y.setsPortSpot !== a && (this.Y.setsPortSpot = a, this.D());\n      }\n    },\n    alternatePortSpot: {\n      get: function get() {\n        return this.Y.portSpot;\n      },\n      set: function set(a) {\n        this.Y.portSpot.C(a) || (this.Y.portSpot = a, this.D());\n      }\n    },\n    alternateSetsChildPortSpot: {\n      get: function get() {\n        return this.Y.setsChildPortSpot;\n      },\n      set: function set(a) {\n        this.Y.setsChildPortSpot !== a && (this.Y.setsChildPortSpot = a, this.D());\n      }\n    },\n    alternateChildPortSpot: {\n      get: function get() {\n        return this.Y.childPortSpot;\n      },\n      set: function set(a) {\n        this.Y.childPortSpot.C(a) || (this.Y.childPortSpot = a, this.D());\n      }\n    }\n  });\n  var yt = new D(xt, \"PathDefault\", -1),\n      zt = new D(xt, \"PathDestination\", 0),\n      Gt = new D(xt, \"PathSource\", 1),\n      Vt = new D(xt, \"SortingForwards\", 10),\n      Wt = new D(xt, \"SortingReverse\", 11),\n      Xt = new D(xt, \"SortingAscending\", 12),\n      Yt = new D(xt, \"SortingDescending\", 13),\n      wu = new D(xt, \"AlignmentCenterSubtrees\", 20),\n      xu = new D(xt, \"AlignmentCenterChildren\", 21),\n      nu = new D(xt, \"AlignmentStart\", 22),\n      ku = new D(xt, \"AlignmentEnd\", 23),\n      $t = new D(xt, \"AlignmentBus\", 24),\n      Qt = new D(xt, \"AlignmentBusBranching\", 25),\n      au = new D(xt, \"AlignmentTopLeftBus\", 26),\n      bu = new D(xt, \"AlignmentBottomRightBus\", 27),\n      eu = new D(xt, \"CompactionNone\", 30),\n      gu = new D(xt, \"CompactionBlock\", 31),\n      At = new D(xt, \"StyleLayered\", 40),\n      Ut = new D(xt, \"StyleLastParents\", 41),\n      Tt = new D(xt, \"StyleAlternating\", 42),\n      St = new D(xt, \"StyleRootOnly\", 43),\n      Ct = new D(xt, \"ArrangementVertical\", 50),\n      Fu = new D(xt, \"ArrangementHorizontal\", 51),\n      Ft = new D(xt, \"ArrangementFixedRoots\", 52),\n      Bt = new D(xt, \"LayerIndividual\", 60),\n      Ot = new D(xt, \"LayerSiblings\", 61),\n      Nt = new D(xt, \"LayerUniform\", 62);\n  xt.className = \"TreeLayout\";\n  xt.PathDefault = yt;\n  xt.PathDestination = zt;\n  xt.PathSource = Gt;\n  xt.SortingForwards = Vt;\n  xt.SortingReverse = Wt;\n  xt.SortingAscending = Xt;\n  xt.SortingDescending = Yt;\n  xt.AlignmentCenterSubtrees = wu;\n  xt.AlignmentCenterChildren = xu;\n  xt.AlignmentStart = nu;\n  xt.AlignmentEnd = ku;\n  xt.AlignmentBus = $t;\n  xt.AlignmentBusBranching = Qt;\n  xt.AlignmentTopLeftBus = au;\n  xt.AlignmentBottomRightBus = bu;\n  xt.CompactionNone = eu;\n  xt.CompactionBlock = gu;\n  xt.StyleLayered = At;\n  xt.StyleLastParents = Ut;\n  xt.StyleAlternating = Tt;\n  xt.StyleRootOnly = St;\n  xt.ArrangementVertical = Ct;\n  xt.ArrangementHorizontal = Fu;\n  xt.ArrangementFixedRoots = Ft;\n  xt.LayerIndividual = Bt;\n  xt.LayerSiblings = Ot;\n  xt.LayerUniform = Nt;\n\n  function Dt(a) {\n    dq.call(this, a);\n  }\n\n  la(Dt, dq);\n\n  Dt.prototype.createVertex = function () {\n    return new Et(this);\n  };\n\n  Dt.prototype.createEdge = function () {\n    return new Hu(this);\n  };\n\n  Dt.className = \"TreeNetwork\";\n\n  function Et(a) {\n    rq.call(this, a);\n    this.W = !1;\n    this.cb = null;\n    this.u = [];\n    this.hb = this.Ga = this.F = this.ga = 0;\n    this.od = null;\n    this.S = new I(0, 0);\n    this.Ca = new K(0, 0);\n    this.ka = new I(0, 0);\n    this.Ql = this.Pl = this.Xz = !1;\n    this.No = this.Bo = null;\n    this.fd = Vt;\n    this.Zc = yq;\n    this.Gb = 0;\n    this.Fb = xu;\n    this.uq = this.tq = 0;\n    this.vq = 20;\n    this.be = 50;\n    this.$p = 0;\n    this.kp = gu;\n    this.cp = 0;\n    this.Mq = 25;\n    this.jp = this.Lq = 10;\n    this.ip = 20;\n    this.Uq = !0;\n    this.Cq = Wc;\n    this.Tq = !0;\n    this.gp = Wc;\n  }\n\n  la(Et, rq);\n\n  Et.prototype.copyInheritedPropertiesFrom = function (a) {\n    null !== a && (this.fd = a.sorting, this.Zc = a.comparer, this.Gb = a.angle, this.Fb = a.alignment, this.tq = a.nodeIndent, this.uq = a.nodeIndentPastParent, this.vq = a.nodeSpacing, this.be = a.layerSpacing, this.$p = a.layerSpacingParentOverlap, this.kp = a.compaction, this.cp = a.breadthLimit, this.Mq = a.rowSpacing, this.Lq = a.rowIndent, this.jp = a.commentSpacing, this.ip = a.commentMargin, this.Uq = a.setsPortSpot, this.Cq = a.portSpot, this.Tq = a.setsChildPortSpot, this.gp = a.childPortSpot);\n  };\n\n  ma.Object.defineProperties(Et.prototype, {\n    initialized: {\n      get: function get() {\n        return this.W;\n      },\n      set: function set(a) {\n        this.W !== a && (this.W = a);\n      }\n    },\n    parent: {\n      get: function get() {\n        return this.cb;\n      },\n      set: function set(a) {\n        this.cb !== a && (this.cb = a);\n      }\n    },\n    children: {\n      get: function get() {\n        return this.u;\n      },\n      set: function set(a) {\n        if (this.u !== a) {\n          if (null !== a) for (var b = a.length, c = 0; c < b; c++) {\n            ;\n          }\n          this.u = a;\n        }\n      }\n    },\n    level: {\n      get: function get() {\n        return this.ga;\n      },\n      set: function set(a) {\n        this.ga !== a && (this.ga = a);\n      }\n    },\n    descendantCount: {\n      get: function get() {\n        return this.F;\n      },\n      set: function set(a) {\n        this.F !== a && (this.F = a);\n      }\n    },\n    maxChildrenCount: {\n      get: function get() {\n        return this.Ga;\n      },\n      set: function set(a) {\n        this.Ga !== a && (this.Ga = a);\n      }\n    },\n    maxGenerationCount: {\n      get: function get() {\n        return this.hb;\n      },\n      set: function set(a) {\n        this.hb !== a && (this.hb = a);\n      }\n    },\n    comments: {\n      get: function get() {\n        return this.od;\n      },\n      set: function set(a) {\n        if (this.od !== a) {\n          if (null !== a) for (var b = a.length, c = 0; c < b; c++) {\n            ;\n          }\n          this.od = a;\n        }\n      }\n    },\n    sorting: {\n      get: function get() {\n        return this.fd;\n      },\n      set: function set(a) {\n        this.fd !== a && (this.fd = a);\n      }\n    },\n    comparer: {\n      get: function get() {\n        return this.Zc;\n      },\n      set: function set(a) {\n        this.Zc !== a && (this.Zc = a);\n      }\n    },\n    angle: {\n      get: function get() {\n        return this.Gb;\n      },\n      set: function set(a) {\n        this.Gb !== a && (this.Gb = a);\n      }\n    },\n    alignment: {\n      get: function get() {\n        return this.Fb;\n      },\n      set: function set(a) {\n        this.Fb !== a && (this.Fb = a);\n      }\n    },\n    nodeIndent: {\n      get: function get() {\n        return this.tq;\n      },\n      set: function set(a) {\n        this.tq !== a && (this.tq = a);\n      }\n    },\n    nodeIndentPastParent: {\n      get: function get() {\n        return this.uq;\n      },\n      set: function set(a) {\n        this.uq !== a && (this.uq = a);\n      }\n    },\n    nodeSpacing: {\n      get: function get() {\n        return this.vq;\n      },\n      set: function set(a) {\n        this.vq !== a && (this.vq = a);\n      }\n    },\n    layerSpacing: {\n      get: function get() {\n        return this.be;\n      },\n      set: function set(a) {\n        this.be !== a && (this.be = a);\n      }\n    },\n    layerSpacingParentOverlap: {\n      get: function get() {\n        return this.$p;\n      },\n      set: function set(a) {\n        this.$p !== a && (this.$p = a);\n      }\n    },\n    compaction: {\n      get: function get() {\n        return this.kp;\n      },\n      set: function set(a) {\n        this.kp !== a && (this.kp = a);\n      }\n    },\n    breadthLimit: {\n      get: function get() {\n        return this.cp;\n      },\n      set: function set(a) {\n        this.cp !== a && (this.cp = a);\n      }\n    },\n    rowSpacing: {\n      get: function get() {\n        return this.Mq;\n      },\n      set: function set(a) {\n        this.Mq !== a && (this.Mq = a);\n      }\n    },\n    rowIndent: {\n      get: function get() {\n        return this.Lq;\n      },\n      set: function set(a) {\n        this.Lq !== a && (this.Lq = a);\n      }\n    },\n    commentSpacing: {\n      get: function get() {\n        return this.jp;\n      },\n      set: function set(a) {\n        this.jp !== a && (this.jp = a);\n      }\n    },\n    commentMargin: {\n      get: function get() {\n        return this.ip;\n      },\n      set: function set(a) {\n        this.ip !== a && (this.ip = a);\n      }\n    },\n    setsPortSpot: {\n      get: function get() {\n        return this.Uq;\n      },\n      set: function set(a) {\n        this.Uq !== a && (this.Uq = a);\n      }\n    },\n    portSpot: {\n      get: function get() {\n        return this.Cq;\n      },\n      set: function set(a) {\n        this.Cq.C(a) || (this.Cq = a);\n      }\n    },\n    setsChildPortSpot: {\n      get: function get() {\n        return this.Tq;\n      },\n      set: function set(a) {\n        this.Tq !== a && (this.Tq = a);\n      }\n    },\n    childPortSpot: {\n      get: function get() {\n        return this.gp;\n      },\n      set: function set(a) {\n        this.gp.C(a) || (this.gp = a);\n      }\n    },\n    childrenCount: {\n      get: function get() {\n        return this.children.length;\n      }\n    },\n    relativePosition: {\n      get: function get() {\n        return this.S;\n      },\n      set: function set(a) {\n        this.S.set(a);\n      }\n    },\n    subtreeSize: {\n      get: function get() {\n        return this.Ca;\n      },\n      set: function set(a) {\n        this.Ca.set(a);\n      }\n    },\n    subtreeOffset: {\n      get: function get() {\n        return this.ka;\n      },\n      set: function set(a) {\n        this.ka.set(a);\n      }\n    }\n  });\n  Et.className = \"TreeVertex\";\n\n  function Hu(a) {\n    sq.call(this, a);\n    this.Ft = new I(0, 0);\n  }\n\n  la(Hu, sq);\n\n  Hu.prototype.commit = function () {\n    var a = this.link;\n\n    if (null !== a && !a.isAvoiding) {\n      var b = this.network.layout,\n          c = null,\n          d = null;\n\n      switch (b.qd) {\n        case zt:\n          c = this.fromVertex;\n          d = this.toVertex;\n          break;\n\n        case Gt:\n          c = this.toVertex;\n          d = this.fromVertex;\n          break;\n\n        default:\n          C(\"Unhandled path value \" + b.qd.toString());\n      }\n\n      if (null !== c && null !== d) if (b = this.Ft, 0 !== b.x || 0 !== b.y || c.Xz) {\n        d = c.bounds;\n        var e = ju(c),\n            f = lu(c),\n            g = c.rowSpacing;\n        a.mg();\n        var h = a.curve === cg,\n            k = a.isOrthogonal,\n            l;\n        a.jh();\n\n        if (k || h) {\n          for (l = 2; 4 < a.pointsCount;) {\n            a.Yu(2);\n          }\n\n          var m = a.i(1);\n          var n = a.i(2);\n        } else {\n          for (l = 1; 3 < a.pointsCount;) {\n            a.Yu(1);\n          }\n\n          m = a.i(0);\n          n = a.i(a.pointsCount - 1);\n        }\n\n        var p = a.i(a.pointsCount - 1);\n        0 === e ? (c.alignment === ku ? (e = d.bottom + b.y, 0 === b.y && m.y > p.y + c.rowIndent && (e = Math.min(e, Math.max(m.y, e - mu(c))))) : c.alignment === nu ? (e = d.top + b.y, 0 === b.y && m.y < p.y - c.rowIndent && (e = Math.max(e, Math.min(m.y, e + mu(c))))) : e = c.Pl || c.Ql && 1 === c.maxGenerationCount ? d.top - c.ka.y + b.y : d.y + d.height / 2 + b.y, h ? (a.l(l, m.x, e), l++, a.l(l, d.right + f, e), l++, a.l(l, d.right + f + (b.x - g) / 3, e), l++, a.l(l, d.right + f + 2 * (b.x - g) / 3, e), l++, a.l(l, d.right + f + (b.x - g), e), l++, a.l(l, n.x, e)) : (k && (a.l(l, d.right + f / 2, m.y), l++), a.l(l, d.right + f / 2, e), l++, a.l(l, d.right + f + b.x - (k ? g / 2 : g), e), l++, k && a.l(l, a.i(l - 1).x, n.y))) : 90 === e ? (c.alignment === ku ? (e = d.right + b.x, 0 === b.x && m.x > p.x + c.rowIndent && (e = Math.min(e, Math.max(m.x, e - mu(c))))) : c.alignment === nu ? (e = d.left + b.x, 0 === b.x && m.x < p.x - c.rowIndent && (e = Math.max(e, Math.min(m.x, e + mu(c))))) : e = c.Pl || c.Ql && 1 === c.maxGenerationCount ? d.left - c.ka.x + b.x : d.x + d.width / 2 + b.x, h ? (a.l(l, e, m.y), l++, a.l(l, e, d.bottom + f), l++, a.l(l, e, d.bottom + f + (b.y - g) / 3), l++, a.l(l, e, d.bottom + f + 2 * (b.y - g) / 3), l++, a.l(l, e, d.bottom + f + (b.y - g)), l++, a.l(l, e, n.y)) : (k && (a.l(l, m.x, d.bottom + f / 2), l++), a.l(l, e, d.bottom + f / 2), l++, a.l(l, e, d.bottom + f + b.y - (k ? g / 2 : g)), l++, k && a.l(l, n.x, a.i(l - 1).y))) : 180 === e ? (c.alignment === ku ? (e = d.bottom + b.y, 0 === b.y && m.y > p.y + c.rowIndent && (e = Math.min(e, Math.max(m.y, e - mu(c))))) : c.alignment === nu ? (e = d.top + b.y, 0 === b.y && m.y < p.y - c.rowIndent && (e = Math.max(e, Math.min(m.y, e + mu(c))))) : e = c.Pl || c.Ql && 1 === c.maxGenerationCount ? d.top - c.ka.y + b.y : d.y + d.height / 2 + b.y, h ? (a.l(l, m.x, e), l++, a.l(l, d.left - f, e), l++, a.l(l, d.left - f + (b.x + g) / 3, e), l++, a.l(l, d.left - f + 2 * (b.x + g) / 3, e), l++, a.l(l, d.left - f + (b.x + g), e), l++, a.l(l, n.x, e)) : (k && (a.l(l, d.left - f / 2, m.y), l++), a.l(l, d.left - f / 2, e), l++, a.l(l, d.left - f + b.x + (k ? g / 2 : g), e), l++, k && a.l(l, a.i(l - 1).x, n.y))) : 270 === e ? (c.alignment === ku ? (e = d.right + b.x, 0 === b.x && m.x > p.x + c.rowIndent && (e = Math.min(e, Math.max(m.x, e - mu(c))))) : c.alignment === nu ? (e = d.left + b.x, 0 === b.x && m.x < p.x - c.rowIndent && (e = Math.max(e, Math.min(m.x, e + mu(c))))) : e = c.Pl || c.Ql && 1 === c.maxGenerationCount ? d.left - c.ka.x + b.x : d.x + d.width / 2 + b.x, h ? (a.l(l, e, m.y), l++, a.l(l, e, d.top - f), l++, a.l(l, e, d.top - f + (b.y + g) / 3), l++, a.l(l, e, d.top - f + 2 * (b.y + g) / 3), l++, a.l(l, e, d.top - f + (b.y + g)), l++, a.l(l, e, n.y)) : (k && (a.l(l, m.x, d.top - f / 2), l++), a.l(l, e, d.top - f / 2), l++, a.l(l, e, d.top - f + b.y + (k ? g / 2 : g)), l++, k && a.l(l, n.x, a.i(l - 1).y))) : C(\"Invalid angle \" + e);\n        a.pf();\n      } else a = this.link, f = ju(c), f !== ju(d) && (g = lu(c), h = c.bounds, c = d.bounds, 0 === f && c.left - h.right < g + 1 || 90 === f && c.top - h.bottom < g + 1 || 180 === f && h.left - c.right < g + 1 || 270 === f && h.top - c.bottom < g + 1 || (a.mg(), c = a.curve === cg, b = a.isOrthogonal, d = Zt(this.fromVertex.alignment), a.jh(), 0 === f ? (f = h.right + g / 2, c ? 4 === a.pointsCount && (c = a.i(3).y, a.M(1, f - 20, a.i(1).y), a.l(2, f - 20, c), a.l(3, f, c), a.l(4, f + 20, c), a.M(5, a.i(5).x, c)) : b ? d ? a.M(3, a.i(2).x, a.i(4).y) : 6 === a.pointsCount && (a.M(2, f, a.i(2).y), a.M(3, f, a.i(3).y)) : 4 === a.pointsCount ? a.l(2, f, a.i(2).y) : 3 === a.pointsCount ? a.M(1, f, a.i(2).y) : 2 === a.pointsCount && a.l(1, f, a.i(1).y)) : 90 === f ? (f = h.bottom + g / 2, c ? 4 === a.pointsCount && (c = a.i(3).x, a.M(1, a.i(1).x, f - 20), a.l(2, c, f - 20), a.l(3, c, f), a.l(4, c, f + 20), a.M(5, c, a.i(5).y)) : b ? d ? a.M(3, a.i(2).x, a.i(4).y) : 6 === a.pointsCount && (a.M(2, a.i(2).x, f), a.M(3, a.i(3).x, f)) : 4 === a.pointsCount ? a.l(2, a.i(2).x, f) : 3 === a.pointsCount ? a.M(1, a.i(2).x, f) : 2 === a.pointsCount && a.l(1, a.i(1).x, f)) : 180 === f ? (f = h.left - g / 2, c ? 4 === a.pointsCount && (c = a.i(3).y, a.M(1, f + 20, a.i(1).y), a.l(2, f + 20, c), a.l(3, f, c), a.l(4, f - 20, c), a.M(5, a.i(5).x, c)) : b ? d ? a.M(3, a.i(2).x, a.i(4).y) : 6 === a.pointsCount && (a.M(2, f, a.i(2).y), a.M(3, f, a.i(3).y)) : 4 === a.pointsCount ? a.l(2, f, a.i(2).y) : 3 === a.pointsCount ? a.M(1, f, a.i(2).y) : 2 === a.pointsCount && a.l(1, f, a.i(1).y)) : 270 === f && (f = h.top - g / 2, c ? 4 === a.pointsCount && (c = a.i(3).x, a.M(1, a.i(1).x, f + 20), a.l(2, c, f + 20), a.l(3, c, f), a.l(4, c, f - 20), a.M(5, c, a.i(5).y)) : b ? d ? a.M(3, a.i(2).x, a.i(4).y) : 6 === a.pointsCount && (a.M(2, a.i(2).x, f), a.M(3, a.i(3).x, f)) : 4 === a.pointsCount ? a.l(2, a.i(2).x, f) : 3 === a.pointsCount ? a.M(1, a.i(2).x, f) : 2 === a.pointsCount && a.l(1, a.i(1).x, f)), a.pf()));\n    }\n  };\n\n  ma.Object.defineProperties(Hu.prototype, {\n    fromVertex: {\n      get: function get() {\n        return this.ad;\n      },\n      set: function set(a) {\n        this.ad !== a && (this.ad = a);\n      }\n    },\n    toVertex: {\n      get: function get() {\n        return this.jd;\n      },\n      set: function set(a) {\n        this.jd !== a && (this.jd = a);\n      }\n    },\n    relativePoint: {\n      get: function get() {\n        return this.Ft;\n      },\n      set: function set(a) {\n        this.Ft.set(a);\n      }\n    }\n  });\n  Hu.className = \"TreeEdge\";\n\n  La.prototype.initializeStandardTools = function () {\n    this.gb(\"Action\", new qg(), this.mouseDownTools);\n    this.gb(\"Relinking\", new Se(), this.mouseDownTools);\n    this.gb(\"LinkReshaping\", new ag(), this.mouseDownTools);\n    this.gb(\"Rotating\", new og(), this.mouseDownTools);\n    this.gb(\"Resizing\", new hg(), this.mouseDownTools);\n    this.gb(\"Linking\", new Uf(), this.mouseMoveTools);\n    this.gb(\"Dragging\", new Be(), this.mouseMoveTools);\n    this.gb(\"DragSelecting\", new Bg(), this.mouseMoveTools);\n    this.gb(\"Panning\", new Cg(), this.mouseMoveTools);\n    this.gb(\"ContextMenu\", new Eg(), this.mouseUpTools);\n    this.gb(\"TextEditing\", new Pg(), this.mouseUpTools);\n    this.gb(\"ClickCreating\", new rg(), this.mouseUpTools);\n    this.gb(\"ClickSelecting\", new pg(), this.mouseUpTools);\n  };\n\n  qn(\"Horizontal\", new um());\n  qn(\"Spot\", new wm());\n  qn(\"Table\", new Bm());\n  qn(\"Viewbox\", new Gm());\n  qn(\"TableRow\", new Em());\n  qn(\"TableColumn\", new Fm());\n  qn(\"Graduated\", new Qm());\n  qn(\"Grid\", new Hm());\n  li.add(\"GraphLinksModel\", Rq);\n  li.add(\"TreeModel\", er);\n  jq(ls, null);\n  jq(As, null);\n  var Iu = x.go,\n      Ju = {\n    get licenseKey() {\n      return Q.licenseKey;\n    },\n\n    set licenseKey(a) {\n      Q.licenseKey = a;\n    },\n\n    get version() {\n      return Q.version;\n    },\n\n    Group: qf,\n    EnumValue: D,\n    List: E,\n    Set: G,\n    Map: pb,\n    Point: I,\n    Size: K,\n    Rect: M,\n    Margin: ec,\n    Spot: N,\n    Geometry: O,\n    PathFigure: Xd,\n    PathSegment: Yd,\n    InputEvent: $d,\n    DiagramEvent: be,\n    ChangedEvent: ce,\n    Model: Z,\n    GraphLinksModel: zr,\n    TreeModel: Er,\n    Binding: wi,\n    Transaction: he,\n    UndoManager: ie,\n    CommandHandler: Qk,\n    Tool: ke,\n    DraggingTool: Be,\n    DraggingInfo: Te,\n    DraggingOptions: Ce,\n    LinkingBaseTool: Bf,\n    LinkingTool: Uf,\n    RelinkingTool: Se,\n    LinkReshapingTool: ag,\n    ResizingTool: hg,\n    RotatingTool: og,\n    ClickSelectingTool: pg,\n    ActionTool: qg,\n    ClickCreatingTool: rg,\n    HTMLInfo: ze,\n    ContextMenuTool: Eg,\n    DragSelectingTool: Bg,\n    PanningTool: Cg,\n    TextEditingTool: Pg,\n    ToolManager: La,\n    Animation: kh,\n    AnimationManager: gh,\n    AnimationTrigger: Zh,\n    Layer: di,\n    Diagram: Q,\n    Palette: Jk,\n    Overview: Mk,\n    Brush: ml,\n    GraphObject: Y,\n    Panel: W,\n    RowColumnDefinition: Oj,\n    Shape: Cf,\n    TextBlock: Qg,\n    Picture: Wj,\n    Part: U,\n    Adornment: ue,\n    Node: V,\n    Link: T,\n    Placeholder: jg,\n    Layout: qi,\n    LayoutNetwork: dq,\n    LayoutVertex: rq,\n    LayoutEdge: sq,\n    GridLayout: Lk,\n    PanelLayout: Kl,\n    CircularLayout: Fr,\n    CircularNetwork: Wr,\n    CircularVertex: js,\n    CircularEdge: ks,\n    ForceDirectedLayout: ls,\n    ForceDirectedNetwork: ms,\n    ForceDirectedVertex: ys,\n    ForceDirectedEdge: zs,\n    LayeredDigraphLayout: As,\n    LayeredDigraphNetwork: Fs,\n    LayeredDigraphVertex: vt,\n    LayeredDigraphEdge: wt,\n    TreeLayout: xt,\n    TreeNetwork: Dt,\n    TreeVertex: Et,\n    TreeEdge: Hu\n  };\n  \"object\" === typeof Iu && Iu.version && xa(\"WARNING: a `go` object on the root object is already defined.  \" + (\"Debug\" in Iu ? \"debug \" : \"\") + \"version: \" + Iu.version + \", replaced with version: \" + Ju.version);\n  Q.prototype.go = Ju;\n  x.go = Ju;\n  'undefined' !== typeof module && 'object' === typeof module.exports && (module.exports = 'undefined' !== typeof global ? global.go : self.go);\n})();\n\nexport default typeof global !== \"undefined\" ? global.go : self.go;\nexport var go = typeof global !== \"undefined\" ? global.go : self.go;\nexport var Group = go.Group;\nexport var EnumValue = go.EnumValue;\nexport var List = go.List;\nexport var Set = go.Set;\nexport var Map = go.Map;\nexport var Point = go.Point;\nexport var Size = go.Size;\nexport var Rect = go.Rect;\nexport var Margin = go.Margin;\nexport var Spot = go.Spot;\nexport var Geometry = go.Geometry;\nexport var PathFigure = go.PathFigure;\nexport var PathSegment = go.PathSegment;\nexport var InputEvent = go.InputEvent;\nexport var DiagramEvent = go.DiagramEvent;\nexport var ChangedEvent = go.ChangedEvent;\nexport var Model = go.Model;\nexport var GraphLinksModel = go.GraphLinksModel;\nexport var TreeModel = go.TreeModel;\nexport var Binding = go.Binding;\nexport var Transaction = go.Transaction;\nexport var UndoManager = go.UndoManager;\nexport var CommandHandler = go.CommandHandler;\nexport var Tool = go.Tool;\nexport var DraggingTool = go.DraggingTool;\nexport var DraggingInfo = go.DraggingInfo;\nexport var LinkingBaseTool = go.LinkingBaseTool;\nexport var LinkingTool = go.LinkingTool;\nexport var RelinkingTool = go.RelinkingTool;\nexport var LinkReshapingTool = go.LinkReshapingTool;\nexport var ResizingTool = go.ResizingTool;\nexport var RotatingTool = go.RotatingTool;\nexport var ClickSelectingTool = go.ClickSelectingTool;\nexport var ActionTool = go.ActionTool;\nexport var ClickCreatingTool = go.ClickCreatingTool;\nexport var HTMLInfo = go.HTMLInfo;\nexport var ContextMenuTool = go.ContextMenuTool;\nexport var DragSelectingTool = go.DragSelectingTool;\nexport var PanningTool = go.PanningTool;\nexport var TextEditingTool = go.TextEditingTool;\nexport var ToolManager = go.ToolManager;\nexport var Animation = go.Animation;\nexport var AnimationManager = go.AnimationManager;\nexport var AnimationTrigger = go.AnimationTrigger;\nexport var Layer = go.Layer;\nexport var Diagram = go.Diagram;\nexport var Palette = go.Palette;\nexport var Overview = go.Overview;\nexport var Brush = go.Brush;\nexport var GraphObject = go.GraphObject;\nexport var Panel = go.Panel;\nexport var RowColumnDefinition = go.RowColumnDefinition;\nexport var Shape = go.Shape;\nexport var TextBlock = go.TextBlock;\nexport var TextBlockMetrics = go.TextBlockMetrics;\nexport var Picture = go.Picture;\nexport var Part = go.Part;\nexport var Adornment = go.Adornment;\nexport var Node = go.Node;\nexport var Link = go.Link;\nexport var Placeholder = go.Placeholder;\nexport var Layout = go.Layout;\nexport var LayoutNetwork = go.LayoutNetwork;\nexport var LayoutVertex = go.LayoutVertex;\nexport var LayoutEdge = go.LayoutEdge;\nexport var GridLayout = go.GridLayout;\nexport var PanelLayout = go.PanelLayout;\nexport var CircularLayout = go.CircularLayout;\nexport var CircularNetwork = go.CircularNetwork;\nexport var CircularVertex = go.CircularVertex;\nexport var CircularEdge = go.CircularEdge;\nexport var ForceDirectedLayout = go.ForceDirectedLayout;\nexport var ForceDirectedNetwork = go.ForceDirectedNetwork;\nexport var ForceDirectedVertex = go.ForceDirectedVertex;\nexport var ForceDirectedEdge = go.ForceDirectedEdge;\nexport var LayeredDigraphLayout = go.LayeredDigraphLayout;\nexport var LayeredDigraphNetwork = go.LayeredDigraphNetwork;\nexport var LayeredDigraphVertex = go.LayeredDigraphVertex;\nexport var LayeredDigraphEdge = go.LayeredDigraphEdge;\nexport var TreeLayout = go.TreeLayout;\nexport var TreeNetwork = go.TreeNetwork;\nexport var TreeVertex = go.TreeVertex;\nexport var TreeEdge = go.TreeEdge;\nexport var version = go.version;","map":null,"metadata":{},"sourceType":"module"}