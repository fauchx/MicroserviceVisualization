{"ast":null,"code":"import _classCallCheck from \"C:\\\\visualizacion_microservicios\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:\\\\visualizacion_microservicios\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/createClass\";\n\n/*\r\n*  Copyright (C) 1998-2022 by Northwoods Software Corporation. All Rights Reserved.\r\n*/\n\n/*\r\n* This is an extension and not part of the main GoJS library.\r\n* Note that the API for this class may change with any version, even point releases.\r\n* If you intend to use an extension in production, you should copy the code to your own source directory.\r\n* Extensions can be found in the GoJS kit under the extensions or extensionsJSM folders.\r\n* See the Extensions intro page (https://gojs.net/latest/intro/extensions.html) for more information.\r\n*/\nimport * as go from '../release/go-module.js';\n/**\r\n * This class implements an inspector for GoJS model data objects.\r\n * The constructor takes three arguments:\r\n *   - `divid` ***string*** a string referencing the HTML ID of the to-be inspector's div\r\n *   - `diagram` ***Diagram*** a reference to a GoJS Diagram\r\n *   - `options` ***Object*** an optional JS Object describing options for the inspector\r\n *\r\n * Options:\r\n *   - `inspectSelection` ***boolean*** see {@link #inspectSelection}\r\n *   - `includesOwnProperties` ***boolean*** see {@link #includesOwnProperties}\r\n *   - `properties` ***Object*** see {@link #properties}\r\n *   - `propertyModified` ***function(propertyName, newValue, inspector)*** see {@link #propertyModified}\r\n *   - `multipleSelection` ***boolean*** see {@link #multipleSelection}\r\n *   - `showUnionProperties` ***boolean*** see {@link #showUnionProperties}\r\n *   - `showLimit` ***number*** see {@link #showLimit}\r\n *\r\n * Options for properties:\r\n *   - `show` ***boolean | function*** a boolean value to show or hide the property from the inspector, or a predicate function to show conditionally.\r\n *   - `readOnly` ***boolean | function*** whether or not the property is read-only\r\n *   - `type` ***string*** a string describing the data type. Supported values: \"string|number|boolean|color|arrayofnumber|point|rect|size|spot|margin|select|date|datetime-local|time\"\r\n *   - `defaultValue` ***any*** a default value for the property. Defaults to the empty string.\r\n *   - `choices` ***Array | function*** when type === \"select\", the Array of choices to use or a function that returns the Array of choices.\r\n *\r\n * Example usage of Inspector:\r\n * ```js\r\n * var inspector = new Inspector(\"myInspector\", myDiagram,\r\n *   {\r\n *     includesOwnProperties: false,\r\n *     properties: {\r\n *       \"key\": { show: Inspector.showIfPresent, readOnly: true },\r\n *       \"comments\": { show: Inspector.showIfNode  },\r\n *       \"LinkComments\": { show: Inspector.showIfLink },\r\n *       \"chosen\": { show: Inspector.showIfNode, type: \"checkbox\" },\r\n *       \"state\": { show: Inspector.showIfNode, type: \"select\", choices: [\"Stopped\", \"Parked\", \"Moving\"] }\r\n *     }\r\n *   });\r\n * ```\r\n *\r\n * This is the basic HTML Structure that the Inspector creates within the given DIV element:\r\n * ```html\r\n * <div id=\"divid\" class=\"inspector\">\r\n *   <tr>\r\n *     <td>propertyName</td>\r\n *     <td><input value=propertyValue /></td>\r\n *   </tr>\r\n *   ...\r\n * </div>\r\n * ```\r\n *\r\n * If you want to experiment with this extension, try the <a href=\"../../extensionsJSM/DataInspector.html\">Data Inspector</a> sample.\r\n * @category Extension\r\n */\n\nexport var Inspector = /*#__PURE__*/function () {\n  /**\r\n   * Constructs an Inspector and sets up properties based on the options provided.\r\n   * Also sets up change listeners on the Diagram so the Inspector stays up-to-date.\r\n   * @param {string} divid a string referencing the HTML ID of the to-be Inspector's div\r\n   * @param {Diagram} diagram a reference to a GoJS Diagram\r\n   * @param {Object=} options an optional JS Object describing options for the inspector\r\n   */\n  function Inspector(divid, diagram, options) {\n    _classCallCheck(this, Inspector);\n\n    this._inspectedObject = null; // Inspector options defaults:\n\n    this._inspectSelection = true;\n    this._includesOwnProperties = true;\n    this._properties = {};\n    this._propertyModified = null;\n    this._multipleSelection = false;\n    this._showUnionProperties = false;\n    this._showLimit = 0; // Private variables used to keep track of internal state\n\n    this.inspectedProperties = {};\n    this.multipleProperties = {};\n    var mainDiv = document.getElementById(divid);\n    mainDiv.className = 'inspector';\n    mainDiv.innerHTML = '';\n    this._div = mainDiv;\n    this._diagram = diagram;\n    this.tabIndex = 0; // Set properties based on options\n\n    if (options !== undefined) {\n      if (options.inspectSelection !== undefined) this._inspectSelection = options.inspectSelection;\n      if (options.includesOwnProperties !== undefined) this._includesOwnProperties = options.includesOwnProperties;\n      if (options.properties !== undefined) this._properties = options.properties;\n      if (options.propertyModified !== undefined) this._propertyModified = options.propertyModified;\n      if (options.multipleSelection !== undefined) this._multipleSelection = options.multipleSelection;\n      if (options.showUnionProperties !== undefined) this._showUnionProperties = options.showUnionProperties;\n      if (options.showLimit !== undefined) this._showLimit = options.showLimit;\n    } // Prepare change listeners\n\n\n    var self = this;\n\n    this.inspectOnModelChanged = function (e) {\n      if (e.isTransactionFinished) self.inspectObject();\n    };\n\n    this.inspectOnSelectionChanged = function (e) {\n      self.inspectObject();\n    };\n\n    this._diagram.addModelChangedListener(this.inspectOnModelChanged);\n\n    if (this._inspectSelection) {\n      this._diagram.addDiagramListener('ChangedSelection', this.inspectOnSelectionChanged);\n    }\n  }\n  /**\r\n   * This read-only property returns the HTMLElement containing the Inspector.\r\n   */\n\n\n  _createClass(Inspector, [{\n    key: \"inspectObject\",\n\n    /**\r\n     * Update the HTML state of this Inspector with the given object.\r\n     *\r\n     * If passed an object, the Inspector will inspect that object.\r\n     * If passed null, this will do nothing.\r\n     * If no parameter is supplied, the {@link #inspectedObject} will be set based on the value of {@link #inspectSelection}.\r\n     * @param {Object=} object an optional argument, used when {@link #inspectSelection} is false to\r\n     *   set {@link #inspectedObject} and show and edit that object's properties.\r\n     */\n    value: function inspectObject(object) {\n      var inspectedObject = null;\n      var inspectedObjects = null;\n      if (object === null) return;\n\n      if (object === undefined) {\n        if (this._inspectSelection) {\n          if (this._multipleSelection) {\n            // gets the selection if multiple selection is true\n            inspectedObjects = this._diagram.selection;\n            this._inspectedObject = inspectedObjects.first();\n          } else {\n            // otherwise grab the first object\n            inspectedObject = this._diagram.selection.first();\n          }\n        } else {\n          // if there is a single inspected object\n          inspectedObject = this._inspectedObject;\n        }\n      } else {\n        // if object was passed in as a parameter\n        inspectedObject = object;\n      }\n\n      if (!inspectedObjects && inspectedObject) {\n        inspectedObjects = new go.Set();\n        inspectedObjects.add(inspectedObject);\n      }\n\n      if (!inspectedObjects || inspectedObjects.count < 1) {\n        // if nothing is selected\n        this.updateAllHTML();\n        return;\n      }\n\n      if (inspectedObjects) {\n        var mainDiv = this._div;\n        mainDiv.innerHTML = '';\n        var shared = new go.Map(); // for properties that the nodes have in common\n\n        var properties = new go.Map(); // for adding properties\n\n        var all = new go.Map(); // used later to prevent changing properties when unneeded\n\n        var it = inspectedObjects.iterator;\n        var nodecount = 2; // Build table:\n\n        var table = document.createElement('table');\n        var tbody = document.createElement('tbody');\n        this.inspectedProperties = {};\n        this.tabIndex = 0;\n        var declaredProperties = this._properties;\n        it.next();\n        inspectedObject = it.value;\n        this._inspectedObject = inspectedObject;\n        var data = inspectedObject instanceof go.Part ? inspectedObject.data : inspectedObject;\n\n        if (data) {\n          // initial pass to set shared and all\n          // Go through all the properties passed in to the inspector and add them to the map, if appropriate:\n          for (var name in declaredProperties) {\n            var desc = declaredProperties[name];\n            if (!this.canShowProperty(name, desc, inspectedObject)) continue;\n            var val = this.findValue(name, desc, data);\n\n            if (val === '' && this._properties[name] && this._properties[name].type === 'checkbox') {\n              shared.add(name, false);\n              all.add(name, false);\n            } else {\n              shared.add(name, val);\n              all.add(name, val);\n            }\n          } // Go through all the properties on the model data and add them to the map, if appropriate:\n\n\n          if (this._includesOwnProperties) {\n            for (var k in data) {\n              if (k === '__gohashid') continue; // skip internal GoJS hash property\n\n              if (this.inspectedProperties[k]) continue; // already exists\n\n              if (declaredProperties[k] && !this.canShowProperty(k, declaredProperties[k], inspectedObject)) continue;\n              shared.add(k, data[k]);\n              all.add(k, data[k]);\n            }\n          }\n        }\n\n        while (it.next() && (this._showLimit < 1 || nodecount <= this._showLimit)) {\n          // grabs all the properties from the other selected objects\n          properties.clear();\n          inspectedObject = it.value;\n\n          if (inspectedObject) {\n            // use either the Part.data or the object itself (for model.modelData)\n            data = inspectedObject instanceof go.Part ? inspectedObject.data : inspectedObject;\n\n            if (data) {\n              // Go through all the properties passed in to the inspector and add them to properties to add, if appropriate:\n              for (var _name in declaredProperties) {\n                var _desc = declaredProperties[_name];\n                if (!this.canShowProperty(_name, _desc, inspectedObject)) continue;\n\n                var _val = this.findValue(_name, _desc, data);\n\n                if (_val === '' && this._properties[_name] && this._properties[_name].type === 'checkbox') {\n                  properties.add(_name, false);\n                } else {\n                  properties.add(_name, _val);\n                }\n              } // Go through all the properties on the model data and add them to properties to add, if appropriate:\n\n\n              if (this._includesOwnProperties) {\n                for (var _k in data) {\n                  if (_k === '__gohashid') continue; // skip internal GoJS hash property\n\n                  if (this.inspectedProperties[_k]) continue; // already exists\n\n                  if (declaredProperties[_k] && !this.canShowProperty(_k, declaredProperties[_k], inspectedObject)) continue;\n                  properties.add(_k, data[_k]);\n                }\n              }\n            }\n          }\n\n          if (!this._showUnionProperties) {\n            // Cleans up shared map with properties that aren't shared between the selected objects\n            // Also adds properties to the add and shared maps if applicable\n            var addIt = shared.iterator;\n            var toRemove = [];\n\n            while (addIt.next()) {\n              if (properties.has(addIt.key)) {\n                var newVal = all.get(addIt.key) + '|' + properties.get(addIt.key);\n                all.set(addIt.key, newVal);\n\n                if (declaredProperties[addIt.key] && declaredProperties[addIt.key].type !== 'color' && declaredProperties[addIt.key].type !== 'checkbox' && declaredProperties[addIt.key].type !== 'select' || !declaredProperties[addIt.key]) {\n                  // for non-string properties i.e color\n                  newVal = shared.get(addIt.key) + '|' + properties.get(addIt.key);\n                  shared.set(addIt.key, newVal);\n                }\n              } else {\n                // toRemove array since addIt is still iterating\n                toRemove.push(addIt.key);\n              }\n            }\n\n            for (var i = 0; i < toRemove.length; i++) {\n              // removes anything that doesn't showUnionProperties\n              shared.remove(toRemove[i]);\n              all.remove(toRemove[i]);\n            }\n          } else {\n            // Adds missing properties to all with the correct amount of seperators\n            var _addIt = properties.iterator;\n\n            while (_addIt.next()) {\n              if (all.has(_addIt.key)) {\n                if (declaredProperties[_addIt.key] && declaredProperties[_addIt.key].type !== 'color' && declaredProperties[_addIt.key].type !== 'checkbox' && declaredProperties[_addIt.key].type !== 'select' || !declaredProperties[_addIt.key]) {\n                  // for non-string properties i.e color\n                  var _newVal = all.get(_addIt.key) + '|' + properties.get(_addIt.key);\n\n                  all.set(_addIt.key, _newVal);\n                }\n              } else {\n                var _newVal2 = '';\n\n                for (var _i = 0; _i < nodecount - 1; _i++) {\n                  _newVal2 += '|';\n                }\n\n                _newVal2 += properties.get(_addIt.key);\n                all.set(_addIt.key, _newVal2);\n              }\n            } // Adds bars in case properties is not in all\n\n\n            _addIt = all.iterator;\n\n            while (_addIt.next()) {\n              if (!properties.has(_addIt.key)) {\n                if (declaredProperties[_addIt.key] && declaredProperties[_addIt.key].type !== 'color' && declaredProperties[_addIt.key].type !== 'checkbox' && declaredProperties[_addIt.key].type !== 'select' || !declaredProperties[_addIt.key]) {\n                  // for non-string properties i.e color\n                  var _newVal3 = all.get(_addIt.key) + '|';\n\n                  all.set(_addIt.key, _newVal3);\n                }\n              }\n            }\n          }\n\n          nodecount++;\n        } // builds the table property rows and sets multipleProperties to help with updateall\n\n\n        var mapIt;\n        if (!this._showUnionProperties) mapIt = shared.iterator;else mapIt = all.iterator;\n\n        while (mapIt.next()) {\n          tbody.appendChild(this.buildPropertyRow(mapIt.key, mapIt.value)); // shows the properties that are allowed\n        }\n\n        table.appendChild(tbody);\n        mainDiv.appendChild(table);\n        var allIt = all.iterator;\n\n        while (allIt.next()) {\n          this.multipleProperties[allIt.key] = allIt.value; // used for updateall to know which properties to change\n        }\n      }\n    }\n    /**\r\n     * This predicate should be false if the given property should not be shown.\r\n     * Normally it only checks the value of \"show\" on the property descriptor.\r\n     *\r\n     * The default value is true.\r\n     * @param {string} propertyName the property name\r\n     * @param {Object} propertyDesc the property descriptor\r\n     * @param {Object} inspectedObject the data object\r\n     * @return {boolean} whether a particular property should be shown in this Inspector\r\n     */\n\n  }, {\n    key: \"canShowProperty\",\n    value: function canShowProperty(propertyName, propertyDesc, inspectedObject) {\n      var prop = propertyDesc;\n      if (prop.show === false) return false; // if \"show\" is a predicate, make sure it passes or do not show this property\n\n      if (typeof prop.show === 'function') return prop.show(inspectedObject, propertyName);\n      return true;\n    }\n    /**\r\n     * This predicate should be false if the given property should not be editable by the user.\r\n     * Normally it only checks the value of \"readOnly\" on the property descriptor.\r\n     *\r\n     * The default value is true.\r\n     * @param {string} propertyName the property name\r\n     * @param {Object} propertyDesc the property descriptor\r\n     * @param {Object} inspectedObject the data object\r\n     * @return {boolean} whether a particular property should be shown in this Inspector\r\n     */\n\n  }, {\n    key: \"canEditProperty\",\n    value: function canEditProperty(propertyName, propertyDesc, inspectedObject) {\n      if (this._diagram.isReadOnly || this._diagram.isModelReadOnly) return false;\n      if (inspectedObject === null) return false; // assume property values that are functions of Objects cannot be edited\n\n      var data = inspectedObject instanceof go.Part ? inspectedObject.data : inspectedObject;\n      var valtype = typeof data[propertyName];\n      if (valtype === 'function') return false;\n\n      if (propertyDesc) {\n        var prop = propertyDesc;\n        if (prop.readOnly === true) return false; // if \"readOnly\" is a predicate, make sure it passes or do not show this property\n\n        if (typeof prop.readOnly === 'function') return !prop.readOnly(inspectedObject, propertyName);\n      }\n\n      return true;\n    }\n    /**\r\n     * @ignore\r\n     * @param propName\r\n     * @param propDesc\r\n     * @param data\r\n     */\n\n  }, {\n    key: \"findValue\",\n    value: function findValue(propName, propDesc, data) {\n      var val = '';\n      if (propDesc && propDesc.defaultValue !== undefined) val = propDesc.defaultValue;\n      if (data[propName] !== undefined) val = data[propName];\n      if (val === undefined) return '';\n      return val;\n    }\n    /**\r\n     * This sets `inspectedProperties[propertyName]` and creates the HTML table row for a given property:\r\n     * ```html\r\n     * <tr>\r\n     *   <td>propertyName</td>\r\n     *   <td><input value=propertyValue /></td>\r\n     * </tr>\r\n     * ```\r\n     *\r\n     * This method can be customized to change how an Inspector row is rendered.\r\n     * @param {string} propertyName the property name\r\n     * @param {*} propertyValue the property value\r\n     * @return {HTMLTableRowElement} the table row\r\n     */\n\n  }, {\n    key: \"buildPropertyRow\",\n    value: function buildPropertyRow(propertyName, propertyValue) {\n      var tr = document.createElement('tr');\n      var td1 = document.createElement('td');\n      var displayName;\n\n      if (this._properties[propertyName] && this._properties[propertyName].name !== undefined) {\n        // name changes the dispaly name shown on inspector\n        displayName = this._properties[propertyName].name;\n      } else {\n        displayName = propertyName;\n      }\n\n      td1.textContent = displayName; // Código  insertado para mostrar Tooltip en el DataInspector\n\n      var definiciones = [{\n        id: \"coupling_AIS\",\n        definicion: \"Definición para coupling AIS\"\n      }, {\n        id: \"coupling_ADS\",\n        definicion: \"Definición para coupling ADS\"\n      }, {\n        id: \"coupling_SIY\",\n        definicion: \"Definición para coupling SIY\"\n      }, {\n        id: \"cohesion_lack\",\n        definicion: \"\"\n      }, {\n        id: \"cohesion_grade\",\n        definicion: \"\"\n      }, {\n        id: \"complexity\",\n        definicion: \"\"\n      }, {\n        id: \"semantic_similarity\",\n        definicion: \"\"\n      }];\n      td1.setAttribute(\"title\", function () {\n        for (var i = 0; i < definiciones.length; i++) {\n          if (propertyName == definiciones[i].id) {\n            return definiciones[i].definicion;\n          }\n        }\n\n        return \"\";\n      }()); // Fin del código  insertado para mostrar Tooltip en el DataInspector\n\n      tr.appendChild(td1);\n      var td2 = document.createElement('td');\n      var decProp = this._properties[propertyName];\n      var input = null;\n      var self = this;\n\n      function updateall() {\n        if (self._diagram.selection.count === 1 || !self.multipleSelection) {\n          self.updateAllProperties();\n        } else {\n          self.updateAllObjectsProperties();\n        }\n      }\n\n      if (decProp && decProp.type === 'select') {\n        var inputs = input = document.createElement('select');\n        this.updateSelect(decProp, inputs, propertyName, propertyValue);\n        inputs.addEventListener('change', updateall);\n      } else {\n        var inputi = input = document.createElement('input');\n\n        if (inputi && inputi.setPointerCapture) {\n          inputi.addEventListener(\"pointerdown\", function (e) {\n            return inputi.setPointerCapture(e.pointerId);\n          });\n        }\n\n        inputi.value = this.convertToString(propertyValue);\n\n        if (decProp) {\n          var t = decProp.type;\n\n          if (t !== 'string' && t !== 'number' && t !== 'boolean' && t !== 'arrayofnumber' && t !== 'point' && t !== 'size' && t !== 'rect' && t !== 'spot' && t !== 'margin') {\n            inputi.setAttribute('type', decProp.type);\n          }\n\n          if (decProp.type === 'color') {\n            if (inputi.type === 'color') {\n              inputi.value = this.convertToColor(propertyValue); // input.addEventListener('input', updateall); // removed with multi select\n\n              inputi.addEventListener('change', updateall);\n            }\n          }\n\n          if (decProp.type === 'checkbox') {\n            inputi.checked = !!propertyValue;\n            inputi.addEventListener('change', updateall);\n          }\n        }\n\n        if (inputi.type !== 'color') inputi.addEventListener('blur', updateall);\n      }\n\n      if (input) {\n        input.tabIndex = this.tabIndex++;\n        input.disabled = !this.canEditProperty(propertyName, decProp, this._inspectedObject);\n        td2.appendChild(input);\n      }\n\n      tr.appendChild(td2);\n      this.inspectedProperties[propertyName] = input;\n      return tr;\n    }\n    /**\r\n     * @hidden @ignore\r\n     * HTML5 color input will only take hex,\r\n     * so let HTML5 canvas convert the color into hex format.\r\n     * This converts \"rgb(255, 0, 0)\" into \"#FF0000\", etc.\r\n     */\n\n  }, {\n    key: \"convertToColor\",\n    value: function convertToColor(propertyValue) {\n      var ctx = document.createElement('canvas').getContext('2d');\n      if (ctx === null) return '#000000';\n      ctx.fillStyle = propertyValue;\n      return ctx.fillStyle;\n    }\n    /**\r\n     * @hidden @ignore\r\n     */\n\n  }, {\n    key: \"convertToArrayOfNumber\",\n    value: function convertToArrayOfNumber(propertyValue) {\n      if (propertyValue === 'null') return null;\n      var split = propertyValue.split(' ');\n      var arr = [];\n\n      for (var i = 0; i < split.length; i++) {\n        var str = split[i];\n        if (!str) continue;\n        arr.push(parseFloat(str));\n      }\n\n      return arr;\n    }\n    /**\r\n     * @hidden @ignore\r\n     */\n\n  }, {\n    key: \"convertToString\",\n    value: function convertToString(x) {\n      if (x === undefined) return 'undefined';\n      if (x === null) return 'null';\n      if (x instanceof go.Point) return go.Point.stringify(x);\n      if (x instanceof go.Size) return go.Size.stringify(x);\n      if (x instanceof go.Rect) return go.Rect.stringify(x);\n      if (x instanceof go.Spot) return go.Spot.stringify(x);\n      if (x instanceof go.Margin) return go.Margin.stringify(x);\n      if (x instanceof go.List) return this.convertToString(x.toArray());\n\n      if (Array.isArray(x)) {\n        var str = '';\n\n        for (var i = 0; i < x.length; i++) {\n          if (i > 0) str += ' ';\n          var v = x[i];\n          str += this.convertToString(v);\n        }\n\n        return str;\n      }\n\n      return x.toString();\n    }\n    /**\r\n     * @hidden @ignore\r\n     * Update all of the HTML in this Inspector.\r\n     */\n\n  }, {\n    key: \"updateAllHTML\",\n    value: function updateAllHTML() {\n      var inspectedProps = this.inspectedProperties;\n      var isPart = this._inspectedObject instanceof go.Part;\n      var data = isPart ? this._inspectedObject.data : this._inspectedObject;\n\n      if (!data) {\n        // clear out all of the fields\n        for (var name in inspectedProps) {\n          var input = inspectedProps[name];\n\n          if (input instanceof HTMLSelectElement) {\n            input.innerHTML = '';\n          } else if (input.type === 'color') {\n            input.value = '#000000';\n          } else if (input.type === 'checkbox') {\n            input.checked = false;\n          } else {\n            input.value = '';\n          }\n        }\n      } else {\n        for (var _name2 in inspectedProps) {\n          var _input = inspectedProps[_name2];\n          var propertyValue = data[_name2];\n\n          if (_input instanceof HTMLSelectElement) {\n            var decProp = this._properties[_name2];\n            this.updateSelect(decProp, _input, _name2, propertyValue);\n          } else if (_input.type === 'color') {\n            _input.value = this.convertToColor(propertyValue);\n          } else if (_input.type === 'checkbox') {\n            _input.checked = !!propertyValue;\n          } else {\n            _input.value = this.convertToString(propertyValue);\n          }\n        }\n      }\n    }\n    /**\r\n     * @hidden @ignore\r\n     * Update an HTMLSelectElement with an appropriate list of choices, given the propertyName\r\n     */\n\n  }, {\n    key: \"updateSelect\",\n    value: function updateSelect(decProp, select, propertyName, propertyValue) {\n      select.innerHTML = ''; // clear out anything that was there\n\n      var choices = decProp.choices;\n      if (typeof choices === 'function') choices = choices(this._inspectedObject, propertyName);\n      if (!Array.isArray(choices)) choices = [];\n      decProp.choicesArray = choices; // remember list of actual choice values (not strings)\n\n      for (var i = 0; i < choices.length; i++) {\n        var choice = choices[i];\n        var opt = document.createElement('option');\n        opt.text = this.convertToString(choice);\n        select.add(opt);\n      }\n\n      select.value = this.convertToString(propertyValue);\n    }\n  }, {\n    key: \"parseValue\",\n    value: function parseValue(decProp, value, input, oldval) {\n      // If it's a boolean, or if its previous value was boolean,\n      // parse the value to be a boolean and then update the input.value to match\n      var type = '';\n\n      if (decProp !== undefined && decProp.type !== undefined) {\n        type = decProp.type;\n      }\n\n      if (type === '') {\n        if (typeof oldval === 'boolean') type = 'boolean'; // infer boolean\n        else if (typeof oldval === 'number') type = 'number';else if (oldval instanceof go.Point) type = 'point';else if (oldval instanceof go.Size) type = 'size';else if (oldval instanceof go.Rect) type = 'rect';else if (oldval instanceof go.Spot) type = 'spot';else if (oldval instanceof go.Margin) type = 'margin';\n      } // convert to specific type, if needed\n\n\n      switch (type) {\n        case 'boolean':\n          value = !(value === false || value === 'false' || value === '0');\n          break;\n\n        case 'number':\n          value = parseFloat(value);\n          break;\n\n        case 'arrayofnumber':\n          value = this.convertToArrayOfNumber(value);\n          break;\n\n        case 'point':\n          value = go.Point.parse(value);\n          break;\n\n        case 'size':\n          value = go.Size.parse(value);\n          break;\n\n        case 'rect':\n          value = go.Rect.parse(value);\n          break;\n\n        case 'spot':\n          value = go.Spot.parse(value);\n          break;\n\n        case 'margin':\n          value = go.Margin.parse(value);\n          break;\n\n        case 'checkbox':\n          value = input.checked;\n          break;\n\n        case 'select':\n          value = decProp.choicesArray[input.selectedIndex];\n          break;\n      }\n\n      return value;\n    }\n    /**\r\n     * @hidden @ignore\r\n     * Update all of the data properties of all the objects in {@link #inspectedObjects} according to the\r\n     * current values held in the HTML input elements.\r\n     */\n\n  }, {\n    key: \"updateAllObjectsProperties\",\n    value: function updateAllObjectsProperties() {\n      var inspectedProps = this.inspectedProperties;\n      var diagram = this._diagram;\n      diagram.startTransaction('set all properties');\n\n      for (var name in inspectedProps) {\n        var input = inspectedProps[name];\n        var value = input.value;\n        var arr1 = value.split('|');\n        var arr2 = [];\n\n        if (this.multipleProperties[name]) {\n          // don't split if it is union and its checkbox type\n          if (this._properties[name] && this._properties[name].type === 'checkbox' && this._showUnionProperties) {\n            arr2.push(this.multipleProperties[name]);\n          } else if (this._properties[name]) {\n            arr2 = this.multipleProperties[name].toString().split('|');\n          }\n        }\n\n        var it = diagram.selection.iterator;\n        var change = false;\n        if (this._properties[name] && this._properties[name].type === 'checkbox') change = true; // always change checkbox\n\n        if (arr1.length < arr2.length // i.e Alpha|Beta -> Alpha procs the change\n        && (!this._properties[name] // from and to links\n        || !(this._properties[name] // do not change color checkbox and choices due to them always having less\n        && (this._properties[name].type === 'color' || this._properties[name].type === 'checkbox' || this._properties[name].type === 'choices')))) {\n          change = true;\n        } else {\n          // standard detection in change in properties\n          for (var j = 0; j < arr1.length && j < arr2.length; j++) {\n            if (!(arr1[j] === arr2[j]) && !(this._properties[name] && this._properties[name].type === 'color' && arr1[j].toLowerCase() === arr2[j].toLowerCase())) {\n              change = true;\n            }\n          }\n        }\n\n        if (change) {\n          // only change properties it needs to change instead all of them\n          for (var i = 0; i < diagram.selection.count; i++) {\n            it.next();\n            var isPart = it.value instanceof go.Part;\n            var data = isPart ? it.value.data : it.value;\n\n            if (data) {\n              // ignores the selected node if there is no data\n              if (i < arr1.length) value = arr1[i];else value = arr1[0]; // don't update \"readOnly\" data properties\n\n              var decProp = this._properties[name];\n              if (!this.canEditProperty(name, decProp, it.value)) continue;\n              var oldval = data[name];\n              value = this.parseValue(decProp, value, input, oldval); // in case parsed to be different, such as in the case of boolean values,\n              // the value shown should match the actual value\n\n              input.value = value; // modify the data object in an undo-able fashion\n\n              diagram.model.setDataProperty(data, name, value); // notify any listener\n\n              if (this.propertyModified !== null) this.propertyModified(name, value, this);\n            }\n          }\n        }\n      }\n\n      diagram.commitTransaction('set all properties');\n    }\n    /**\r\n     * @hidden @ignore\r\n     * Update all of the data properties of {@link #inspectedObject} according to the\r\n     * current values held in the HTML input elements.\r\n     */\n\n  }, {\n    key: \"updateAllProperties\",\n    value: function updateAllProperties() {\n      var inspectedProps = this.inspectedProperties;\n      var diagram = this._diagram;\n      var isPart = this.inspectedObject instanceof go.Part;\n      var data = isPart ? this.inspectedObject.data : this.inspectedObject;\n      if (!data) return; // must not try to update data when there's no data!\n\n      diagram.startTransaction('set all properties');\n\n      for (var name in inspectedProps) {\n        var input = inspectedProps[name];\n        var value = input.value; // don't update \"readOnly\" data properties\n\n        var decProp = this._properties[name];\n        if (!this.canEditProperty(name, decProp, this.inspectedObject)) continue;\n        var oldval = data[name];\n        value = this.parseValue(decProp, value, input, oldval); // in case parsed to be different, such as in the case of boolean values,\n        // the value shown should match the actual value\n\n        input.value = value; // modify the data object in an undo-able fashion\n\n        diagram.model.setDataProperty(data, name, value); // notify any listener\n\n        if (this.propertyModified !== null) this.propertyModified(name, value, this);\n      }\n\n      diagram.commitTransaction('set all properties');\n    }\n  }, {\n    key: \"div\",\n    get: function get() {\n      return this._div;\n    }\n    /**\r\n     * Gets or sets the {@link Diagram} associated with this Inspector.\r\n     */\n\n  }, {\n    key: \"diagram\",\n    get: function get() {\n      return this._diagram;\n    },\n    set: function set(val) {\n      if (val !== this._diagram) {\n        // First, unassociate change listeners with current inspected diagram\n        this._diagram.removeModelChangedListener(this.inspectOnModelChanged);\n\n        this._diagram.removeDiagramListener('ChangedSelection', this.inspectOnSelectionChanged); // Now set the diagram and add the necessary change listeners\n\n\n        this._diagram = val;\n\n        this._diagram.addModelChangedListener(this.inspectOnModelChanged);\n\n        if (this._inspectSelection) {\n          this._diagram.addDiagramListener('ChangedSelection', this.inspectOnSelectionChanged);\n\n          this.inspectObject();\n        } else {\n          this.inspectObject(null);\n        }\n      }\n    }\n    /**\r\n     * This read-only property returns the object currently being inspected.\r\n     *\r\n     * To set the inspected object, call {@link #inspectObject}.\r\n     */\n\n  }, {\n    key: \"inspectedObject\",\n    get: function get() {\n      return this._inspectedObject;\n    }\n    /**\r\n     * Gets or sets whether the Inspector automatically inspects the associated Diagram's selection.\r\n     * When set to false, the Inspector won't show anything until {@link #inspectObject} is called.\r\n     *\r\n     * The default value is true.\r\n     */\n\n  }, {\n    key: \"inspectSelection\",\n    get: function get() {\n      return this._inspectSelection;\n    },\n    set: function set(val) {\n      if (val !== this._inspectSelection) {\n        this._inspectSelection = val;\n\n        if (this._inspectSelection) {\n          this._diagram.addDiagramListener('ChangedSelection', this.inspectOnSelectionChanged);\n\n          this.inspectObject();\n        } else {\n          this._diagram.removeDiagramListener('ChangedSelection', this.inspectOnSelectionChanged);\n\n          this.inspectObject(null);\n        }\n      }\n    }\n    /**\r\n     * Gets or sets whether the Inspector includes all properties currently on the inspected object.\r\n     *\r\n     * The default value is true.\r\n     */\n\n  }, {\n    key: \"includesOwnProperties\",\n    get: function get() {\n      return this._includesOwnProperties;\n    },\n    set: function set(val) {\n      if (val !== this._includesOwnProperties) {\n        this._includesOwnProperties = val;\n        this.inspectObject();\n      }\n    }\n    /**\r\n     * Gets or sets the properties that the Inspector will inspect, maybe setting options for those properties.\r\n     * The object should contain string: Object pairs represnting propertyName: propertyOptions.\r\n     * Can be used to include or exclude additional properties.\r\n     *\r\n     * The default value is an empty object.\r\n     */\n\n  }, {\n    key: \"properties\",\n    get: function get() {\n      return this._properties;\n    },\n    set: function set(val) {\n      if (val !== this._properties) {\n        this._properties = val;\n        this.inspectObject();\n      }\n    }\n    /**\r\n     * Gets or sets the function to be called when a property is modified by the Inspector.\r\n     * The first paremeter will be the property name, the second will be the new value, and the third will be a reference to this Inspector.\r\n     *\r\n     * The default value is null, meaning nothing will be done.\r\n     */\n\n  }, {\n    key: \"propertyModified\",\n    get: function get() {\n      return this._propertyModified;\n    },\n    set: function set(val) {\n      if (val !== this._propertyModified) {\n        this._propertyModified = val;\n      }\n    }\n    /**\r\n     * Gets or sets whether the Inspector displays properties for multiple selected objects or just the first.\r\n     *\r\n     * The default value is false, meaning only the first item in the {@link Diagram#selection} is inspected.\r\n     */\n\n  }, {\n    key: \"multipleSelection\",\n    get: function get() {\n      return this._multipleSelection;\n    },\n    set: function set(val) {\n      if (val !== this._multipleSelection) {\n        this._multipleSelection = val;\n        this.inspectObject();\n      }\n    }\n    /**\r\n     * Gets or sets whether the Inspector displays the union or intersection of properties for multiple selected objects.\r\n     *\r\n     * The default value is false, meaning the intersection of properties is inspected.\r\n     */\n\n  }, {\n    key: \"showUnionProperties\",\n    get: function get() {\n      return this._showUnionProperties;\n    },\n    set: function set(val) {\n      if (val !== this._showUnionProperties) {\n        this._showUnionProperties = val;\n        this.inspectObject();\n      }\n    }\n    /**\r\n     * Gets or sets how many objects will be displayed when {@link #multipleSelection} is true.\r\n     *\r\n     * The default value is 0, meaning all selected objects will be displayed for a given property.\r\n     */\n\n  }, {\n    key: \"showLimit\",\n    get: function get() {\n      return this._showLimit;\n    },\n    set: function set(val) {\n      if (val !== this._showLimit) {\n        this._showLimit = val;\n        this.inspectObject();\n      }\n    }\n    /**\r\n     * This predicate function can be used as a value for the `show` option for properties.\r\n     * When used, the property will only be shown when inspecting a {@link Node}.\r\n     * @param {Part} part the Part being inspected\r\n     * @return {boolean}\r\n     */\n\n  }], [{\n    key: \"showIfNode\",\n    value: function showIfNode(part) {\n      return part instanceof go.Node;\n    }\n    /**\r\n     * This predicate function can be used as a value for the `show` option for properties.\r\n     * When used, the property will only be shown when inspecting a {@link Link}.\r\n     * @param {Part} part the Part being inspected\r\n     * @return {boolean}\r\n     */\n\n  }, {\n    key: \"showIfLink\",\n    value: function showIfLink(part) {\n      return part instanceof go.Link;\n    }\n    /**\r\n     * This predicate function can be used as a value for the `show` option for properties.\r\n     * When used, the property will only be shown when inspecting a {@link Group}.\r\n     * @param {Part} part the Part being inspected\r\n     * @return {boolean}\r\n     */\n\n  }, {\n    key: \"showIfGroup\",\n    value: function showIfGroup(part) {\n      return part instanceof go.Group;\n    }\n    /**\r\n     * This predicate function can be used as a value for the `show` option for properties.\r\n     * When used, the property will only be shown if present.\r\n     * Useful for properties such as `key`, which will be shown on Nodes and Groups, but normally not on Links\r\n     * @param {Part|null} part the Part being inspected\r\n     * @param {string} propname the property to check presence of\r\n     * @return {boolean}\r\n     */\n\n  }, {\n    key: \"showIfPresent\",\n    value: function showIfPresent(data, propname) {\n      if (data instanceof go.Part) data = data.data;\n      return typeof data === 'object' && data[propname] !== undefined;\n    }\n  }]);\n\n  return Inspector;\n}();\nexport default Inspector;","map":null,"metadata":{},"sourceType":"module"}