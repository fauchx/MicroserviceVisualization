{"ast":null,"code":"\"use strict\";\n/*\r\n*  Copyright (C) 1998-2022 by Northwoods Software Corporation. All Rights Reserved.\r\n*/\n\n/**\r\n  This class implements an inspector for GoJS model data objects.\r\n  The constructor takes three arguments:\r\n    {string} divid a string referencing the HTML ID of the to-be inspector's div.\r\n    {Diagram} diagram a reference to a GoJS Diagram.\r\n    {Object} options An optional JS Object describing options for the inspector.\r\n\r\n  Options:\r\n    inspectSelection {boolean} Default true, whether to automatically show and populate the Inspector\r\n                               with the currently selected Diagram Part. If set to false, the inspector won't show anything\r\n                               until you call Inspector.inspectObject(object) with a Part or JavaScript object as the argument.\r\n    includesOwnProperties {boolean} Default true, whether to list all properties currently on the inspected data object.\r\n    properties {Object} An object of string:Object pairs representing propertyName:propertyOptions.\r\n                        Can be used to include or exclude additional properties.\r\n    propertyModified function(propertyName, newValue) a callback\r\n    multipleSelection {boolean} Default false, whether to allow multiple selection and change the properties of all the selected instead of\r\n                                the single first object\r\n    showAllProperties {boolean} Default false, whether properties that are shown with multipleSelection use the intersect of the properties when false or the union when true\r\n                                only affects if multipleSelection is true\r\n    showSize {number} Defaults 0, shows how many nodes are showed when selecting multiple nodes\r\n                      when its lower than 1, it shows all nodes\r\n\r\n  Options for properties:\r\n    show: {boolean|function} a boolean value to show or hide the property from the inspector, or a predicate function to show conditionally.\r\n    readOnly: {boolean|function} whether or not the property is read-only\r\n    type: {string} a string describing the data type. Supported values: \"string|number|boolean|color|arrayofnumber|point|rect|size|spot|margin|select|checkbox|date|datetime-local|time\"\r\n    defaultValue: {*} a default value for the property. Defaults to the empty string.\r\n    choices: {Array|function} when type == \"select\", the Array of choices to use or a function that returns the Array of choices.\r\n\r\n  Example usage of Inspector:\r\n\r\n  var inspector = new Inspector(\"myInspector\", myDiagram,\r\n    {\r\n      includesOwnProperties: false,\r\n      properties: {\r\n        \"key\": { show: Inspector.showIfPresent, readOnly: true },\r\n        \"comments\": { show: Inspector.showIfNode  },\r\n        \"LinkComments\": { show: Inspector.showIfLink },\r\n        \"chosen\": { show: Inspector.showIfNode, type: \"checkbox\" },\r\n        \"state\": { show: Inspector.showIfNode, type: \"select\", choices: [\"Stopped\", \"Parked\", \"Moving\"] }\r\n      }\r\n    });\r\n\r\n  This is the basic HTML Structure that the Inspector creates within the given DIV element:\r\n\r\n  <div id=\"divid\" class=\"inspector\">\r\n    <tr>\r\n      <td>propertyName</td>\r\n      <td><input value=propertyValue /></td>\r\n    </tr>\r\n    ...\r\n  </div>\r\n\r\n*/\n\nfunction Inspector(divid, diagram, options) {\n  var mainDiv = document.getElementById(divid);\n  mainDiv.className = \"inspector\";\n  mainDiv.innerHTML = \"\";\n  this._div = mainDiv;\n  this._diagram = diagram;\n  this._inspectedProperties = {};\n  this._multipleProperties = {}; // Either a GoJS Part or a simple data object, such as Model.modelData\n\n  this.inspectedObject = null; // Inspector options defaults:\n\n  this.includesOwnProperties = true;\n  this.declaredProperties = {};\n  this.inspectsSelection = true;\n  this.propertyModified = null;\n  this.multipleSelection = false;\n  this.showAllProperties = false;\n  this.showSize = 0;\n\n  if (options !== undefined) {\n    if (options[\"includesOwnProperties\"] !== undefined) this.includesOwnProperties = options[\"includesOwnProperties\"];\n    if (options[\"properties\"] !== undefined) this.declaredProperties = options[\"properties\"];\n    if (options[\"inspectSelection\"] !== undefined) this.inspectsSelection = options[\"inspectSelection\"];\n    if (options[\"propertyModified\"] !== undefined) this.propertyModified = options[\"propertyModified\"];\n    if (options['multipleSelection'] !== undefined) this.multipleSelection = options['multipleSelection'];\n    if (options['showAllProperties'] !== undefined) this.showAllProperties = options['showAllProperties'];\n    if (options['showSize'] !== undefined) this.showSize = options['showSize'];\n  }\n\n  var self = this;\n  diagram.addModelChangedListener(function (e) {\n    if (e.isTransactionFinished) self.inspectObject();\n  });\n\n  if (this.inspectsSelection) {\n    diagram.addDiagramListener(\"ChangedSelection\", function (e) {\n      self.inspectObject();\n    });\n  }\n} // Some static predicates to use with the \"show\" property.\n\n\nInspector.showIfNode = function (part) {\n  return part instanceof go.Node;\n};\n\nInspector.showIfLink = function (part) {\n  return part instanceof go.Link;\n};\n\nInspector.showIfGroup = function (part) {\n  return part instanceof go.Group;\n}; // Only show the property if its present. Useful for \"key\" which will be shown on Nodes and Groups, but normally not on Links\n\n\nInspector.showIfPresent = function (data, propname) {\n  if (data instanceof go.Part) data = data.data;\n  return typeof data === \"object\" && data[propname] !== undefined;\n};\n/**\r\n* Update the HTML state of this Inspector given the properties of the {@link #inspectedObject}.\r\n* @param {Object} object is an optional argument, used when {@link #inspectSelection} is false to\r\n*                        set {@link #inspectedObject} and show and edit that object's properties.\r\n*/\n\n\nInspector.prototype.inspectObject = function (object) {\n  var inspectedObject = null;\n  var inspectedObjects = null;\n  if (object === null) return;\n\n  if (object === undefined) {\n    if (this.inspectsSelection) {\n      if (this.multipleSelection) {\n        // gets the selection if multiple selection is true\n        inspectedObjects = this._diagram.selection;\n        this._inspectedObject = inspectedObjects.first();\n      } else {\n        // otherwise grab the first object\n        inspectedObject = this._diagram.selection.first();\n      }\n    } else {\n      // if there is a single inspected object\n      inspectedObject = this.inspectedObject;\n    }\n  } else {\n    // if object was passed in as a parameter\n    inspectedObject = object;\n  }\n\n  if (inspectedObjects && inspectedObjects.count === 1) {\n    inspectedObject = inspectedObjects.first();\n  }\n\n  if (inspectedObjects && inspectedObjects.count <= 1) {\n    inspectedObjects = null;\n  } // single object or no objects\n\n\n  if (!inspectedObjects || !this.multipleSelection) {\n    if (inspectedObject === null) {\n      this.inspectedObject = inspectedObject;\n      this.updateAllHTML();\n      return;\n    }\n\n    this.inspectedObject = inspectedObject;\n    if (this.inspectObject === null) return;\n    var mainDiv = this._div;\n    mainDiv.innerHTML = ''; // use either the Part.data or the object itself (for model.modelData)\n\n    var data = inspectedObject instanceof go.Part ? inspectedObject.data : inspectedObject;\n    if (!data) return; // Build table:\n\n    var table = document.createElement('table');\n    var tbody = document.createElement('tbody');\n    this._inspectedProperties = {};\n    this.tabIndex = 0;\n    var declaredProperties = this.declaredProperties; // Go through all the properties passed in to the inspector and show them, if appropriate:\n\n    for (var name in declaredProperties) {\n      var desc = declaredProperties[name];\n      if (!this.canShowProperty(name, desc, inspectedObject)) continue;\n      var val = this.findValue(name, desc, data);\n      tbody.appendChild(this.buildPropertyRow(name, val));\n    } // Go through all the properties on the model data and show them, if appropriate:\n\n\n    if (this.includesOwnProperties) {\n      for (var k in data) {\n        if (k === '__gohashid') continue; // skip internal GoJS hash property\n\n        if (this._inspectedProperties[k]) continue; // already exists\n\n        if (declaredProperties[k] && !this.canShowProperty(k, declaredProperties[k], inspectedObject)) continue;\n        tbody.appendChild(this.buildPropertyRow(k, data[k]));\n      }\n    }\n\n    table.appendChild(tbody);\n    mainDiv.appendChild(table);\n  } else {\n    // multiple objects selected\n    var mainDiv = this._div;\n    mainDiv.innerHTML = '';\n    var shared = new go.Map(); // for properties that the nodes have in common\n\n    var properties = new go.Map(); // for adding properties\n\n    var all = new go.Map(); // used later to prevent changing properties when unneeded\n\n    var it = inspectedObjects.iterator; // Build table:\n\n    var table = document.createElement('table');\n    var tbody = document.createElement('tbody');\n    this._inspectedProperties = {};\n    this.tabIndex = 0;\n    var declaredProperties = this.declaredProperties;\n    it.next();\n    inspectedObject = it.value;\n    this.inspectedObject = inspectedObject;\n    var data = inspectedObject instanceof go.Part ? inspectedObject.data : inspectedObject;\n\n    if (data) {\n      // initial pass to set shared and all\n      // Go through all the properties passed in to the inspector and add them to the map, if appropriate:\n      for (var name in declaredProperties) {\n        var desc = declaredProperties[name];\n        if (!this.canShowProperty(name, desc, inspectedObject)) continue;\n        var val = this.findValue(name, desc, data);\n\n        if (val === '' && desc && desc.type === 'checkbox') {\n          shared.add(name, false);\n          all.add(name, false);\n        } else {\n          shared.add(name, val);\n          all.add(name, val);\n        }\n      } // Go through all the properties on the model data and add them to the map, if appropriate:\n\n\n      if (this.includesOwnProperties) {\n        for (var k in data) {\n          if (k === '__gohashid') continue; // skip internal GoJS hash property\n\n          if (this._inspectedProperties[k]) continue; // already exists\n\n          if (declaredProperties[k] && !this.canShowProperty(k, declaredProperties[k], inspectedObject)) continue;\n          shared.add(k, data[k]);\n          all.add(k, data[k]);\n        }\n      }\n    }\n\n    var nodecount = 2;\n\n    while (it.next() && (this.showSize < 1 || nodecount <= this.showSize)) {\n      // grabs all the properties from the other selected objects\n      properties.clear();\n      inspectedObject = it.value;\n\n      if (inspectedObject) {\n        // use either the Part.data or the object itself (for model.modelData)\n        data = inspectedObject instanceof go.Part ? inspectedObject.data : inspectedObject;\n\n        if (data) {\n          // Go through all the properties passed in to the inspector and add them to properties to add, if appropriate:\n          for (var name in declaredProperties) {\n            var desc = declaredProperties[name];\n            if (!this.canShowProperty(name, desc, inspectedObject)) continue;\n            var val = this.findValue(name, desc, data);\n\n            if (val === '' && desc && desc.type === 'checkbox') {\n              properties.add(name, false);\n            } else {\n              properties.add(name, val);\n            }\n          } // Go through all the properties on the model data and add them to properties to add, if appropriate:\n\n\n          if (this.includesOwnProperties) {\n            for (var k in data) {\n              if (k === '__gohashid') continue; // skip internal GoJS hash property\n\n              if (this._inspectedProperties[k]) continue; // already exists\n\n              if (declaredProperties[k] && !this.canShowProperty(k, declaredProperties[k], inspectedObject)) continue;\n              properties.add(k, data[k]);\n            }\n          }\n        }\n      }\n\n      if (!this.showAllProperties) {\n        // Cleans up shared map with properties that aren't shared between the selected objects\n        // Also adds properties to the add and shared maps if applicable\n        var addIt = shared.iterator;\n        var toRemove = [];\n\n        while (addIt.next()) {\n          if (properties.has(addIt.key)) {\n            var newVal = all.get(addIt.key) + '|' + properties.get(addIt.key);\n            all.set(addIt.key, newVal);\n\n            if (declaredProperties[addIt.key] && declaredProperties[addIt.key].type !== 'color' && declaredProperties[addIt.key].type !== 'checkbox' && declaredProperties[addIt.key].type !== 'select' || !declaredProperties[addIt.key]) {\n              // for non-string properties i.e color\n              newVal = shared.get(addIt.key) + '|' + properties.get(addIt.key);\n              shared.set(addIt.key, newVal);\n            }\n          } else {\n            // toRemove array since addIt is still iterating\n            toRemove.push(addIt.key);\n          }\n        }\n\n        for (var i = 0; i < toRemove.length; i++) {\n          // removes anything that doesn't showAllPropertiess\n          shared.remove(toRemove[i]);\n          all.remove(toRemove[i]);\n        }\n      } else {\n        // Adds missing properties to all with the correct amount of seperators\n        var addIt = properties.iterator;\n\n        while (addIt.next()) {\n          if (all.has(addIt.key)) {\n            if (declaredProperties[addIt.key] && declaredProperties[addIt.key].type !== 'color' && declaredProperties[addIt.key].type !== 'checkbox' && declaredProperties[addIt.key].type !== 'select' || !declaredProperties[addIt.key]) {\n              // for non-string properties i.e color\n              var newVal = all.get(addIt.key) + '|' + properties.get(addIt.key);\n              all.set(addIt.key, newVal);\n            }\n          } else {\n            var newVal = '';\n\n            for (var i = 0; i < nodecount - 1; i++) {\n              newVal += '|';\n            }\n\n            newVal += properties.get(addIt.key);\n            all.set(addIt.key, newVal);\n          }\n        } // Adds bars in case properties is not in all\n\n\n        addIt = all.iterator;\n\n        while (addIt.next()) {\n          if (!properties.has(addIt.key)) {\n            if (declaredProperties[addIt.key] && declaredProperties[addIt.key].type !== 'color' && declaredProperties[addIt.key].type !== 'checkbox' && declaredProperties[addIt.key].type !== 'select' || !declaredProperties[addIt.key]) {\n              // for non-string properties i.e color\n              var newVal = all.get(addIt.key) + '|';\n              all.set(addIt.key, newVal);\n            }\n          }\n        }\n      }\n\n      nodecount++;\n    } // builds the table property rows and sets multipleProperties to help with updateall\n\n\n    var mapIt;\n    if (!this.showAllProperties) mapIt = shared.iterator;else mapIt = all.iterator;\n\n    while (mapIt.next()) {\n      tbody.appendChild(this.buildPropertyRow(mapIt.key, mapIt.value)); // shows the properties that are allowed\n    }\n\n    table.appendChild(tbody);\n    mainDiv.appendChild(table);\n    var allIt = all.iterator;\n\n    while (allIt.next()) {\n      this._multipleProperties[allIt.key] = allIt.value; // used for updateall to know which properties to change\n    }\n  }\n};\n/**\r\n* @ignore\r\n* This predicate should be false if the given property should not be shown.\r\n* Normally it only checks the value of \"show\" on the property descriptor.\r\n* The default value is true.\r\n* @param {string} propertyName the property name\r\n* @param {Object} propertyDesc the property descriptor\r\n* @param {Object} inspectedObject the data object\r\n* @return {boolean} whether a particular property should be shown in this Inspector\r\n*/\n\n\nInspector.prototype.canShowProperty = function (propertyName, propertyDesc, inspectedObject) {\n  if (propertyDesc.show === false) return false; // if \"show\" is a predicate, make sure it passes or do not show this property\n\n  if (typeof propertyDesc.show === \"function\") return propertyDesc.show(inspectedObject, propertyName);\n  return true;\n};\n/**\r\n* @ignore\r\n* This predicate should be false if the given property should not be editable by the user.\r\n* Normally it only checks the value of \"readOnly\" on the property descriptor.\r\n* The default value is true.\r\n* @param {string} propertyName the property name\r\n* @param {Object} propertyDesc the property descriptor\r\n* @param {Object} inspectedObject the data object\r\n* @return {boolean} whether a particular property should be shown in this Inspector\r\n*/\n\n\nInspector.prototype.canEditProperty = function (propertyName, propertyDesc, inspectedObject) {\n  if (this._diagram.isReadOnly || this._diagram.isModelReadOnly) return false; // assume property values that are functions of Objects cannot be edited\n\n  var data = inspectedObject instanceof go.Part ? inspectedObject.data : inspectedObject;\n  var valtype = typeof data[propertyName];\n  if (valtype === \"function\") return false;\n\n  if (propertyDesc) {\n    if (propertyDesc.readOnly === true) return false; // if \"readOnly\" is a predicate, make sure it passes or do not show this property\n\n    if (typeof propertyDesc.readOnly === \"function\") return !propertyDesc.readOnly(inspectedObject, propertyName);\n  }\n\n  return true;\n};\n/**\r\n * @ignore\r\n * @param {any} propName\r\n * @param {any} propDesc\r\n * @param {any} data\r\n * @return {any}\r\n */\n\n\nInspector.prototype.findValue = function (propName, propDesc, data) {\n  var val = '';\n  if (propDesc && propDesc.defaultValue !== undefined) val = propDesc.defaultValue;\n  if (data[propName] !== undefined) val = data[propName];\n  if (val === undefined) return '';\n  return val;\n};\n/**\r\n* @ignore\r\n* This sets this._inspectedProperties[propertyName] and creates the HTML table row:\r\n*    <tr>\r\n*      <td>propertyName</td>\r\n*      <td><input value=propertyValue /></td>\r\n*    </tr>\r\n* @param {string} propertyName the property name\r\n* @param {*} propertyValue the property value\r\n* @return the table row\r\n*/\n\n\nInspector.prototype.buildPropertyRow = function (propertyName, propertyValue) {\n  var mainDiv = this._div;\n  var tr = document.createElement(\"tr\");\n  var td1 = document.createElement(\"td\");\n  td1.textContent = propertyName;\n  tr.appendChild(td1);\n  var td2 = document.createElement(\"td\");\n  var decProp = this.declaredProperties[propertyName];\n  var input = null;\n  var self = this;\n\n  function updateall() {\n    self.updateAllProperties();\n  }\n\n  if (decProp && decProp.type === \"select\") {\n    input = document.createElement(\"select\");\n    this.updateSelect(decProp, input, propertyName, propertyValue);\n    input.addEventListener(\"change\", updateall);\n  } else {\n    input = document.createElement(\"input\");\n\n    if (input.setPointerCapture) {\n      input.addEventListener(\"pointerdown\", function (e) {\n        input.setPointerCapture(e.pointerId);\n      });\n    }\n\n    input.value = this.convertToString(propertyValue);\n\n    if (decProp) {\n      var t = decProp.type;\n\n      if (t !== 'string' && t !== 'number' && t !== 'boolean' && t !== 'arrayofnumber' && t !== 'point' && t !== 'size' && t !== 'rect' && t !== 'spot' && t !== 'margin') {\n        input.setAttribute(\"type\", decProp.type);\n      }\n\n      if (decProp.type === \"color\") {\n        if (input.type === \"color\") {\n          input.value = this.convertToColor(propertyValue); // input.addEventListener(\"input\", updateall);\n\n          input.addEventListener(\"change\", updateall);\n        }\n      }\n\n      if (decProp.type === \"checkbox\") {\n        input.checked = !!propertyValue;\n        input.addEventListener(\"change\", updateall);\n      }\n    }\n\n    if (input.type !== \"color\") input.addEventListener(\"blur\", updateall);\n  }\n\n  if (input) {\n    input.tabIndex = this.tabIndex++;\n    input.disabled = !this.canEditProperty(propertyName, decProp, this.inspectedObject);\n    td2.appendChild(input);\n  }\n\n  tr.appendChild(td2);\n  this._inspectedProperties[propertyName] = input;\n  return tr;\n};\n/**\r\n* @ignore\r\n* HTML5 color input will only take hex,\r\n* so var HTML5 canvas convert the color into hex format.\r\n* This converts \"rgb(255, 0, 0)\" into \"#FF0000\", etc.\r\n* @param {string} propertyValue\r\n* @return {string}\r\n*/\n\n\nInspector.prototype.convertToColor = function (propertyValue) {\n  var ctx = document.createElement(\"canvas\").getContext(\"2d\");\n  ctx.fillStyle = propertyValue;\n  return ctx.fillStyle;\n};\n/**\r\n* @ignore\r\n* @param {string}\r\n* @return {Array.<number>}\r\n*/\n\n\nInspector.prototype.convertToArrayOfNumber = function (propertyValue) {\n  if (propertyValue === \"null\") return null;\n  var split = propertyValue.split(' ');\n  var arr = [];\n\n  for (var i = 0; i < split.length; i++) {\n    var str = split[i];\n    if (!str) continue;\n    arr.push(parseFloat(str));\n  }\n\n  return arr;\n};\n/**\r\n* @ignore\r\n* @param {*}\r\n* @return {string}\r\n*/\n\n\nInspector.prototype.convertToString = function (x) {\n  if (x === undefined) return \"undefined\";\n  if (x === null) return \"null\";\n  if (x instanceof go.Point) return go.Point.stringify(x);\n  if (x instanceof go.Size) return go.Size.stringify(x);\n  if (x instanceof go.Rect) return go.Rect.stringify(x);\n  if (x instanceof go.Spot) return go.Spot.stringify(x);\n  if (x instanceof go.Margin) return go.Margin.stringify(x);\n  if (x instanceof go.List) return this.convertToString(x.toArray());\n\n  if (Array.isArray(x)) {\n    var str = \"\";\n\n    for (var i = 0; i < x.length; i++) {\n      if (i > 0) str += \" \";\n      var v = x[i];\n      str += this.convertToString(v);\n    }\n\n    return str;\n  }\n\n  return x.toString();\n};\n/**\r\n* @ignore\r\n* Update all of the HTML in this Inspector.\r\n*/\n\n\nInspector.prototype.updateAllHTML = function () {\n  var inspectedProps = this._inspectedProperties;\n  var diagram = this._diagram;\n  var isPart = this.inspectedObject instanceof go.Part;\n  var data = isPart ? this.inspectedObject.data : this.inspectedObject;\n\n  if (!data) {\n    // clear out all of the fields\n    for (var name in inspectedProps) {\n      var input = inspectedProps[name];\n\n      if (input instanceof HTMLSelectElement) {\n        input.innerHTML = \"\";\n      } else if (input.type === \"color\") {\n        input.value = \"#000000\";\n      } else if (input.type === \"checkbox\") {\n        input.checked = false;\n      } else {\n        input.value = \"\";\n      }\n    }\n  } else {\n    for (var name in inspectedProps) {\n      var input = inspectedProps[name];\n      var propertyValue = data[name];\n\n      if (input instanceof HTMLSelectElement) {\n        var decProp = this.declaredProperties[name];\n        this.updateSelect(decProp, input, name, propertyValue);\n      } else if (input.type === \"color\") {\n        input.value = this.convertToColor(propertyValue);\n      } else if (input.type === \"checkbox\") {\n        input.checked = !!propertyValue;\n      } else {\n        input.value = this.convertToString(propertyValue);\n      }\n    }\n  }\n};\n/**\r\n* @ignore\r\n* Update an HTMLSelectElement with an appropriate list of choices, given the propertyName\r\n*/\n\n\nInspector.prototype.updateSelect = function (decProp, select, propertyName, propertyValue) {\n  select.innerHTML = \"\"; // clear out anything that was there\n\n  var choices = decProp.choices;\n  if (typeof choices === \"function\") choices = choices(this.inspectedObject, propertyName);\n  if (!Array.isArray(choices)) choices = [];\n  decProp.choicesArray = choices; // remember list of actual choice values (not strings)\n\n  for (var i = 0; i < choices.length; i++) {\n    var choice = choices[i];\n    var opt = document.createElement(\"option\");\n    opt.text = this.convertToString(choice);\n    select.add(opt, null);\n  }\n\n  select.value = this.convertToString(propertyValue);\n};\n/**\r\n* @ignore\r\n* Update all of the data properties of {@link #inspectedObject} according to the\r\n* current values held in the HTML input elements.\r\n*/\n\n\nInspector.prototype.updateAllProperties = function () {\n  var inspectedProps = this._inspectedProperties;\n  var diagram = this._diagram;\n\n  if (diagram.selection.count === 1 || !this.multipleSelection) {\n    // single object update\n    var isPart = this.inspectedObject instanceof go.Part;\n    var data = isPart ? this.inspectedObject.data : this.inspectedObject;\n    if (!data) return; // must not try to update data when there's no data!\n\n    diagram.startTransaction('set all properties');\n\n    for (var name in inspectedProps) {\n      var input = inspectedProps[name];\n      var value = input.value; // don't update \"readOnly\" data properties\n\n      var decProp = this.declaredProperties[name];\n      if (!this.canEditProperty(name, decProp, this.inspectedObject)) continue; // If it's a boolean, or if its previous value was boolean,\n      // parse the value to be a boolean and then update the input.value to match\n\n      var type = '';\n\n      if (decProp !== undefined && decProp.type !== undefined) {\n        type = decProp.type;\n      }\n\n      if (type === '') {\n        var oldval = data[name];\n        if (typeof oldval === 'boolean') type = 'boolean'; // infer boolean\n        else if (typeof oldval === 'number') type = 'number';else if (oldval instanceof go.Point) type = 'point';else if (oldval instanceof go.Size) type = 'size';else if (oldval instanceof go.Rect) type = 'rect';else if (oldval instanceof go.Spot) type = 'spot';else if (oldval instanceof go.Margin) type = 'margin';\n      } // convert to specific type, if needed\n\n\n      switch (type) {\n        case 'boolean':\n          value = !(value === false || value === 'false' || value === '0');\n          break;\n\n        case 'number':\n          value = parseFloat(value);\n          break;\n\n        case 'arrayofnumber':\n          value = this.convertToArrayOfNumber(value);\n          break;\n\n        case 'point':\n          value = go.Point.parse(value);\n          break;\n\n        case 'size':\n          value = go.Size.parse(value);\n          break;\n\n        case 'rect':\n          value = go.Rect.parse(value);\n          break;\n\n        case 'spot':\n          value = go.Spot.parse(value);\n          break;\n\n        case 'margin':\n          value = go.Margin.parse(value);\n          break;\n\n        case 'checkbox':\n          value = input.checked;\n          break;\n\n        case 'select':\n          value = decProp.choicesArray[input.selectedIndex];\n          break;\n      } // in case parsed to be different, such as in the case of boolean values,\n      // the value shown should match the actual value\n\n\n      input.value = value; // modify the data object in an undo-able fashion\n\n      diagram.model.setDataProperty(data, name, value); // notify any listener\n\n      if (this.propertyModified !== null) this.propertyModified(name, value, this);\n    }\n\n    diagram.commitTransaction('set all properties');\n  } else {\n    // selection object update\n    diagram.startTransaction('set all properties');\n\n    for (var name in inspectedProps) {\n      var input = inspectedProps[name];\n      var value = input.value;\n      var arr1 = value.split('|');\n      var arr2 = [];\n\n      if (this._multipleProperties[name]) {\n        // don't split if it is union and its checkbox type\n        if (this.declaredProperties[name] && this.declaredProperties[name].type === 'checkbox' && this.showAllProperties) {\n          arr2.push(this._multipleProperties[name]);\n        } else {\n          arr2 = this._multipleProperties[name].toString().split('|');\n        }\n      }\n\n      var it = diagram.selection.iterator;\n      var change = false;\n      if (this.declaredProperties[name] && this.declaredProperties[name].type === 'checkbox') change = true; // always change checkbox\n\n      if (arr1.length < arr2.length // i.e Alpha|Beta -> Alpha procs the change\n      && (!this.declaredProperties[name] // from and to links\n      || !(this.declaredProperties[name] // do not change color checkbox and choices due to them always having less\n      && (this.declaredProperties[name].type === 'color' || this.declaredProperties[name].type === 'checkbox' || this.declaredProperties[name].type === 'choices')))) {\n        change = true;\n      } else {\n        // standard detection in change in properties\n        for (var j = 0; j < arr1.length && j < arr2.length; j++) {\n          if (!(arr1[j] === arr2[j]) && !(this.declaredProperties[name] && this.declaredProperties[name].type === 'color' && arr1[j].toLowerCase() === arr2[j].toLowerCase())) {\n            change = true;\n          }\n        }\n      }\n\n      if (change) {\n        // only change properties it needs to change instead all of them\n        for (var i = 0; i < diagram.selection.count; i++) {\n          it.next();\n          var isPart = it.value instanceof go.Part;\n          var data = isPart ? it.value.data : it.value;\n\n          if (data) {\n            // ignores the selected node if there is no data\n            if (i < arr1.length) value = arr1[i];else value = arr1[0]; // don't update \"readOnly\" data properties\n\n            var decProp = this.declaredProperties[name];\n            if (!this.canEditProperty(name, decProp, it.value)) continue; // If it's a boolean, or if its previous value was boolean,\n            // parse the value to be a boolean and then update the input.value to match\n\n            var type = '';\n\n            if (decProp !== undefined && decProp.type !== undefined) {\n              type = decProp.type;\n            }\n\n            if (type === '') {\n              var oldval = data[name];\n              if (typeof oldval === 'boolean') type = 'boolean'; // infer boolean\n              else if (typeof oldval === 'number') type = 'number';else if (oldval instanceof go.Point) type = 'point';else if (oldval instanceof go.Size) type = 'size';else if (oldval instanceof go.Rect) type = 'rect';else if (oldval instanceof go.Spot) type = 'spot';else if (oldval instanceof go.Margin) type = 'margin';\n            } // convert to specific type, if needed\n\n\n            switch (type) {\n              case 'boolean':\n                value = !(value === false || value === 'false' || value === '0');\n                break;\n\n              case 'number':\n                value = parseFloat(value);\n                break;\n\n              case 'arrayofnumber':\n                value = this.convertToArrayOfNumber(value);\n                break;\n\n              case 'point':\n                value = go.Point.parse(value);\n                break;\n\n              case 'size':\n                value = go.Size.parse(value);\n                break;\n\n              case 'rect':\n                value = go.Rect.parse(value);\n                break;\n\n              case 'spot':\n                value = go.Spot.parse(value);\n                break;\n\n              case 'margin':\n                value = go.Margin.parse(value);\n                break;\n\n              case 'checkbox':\n                value = input.checked;\n                break;\n\n              case 'select':\n                value = decProp.choicesArray[input.selectedIndex];\n                break;\n            } // in case parsed to be different, such as in the case of boolean values,\n            // the value shown should match the actual value\n\n\n            input.value = value; // modify the data object in an undo-able fashion\n\n            diagram.model.setDataProperty(data, name, value); // notify any listener\n\n            if (this.propertyModified !== null) this.propertyModified(name, value, this);\n          }\n        }\n      }\n    }\n\n    diagram.commitTransaction('set all properties');\n  }\n};","map":null,"metadata":{},"sourceType":"script"}